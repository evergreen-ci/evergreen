// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/evergreen-ci/evergreen"
	"github.com/evergreen-ci/evergreen/apimodels"
	model1 "github.com/evergreen-ci/evergreen/model"
	"github.com/evergreen-ci/evergreen/model/cost"
	"github.com/evergreen-ci/evergreen/model/distro"
	"github.com/evergreen-ci/evergreen/model/event"
	"github.com/evergreen-ci/evergreen/model/host"
	"github.com/evergreen-ci/evergreen/model/task"
	"github.com/evergreen-ci/evergreen/rest/model"
	"github.com/evergreen-ci/evergreen/thirdparty"
	"github.com/evergreen-ci/plank"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AdminSettings() AdminSettingsResolver
	Annotation() AnnotationResolver
	ContainerPool() ContainerPoolResolver
	Distro() DistroResolver
	Host() HostResolver
	Image() ImageResolver
	IssueLink() IssueLinkResolver
	JiraNotificationsConfig() JiraNotificationsConfigResolver
	LogkeeperBuild() LogkeeperBuildResolver
	Mutation() MutationResolver
	Patch() PatchResolver
	Permissions() PermissionsResolver
	Pod() PodResolver
	PodEventLogData() PodEventLogDataResolver
	Project() ProjectResolver
	ProjectSettings() ProjectSettingsResolver
	ProjectVars() ProjectVarsResolver
	Query() QueryResolver
	RepoSettings() RepoSettingsResolver
	SleepSchedule() SleepScheduleResolver
	SpruceConfig() SpruceConfigResolver
	SubscriberWrapper() SubscriberWrapperResolver
	Task() TaskResolver
	TaskContainerCreationOpts() TaskContainerCreationOptsResolver
	TaskLogs() TaskLogsResolver
	TicketFields() TicketFieldsResolver
	User() UserResolver
	Version() VersionResolver
	Volume() VolumeResolver
	AdminSettingsInput() AdminSettingsInputResolver
	ContainerPoolInput() ContainerPoolInputResolver
	DistroInput() DistroInputResolver
	HostAllocatorSettingsInput() HostAllocatorSettingsInputResolver
	JiraNotificationsConfigInput() JiraNotificationsConfigInputResolver
	PlannerSettingsInput() PlannerSettingsInputResolver
	ProjectSettingsInput() ProjectSettingsInputResolver
	RepoSettingsInput() RepoSettingsInputResolver
	SleepScheduleInput() SleepScheduleInputResolver
	SubscriberInput() SubscriberInputResolver
}

type DirectiveRoot struct {
	RedactSecrets                func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireAdmin                 func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireDistroAccess          func(ctx context.Context, obj any, next graphql.Resolver, access DistroSettingsAccess) (res any, err error)
	RequireHostAccess            func(ctx context.Context, obj any, next graphql.Resolver, access HostAccessLevel) (res any, err error)
	RequirePatchOwner            func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireProjectAccess         func(ctx context.Context, obj any, next graphql.Resolver, permission ProjectPermission, access AccessLevel) (res any, err error)
	RequireProjectAdmin          func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireProjectSettingsAccess func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
}

type ComplexityRoot struct {
	APIConfig struct {
		CorpURL        func(childComplexity int) int
		HttpListenAddr func(childComplexity int) int
		URL            func(childComplexity int) int
	}

	AWSAccountRoleMapping struct {
		Account func(childComplexity int) int
		Role    func(childComplexity int) int
	}

	AWSConfig struct {
		AccountRoles           func(childComplexity int) int
		AlertableInstanceTypes func(childComplexity int) int
		AllowedInstanceTypes   func(childComplexity int) int
		AllowedRegions         func(childComplexity int) int
		DefaultSecurityGroup   func(childComplexity int) int
		EC2Keys                func(childComplexity int) int
		ElasticIPUsageRate     func(childComplexity int) int
		IPAMPoolID             func(childComplexity int) int
		MaxVolumeSizePerUser   func(childComplexity int) int
		ParserProject          func(childComplexity int) int
		PersistentDNS          func(childComplexity int) int
		Pod                    func(childComplexity int) int
		Subnets                func(childComplexity int) int
	}

	AWSPodConfig struct {
		ECS            func(childComplexity int) int
		Region         func(childComplexity int) int
		Role           func(childComplexity int) int
		SecretsManager func(childComplexity int) int
	}

	AWSVPCConfig struct {
		SecurityGroups func(childComplexity int) int
		Subnets        func(childComplexity int) int
	}

	AbortInfo struct {
		BuildVariantDisplayName func(childComplexity int) int
		NewVersion              func(childComplexity int) int
		PrClosed                func(childComplexity int) int
		TaskDisplayName         func(childComplexity int) int
		TaskID                  func(childComplexity int) int
		User                    func(childComplexity int) int
	}

	AdminEvent struct {
		After     func(childComplexity int) int
		Before    func(childComplexity int) int
		Section   func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	AdminEventsPayload struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	AdminSettings struct {
		Amboy                   func(childComplexity int) int
		AmboyDB                 func(childComplexity int) int
		Api                     func(childComplexity int) int
		AuthConfig              func(childComplexity int) int
		Banner                  func(childComplexity int) int
		BannerTheme             func(childComplexity int) int
		Buckets                 func(childComplexity int) int
		Cedar                   func(childComplexity int) int
		ConfigDir               func(childComplexity int) int
		ContainerPools          func(childComplexity int) int
		Cost                    func(childComplexity int) int
		DisabledGQLQueries      func(childComplexity int) int
		DomainName              func(childComplexity int) int
		Expansions              func(childComplexity int) int
		FWS                     func(childComplexity int) int
		GitHubCheckRun          func(childComplexity int) int
		GithubOrgs              func(childComplexity int) int
		GithubPRCreatorOrg      func(childComplexity int) int
		GithubWebhookSecret     func(childComplexity int) int
		Graphite                func(childComplexity int) int
		HostInit                func(childComplexity int) int
		HostJasper              func(childComplexity int) int
		JIRANotifications       func(childComplexity int) int
		Jira                    func(childComplexity int) int
		KanopySSHKeyPath        func(childComplexity int) int
		LogPath                 func(childComplexity int) int
		LoggerConfig            func(childComplexity int) int
		Notify                  func(childComplexity int) int
		OldestAllowedCLIVersion func(childComplexity int) int
		ParameterStore          func(childComplexity int) int
		PerfMonitoringKanopyURL func(childComplexity int) int
		PerfMonitoringURL       func(childComplexity int) int
		PodLifecycle            func(childComplexity int) int
		PprofPort               func(childComplexity int) int
		ProjectCreation         func(childComplexity int) int
		Providers               func(childComplexity int) int
		ReleaseMode             func(childComplexity int) int
		RepoTracker             func(childComplexity int) int
		RuntimeEnvironments     func(childComplexity int) int
		SSH                     func(childComplexity int) int
		Scheduler               func(childComplexity int) int
		ServiceFlags            func(childComplexity int) int
		ShutdownWaitSeconds     func(childComplexity int) int
		SingleTaskDistro        func(childComplexity int) int
		Slack                   func(childComplexity int) int
		SleepSchedule           func(childComplexity int) int
		Spawnhost               func(childComplexity int) int
		Splunk                  func(childComplexity int) int
		TaskLimits              func(childComplexity int) int
		TestSelection           func(childComplexity int) int
		Tracer                  func(childComplexity int) int
		Triggers                func(childComplexity int) int
		Ui                      func(childComplexity int) int
	}

	AdminTasksToRestartPayload struct {
		TasksToRestart func(childComplexity int) int
	}

	AmboyConfig struct {
		GroupBackgroundCreateFrequencyMinutes func(childComplexity int) int
		GroupDefaultWorkers                   func(childComplexity int) int
		GroupPruneFrequencyMinutes            func(childComplexity int) int
		GroupTTLMinutes                       func(childComplexity int) int
		LocalStorage                          func(childComplexity int) int
		LockTimeoutMinutes                    func(childComplexity int) int
		Name                                  func(childComplexity int) int
		NamedQueues                           func(childComplexity int) int
		PoolSizeLocal                         func(childComplexity int) int
		PoolSizeRemote                        func(childComplexity int) int
		Retry                                 func(childComplexity int) int
		SampleSize                            func(childComplexity int) int
		SingleName                            func(childComplexity int) int
	}

	AmboyDBConfig struct {
		Database func(childComplexity int) int
		URL      func(childComplexity int) int
	}

	AmboyNamedQueueConfig struct {
		LockTimeoutSeconds func(childComplexity int) int
		Name               func(childComplexity int) int
		NumWorkers         func(childComplexity int) int
		Regexp             func(childComplexity int) int
		SampleSize         func(childComplexity int) int
	}

	AmboyRetryConfig struct {
		MaxCapacity                         func(childComplexity int) int
		MaxRetryAttempts                    func(childComplexity int) int
		MaxRetryTimeSeconds                 func(childComplexity int) int
		NumWorkers                          func(childComplexity int) int
		RetryBackoffSeconds                 func(childComplexity int) int
		StaleRetryingMonitorIntervalSeconds func(childComplexity int) int
	}

	Annotation struct {
		CreatedIssues     func(childComplexity int) int
		Id                func(childComplexity int) int
		Issues            func(childComplexity int) int
		MetadataLinks     func(childComplexity int) int
		Note              func(childComplexity int) int
		SuspectedIssues   func(childComplexity int) int
		TaskExecution     func(childComplexity int) int
		TaskId            func(childComplexity int) int
		WebhookConfigured func(childComplexity int) int
	}

	AuthConfig struct {
		AllowServiceUsers       func(childComplexity int) int
		BackgroundReauthMinutes func(childComplexity int) int
		Github                  func(childComplexity int) int
		Kanopy                  func(childComplexity int) int
		Multi                   func(childComplexity int) int
		Naive                   func(childComplexity int) int
		OAuth                   func(childComplexity int) int
		Okta                    func(childComplexity int) int
		PreferredType           func(childComplexity int) int
	}

	AuthUser struct {
		DisplayName func(childComplexity int) int
		Email       func(childComplexity int) int
		Password    func(childComplexity int) int
		Username    func(childComplexity int) int
	}

	BetaFeatures struct {
		ParsleyAIEnabled       func(childComplexity int) int
		SpruceWaterfallEnabled func(childComplexity int) int
	}

	BootstrapSettings struct {
		ClientDir             func(childComplexity int) int
		Communication         func(childComplexity int) int
		Env                   func(childComplexity int) int
		JasperBinaryDir       func(childComplexity int) int
		JasperCredentialsPath func(childComplexity int) int
		Method                func(childComplexity int) int
		PreconditionScripts   func(childComplexity int) int
		ResourceLimits        func(childComplexity int) int
		RootDir               func(childComplexity int) int
		ServiceUser           func(childComplexity int) int
		ShellPath             func(childComplexity int) int
	}

	BucketConfig struct {
		Name              func(childComplexity int) int
		RoleARN           func(childComplexity int) int
		TestResultsPrefix func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	BucketsConfig struct {
		Credentials            func(childComplexity int) int
		InternalBuckets        func(childComplexity int) int
		LogBucket              func(childComplexity int) int
		LogBucketFailedTasks   func(childComplexity int) int
		LogBucketLongRetention func(childComplexity int) int
		LongRetentionProjects  func(childComplexity int) int
		TestResultsBucket      func(childComplexity int) int
	}

	Build struct {
		ActualMakespan    func(childComplexity int) int
		BuildVariant      func(childComplexity int) int
		Id                func(childComplexity int) int
		PredictedMakespan func(childComplexity int) int
		Status            func(childComplexity int) int
	}

	BuildBaron struct {
		BbTicketCreationDefined func(childComplexity int) int
		BuildBaronConfigured    func(childComplexity int) int
		SearchReturnInfo        func(childComplexity int) int
	}

	BuildBaronSettings struct {
		BFSuggestionFeaturesURL func(childComplexity int) int
		BFSuggestionPassword    func(childComplexity int) int
		BFSuggestionServer      func(childComplexity int) int
		BFSuggestionTimeoutSecs func(childComplexity int) int
		BFSuggestionUsername    func(childComplexity int) int
		TicketCreateIssueType   func(childComplexity int) int
		TicketCreateProject     func(childComplexity int) int
		TicketSearchProjects    func(childComplexity int) int
	}

	BuildVariantTuple struct {
		BuildVariant func(childComplexity int) int
		DisplayName  func(childComplexity int) int
	}

	CedarConfig struct {
		DBName func(childComplexity int) int
		DBURL  func(childComplexity int) int
	}

	ChildPatchAlias struct {
		Alias   func(childComplexity int) int
		PatchID func(childComplexity int) int
	}

	ClientBinary struct {
		Arch        func(childComplexity int) int
		DisplayName func(childComplexity int) int
		OS          func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	ClientConfig struct {
		ClientBinaries func(childComplexity int) int
		LatestRevision func(childComplexity int) int
	}

	CloudProviderConfig struct {
		AWS    func(childComplexity int) int
		Docker func(childComplexity int) int
	}

	CommitQueueParams struct {
		Enabled     func(childComplexity int) int
		MergeMethod func(childComplexity int) int
		Message     func(childComplexity int) int
	}

	ContainerPool struct {
		Distro        func(childComplexity int) int
		Id            func(childComplexity int) int
		MaxContainers func(childComplexity int) int
		Port          func(childComplexity int) int
	}

	ContainerPoolsConfig struct {
		Pools func(childComplexity int) int
	}

	ContainerResources struct {
		CPU      func(childComplexity int) int
		MemoryMB func(childComplexity int) int
		Name     func(childComplexity int) int
	}

	Cost struct {
		AdjustedEC2Cost func(childComplexity int) int
		OnDemandEC2Cost func(childComplexity int) int
	}

	CostConfig struct {
		FinanceFormula      func(childComplexity int) int
		OnDemandDiscount    func(childComplexity int) int
		SavingsPlanDiscount func(childComplexity int) int
	}

	CostData struct {
		OnDemandRate    func(childComplexity int) int
		SavingsPlanRate func(childComplexity int) int
	}

	DeleteDistroPayload struct {
		DeletedDistroID func(childComplexity int) int
	}

	DeleteGithubAppCredentialsPayload struct {
		OldAppID func(childComplexity int) int
	}

	Dependency struct {
		BuildVariant   func(childComplexity int) int
		MetStatus      func(childComplexity int) int
		Name           func(childComplexity int) int
		RequiredStatus func(childComplexity int) int
		TaskID         func(childComplexity int) int
	}

	DispatcherSettings struct {
		Version func(childComplexity int) int
	}

	Distro struct {
		AdminOnly             func(childComplexity int) int
		Aliases               func(childComplexity int) int
		Arch                  func(childComplexity int) int
		AuthorizedKeysFile    func(childComplexity int) int
		AvailableRegions      func(childComplexity int) int
		BootstrapSettings     func(childComplexity int) int
		ContainerPool         func(childComplexity int) int
		CostData              func(childComplexity int) int
		DisableShallowClone   func(childComplexity int) int
		Disabled              func(childComplexity int) int
		DispatcherSettings    func(childComplexity int) int
		ExecUser              func(childComplexity int) int
		Expansions            func(childComplexity int) int
		FinderSettings        func(childComplexity int) int
		HomeVolumeSettings    func(childComplexity int) int
		HostAllocatorSettings func(childComplexity int) int
		IcecreamSettings      func(childComplexity int) int
		ImageID               func(childComplexity int) int
		IsCluster             func(childComplexity int) int
		IsVirtualWorkstation  func(childComplexity int) int
		Mountpoints           func(childComplexity int) int
		Name                  func(childComplexity int) int
		Note                  func(childComplexity int) int
		PlannerSettings       func(childComplexity int) int
		Provider              func(childComplexity int) int
		ProviderAccount       func(childComplexity int) int
		ProviderSettingsList  func(childComplexity int) int
		SSHOptions            func(childComplexity int) int
		Setup                 func(childComplexity int) int
		SetupAsSudo           func(childComplexity int) int
		SingleTaskDistro      func(childComplexity int) int
		User                  func(childComplexity int) int
		UserSpawnAllowed      func(childComplexity int) int
		ValidProjects         func(childComplexity int) int
		WarningNote           func(childComplexity int) int
		WorkDir               func(childComplexity int) int
	}

	DistroEvent struct {
		After     func(childComplexity int) int
		Before    func(childComplexity int) int
		Data      func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	DistroEventsPayload struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	DistroInfo struct {
		BootstrapMethod      func(childComplexity int) int
		Id                   func(childComplexity int) int
		IsVirtualWorkstation func(childComplexity int) int
		IsWindows            func(childComplexity int) int
		User                 func(childComplexity int) int
		WorkDir              func(childComplexity int) int
	}

	DistroPermissions struct {
		Admin func(childComplexity int) int
		Edit  func(childComplexity int) int
		View  func(childComplexity int) int
	}

	DockerConfig struct {
		APIVersion func(childComplexity int) int
	}

	EC2Key struct {
		Key    func(childComplexity int) int
		Name   func(childComplexity int) int
		Secret func(childComplexity int) int
	}

	ECSCapacityProvider struct {
		Arch           func(childComplexity int) int
		Name           func(childComplexity int) int
		OS             func(childComplexity int) int
		WindowsVersion func(childComplexity int) int
	}

	ECSClusterConfig struct {
		Name func(childComplexity int) int
		OS   func(childComplexity int) int
	}

	ECSConfig struct {
		AWSVPC               func(childComplexity int) int
		AllowedImages        func(childComplexity int) int
		CapacityProviders    func(childComplexity int) int
		Clusters             func(childComplexity int) int
		ExecutionRole        func(childComplexity int) int
		LogGroup             func(childComplexity int) int
		LogRegion            func(childComplexity int) int
		LogStreamPrefix      func(childComplexity int) int
		MaxCPU               func(childComplexity int) int
		MaxMemoryMB          func(childComplexity int) int
		TaskDefinitionPrefix func(childComplexity int) int
		TaskRole             func(childComplexity int) int
	}

	EnvVar struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Expansion struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ExternalLink struct {
		DisplayName func(childComplexity int) int
		Requesters  func(childComplexity int) int
		URLTemplate func(childComplexity int) int
	}

	ExternalLinkForMetadata struct {
		DisplayName func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	FWSConfig struct {
		URL func(childComplexity int) int
	}

	FailingCommand struct {
		FailureMetadataTags func(childComplexity int) int
		FullDisplayName     func(childComplexity int) int
	}

	File struct {
		Link       func(childComplexity int) int
		Name       func(childComplexity int) int
		URLParsley func(childComplexity int) int
		Visibility func(childComplexity int) int
	}

	FileDiff struct {
		Additions   func(childComplexity int) int
		Deletions   func(childComplexity int) int
		Description func(childComplexity int) int
		DiffLink    func(childComplexity int) int
		FileName    func(childComplexity int) int
	}

	FinderSettings struct {
		Version func(childComplexity int) int
	}

	GeneralSubscription struct {
		ID             func(childComplexity int) int
		OwnerType      func(childComplexity int) int
		RegexSelectors func(childComplexity int) int
		ResourceType   func(childComplexity int) int
		Selectors      func(childComplexity int) int
		Subscriber     func(childComplexity int) int
		Trigger        func(childComplexity int) int
		TriggerData    func(childComplexity int) int
	}

	GeneratedTaskCountResults struct {
		BuildVariantName func(childComplexity int) int
		EstimatedTasks   func(childComplexity int) int
		TaskID           func(childComplexity int) int
		TaskName         func(childComplexity int) int
	}

	GitHubAuthConfig struct {
		AppId        func(childComplexity int) int
		ClientId     func(childComplexity int) int
		ClientSecret func(childComplexity int) int
		DefaultOwner func(childComplexity int) int
		DefaultRepo  func(childComplexity int) int
		Organization func(childComplexity int) int
		Users        func(childComplexity int) int
	}

	GitHubCheckRunConfig struct {
		CheckRunLimit func(childComplexity int) int
	}

	GitHubDynamicTokenPermissionGroup struct {
		Name        func(childComplexity int) int
		Permissions func(childComplexity int) int
	}

	GitTag struct {
		Pusher func(childComplexity int) int
		Tag    func(childComplexity int) int
	}

	GithubAppAuth struct {
		AppID      func(childComplexity int) int
		PrivateKey func(childComplexity int) int
	}

	GithubCheckSubscriber struct {
		Owner func(childComplexity int) int
		Ref   func(childComplexity int) int
		Repo  func(childComplexity int) int
	}

	GithubPRSubscriber struct {
		Owner    func(childComplexity int) int
		PRNumber func(childComplexity int) int
		Ref      func(childComplexity int) int
		Repo     func(childComplexity int) int
	}

	GithubPatch struct {
		Author     func(childComplexity int) int
		BaseOwner  func(childComplexity int) int
		BaseRepo   func(childComplexity int) int
		HeadBranch func(childComplexity int) int
		HeadHash   func(childComplexity int) int
		HeadOwner  func(childComplexity int) int
		HeadRepo   func(childComplexity int) int
		PRNumber   func(childComplexity int) int
	}

	GithubProjectConflicts struct {
		CommitCheckIdentifiers func(childComplexity int) int
		CommitQueueIdentifiers func(childComplexity int) int
		PRTestingIdentifiers   func(childComplexity int) int
	}

	GithubUser struct {
		LastKnownAs func(childComplexity int) int
		UID         func(childComplexity int) int
	}

	GraphiteConfig struct {
		CIOptimizationToken func(childComplexity int) int
		ServerURL           func(childComplexity int) int
	}

	GroupedBuildVariant struct {
		DisplayName func(childComplexity int) int
		Tasks       func(childComplexity int) int
		Variant     func(childComplexity int) int
	}

	GroupedFiles struct {
		Execution func(childComplexity int) int
		Files     func(childComplexity int) int
		TaskID    func(childComplexity int) int
		TaskName  func(childComplexity int) int
	}

	GroupedProjects struct {
		GroupDisplayName func(childComplexity int) int
		Projects         func(childComplexity int) int
		Repo             func(childComplexity int) int
	}

	GroupedTaskStatusCount struct {
		DisplayName  func(childComplexity int) int
		StatusCounts func(childComplexity int) int
		Variant      func(childComplexity int) int
	}

	HomeVolumeSettings struct {
		FormatCommand func(childComplexity int) int
	}

	Host struct {
		Ami                   func(childComplexity int) int
		AvailabilityZone      func(childComplexity int) int
		DisplayName           func(childComplexity int) int
		Distro                func(childComplexity int) int
		DistroID              func(childComplexity int) int
		Elapsed               func(childComplexity int) int
		EventTypes            func(childComplexity int) int
		Events                func(childComplexity int, opts HostEventsInput) int
		Expiration            func(childComplexity int) int
		HomeVolume            func(childComplexity int) int
		HomeVolumeID          func(childComplexity int) int
		HostURL               func(childComplexity int) int
		Id                    func(childComplexity int) int
		InstanceTags          func(childComplexity int) int
		InstanceType          func(childComplexity int) int
		LastCommunicationTime func(childComplexity int) int
		NoExpiration          func(childComplexity int) int
		PersistentDNSName     func(childComplexity int) int
		Provider              func(childComplexity int) int
		RunningTask           func(childComplexity int) int
		SleepSchedule         func(childComplexity int) int
		StartedBy             func(childComplexity int) int
		Status                func(childComplexity int) int
		Tag                   func(childComplexity int) int
		TotalIdleTime         func(childComplexity int) int
		Uptime                func(childComplexity int) int
		User                  func(childComplexity int) int
		Volumes               func(childComplexity int) int
	}

	HostAllocatorSettings struct {
		AcceptableHostIdleTime func(childComplexity int) int
		AutoTuneMaximumHosts   func(childComplexity int) int
		FeedbackRule           func(childComplexity int) int
		FutureHostFraction     func(childComplexity int) int
		HostsOverallocatedRule func(childComplexity int) int
		MaximumHosts           func(childComplexity int) int
		MinimumHosts           func(childComplexity int) int
		RoundingRule           func(childComplexity int) int
		Version                func(childComplexity int) int
	}

	HostEventLogData struct {
		AgentBuild         func(childComplexity int) int
		AgentRevision      func(childComplexity int) int
		Duration           func(childComplexity int) int
		Execution          func(childComplexity int) int
		Hostname           func(childComplexity int) int
		JasperRevision     func(childComplexity int) int
		Logs               func(childComplexity int) int
		MonitorOp          func(childComplexity int) int
		NewStatus          func(childComplexity int) int
		OldStatus          func(childComplexity int) int
		ProvisioningMethod func(childComplexity int) int
		Successful         func(childComplexity int) int
		TaskId             func(childComplexity int) int
		TaskPid            func(childComplexity int) int
		TaskStatus         func(childComplexity int) int
		User               func(childComplexity int) int
	}

	HostEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	HostEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	HostInitConfig struct {
		CloudStatusBatchSize func(childComplexity int) int
		HostThrottle         func(childComplexity int) int
		MaxTotalDynamicHosts func(childComplexity int) int
		ProvisioningThrottle func(childComplexity int) int
	}

	HostJasperConfig struct {
		BinaryName       func(childComplexity int) int
		DownloadFileName func(childComplexity int) int
		Port             func(childComplexity int) int
		URL              func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	HostsResponse struct {
		FilteredHostsCount func(childComplexity int) int
		Hosts              func(childComplexity int) int
		TotalHostsCount    func(childComplexity int) int
	}

	IceCreamSettings struct {
		ConfigPath    func(childComplexity int) int
		SchedulerHost func(childComplexity int) int
	}

	Image struct {
		AMI             func(childComplexity int) int
		Distros         func(childComplexity int) int
		Events          func(childComplexity int, limit int, page int) int
		Files           func(childComplexity int, opts thirdparty.FileFilterOptions) int
		ID              func(childComplexity int) int
		LastDeployed    func(childComplexity int) int
		LatestTask      func(childComplexity int) int
		OperatingSystem func(childComplexity int, opts thirdparty.OSInfoFilterOptions) int
		Packages        func(childComplexity int, opts thirdparty.PackageFilterOptions) int
		Toolchains      func(childComplexity int, opts thirdparty.ToolchainFilterOptions) int
	}

	ImageEvent struct {
		AMIAfter  func(childComplexity int) int
		AMIBefore func(childComplexity int) int
		Entries   func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	ImageEventEntry struct {
		Action func(childComplexity int) int
		After  func(childComplexity int) int
		Before func(childComplexity int) int
		Name   func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	ImageEventsPayload struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	ImageFile struct {
		Name    func(childComplexity int) int
		Path    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	ImageFilesPayload struct {
		Data          func(childComplexity int) int
		FilteredCount func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	ImageOperatingSystemPayload struct {
		Data          func(childComplexity int) int
		FilteredCount func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	ImagePackagesPayload struct {
		Data          func(childComplexity int) int
		FilteredCount func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	ImageToolchainsPayload struct {
		Data          func(childComplexity int) int
		FilteredCount func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	IncludedLocalModule struct {
		FileName func(childComplexity int) int
		Module   func(childComplexity int) int
	}

	InstanceTag struct {
		CanBeModified func(childComplexity int) int
		Key           func(childComplexity int) int
		Value         func(childComplexity int) int
	}

	IssueLink struct {
		ConfidenceScore func(childComplexity int) int
		IssueKey        func(childComplexity int) int
		JiraTicket      func(childComplexity int) int
		Source          func(childComplexity int) int
		URL             func(childComplexity int) int
	}

	JiraConfig struct {
		Email               func(childComplexity int) int
		Host                func(childComplexity int) int
		PersonalAccessToken func(childComplexity int) int
	}

	JiraIssueSubscriber struct {
		IssueType func(childComplexity int) int
		Project   func(childComplexity int) int
	}

	JiraNotificationsConfig struct {
		CustomFields func(childComplexity int) int
	}

	JiraNotificationsProject struct {
		Components func(childComplexity int) int
		Fields     func(childComplexity int) int
		Labels     func(childComplexity int) int
	}

	JiraNotificationsProjectEntry struct {
		Components func(childComplexity int) int
		Fields     func(childComplexity int) int
		Labels     func(childComplexity int) int
		Project    func(childComplexity int) int
	}

	JiraStatus struct {
		Id   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	JiraTicket struct {
		Fields func(childComplexity int) int
		Key    func(childComplexity int) int
	}

	KanopyAuthConfig struct {
		HeaderName func(childComplexity int) int
		Issuer     func(childComplexity int) int
		KeysetURL  func(childComplexity int) int
	}

	LogBuffering struct {
		Count                func(childComplexity int) int
		DurationSeconds      func(childComplexity int) int
		IncomingBufferFactor func(childComplexity int) int
		UseAsync             func(childComplexity int) int
	}

	LogMessage struct {
		Message   func(childComplexity int) int
		Severity  func(childComplexity int) int
		Timestamp func(childComplexity int) int
		Type      func(childComplexity int) int
		Version   func(childComplexity int) int
	}

	LoggerConfig struct {
		Buffer         func(childComplexity int) int
		DefaultLevel   func(childComplexity int) int
		LogkeeperURL   func(childComplexity int) int
		RedactKeys     func(childComplexity int) int
		ThresholdLevel func(childComplexity int) int
	}

	LogkeeperBuild struct {
		BuildNum      func(childComplexity int) int
		Builder       func(childComplexity int) int
		ID            func(childComplexity int) int
		Task          func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
		Tests         func(childComplexity int) int
	}

	LogkeeperTest struct {
		BuildID       func(childComplexity int) int
		Command       func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Phase         func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
	}

	MainlineCommitVersion struct {
		RolledUpVersions func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	MainlineCommits struct {
		NextPageOrderNumber func(childComplexity int) int
		PrevPageOrderNumber func(childComplexity int) int
		Versions            func(childComplexity int) int
	}

	Manifest struct {
		Branch          func(childComplexity int) int
		ID              func(childComplexity int) int
		IsBase          func(childComplexity int) int
		ModuleOverrides func(childComplexity int) int
		Modules         func(childComplexity int) int
		Project         func(childComplexity int) int
		Revision        func(childComplexity int) int
	}

	MetadataLink struct {
		Source func(childComplexity int) int
		Text   func(childComplexity int) int
		URL    func(childComplexity int) int
	}

	ModuleCodeChange struct {
		BranchName func(childComplexity int) int
		FileDiffs  func(childComplexity int) int
		HTMLLink   func(childComplexity int) int
		RawLink    func(childComplexity int) int
	}

	MultiAuthConfig struct {
		ReadOnly  func(childComplexity int) int
		ReadWrite func(childComplexity int) int
	}

	Mutation struct {
		AbortTask                     func(childComplexity int, taskID string) int
		AddAnnotationIssue            func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		AddFavoriteProject            func(childComplexity int, opts AddFavoriteProjectInput) int
		AttachProjectToNewRepo        func(childComplexity int, project MoveProjectInput) int
		AttachProjectToRepo           func(childComplexity int, projectID string) int
		AttachVolumeToHost            func(childComplexity int, volumeAndHost VolumeHost) int
		BbCreateTicket                func(childComplexity int, taskID string, execution *int) int
		ClearMySubscriptions          func(childComplexity int) int
		CopyDistro                    func(childComplexity int, opts model.CopyDistroOpts) int
		CopyProject                   func(childComplexity int, project model.CopyProjectOpts, requestS3Creds *bool) int
		CreateDistro                  func(childComplexity int, opts CreateDistroInput) int
		CreateProject                 func(childComplexity int, project model.APIProjectRef, requestS3Creds *bool) int
		CreatePublicKey               func(childComplexity int, publicKeyInput PublicKeyInput) int
		DeactivateStepbackTask        func(childComplexity int, opts DeactivateStepbackTaskInput) int
		DefaultSectionToRepo          func(childComplexity int, opts DefaultSectionToRepoInput) int
		DeleteDistro                  func(childComplexity int, opts DeleteDistroInput) int
		DeleteGithubAppCredentials    func(childComplexity int, opts DeleteGithubAppCredentialsInput) int
		DeleteProject                 func(childComplexity int, projectID string) int
		DeleteSubscriptions           func(childComplexity int, subscriptionIds []string) int
		DetachProjectFromRepo         func(childComplexity int, projectID string) int
		DetachVolumeFromHost          func(childComplexity int, volumeID string) int
		EditAnnotationNote            func(childComplexity int, taskID string, execution int, originalMessage string, newMessage string) int
		EditSpawnHost                 func(childComplexity int, spawnHost *EditSpawnHostInput) int
		ForceRepotrackerRun           func(childComplexity int, projectID string) int
		MigrateVolume                 func(childComplexity int, volumeID string, spawnHostInput *SpawnHostInput) int
		MoveAnnotationIssue           func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		OverrideTaskDependencies      func(childComplexity int, taskID string) int
		PromoteVarsToRepo             func(childComplexity int, opts PromoteVarsToRepoInput) int
		QuarantineTest                func(childComplexity int, opts QuarantineTestInput) int
		RemoveAnnotationIssue         func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		RemoveFavoriteProject         func(childComplexity int, opts RemoveFavoriteProjectInput) int
		RemovePublicKey               func(childComplexity int, keyName string) int
		RemoveVolume                  func(childComplexity int, volumeID string) int
		ReprovisionToNew              func(childComplexity int, hostIds []string) int
		ResetAPIKey                   func(childComplexity int) int
		RestartAdminTasks             func(childComplexity int, opts model1.RestartOptions) int
		RestartJasper                 func(childComplexity int, hostIds []string) int
		RestartTask                   func(childComplexity int, taskID string, failedOnly bool) int
		RestartVersions               func(childComplexity int, versionID string, abort bool, versionsToRestart []*model1.VersionToRestart) int
		SaveAdminSettings             func(childComplexity int, adminSettings model.APIAdminSettings) int
		SaveDistro                    func(childComplexity int, opts SaveDistroInput) int
		SaveProjectSettingsForSection func(childComplexity int, projectSettings *model.APIProjectSettings, section ProjectSettingsSection) int
		SaveRepoSettingsForSection    func(childComplexity int, repoSettings *model.APIProjectSettings, section ProjectSettingsSection) int
		SaveSubscription              func(childComplexity int, subscription model.APISubscription) int
		SchedulePatch                 func(childComplexity int, patchID string, configure PatchConfigure) int
		ScheduleTasks                 func(childComplexity int, versionID string, taskIds []string) int
		ScheduleUndispatchedBaseTasks func(childComplexity int, versionID string) int
		SetAnnotationMetadataLinks    func(childComplexity int, taskID string, execution int, metadataLinks []*model.APIMetadataLink) int
		SetLastRevision               func(childComplexity int, opts SetLastRevisionInput) int
		SetPatchVisibility            func(childComplexity int, patchIds []string, hidden bool) int
		SetTaskPriorities             func(childComplexity int, taskPriorities []*TaskPriority) int
		SetTaskPriority               func(childComplexity int, taskID string, priority int) int
		SetVersionPriority            func(childComplexity int, versionID string, priority int) int
		SpawnHost                     func(childComplexity int, spawnHostInput *SpawnHostInput) int
		SpawnVolume                   func(childComplexity int, spawnVolumeInput SpawnVolumeInput) int
		UnscheduleTask                func(childComplexity int, taskID string) int
		UnscheduleVersionTasks        func(childComplexity int, versionID string, abort bool) int
		UpdateBetaFeatures            func(childComplexity int, opts UpdateBetaFeaturesInput) int
		UpdateHostStatus              func(childComplexity int, hostIds []string, status string, notes *string) int
		UpdateParsleySettings         func(childComplexity int, opts UpdateParsleySettingsInput) int
		UpdatePublicKey               func(childComplexity int, targetKeyName string, updateInfo PublicKeyInput) int
		UpdateSpawnHostStatus         func(childComplexity int, updateSpawnHostStatusInput UpdateSpawnHostStatusInput) int
		UpdateUserSettings            func(childComplexity int, userSettings *model.APIUserSettings) int
		UpdateVolume                  func(childComplexity int, updateVolumeInput UpdateVolumeInput) int
	}

	NaiveAuthConfig struct {
		Users func(childComplexity int) int
	}

	NewDistroPayload struct {
		NewDistroID func(childComplexity int) int
	}

	Note struct {
		Message func(childComplexity int) int
		Source  func(childComplexity int) int
	}

	Notifications struct {
		BuildBreak            func(childComplexity int) int
		BuildBreakID          func(childComplexity int) int
		PatchFinish           func(childComplexity int) int
		PatchFinishID         func(childComplexity int) int
		PatchFirstFailure     func(childComplexity int) int
		PatchFirstFailureID   func(childComplexity int) int
		SpawnHostExpiration   func(childComplexity int) int
		SpawnHostExpirationID func(childComplexity int) int
		SpawnHostOutcome      func(childComplexity int) int
		SpawnHostOutcomeID    func(childComplexity int) int
	}

	NotifyConfig struct {
		BufferIntervalSeconds   func(childComplexity int) int
		BufferTargetPerInterval func(childComplexity int) int
		SES                     func(childComplexity int) int
	}

	OAuthConfig struct {
		ClientID    func(childComplexity int) int
		ConnectorID func(childComplexity int) int
		Issuer      func(childComplexity int) int
	}

	OSInfo struct {
		Name    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	OktaConfig struct {
		ClientID           func(childComplexity int) int
		ClientSecret       func(childComplexity int) int
		ExpireAfterMinutes func(childComplexity int) int
		Issuer             func(childComplexity int) int
		Scopes             func(childComplexity int) int
		UserGroup          func(childComplexity int) int
	}

	OomTrackerInfo struct {
		Detected func(childComplexity int) int
		Pids     func(childComplexity int) int
	}

	OwnerRepo struct {
		Owner func(childComplexity int) int
		Repo  func(childComplexity int) int
	}

	Package struct {
		Manager func(childComplexity int) int
		Name    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	Parameter struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ParameterStoreConfig struct {
		Prefix func(childComplexity int) int
	}

	ParserProjectS3Config struct {
		Bucket              func(childComplexity int) int
		GeneratedJSONPrefix func(childComplexity int) int
		Key                 func(childComplexity int) int
		Prefix              func(childComplexity int) int
		Secret              func(childComplexity int) int
	}

	ParsleyFilter struct {
		CaseSensitive func(childComplexity int) int
		Description   func(childComplexity int) int
		ExactMatch    func(childComplexity int) int
		Expression    func(childComplexity int) int
	}

	ParsleySettings struct {
		JumpToFailingLineEnabled func(childComplexity int) int
		SectionsEnabled          func(childComplexity int) int
	}

	Patch struct {
		Activated            func(childComplexity int) int
		Alias                func(childComplexity int) int
		Author               func(childComplexity int) int
		AuthorDisplayName    func(childComplexity int) int
		BaseTaskStatuses     func(childComplexity int) int
		Builds               func(childComplexity int) int
		ChildPatchAliases    func(childComplexity int) int
		ChildPatches         func(childComplexity int) int
		CreateTime           func(childComplexity int) int
		Description          func(childComplexity int) int
		Duration             func(childComplexity int) int
		GeneratedTaskCounts  func(childComplexity int) int
		Githash              func(childComplexity int) int
		GithubPatchData      func(childComplexity int) int
		Hidden               func(childComplexity int) int
		Id                   func(childComplexity int) int
		IncludedLocalModules func(childComplexity int) int
		ModuleCodeChanges    func(childComplexity int) int
		Parameters           func(childComplexity int) int
		PatchNumber          func(childComplexity int) int
		PatchTriggerAliases  func(childComplexity int) int
		Project              func(childComplexity int) int
		ProjectId            func(childComplexity int) int
		ProjectIdentifier    func(childComplexity int) int
		ProjectMetadata      func(childComplexity int) int
		Status               func(childComplexity int) int
		TaskCount            func(childComplexity int) int
		TaskStatuses         func(childComplexity int) int
		Tasks                func(childComplexity int) int
		Time                 func(childComplexity int) int
		User                 func(childComplexity int) int
		Variants             func(childComplexity int) int
		VariantsTasks        func(childComplexity int) int
		VersionFull          func(childComplexity int) int
	}

	PatchDuration struct {
		Makespan  func(childComplexity int) int
		Time      func(childComplexity int) int
		TimeTaken func(childComplexity int) int
	}

	PatchProject struct {
		Variants func(childComplexity int) int
	}

	PatchTime struct {
		Finished    func(childComplexity int) int
		Started     func(childComplexity int) int
		SubmittedAt func(childComplexity int) int
	}

	PatchTriggerAlias struct {
		Alias                  func(childComplexity int) int
		ChildProjectId         func(childComplexity int) int
		ChildProjectIdentifier func(childComplexity int) int
		DownstreamRevision     func(childComplexity int) int
		ParentAsModule         func(childComplexity int) int
		Status                 func(childComplexity int) int
		TaskSpecifiers         func(childComplexity int) int
		VariantsTasks          func(childComplexity int) int
	}

	Patches struct {
		FilteredPatchCount func(childComplexity int) int
		Patches            func(childComplexity int) int
	}

	PeriodicBuild struct {
		Alias         func(childComplexity int) int
		ConfigFile    func(childComplexity int) int
		Cron          func(childComplexity int) int
		ID            func(childComplexity int) int
		IntervalHours func(childComplexity int) int
		Message       func(childComplexity int) int
		NextRunTime   func(childComplexity int) int
	}

	Permissions struct {
		CanCreateDistro      func(childComplexity int) int
		CanCreateProject     func(childComplexity int) int
		CanEditAdminSettings func(childComplexity int) int
		DistroPermissions    func(childComplexity int, options DistroPermissionsOptions) int
		ProjectPermissions   func(childComplexity int, options ProjectPermissionsOptions) int
		RepoPermissions      func(childComplexity int, options RepoPermissionsOptions) int
		UserID               func(childComplexity int) int
	}

	PersistentDNSConfig struct {
		Domain       func(childComplexity int) int
		HostedZoneID func(childComplexity int) int
	}

	PlannerSettings struct {
		CommitQueueFactor         func(childComplexity int) int
		ExpectedRuntimeFactor     func(childComplexity int) int
		GenerateTaskFactor        func(childComplexity int) int
		GroupVersions             func(childComplexity int) int
		MainlineTimeInQueueFactor func(childComplexity int) int
		NumDependentsFactor       func(childComplexity int) int
		PatchFactor               func(childComplexity int) int
		PatchTimeInQueueFactor    func(childComplexity int) int
		TargetTime                func(childComplexity int) int
		Version                   func(childComplexity int) int
	}

	Pod struct {
		Events                    func(childComplexity int, limit *int, page *int) int
		ID                        func(childComplexity int) int
		Status                    func(childComplexity int) int
		Task                      func(childComplexity int) int
		TaskContainerCreationOpts func(childComplexity int) int
		Type                      func(childComplexity int) int
	}

	PodEventLogData struct {
		NewStatus     func(childComplexity int) int
		OldStatus     func(childComplexity int) int
		Reason        func(childComplexity int) int
		Task          func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
		TaskStatus    func(childComplexity int) int
	}

	PodEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	PodEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	PodLifecycleConfig struct {
		MaxParallelPodRequests      func(childComplexity int) int
		MaxPodDefinitionCleanupRate func(childComplexity int) int
		MaxSecretCleanupRate        func(childComplexity int) int
	}

	PreconditionScript struct {
		Path   func(childComplexity int) int
		Script func(childComplexity int) int
	}

	Project struct {
		Admins                             func(childComplexity int) int
		Banner                             func(childComplexity int) int
		BatchTime                          func(childComplexity int) int
		Branch                             func(childComplexity int) int
		BuildBaronSettings                 func(childComplexity int) int
		CommitQueue                        func(childComplexity int) int
		ContainerSizeDefinitions           func(childComplexity int) int
		DeactivatePrevious                 func(childComplexity int) int
		DebugSpawnHostsDisabled            func(childComplexity int) int
		DisabledStatsCache                 func(childComplexity int) int
		DispatchingDisabled                func(childComplexity int) int
		DisplayName                        func(childComplexity int) int
		Enabled                            func(childComplexity int) int
		ExternalLinks                      func(childComplexity int) int
		GitHubDynamicTokenPermissionGroups func(childComplexity int) int
		GitHubPermissionGroupByRequester   func(childComplexity int) int
		GitTagAuthorizedTeams              func(childComplexity int) int
		GitTagAuthorizedUsers              func(childComplexity int) int
		GitTagVersionsEnabled              func(childComplexity int) int
		GithubChecksEnabled                func(childComplexity int) int
		GithubMQTriggerAliases             func(childComplexity int) int
		GithubPRTriggerAliases             func(childComplexity int) int
		Hidden                             func(childComplexity int) int
		Id                                 func(childComplexity int) int
		Identifier                         func(childComplexity int) int
		IsFavorite                         func(childComplexity int) int
		ManualPRTestingEnabled             func(childComplexity int) int
		NotifyOnBuildFailure               func(childComplexity int) int
		OldestAllowedMergeBase             func(childComplexity int) int
		Owner                              func(childComplexity int) int
		PRTestingEnabled                   func(childComplexity int) int
		ParsleyFilters                     func(childComplexity int) int
		PatchTriggerAliases                func(childComplexity int) int
		Patches                            func(childComplexity int, patchesInput PatchesInput) int
		PatchingDisabled                   func(childComplexity int) int
		PerfEnabled                        func(childComplexity int) int
		PeriodicBuilds                     func(childComplexity int) int
		ProjectHealthView                  func(childComplexity int) int
		RemotePath                         func(childComplexity int) int
		Repo                               func(childComplexity int) int
		RepoRefId                          func(childComplexity int) int
		RepotrackerDisabled                func(childComplexity int) int
		RepotrackerError                   func(childComplexity int) int
		Restricted                         func(childComplexity int) int
		SpawnHostScriptPath                func(childComplexity int) int
		StepbackBisect                     func(childComplexity int) int
		StepbackDisabled                   func(childComplexity int) int
		TaskAnnotationSettings             func(childComplexity int) int
		TestSelection                      func(childComplexity int) int
		TracksPushEvents                   func(childComplexity int) int
		Triggers                           func(childComplexity int) int
		VersionControlEnabled              func(childComplexity int) int
		WorkstationConfig                  func(childComplexity int) int
	}

	ProjectAlias struct {
		Alias       func(childComplexity int) int
		Description func(childComplexity int) int
		GitTag      func(childComplexity int) int
		ID          func(childComplexity int) int
		Parameters  func(childComplexity int) int
		RemotePath  func(childComplexity int) int
		Task        func(childComplexity int) int
		TaskTags    func(childComplexity int) int
		Variant     func(childComplexity int) int
		VariantTags func(childComplexity int) int
	}

	ProjectBanner struct {
		Text  func(childComplexity int) int
		Theme func(childComplexity int) int
	}

	ProjectBuildVariant struct {
		DisplayName func(childComplexity int) int
		Name        func(childComplexity int) int
		Tasks       func(childComplexity int) int
	}

	ProjectCreationConfig struct {
		JiraProject       func(childComplexity int) int
		RepoExceptions    func(childComplexity int) int
		RepoProjectLimit  func(childComplexity int) int
		TotalProjectLimit func(childComplexity int) int
	}

	ProjectEventLogEntry struct {
		After     func(childComplexity int) int
		Before    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	ProjectEventSettings struct {
		Aliases               func(childComplexity int) int
		GithubAppAuth         func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	ProjectEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	ProjectPermissions struct {
		Edit func(childComplexity int) int
		View func(childComplexity int) int
	}

	ProjectSettings struct {
		Aliases               func(childComplexity int) int
		GithubAppAuth         func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	ProjectTasksPair struct {
		AllowedBVs   func(childComplexity int) int
		AllowedTasks func(childComplexity int) int
		ProjectID    func(childComplexity int) int
	}

	ProjectVars struct {
		AdminOnlyVars func(childComplexity int) int
		PrivateVars   func(childComplexity int) int
		Vars          func(childComplexity int) int
	}

	PublicKey struct {
		Key  func(childComplexity int) int
		Name func(childComplexity int) int
	}

	QuarantineTestPayload struct {
		Success func(childComplexity int) int
	}

	Query struct {
		AWSRegions               func(childComplexity int) int
		AdminEvents              func(childComplexity int, opts AdminEventsInput) int
		AdminSettings            func(childComplexity int) int
		AdminTasksToRestart      func(childComplexity int, opts model1.RestartOptions) int
		BbGetCreatedTickets      func(childComplexity int, taskID string) int
		BuildBaron               func(childComplexity int, taskID string, execution int) int
		BuildVariantsForTaskName func(childComplexity int, projectIdentifier string, taskName string) int
		ClientConfig             func(childComplexity int) int
		Distro                   func(childComplexity int, distroID string) int
		DistroEvents             func(childComplexity int, opts DistroEventsInput) int
		DistroTaskQueue          func(childComplexity int, distroID string) int
		Distros                  func(childComplexity int, onlySpawnable bool) int
		GithubProjectConflicts   func(childComplexity int, projectID string) int
		HasVersion               func(childComplexity int, patchID string) int
		Host                     func(childComplexity int, hostID string) int
		HostEvents               func(childComplexity int, hostID string, hostTag *string, limit *int, page *int) int
		Hosts                    func(childComplexity int, hostID *string, distroID *string, currentTaskID *string, statuses []string, startedBy *string, sortBy *HostSortBy, sortDir *SortDirection, page *int, limit *int) int
		Image                    func(childComplexity int, imageID string) int
		Images                   func(childComplexity int) int
		InstanceTypes            func(childComplexity int) int
		IsRepo                   func(childComplexity int, projectOrRepoID string) int
		LogkeeperBuildMetadata   func(childComplexity int, buildID string) int
		MainlineCommits          func(childComplexity int, options MainlineCommitsOptions, buildVariantOptions *BuildVariantOptions) int
		MyHosts                  func(childComplexity int) int
		MyPublicKeys             func(childComplexity int) int
		MyVolumes                func(childComplexity int) int
		Patch                    func(childComplexity int, patchID string) int
		Pod                      func(childComplexity int, podID string) int
		Project                  func(childComplexity int, projectIdentifier string) int
		ProjectEvents            func(childComplexity int, projectIdentifier string, limit *int, before *time.Time) int
		ProjectSettings          func(childComplexity int, projectIdentifier string) int
		Projects                 func(childComplexity int) int
		RepoEvents               func(childComplexity int, repoID string, limit *int, before *time.Time) int
		RepoSettings             func(childComplexity int, repoID string) int
		SpruceConfig             func(childComplexity int) int
		SubnetAvailabilityZones  func(childComplexity int) int
		Task                     func(childComplexity int, taskID string, execution *int) int
		TaskAllExecutions        func(childComplexity int, taskID string) int
		TaskHistory              func(childComplexity int, options TaskHistoryOpts) int
		TaskNamesForBuildVariant func(childComplexity int, projectIdentifier string, buildVariant string) int
		TaskQueueDistros         func(childComplexity int) int
		TaskTestSample           func(childComplexity int, versionID string, taskIds []string, filters []*TestFilter) int
		User                     func(childComplexity int, userID *string) int
		UserConfig               func(childComplexity int) int
		Version                  func(childComplexity int, versionID string) int
		ViewableProjectRefs      func(childComplexity int) int
		Waterfall                func(childComplexity int, options WaterfallOptions) int
	}

	ReleaseModeConfig struct {
		DistroMaxHostsFactor      func(childComplexity int) int
		IdleTimeSecondsOverride   func(childComplexity int) int
		TargetTimeSecondsOverride func(childComplexity int) int
	}

	RepoCommitQueueParams struct {
		Enabled     func(childComplexity int) int
		MergeMethod func(childComplexity int) int
		Message     func(childComplexity int) int
	}

	RepoPermissions struct {
		Edit func(childComplexity int) int
		View func(childComplexity int) int
	}

	RepoRef struct {
		Admins                             func(childComplexity int) int
		BatchTime                          func(childComplexity int) int
		BuildBaronSettings                 func(childComplexity int) int
		CommitQueue                        func(childComplexity int) int
		ContainerSizeDefinitions           func(childComplexity int) int
		DeactivatePrevious                 func(childComplexity int) int
		DebugSpawnHostsDisabled            func(childComplexity int) int
		DisabledStatsCache                 func(childComplexity int) int
		DispatchingDisabled                func(childComplexity int) int
		DisplayName                        func(childComplexity int) int
		Enabled                            func(childComplexity int) int
		ExternalLinks                      func(childComplexity int) int
		GitHubDynamicTokenPermissionGroups func(childComplexity int) int
		GitHubPermissionGroupByRequester   func(childComplexity int) int
		GitTagAuthorizedTeams              func(childComplexity int) int
		GitTagAuthorizedUsers              func(childComplexity int) int
		GitTagVersionsEnabled              func(childComplexity int) int
		GithubChecksEnabled                func(childComplexity int) int
		GithubMQTriggerAliases             func(childComplexity int) int
		GithubPRTriggerAliases             func(childComplexity int) int
		Id                                 func(childComplexity int) int
		ManualPRTestingEnabled             func(childComplexity int) int
		NotifyOnBuildFailure               func(childComplexity int) int
		OldestAllowedMergeBase             func(childComplexity int) int
		Owner                              func(childComplexity int) int
		PRTestingEnabled                   func(childComplexity int) int
		ParsleyFilters                     func(childComplexity int) int
		PatchTriggerAliases                func(childComplexity int) int
		PatchingDisabled                   func(childComplexity int) int
		PerfEnabled                        func(childComplexity int) int
		PeriodicBuilds                     func(childComplexity int) int
		RemotePath                         func(childComplexity int) int
		Repo                               func(childComplexity int) int
		RepotrackerDisabled                func(childComplexity int) int
		Restricted                         func(childComplexity int) int
		SpawnHostScriptPath                func(childComplexity int) int
		StepbackBisect                     func(childComplexity int) int
		StepbackDisabled                   func(childComplexity int) int
		TaskAnnotationSettings             func(childComplexity int) int
		TestSelection                      func(childComplexity int) int
		TracksPushEvents                   func(childComplexity int) int
		Triggers                           func(childComplexity int) int
		VersionControlEnabled              func(childComplexity int) int
		WorkstationConfig                  func(childComplexity int) int
	}

	RepoSettings struct {
		Aliases               func(childComplexity int) int
		GithubAppAuth         func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	RepoTestSelectionSettings struct {
		Allowed        func(childComplexity int) int
		DefaultEnabled func(childComplexity int) int
	}

	RepoWorkstationConfig struct {
		GitClone      func(childComplexity int) int
		SetupCommands func(childComplexity int) int
	}

	RepotrackerConfig struct {
		MaxConcurrentRequests      func(childComplexity int) int
		MaxRepoRevisionsToSearch   func(childComplexity int) int
		NumNewRepoRevisionsToFetch func(childComplexity int) int
	}

	RepotrackerError struct {
		Exists            func(childComplexity int) int
		InvalidRevision   func(childComplexity int) int
		MergeBaseRevision func(childComplexity int) int
	}

	ResourceLimits struct {
		LockedMemoryKB  func(childComplexity int) int
		NumFiles        func(childComplexity int) int
		NumProcesses    func(childComplexity int) int
		NumTasks        func(childComplexity int) int
		VirtualMemoryKB func(childComplexity int) int
	}

	RestartAdminTasksPayload struct {
		NumRestartedTasks func(childComplexity int) int
	}

	RuntimeEnvironmentConfig struct {
		APIKey  func(childComplexity int) int
		BaseURL func(childComplexity int) int
	}

	S3Credentials struct {
		Bucket func(childComplexity int) int
		Key    func(childComplexity int) int
		Secret func(childComplexity int) int
	}

	SESConfig struct {
		SenderAddress func(childComplexity int) int
	}

	SSHConfig struct {
		SpawnHostKey func(childComplexity int) int
		TaskHostKey  func(childComplexity int) int
	}

	SSHKeyPair struct {
		Name      func(childComplexity int) int
		SecretARN func(childComplexity int) int
	}

	SaveDistroPayload struct {
		Distro    func(childComplexity int) int
		HostCount func(childComplexity int) int
	}

	SchedulerConfig struct {
		AcceptableHostIdleTimeSeconds func(childComplexity int) int
		CacheDurationSeconds          func(childComplexity int) int
		CommitQueueFactor             func(childComplexity int) int
		ExpectedRuntimeFactor         func(childComplexity int) int
		FutureHostFraction            func(childComplexity int) int
		GenerateTaskFactor            func(childComplexity int) int
		GroupVersions                 func(childComplexity int) int
		HostAllocator                 func(childComplexity int) int
		HostAllocatorFeedbackRule     func(childComplexity int) int
		HostAllocatorRoundingRule     func(childComplexity int) int
		HostsOverallocatedRule        func(childComplexity int) int
		MainlineTimeInQueueFactor     func(childComplexity int) int
		NumDependentsFactor           func(childComplexity int) int
		PatchFactor                   func(childComplexity int) int
		PatchTimeInQueueFactor        func(childComplexity int) int
		StepbackTaskFactor            func(childComplexity int) int
		TargetTimeSeconds             func(childComplexity int) int
		TaskFinder                    func(childComplexity int) int
	}

	SearchReturnInfo struct {
		FeaturesURL func(childComplexity int) int
		Issues      func(childComplexity int) int
		Search      func(childComplexity int) int
		Source      func(childComplexity int) int
	}

	SecretsManagerConfig struct {
		SecretPrefix func(childComplexity int) int
	}

	Selector struct {
		Data func(childComplexity int) int
		Type func(childComplexity int) int
	}

	ServiceFlags struct {
		AgentStartDisabled              func(childComplexity int) int
		AlertsDisabled                  func(childComplexity int) int
		BackgroundReauthDisabled        func(childComplexity int) int
		BackgroundStatsDisabled         func(childComplexity int) int
		CLIUpdatesDisabled              func(childComplexity int) int
		CacheStatsEndpointDisabled      func(childComplexity int) int
		CacheStatsJobDisabled           func(childComplexity int) int
		CheckBlockedTasksDisabled       func(childComplexity int) int
		CloudCleanupDisabled            func(childComplexity int) int
		DebugSpawnHostDisabled          func(childComplexity int) int
		DegradedModeDisabled            func(childComplexity int) int
		ElasticIPsDisabled              func(childComplexity int) int
		EmailNotificationsDisabled      func(childComplexity int) int
		EventProcessingDisabled         func(childComplexity int) int
		GithubPRTestingDisabled         func(childComplexity int) int
		GithubStatusAPIDisabled         func(childComplexity int) int
		HostAllocatorDisabled           func(childComplexity int) int
		HostInitDisabled                func(childComplexity int) int
		JIRANotificationsDisabled       func(childComplexity int) int
		JWTTokenForCLIDisabled          func(childComplexity int) int
		LargeParserProjectsDisabled     func(childComplexity int) int
		MonitorDisabled                 func(childComplexity int) int
		PodAllocatorDisabled            func(childComplexity int) int
		PodInitDisabled                 func(childComplexity int) int
		ReleaseModeDisabled             func(childComplexity int) int
		RepotrackerDisabled             func(childComplexity int) int
		S3LifecycleSyncDisabled         func(childComplexity int) int
		SchedulerDisabled               func(childComplexity int) int
		SlackNotificationsDisabled      func(childComplexity int) int
		SleepScheduleDisabled           func(childComplexity int) int
		StaticAPIKeysDisabled           func(childComplexity int) int
		SystemFailedTaskRestartDisabled func(childComplexity int) int
		TaskDispatchDisabled            func(childComplexity int) int
		TaskLoggingDisabled             func(childComplexity int) int
		TaskReliabilityDisabled         func(childComplexity int) int
		UnrecognizedPodCleanupDisabled  func(childComplexity int) int
		UseGitForGitHubFilesDisabled    func(childComplexity int) int
		WebhookNotificationsDisabled    func(childComplexity int) int
	}

	SetLastRevisionPayload struct {
		MergeBaseRevision func(childComplexity int) int
	}

	SingleTaskDistroConfig struct {
		ProjectTasksPairs func(childComplexity int) int
	}

	SlackConfig struct {
		Level   func(childComplexity int) int
		Name    func(childComplexity int) int
		Options func(childComplexity int) int
		Token   func(childComplexity int) int
	}

	SlackOptions struct {
		AllFields     func(childComplexity int) int
		BasicMetadata func(childComplexity int) int
		Channel       func(childComplexity int) int
		Fields        func(childComplexity int) int
		FieldsSet     func(childComplexity int) int
		Hostname      func(childComplexity int) int
		Name          func(childComplexity int) int
		Username      func(childComplexity int) int
	}

	SleepSchedule struct {
		DailyStartTime         func(childComplexity int) int
		DailyStopTime          func(childComplexity int) int
		NextStartTime          func(childComplexity int) int
		NextStopTime           func(childComplexity int) int
		PermanentlyExempt      func(childComplexity int) int
		ShouldKeepOff          func(childComplexity int) int
		TemporarilyExemptUntil func(childComplexity int) int
		TimeZone               func(childComplexity int) int
		WholeWeekdaysOff       func(childComplexity int) int
	}

	SleepScheduleConfig struct {
		PermanentlyExemptHosts func(childComplexity int) int
	}

	Source struct {
		Author    func(childComplexity int) int
		Requester func(childComplexity int) int
		Time      func(childComplexity int) int
	}

	SpawnHostConfig struct {
		SpawnHostsPerUser         func(childComplexity int) int
		UnexpirableHostsPerUser   func(childComplexity int) int
		UnexpirableVolumesPerUser func(childComplexity int) int
	}

	SplunkConfig struct {
		SplunkConnectionInfo func(childComplexity int) int
	}

	SplunkConnectionInfo struct {
		Channel   func(childComplexity int) int
		ServerURL func(childComplexity int) int
		Token     func(childComplexity int) int
	}

	SpruceConfig struct {
		Banner           func(childComplexity int) int
		BannerTheme      func(childComplexity int) int
		ContainerPools   func(childComplexity int) int
		GithubOrgs       func(childComplexity int) int
		Jira             func(childComplexity int) int
		Providers        func(childComplexity int) int
		SecretFields     func(childComplexity int) int
		ServiceFlags     func(childComplexity int) int
		SingleTaskDistro func(childComplexity int) int
		Slack            func(childComplexity int) int
		Spawnhost        func(childComplexity int) int
		Ui               func(childComplexity int) int
	}

	StatusCount struct {
		Count  func(childComplexity int) int
		Status func(childComplexity int) int
	}

	StepbackInfo struct {
		LastFailingStepbackTaskId func(childComplexity int) int
		LastPassingStepbackTaskId func(childComplexity int) int
		NextStepbackTaskId        func(childComplexity int) int
		PreviousStepbackTaskId    func(childComplexity int) int
	}

	Subnet struct {
		AZ       func(childComplexity int) int
		SubnetID func(childComplexity int) int
	}

	Subscriber struct {
		EmailSubscriber       func(childComplexity int) int
		GithubCheckSubscriber func(childComplexity int) int
		GithubPRSubscriber    func(childComplexity int) int
		JiraCommentSubscriber func(childComplexity int) int
		JiraIssueSubscriber   func(childComplexity int) int
		SlackSubscriber       func(childComplexity int) int
		WebhookSubscriber     func(childComplexity int) int
	}

	SubscriberWrapper struct {
		Subscriber func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	Task struct {
		AbortInfo               func(childComplexity int) int
		Aborted                 func(childComplexity int) int
		Activated               func(childComplexity int) int
		ActivatedBy             func(childComplexity int) int
		ActivatedTime           func(childComplexity int) int
		Ami                     func(childComplexity int) int
		Annotation              func(childComplexity int) int
		BaseStatus              func(childComplexity int) int
		BaseTask                func(childComplexity int) int
		Blocked                 func(childComplexity int) int
		BuildId                 func(childComplexity int) int
		BuildVariant            func(childComplexity int) int
		BuildVariantDisplayName func(childComplexity int) int
		CanAbort                func(childComplexity int) int
		CanDisable              func(childComplexity int) int
		CanModifyAnnotation     func(childComplexity int) int
		CanOverrideDependencies func(childComplexity int) int
		CanRestart              func(childComplexity int) int
		CanSchedule             func(childComplexity int) int
		CanSetPriority          func(childComplexity int) int
		CanUnschedule           func(childComplexity int) int
		ContainerAllocatedTime  func(childComplexity int) int
		CreateTime              func(childComplexity int) int
		DependsOn               func(childComplexity int) int
		Details                 func(childComplexity int) int
		DispatchTime            func(childComplexity int) int
		DisplayName             func(childComplexity int) int
		DisplayOnly             func(childComplexity int) int
		DisplayStatus           func(childComplexity int) int
		DisplayTask             func(childComplexity int) int
		DistroId                func(childComplexity int) int
		EstimatedStart          func(childComplexity int) int
		Execution               func(childComplexity int) int
		ExecutionTasks          func(childComplexity int) int
		ExecutionTasksFull      func(childComplexity int) int
		ExpectedDuration        func(childComplexity int) int
		FailedTestCount         func(childComplexity int) int
		Files                   func(childComplexity int) int
		FinishTime              func(childComplexity int) int
		GenerateTask            func(childComplexity int) int
		GeneratedBy             func(childComplexity int) int
		GeneratedByName         func(childComplexity int) int
		HasTestResults          func(childComplexity int) int
		HostId                  func(childComplexity int) int
		Id                      func(childComplexity int) int
		ImageID                 func(childComplexity int) int
		IngestTime              func(childComplexity int) int
		IsPerfPluginEnabled     func(childComplexity int) int
		LatestExecution         func(childComplexity int) int
		Logs                    func(childComplexity int) int
		MinQueuePosition        func(childComplexity int) int
		Order                   func(childComplexity int) int
		Patch                   func(childComplexity int) int
		PatchNumber             func(childComplexity int) int
		Pod                     func(childComplexity int) int
		PredictedTaskCost       func(childComplexity int) int
		Priority                func(childComplexity int) int
		Project                 func(childComplexity int) int
		ProjectId               func(childComplexity int) int
		ProjectIdentifier       func(childComplexity int) int
		Requester               func(childComplexity int) int
		ResetWhenFinished       func(childComplexity int) int
		Revision                func(childComplexity int) int
		ScheduledTime           func(childComplexity int) int
		SpawnHostLink           func(childComplexity int) int
		StartTime               func(childComplexity int) int
		Status                  func(childComplexity int) int
		StepbackInfo            func(childComplexity int) int
		Tags                    func(childComplexity int) int
		TaskCost                func(childComplexity int) int
		TaskGroup               func(childComplexity int) int
		TaskGroupMaxHosts       func(childComplexity int) int
		TaskLogs                func(childComplexity int) int
		TaskOwnerTeam           func(childComplexity int) int
		TestSelectionEnabled    func(childComplexity int) int
		Tests                   func(childComplexity int, opts *TestFilterOptions) int
		TimeTaken               func(childComplexity int) int
		TotalTestCount          func(childComplexity int) int
		VersionMetadata         func(childComplexity int) int
	}

	TaskAnnotationSettings struct {
		FileTicketWebhook func(childComplexity int) int
	}

	TaskContainerCreationOpts struct {
		Arch       func(childComplexity int) int
		CPU        func(childComplexity int) int
		Image      func(childComplexity int) int
		MemoryMB   func(childComplexity int) int
		Os         func(childComplexity int) int
		WorkingDir func(childComplexity int) int
	}

	TaskEndDetail struct {
		Description          func(childComplexity int) int
		DiskDevices          func(childComplexity int) int
		FailingCommand       func(childComplexity int) int
		FailureMetadataTags  func(childComplexity int) int
		OOMTracker           func(childComplexity int) int
		OtherFailingCommands func(childComplexity int) int
		Status               func(childComplexity int) int
		TimedOut             func(childComplexity int) int
		TimeoutType          func(childComplexity int) int
		TraceID              func(childComplexity int) int
		Type                 func(childComplexity int) int
	}

	TaskEventLogData struct {
		BlockedOn func(childComplexity int) int
		HostId    func(childComplexity int) int
		JiraIssue func(childComplexity int) int
		JiraLink  func(childComplexity int) int
		PodId     func(childComplexity int) int
		Priority  func(childComplexity int) int
		Status    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		UserId    func(childComplexity int) int
	}

	TaskEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	TaskFiles struct {
		FileCount    func(childComplexity int) int
		GroupedFiles func(childComplexity int) int
	}

	TaskHistory struct {
		Pagination func(childComplexity int) int
		Tasks      func(childComplexity int) int
	}

	TaskHistoryPagination struct {
		MostRecentTaskOrder func(childComplexity int) int
		OldestTaskOrder     func(childComplexity int) int
	}

	TaskInfo struct {
		Id   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	TaskLimitsConfig struct {
		MaxConcurrentLargeParserProjectTasks             func(childComplexity int) int
		MaxDailyAutomaticRestarts                        func(childComplexity int) int
		MaxDegradedModeConcurrentLargeParserProjectTasks func(childComplexity int) int
		MaxDegradedModeParserProjectSize                 func(childComplexity int) int
		MaxExecTimeoutSecs                               func(childComplexity int) int
		MaxGenerateTaskJSONSize                          func(childComplexity int) int
		MaxHourlyPatchTasks                              func(childComplexity int) int
		MaxIncludesPerVersion                            func(childComplexity int) int
		MaxParserProjectSize                             func(childComplexity int) int
		MaxPendingGeneratedTasks                         func(childComplexity int) int
		MaxTaskExecution                                 func(childComplexity int) int
		MaxTasksPerVersion                               func(childComplexity int) int
	}

	TaskLogLinks struct {
		AgentLogLink  func(childComplexity int) int
		AllLogLink    func(childComplexity int) int
		SystemLogLink func(childComplexity int) int
		TaskLogLink   func(childComplexity int) int
	}

	TaskLogs struct {
		AgentLogs  func(childComplexity int) int
		AllLogs    func(childComplexity int) int
		EventLogs  func(childComplexity int) int
		Execution  func(childComplexity int) int
		SystemLogs func(childComplexity int) int
		TaskID     func(childComplexity int) int
		TaskLogs   func(childComplexity int) int
	}

	TaskOwnerTeam struct {
		AssignmentType func(childComplexity int) int
		JiraProject    func(childComplexity int) int
		Messages       func(childComplexity int) int
		TeamName       func(childComplexity int) int
	}

	TaskQueueDistro struct {
		HostCount func(childComplexity int) int
		ID        func(childComplexity int) int
		TaskCount func(childComplexity int) int
	}

	TaskQueueItem struct {
		ActivatedBy       func(childComplexity int) int
		BuildVariant      func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ExpectedDuration  func(childComplexity int) int
		Id                func(childComplexity int) int
		Priority          func(childComplexity int) int
		Project           func(childComplexity int) int
		ProjectIdentifier func(childComplexity int) int
		Requester         func(childComplexity int) int
		Revision          func(childComplexity int) int
		Version           func(childComplexity int) int
	}

	TaskSpecifier struct {
		PatchAlias   func(childComplexity int) int
		TaskRegex    func(childComplexity int) int
		VariantRegex func(childComplexity int) int
	}

	TaskStats struct {
		Counts func(childComplexity int) int
		ETA    func(childComplexity int) int
	}

	TaskTestResult struct {
		FilteredTestCount func(childComplexity int) int
		TestResults       func(childComplexity int) int
		TotalTestCount    func(childComplexity int) int
	}

	TaskTestResultSample struct {
		Execution               func(childComplexity int) int
		MatchingFailedTestNames func(childComplexity int) int
		TaskID                  func(childComplexity int) int
		TotalTestCount          func(childComplexity int) int
	}

	TestLog struct {
		LineNum       func(childComplexity int) int
		RenderingType func(childComplexity int) int
		TestName      func(childComplexity int) int
		URL           func(childComplexity int) int
		URLParsley    func(childComplexity int) int
		URLRaw        func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	TestResult struct {
		BaseStatus func(childComplexity int) int
		Duration   func(childComplexity int) int
		EndTime    func(childComplexity int) int
		Execution  func(childComplexity int) int
		ExitCode   func(childComplexity int) int
		GroupID    func(childComplexity int) int
		ID         func(childComplexity int) int
		Logs       func(childComplexity int) int
		StartTime  func(childComplexity int) int
		Status     func(childComplexity int) int
		TaskID     func(childComplexity int) int
		TestFile   func(childComplexity int) int
	}

	TestSelectionConfig struct {
		URL func(childComplexity int) int
	}

	TestSelectionSettings struct {
		Allowed        func(childComplexity int) int
		DefaultEnabled func(childComplexity int) int
	}

	TicketFields struct {
		AssignedTeam        func(childComplexity int) int
		AssigneeDisplayName func(childComplexity int) int
		Created             func(childComplexity int) int
		ResolutionName      func(childComplexity int) int
		Status              func(childComplexity int) int
		Summary             func(childComplexity int) int
		Updated             func(childComplexity int) int
	}

	Toolchain struct {
		Name    func(childComplexity int) int
		Path    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	TracerSettings struct {
		CollectorAPIKey           func(childComplexity int) int
		CollectorEndpoint         func(childComplexity int) int
		CollectorInternalEndpoint func(childComplexity int) int
		Enabled                   func(childComplexity int) int
	}

	TriggerAlias struct {
		Alias                        func(childComplexity int) int
		BuildVariantRegex            func(childComplexity int) int
		ConfigFile                   func(childComplexity int) int
		DateCutoff                   func(childComplexity int) int
		Level                        func(childComplexity int) int
		Project                      func(childComplexity int) int
		Status                       func(childComplexity int) int
		TaskRegex                    func(childComplexity int) int
		UnscheduleDownstreamVersions func(childComplexity int) int
	}

	TriggerConfig struct {
		GenerateTaskDistro func(childComplexity int) int
	}

	UIConfig struct {
		BetaFeatures              func(childComplexity int) int
		CORSOrigins               func(childComplexity int) int
		CacheTemplates            func(childComplexity int) int
		CsrfKey                   func(childComplexity int) int
		DefaultProject            func(childComplexity int) int
		FileStreamingContentTypes func(childComplexity int) int
		HelpUrl                   func(childComplexity int) int
		HttpListenAddr            func(childComplexity int) int
		LoginDomain               func(childComplexity int) int
		ParsleyUrl                func(childComplexity int) int
		Secret                    func(childComplexity int) int
		StagingEnvironment        func(childComplexity int) int
		UIv2Url                   func(childComplexity int) int
		Url                       func(childComplexity int) int
		UserVoice                 func(childComplexity int) int
	}

	UpdateBetaFeaturesPayload struct {
		BetaFeatures func(childComplexity int) int
	}

	UpdateParsleySettingsPayload struct {
		ParsleySettings func(childComplexity int) int
	}

	UpstreamProject struct {
		Owner       func(childComplexity int) int
		Project     func(childComplexity int) int
		Repo        func(childComplexity int) int
		ResourceID  func(childComplexity int) int
		Revision    func(childComplexity int) int
		Task        func(childComplexity int) int
		TriggerID   func(childComplexity int) int
		TriggerType func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	UseSpruceOptions struct {
		SpruceV1 func(childComplexity int) int
	}

	User struct {
		BetaFeatures    func(childComplexity int) int
		DisplayName     func(childComplexity int) int
		EmailAddress    func(childComplexity int) int
		ParsleyFilters  func(childComplexity int) int
		ParsleySettings func(childComplexity int) int
		Patches         func(childComplexity int, patchesInput PatchesInput) int
		Permissions     func(childComplexity int) int
		Settings        func(childComplexity int) int
		Subscriptions   func(childComplexity int) int
		UserID          func(childComplexity int) int
	}

	UserConfig struct {
		APIKey           func(childComplexity int) int
		APIServerHost    func(childComplexity int) int
		OauthClientID    func(childComplexity int) int
		OauthConnectorID func(childComplexity int) int
		OauthIssuer      func(childComplexity int) int
		UIServerHost     func(childComplexity int) int
		User             func(childComplexity int) int
	}

	UserServiceFlags struct {
		JWTTokenForCLIDisabled func(childComplexity int) int
	}

	UserSettings struct {
		DateFormat       func(childComplexity int) int
		GithubUser       func(childComplexity int) int
		Notifications    func(childComplexity int) int
		Region           func(childComplexity int) int
		SlackMemberId    func(childComplexity int) int
		SlackUsername    func(childComplexity int) int
		TimeFormat       func(childComplexity int) int
		Timezone         func(childComplexity int) int
		UseSpruceOptions func(childComplexity int) int
	}

	VariantTask struct {
		Name  func(childComplexity int) int
		Tasks func(childComplexity int) int
	}

	Version struct {
		Activated                func(childComplexity int) int
		Author                   func(childComplexity int) int
		AuthorEmail              func(childComplexity int) int
		BaseTaskStatuses         func(childComplexity int) int
		BaseVersion              func(childComplexity int) int
		Branch                   func(childComplexity int) int
		BuildVariantStats        func(childComplexity int, options BuildVariantOptions) int
		BuildVariants            func(childComplexity int, options BuildVariantOptions) int
		ChildVersions            func(childComplexity int) int
		CreateTime               func(childComplexity int) int
		Errors                   func(childComplexity int) int
		ExternalLinksForMetadata func(childComplexity int) int
		FinishTime               func(childComplexity int) int
		GeneratedTaskCounts      func(childComplexity int) int
		GitTags                  func(childComplexity int) int
		Id                       func(childComplexity int) int
		Ignored                  func(childComplexity int) int
		IsPatch                  func(childComplexity int) int
		Manifest                 func(childComplexity int) int
		Message                  func(childComplexity int) int
		Order                    func(childComplexity int) int
		Parameters               func(childComplexity int) int
		Patch                    func(childComplexity int) int
		PredictedCost            func(childComplexity int) int
		PreviousVersion          func(childComplexity int) int
		Project                  func(childComplexity int) int
		ProjectIdentifier        func(childComplexity int) int
		ProjectMetadata          func(childComplexity int) int
		Repo                     func(childComplexity int) int
		Requester                func(childComplexity int) int
		Revision                 func(childComplexity int) int
		StartTime                func(childComplexity int) int
		Status                   func(childComplexity int) int
		TaskCount                func(childComplexity int, options *TaskCountOptions) int
		TaskStatusStats          func(childComplexity int, options BuildVariantOptions) int
		TaskStatuses             func(childComplexity int) int
		Tasks                    func(childComplexity int, options TaskFilterOptions) int
		UpstreamProject          func(childComplexity int) int
		User                     func(childComplexity int) int
		VersionTiming            func(childComplexity int) int
		Warnings                 func(childComplexity int) int
		WaterfallBuilds          func(childComplexity int) int
	}

	VersionTasks struct {
		Count func(childComplexity int) int
		Data  func(childComplexity int) int
	}

	VersionTiming struct {
		Makespan  func(childComplexity int) int
		TimeTaken func(childComplexity int) int
	}

	Volume struct {
		AvailabilityZone func(childComplexity int) int
		CreatedBy        func(childComplexity int) int
		CreationTime     func(childComplexity int) int
		DeviceName       func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		Expiration       func(childComplexity int) int
		HomeVolume       func(childComplexity int) int
		Host             func(childComplexity int) int
		HostID           func(childComplexity int) int
		ID               func(childComplexity int) int
		Migrating        func(childComplexity int) int
		NoExpiration     func(childComplexity int) int
		Size             func(childComplexity int) int
		Type             func(childComplexity int) int
	}

	Waterfall struct {
		FlattenedVersions func(childComplexity int) int
		Pagination        func(childComplexity int) int
	}

	WaterfallBuild struct {
		Activated    func(childComplexity int) int
		BuildVariant func(childComplexity int) int
		DisplayName  func(childComplexity int) int
		Id           func(childComplexity int) int
		Tasks        func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	WaterfallBuildVariant struct {
		Builds      func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Id          func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	WaterfallPagination struct {
		ActiveVersionIds       func(childComplexity int) int
		HasNextPage            func(childComplexity int) int
		HasPrevPage            func(childComplexity int) int
		MostRecentVersionOrder func(childComplexity int) int
		NextPageOrder          func(childComplexity int) int
		PrevPageOrder          func(childComplexity int) int
	}

	WaterfallTask struct {
		DisplayName        func(childComplexity int) int
		DisplayStatusCache func(childComplexity int) int
		Execution          func(childComplexity int) int
		Id                 func(childComplexity int) int
		Status             func(childComplexity int) int
	}

	WaterfallVersion struct {
		InactiveVersions func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	Webhook struct {
		Endpoint func(childComplexity int) int
		Secret   func(childComplexity int) int
	}

	WebhookHeader struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	WebhookSubscriber struct {
		Headers    func(childComplexity int) int
		MinDelayMS func(childComplexity int) int
		Retries    func(childComplexity int) int
		Secret     func(childComplexity int) int
		TimeoutMS  func(childComplexity int) int
		URL        func(childComplexity int) int
	}

	WorkstationConfig struct {
		GitClone      func(childComplexity int) int
		SetupCommands func(childComplexity int) int
	}

	WorkstationSetupCommand struct {
		Command   func(childComplexity int) int
		Directory func(childComplexity int) int
	}
}

type AdminSettingsResolver interface {
	BannerTheme(ctx context.Context, obj *model.APIAdminSettings) (*evergreen.BannerTheme, error)
}
type AnnotationResolver interface {
	WebhookConfigured(ctx context.Context, obj *model.APITaskAnnotation) (bool, error)
}
type ContainerPoolResolver interface {
	Port(ctx context.Context, obj *model.APIContainerPool) (int, error)
}
type DistroResolver interface {
	AvailableRegions(ctx context.Context, obj *model.APIDistro) ([]string, error)

	ProviderSettingsList(ctx context.Context, obj *model.APIDistro) ([]map[string]any, error)
}
type HostResolver interface {
	Ami(ctx context.Context, obj *model.APIHost) (*string, error)

	DistroID(ctx context.Context, obj *model.APIHost) (*string, error)
	Elapsed(ctx context.Context, obj *model.APIHost) (*time.Time, error)
	Events(ctx context.Context, obj *model.APIHost, opts HostEventsInput) (*HostEvents, error)
	EventTypes(ctx context.Context, obj *model.APIHost) ([]string, error)

	HomeVolume(ctx context.Context, obj *model.APIHost) (*model.APIVolume, error)

	SleepSchedule(ctx context.Context, obj *model.APIHost) (*host.SleepScheduleInfo, error)

	Uptime(ctx context.Context, obj *model.APIHost) (*time.Time, error)

	Volumes(ctx context.Context, obj *model.APIHost) ([]*model.APIVolume, error)
}
type ImageResolver interface {
	Distros(ctx context.Context, obj *model.APIImage) ([]*model.APIDistro, error)
	Events(ctx context.Context, obj *model.APIImage, limit int, page int) (*ImageEventsPayload, error)
	Files(ctx context.Context, obj *model.APIImage, opts thirdparty.FileFilterOptions) (*ImageFilesPayload, error)

	LatestTask(ctx context.Context, obj *model.APIImage) (*model.APITask, error)
	OperatingSystem(ctx context.Context, obj *model.APIImage, opts thirdparty.OSInfoFilterOptions) (*ImageOperatingSystemPayload, error)
	Packages(ctx context.Context, obj *model.APIImage, opts thirdparty.PackageFilterOptions) (*ImagePackagesPayload, error)
	Toolchains(ctx context.Context, obj *model.APIImage, opts thirdparty.ToolchainFilterOptions) (*ImageToolchainsPayload, error)
}
type IssueLinkResolver interface {
	JiraTicket(ctx context.Context, obj *model.APIIssueLink) (*thirdparty.JiraTicket, error)
}
type JiraNotificationsConfigResolver interface {
	CustomFields(ctx context.Context, obj *model.APIJIRANotificationsConfig) ([]*JiraNotificationsProjectEntry, error)
}
type LogkeeperBuildResolver interface {
	Task(ctx context.Context, obj *plank.Build) (*model.APITask, error)
}
type MutationResolver interface {
	BbCreateTicket(ctx context.Context, taskID string, execution *int) (bool, error)
	AddAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	EditAnnotationNote(ctx context.Context, taskID string, execution int, originalMessage string, newMessage string) (bool, error)
	MoveAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	RemoveAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	SetAnnotationMetadataLinks(ctx context.Context, taskID string, execution int, metadataLinks []*model.APIMetadataLink) (bool, error)
	SaveAdminSettings(ctx context.Context, adminSettings model.APIAdminSettings) (*model.APIAdminSettings, error)
	RestartAdminTasks(ctx context.Context, opts model1.RestartOptions) (*RestartAdminTasksPayload, error)
	DeleteDistro(ctx context.Context, opts DeleteDistroInput) (*DeleteDistroPayload, error)
	CopyDistro(ctx context.Context, opts model.CopyDistroOpts) (*NewDistroPayload, error)
	CreateDistro(ctx context.Context, opts CreateDistroInput) (*NewDistroPayload, error)
	SaveDistro(ctx context.Context, opts SaveDistroInput) (*SaveDistroPayload, error)
	ReprovisionToNew(ctx context.Context, hostIds []string) (int, error)
	RestartJasper(ctx context.Context, hostIds []string) (int, error)
	UpdateHostStatus(ctx context.Context, hostIds []string, status string, notes *string) (int, error)
	SetPatchVisibility(ctx context.Context, patchIds []string, hidden bool) ([]*model.APIPatch, error)
	SchedulePatch(ctx context.Context, patchID string, configure PatchConfigure) (*model.APIPatch, error)
	AttachProjectToNewRepo(ctx context.Context, project MoveProjectInput) (*model.APIProjectRef, error)
	AttachProjectToRepo(ctx context.Context, projectID string) (*model.APIProjectRef, error)
	CreateProject(ctx context.Context, project model.APIProjectRef, requestS3Creds *bool) (*model.APIProjectRef, error)
	CopyProject(ctx context.Context, project model.CopyProjectOpts, requestS3Creds *bool) (*model.APIProjectRef, error)
	DeactivateStepbackTask(ctx context.Context, opts DeactivateStepbackTaskInput) (bool, error)
	DefaultSectionToRepo(ctx context.Context, opts DefaultSectionToRepoInput) (*string, error)
	DeleteGithubAppCredentials(ctx context.Context, opts DeleteGithubAppCredentialsInput) (*DeleteGithubAppCredentialsPayload, error)
	DeleteProject(ctx context.Context, projectID string) (bool, error)
	DetachProjectFromRepo(ctx context.Context, projectID string) (*model.APIProjectRef, error)
	ForceRepotrackerRun(ctx context.Context, projectID string) (bool, error)
	PromoteVarsToRepo(ctx context.Context, opts PromoteVarsToRepoInput) (bool, error)
	SaveProjectSettingsForSection(ctx context.Context, projectSettings *model.APIProjectSettings, section ProjectSettingsSection) (*model.APIProjectSettings, error)
	SaveRepoSettingsForSection(ctx context.Context, repoSettings *model.APIProjectSettings, section ProjectSettingsSection) (*model.APIProjectSettings, error)
	SetLastRevision(ctx context.Context, opts SetLastRevisionInput) (*SetLastRevisionPayload, error)
	AttachVolumeToHost(ctx context.Context, volumeAndHost VolumeHost) (bool, error)
	DetachVolumeFromHost(ctx context.Context, volumeID string) (bool, error)
	EditSpawnHost(ctx context.Context, spawnHost *EditSpawnHostInput) (*model.APIHost, error)
	MigrateVolume(ctx context.Context, volumeID string, spawnHostInput *SpawnHostInput) (bool, error)
	SpawnHost(ctx context.Context, spawnHostInput *SpawnHostInput) (*model.APIHost, error)
	SpawnVolume(ctx context.Context, spawnVolumeInput SpawnVolumeInput) (bool, error)
	RemoveVolume(ctx context.Context, volumeID string) (bool, error)
	UpdateSpawnHostStatus(ctx context.Context, updateSpawnHostStatusInput UpdateSpawnHostStatusInput) (*model.APIHost, error)
	UpdateVolume(ctx context.Context, updateVolumeInput UpdateVolumeInput) (bool, error)
	AbortTask(ctx context.Context, taskID string) (*model.APITask, error)
	OverrideTaskDependencies(ctx context.Context, taskID string) (*model.APITask, error)
	RestartTask(ctx context.Context, taskID string, failedOnly bool) (*model.APITask, error)
	ScheduleTasks(ctx context.Context, versionID string, taskIds []string) ([]*model.APITask, error)
	SetTaskPriority(ctx context.Context, taskID string, priority int) (*model.APITask, error)
	SetTaskPriorities(ctx context.Context, taskPriorities []*TaskPriority) ([]*model.APITask, error)
	UnscheduleTask(ctx context.Context, taskID string) (*model.APITask, error)
	QuarantineTest(ctx context.Context, opts QuarantineTestInput) (*QuarantineTestPayload, error)
	AddFavoriteProject(ctx context.Context, opts AddFavoriteProjectInput) (*model.APIProjectRef, error)
	ClearMySubscriptions(ctx context.Context) (int, error)
	CreatePublicKey(ctx context.Context, publicKeyInput PublicKeyInput) ([]*model.APIPubKey, error)
	DeleteSubscriptions(ctx context.Context, subscriptionIds []string) (int, error)
	RemoveFavoriteProject(ctx context.Context, opts RemoveFavoriteProjectInput) (*model.APIProjectRef, error)
	RemovePublicKey(ctx context.Context, keyName string) ([]*model.APIPubKey, error)
	ResetAPIKey(ctx context.Context) (*UserConfig, error)
	SaveSubscription(ctx context.Context, subscription model.APISubscription) (bool, error)
	UpdateBetaFeatures(ctx context.Context, opts UpdateBetaFeaturesInput) (*UpdateBetaFeaturesPayload, error)
	UpdateParsleySettings(ctx context.Context, opts UpdateParsleySettingsInput) (*UpdateParsleySettingsPayload, error)
	UpdatePublicKey(ctx context.Context, targetKeyName string, updateInfo PublicKeyInput) ([]*model.APIPubKey, error)
	UpdateUserSettings(ctx context.Context, userSettings *model.APIUserSettings) (bool, error)
	RestartVersions(ctx context.Context, versionID string, abort bool, versionsToRestart []*model1.VersionToRestart) ([]*model.APIVersion, error)
	ScheduleUndispatchedBaseTasks(ctx context.Context, versionID string) ([]*model.APITask, error)
	SetVersionPriority(ctx context.Context, versionID string, priority int) (*string, error)
	UnscheduleVersionTasks(ctx context.Context, versionID string, abort bool) (*string, error)
}
type PatchResolver interface {
	AuthorDisplayName(ctx context.Context, obj *model.APIPatch) (string, error)
	BaseTaskStatuses(ctx context.Context, obj *model.APIPatch) ([]string, error)
	Builds(ctx context.Context, obj *model.APIPatch) ([]*model.APIBuild, error)

	Duration(ctx context.Context, obj *model.APIPatch) (*PatchDuration, error)
	GeneratedTaskCounts(ctx context.Context, obj *model.APIPatch) ([]*GeneratedTaskCountResults, error)

	IncludedLocalModules(ctx context.Context, obj *model.APIPatch) ([]*model.APILocalModuleInclude, error)

	Parameters(ctx context.Context, obj *model.APIPatch) ([]*model.APIParameter, error)

	PatchTriggerAliases(ctx context.Context, obj *model.APIPatch) ([]*model.APIPatchTriggerDefinition, error)
	Project(ctx context.Context, obj *model.APIPatch) (*PatchProject, error)

	ProjectIdentifier(ctx context.Context, obj *model.APIPatch) (string, error)
	ProjectMetadata(ctx context.Context, obj *model.APIPatch) (*model.APIProjectRef, error)

	TaskCount(ctx context.Context, obj *model.APIPatch) (*int, error)

	TaskStatuses(ctx context.Context, obj *model.APIPatch) ([]string, error)
	Time(ctx context.Context, obj *model.APIPatch) (*PatchTime, error)
	User(ctx context.Context, obj *model.APIPatch) (*model.APIDBUser, error)

	VersionFull(ctx context.Context, obj *model.APIPatch) (*model.APIVersion, error)
}
type PermissionsResolver interface {
	CanCreateDistro(ctx context.Context, obj *Permissions) (bool, error)
	CanCreateProject(ctx context.Context, obj *Permissions) (bool, error)
	CanEditAdminSettings(ctx context.Context, obj *Permissions) (bool, error)
	DistroPermissions(ctx context.Context, obj *Permissions, options DistroPermissionsOptions) (*DistroPermissions, error)
	ProjectPermissions(ctx context.Context, obj *Permissions, options ProjectPermissionsOptions) (*ProjectPermissions, error)
	RepoPermissions(ctx context.Context, obj *Permissions, options RepoPermissionsOptions) (*RepoPermissions, error)
}
type PodResolver interface {
	Events(ctx context.Context, obj *model.APIPod, limit *int, page *int) (*PodEvents, error)

	Status(ctx context.Context, obj *model.APIPod) (string, error)
	Task(ctx context.Context, obj *model.APIPod) (*model.APITask, error)

	Type(ctx context.Context, obj *model.APIPod) (string, error)
}
type PodEventLogDataResolver interface {
	Task(ctx context.Context, obj *model.PodAPIEventData) (*model.APITask, error)
}
type ProjectResolver interface {
	IsFavorite(ctx context.Context, obj *model.APIProjectRef) (bool, error)

	Patches(ctx context.Context, obj *model.APIProjectRef, patchesInput PatchesInput) (*Patches, error)
}
type ProjectSettingsResolver interface {
	Aliases(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APIProjectAlias, error)
	GithubAppAuth(ctx context.Context, obj *model.APIProjectSettings) (*model.APIGithubAppAuth, error)
	GithubWebhooksEnabled(ctx context.Context, obj *model.APIProjectSettings) (bool, error)

	Subscriptions(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APISubscription, error)
	Vars(ctx context.Context, obj *model.APIProjectSettings) (*model.APIProjectVars, error)
}
type ProjectVarsResolver interface {
	AdminOnlyVars(ctx context.Context, obj *model.APIProjectVars) ([]string, error)
	PrivateVars(ctx context.Context, obj *model.APIProjectVars) ([]string, error)
}
type QueryResolver interface {
	BbGetCreatedTickets(ctx context.Context, taskID string) ([]*thirdparty.JiraTicket, error)
	BuildBaron(ctx context.Context, taskID string, execution int) (*BuildBaron, error)
	AdminEvents(ctx context.Context, opts AdminEventsInput) (*AdminEventsPayload, error)
	AdminSettings(ctx context.Context) (*model.APIAdminSettings, error)
	AdminTasksToRestart(ctx context.Context, opts model1.RestartOptions) (*AdminTasksToRestartPayload, error)
	AWSRegions(ctx context.Context) ([]string, error)
	ClientConfig(ctx context.Context) (*model.APIClientConfig, error)
	InstanceTypes(ctx context.Context) ([]string, error)
	SpruceConfig(ctx context.Context) (*model.APIAdminSettings, error)
	SubnetAvailabilityZones(ctx context.Context) ([]string, error)
	Distro(ctx context.Context, distroID string) (*model.APIDistro, error)
	DistroEvents(ctx context.Context, opts DistroEventsInput) (*DistroEventsPayload, error)
	Distros(ctx context.Context, onlySpawnable bool) ([]*model.APIDistro, error)
	DistroTaskQueue(ctx context.Context, distroID string) ([]*model.APITaskQueueItem, error)
	Host(ctx context.Context, hostID string) (*model.APIHost, error)
	HostEvents(ctx context.Context, hostID string, hostTag *string, limit *int, page *int) (*HostEvents, error)
	Hosts(ctx context.Context, hostID *string, distroID *string, currentTaskID *string, statuses []string, startedBy *string, sortBy *HostSortBy, sortDir *SortDirection, page *int, limit *int) (*HostsResponse, error)
	TaskQueueDistros(ctx context.Context) ([]*TaskQueueDistro, error)
	Pod(ctx context.Context, podID string) (*model.APIPod, error)
	Patch(ctx context.Context, patchID string) (*model.APIPatch, error)
	GithubProjectConflicts(ctx context.Context, projectID string) (*model1.GithubProjectConflicts, error)
	Project(ctx context.Context, projectIdentifier string) (*model.APIProjectRef, error)
	Projects(ctx context.Context) ([]*GroupedProjects, error)
	ProjectEvents(ctx context.Context, projectIdentifier string, limit *int, before *time.Time) (*ProjectEvents, error)
	ProjectSettings(ctx context.Context, projectIdentifier string) (*model.APIProjectSettings, error)
	RepoEvents(ctx context.Context, repoID string, limit *int, before *time.Time) (*ProjectEvents, error)
	RepoSettings(ctx context.Context, repoID string) (*model.APIProjectSettings, error)
	ViewableProjectRefs(ctx context.Context) ([]*GroupedProjects, error)
	IsRepo(ctx context.Context, projectOrRepoID string) (bool, error)
	MyHosts(ctx context.Context) ([]*model.APIHost, error)
	MyVolumes(ctx context.Context) ([]*model.APIVolume, error)
	LogkeeperBuildMetadata(ctx context.Context, buildID string) (*plank.Build, error)
	Task(ctx context.Context, taskID string, execution *int) (*model.APITask, error)
	TaskAllExecutions(ctx context.Context, taskID string) ([]*model.APITask, error)
	TaskTestSample(ctx context.Context, versionID string, taskIds []string, filters []*TestFilter) ([]*TaskTestResultSample, error)
	MyPublicKeys(ctx context.Context) ([]*model.APIPubKey, error)
	User(ctx context.Context, userID *string) (*model.APIDBUser, error)
	UserConfig(ctx context.Context) (*UserConfig, error)
	BuildVariantsForTaskName(ctx context.Context, projectIdentifier string, taskName string) ([]*task.BuildVariantTuple, error)
	MainlineCommits(ctx context.Context, options MainlineCommitsOptions, buildVariantOptions *BuildVariantOptions) (*MainlineCommits, error)
	TaskNamesForBuildVariant(ctx context.Context, projectIdentifier string, buildVariant string) ([]string, error)
	Waterfall(ctx context.Context, options WaterfallOptions) (*Waterfall, error)
	TaskHistory(ctx context.Context, options TaskHistoryOpts) (*TaskHistory, error)
	HasVersion(ctx context.Context, patchID string) (bool, error)
	Version(ctx context.Context, versionID string) (*model.APIVersion, error)
	Image(ctx context.Context, imageID string) (*model.APIImage, error)
	Images(ctx context.Context) ([]string, error)
}
type RepoSettingsResolver interface {
	Aliases(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APIProjectAlias, error)
	GithubAppAuth(ctx context.Context, obj *model.APIProjectSettings) (*model.APIGithubAppAuth, error)
	GithubWebhooksEnabled(ctx context.Context, obj *model.APIProjectSettings) (bool, error)

	Subscriptions(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APISubscription, error)
	Vars(ctx context.Context, obj *model.APIProjectSettings) (*model.APIProjectVars, error)
}
type SleepScheduleResolver interface {
	WholeWeekdaysOff(ctx context.Context, obj *host.SleepScheduleInfo) ([]int, error)
}
type SpruceConfigResolver interface {
	SecretFields(ctx context.Context, obj *model.APIAdminSettings) ([]string, error)
}
type SubscriberWrapperResolver interface {
	Subscriber(ctx context.Context, obj *model.APISubscriber) (*Subscriber, error)
}
type TaskResolver interface {
	AbortInfo(ctx context.Context, obj *model.APITask) (*AbortInfo, error)

	Ami(ctx context.Context, obj *model.APITask) (*string, error)
	Annotation(ctx context.Context, obj *model.APITask) (*model.APITaskAnnotation, error)

	BaseStatus(ctx context.Context, obj *model.APITask) (*string, error)
	BaseTask(ctx context.Context, obj *model.APITask) (*model.APITask, error)

	BuildVariantDisplayName(ctx context.Context, obj *model.APITask) (*string, error)
	CanAbort(ctx context.Context, obj *model.APITask) (bool, error)
	CanDisable(ctx context.Context, obj *model.APITask) (bool, error)
	CanModifyAnnotation(ctx context.Context, obj *model.APITask) (bool, error)
	CanOverrideDependencies(ctx context.Context, obj *model.APITask) (bool, error)
	CanRestart(ctx context.Context, obj *model.APITask) (bool, error)
	CanSchedule(ctx context.Context, obj *model.APITask) (bool, error)
	CanSetPriority(ctx context.Context, obj *model.APITask) (bool, error)
	CanUnschedule(ctx context.Context, obj *model.APITask) (bool, error)

	DependsOn(ctx context.Context, obj *model.APITask) ([]*Dependency, error)

	DisplayTask(ctx context.Context, obj *model.APITask) (*model.APITask, error)

	EstimatedStart(ctx context.Context, obj *model.APITask) (*model.APIDuration, error)

	ExecutionTasksFull(ctx context.Context, obj *model.APITask) ([]*model.APITask, error)

	FailedTestCount(ctx context.Context, obj *model.APITask) (int, error)
	Files(ctx context.Context, obj *model.APITask) (*TaskFiles, error)

	GeneratedByName(ctx context.Context, obj *model.APITask) (*string, error)

	ImageID(ctx context.Context, obj *model.APITask) (string, error)

	IsPerfPluginEnabled(ctx context.Context, obj *model.APITask) (bool, error)
	LatestExecution(ctx context.Context, obj *model.APITask) (int, error)

	MinQueuePosition(ctx context.Context, obj *model.APITask) (int, error)

	Patch(ctx context.Context, obj *model.APITask) (*model.APIPatch, error)
	PatchNumber(ctx context.Context, obj *model.APITask) (*int, error)
	Pod(ctx context.Context, obj *model.APITask) (*model.APIPod, error)

	Project(ctx context.Context, obj *model.APITask) (*model.APIProjectRef, error)

	ProjectIdentifier(ctx context.Context, obj *model.APITask) (*string, error)

	SpawnHostLink(ctx context.Context, obj *model.APITask) (*string, error)

	TaskLogs(ctx context.Context, obj *model.APITask) (*TaskLogs, error)

	TaskOwnerTeam(ctx context.Context, obj *model.APITask) (*TaskOwnerTeam, error)
	Tests(ctx context.Context, obj *model.APITask, opts *TestFilterOptions) (*TaskTestResult, error)

	TotalTestCount(ctx context.Context, obj *model.APITask) (int, error)
	VersionMetadata(ctx context.Context, obj *model.APITask) (*model.APIVersion, error)
}
type TaskContainerCreationOptsResolver interface {
	Os(ctx context.Context, obj *model.APIPodTaskContainerCreationOptions) (string, error)
	Arch(ctx context.Context, obj *model.APIPodTaskContainerCreationOptions) (string, error)
}
type TaskLogsResolver interface {
	AgentLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
	AllLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
	EventLogs(ctx context.Context, obj *TaskLogs) ([]*model.TaskAPIEventLogEntry, error)

	SystemLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)

	TaskLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
}
type TicketFieldsResolver interface {
	AssignedTeam(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)
	AssigneeDisplayName(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)

	ResolutionName(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)
}
type UserResolver interface {
	Patches(ctx context.Context, obj *model.APIDBUser, patchesInput PatchesInput) (*Patches, error)
	Permissions(ctx context.Context, obj *model.APIDBUser) (*Permissions, error)

	Subscriptions(ctx context.Context, obj *model.APIDBUser) ([]*model.APISubscription, error)
}
type VersionResolver interface {
	BaseTaskStatuses(ctx context.Context, obj *model.APIVersion) ([]string, error)
	BaseVersion(ctx context.Context, obj *model.APIVersion) (*model.APIVersion, error)

	BuildVariants(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) ([]*GroupedBuildVariant, error)
	BuildVariantStats(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) ([]*task.GroupedTaskStatusCount, error)
	ChildVersions(ctx context.Context, obj *model.APIVersion) ([]*model.APIVersion, error)

	ExternalLinksForMetadata(ctx context.Context, obj *model.APIVersion) ([]*ExternalLinkForMetadata, error)

	GeneratedTaskCounts(ctx context.Context, obj *model.APIVersion) ([]*GeneratedTaskCountResults, error)

	IsPatch(ctx context.Context, obj *model.APIVersion) (bool, error)
	Manifest(ctx context.Context, obj *model.APIVersion) (*Manifest, error)

	Patch(ctx context.Context, obj *model.APIVersion) (*model.APIPatch, error)
	PreviousVersion(ctx context.Context, obj *model.APIVersion) (*model.APIVersion, error)

	ProjectMetadata(ctx context.Context, obj *model.APIVersion) (*model.APIProjectRef, error)

	Status(ctx context.Context, obj *model.APIVersion) (string, error)
	TaskCount(ctx context.Context, obj *model.APIVersion, options *TaskCountOptions) (*int, error)
	Tasks(ctx context.Context, obj *model.APIVersion, options TaskFilterOptions) (*VersionTasks, error)
	TaskStatuses(ctx context.Context, obj *model.APIVersion) ([]string, error)
	TaskStatusStats(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) (*task.TaskStats, error)
	UpstreamProject(ctx context.Context, obj *model.APIVersion) (*UpstreamProject, error)
	User(ctx context.Context, obj *model.APIVersion) (*model.APIDBUser, error)
	VersionTiming(ctx context.Context, obj *model.APIVersion) (*VersionTiming, error)
	Warnings(ctx context.Context, obj *model.APIVersion) ([]string, error)
	WaterfallBuilds(ctx context.Context, obj *model.APIVersion) ([]*model1.WaterfallBuild, error)
}
type VolumeResolver interface {
	Host(ctx context.Context, obj *model.APIVolume) (*model.APIHost, error)
}

type AdminSettingsInputResolver interface {
	BannerTheme(ctx context.Context, obj *model.APIAdminSettings, data *evergreen.BannerTheme) error
}
type ContainerPoolInputResolver interface {
	Port(ctx context.Context, obj *model.APIContainerPool, data int) error
}
type DistroInputResolver interface {
	ProviderSettingsList(ctx context.Context, obj *model.APIDistro, data []map[string]any) error
}
type HostAllocatorSettingsInputResolver interface {
	AcceptableHostIdleTime(ctx context.Context, obj *model.APIHostAllocatorSettings, data int) error
}
type JiraNotificationsConfigInputResolver interface {
	CustomFields(ctx context.Context, obj *model.APIJIRANotificationsConfig, data []*JiraNotificationsProjectEntryInput) error
}
type PlannerSettingsInputResolver interface {
	TargetTime(ctx context.Context, obj *model.APIPlannerSettings, data int) error
}
type ProjectSettingsInputResolver interface {
	ProjectID(ctx context.Context, obj *model.APIProjectSettings, data string) error
}
type RepoSettingsInputResolver interface {
	RepoID(ctx context.Context, obj *model.APIProjectSettings, data string) error
}
type SleepScheduleInputResolver interface {
	WholeWeekdaysOff(ctx context.Context, obj *host.SleepScheduleInfo, data []int) error
}
type SubscriberInputResolver interface {
	Target(ctx context.Context, obj *model.APISubscriber, data string) error
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "APIConfig.corpUrl":
		if e.complexity.APIConfig.CorpURL == nil {
			break
		}

		return e.complexity.APIConfig.CorpURL(childComplexity), true
	case "APIConfig.httpListenAddr":
		if e.complexity.APIConfig.HttpListenAddr == nil {
			break
		}

		return e.complexity.APIConfig.HttpListenAddr(childComplexity), true
	case "APIConfig.url":
		if e.complexity.APIConfig.URL == nil {
			break
		}

		return e.complexity.APIConfig.URL(childComplexity), true

	case "AWSAccountRoleMapping.account":
		if e.complexity.AWSAccountRoleMapping.Account == nil {
			break
		}

		return e.complexity.AWSAccountRoleMapping.Account(childComplexity), true
	case "AWSAccountRoleMapping.role":
		if e.complexity.AWSAccountRoleMapping.Role == nil {
			break
		}

		return e.complexity.AWSAccountRoleMapping.Role(childComplexity), true

	case "AWSConfig.accountRoles":
		if e.complexity.AWSConfig.AccountRoles == nil {
			break
		}

		return e.complexity.AWSConfig.AccountRoles(childComplexity), true
	case "AWSConfig.alertableInstanceTypes":
		if e.complexity.AWSConfig.AlertableInstanceTypes == nil {
			break
		}

		return e.complexity.AWSConfig.AlertableInstanceTypes(childComplexity), true
	case "AWSConfig.allowedInstanceTypes":
		if e.complexity.AWSConfig.AllowedInstanceTypes == nil {
			break
		}

		return e.complexity.AWSConfig.AllowedInstanceTypes(childComplexity), true
	case "AWSConfig.allowedRegions":
		if e.complexity.AWSConfig.AllowedRegions == nil {
			break
		}

		return e.complexity.AWSConfig.AllowedRegions(childComplexity), true
	case "AWSConfig.defaultSecurityGroup":
		if e.complexity.AWSConfig.DefaultSecurityGroup == nil {
			break
		}

		return e.complexity.AWSConfig.DefaultSecurityGroup(childComplexity), true
	case "AWSConfig.ec2Keys":
		if e.complexity.AWSConfig.EC2Keys == nil {
			break
		}

		return e.complexity.AWSConfig.EC2Keys(childComplexity), true
	case "AWSConfig.elasticIPUsageRate":
		if e.complexity.AWSConfig.ElasticIPUsageRate == nil {
			break
		}

		return e.complexity.AWSConfig.ElasticIPUsageRate(childComplexity), true
	case "AWSConfig.ipamPoolID":
		if e.complexity.AWSConfig.IPAMPoolID == nil {
			break
		}

		return e.complexity.AWSConfig.IPAMPoolID(childComplexity), true
	case "AWSConfig.maxVolumeSizePerUser":
		if e.complexity.AWSConfig.MaxVolumeSizePerUser == nil {
			break
		}

		return e.complexity.AWSConfig.MaxVolumeSizePerUser(childComplexity), true
	case "AWSConfig.parserProject":
		if e.complexity.AWSConfig.ParserProject == nil {
			break
		}

		return e.complexity.AWSConfig.ParserProject(childComplexity), true
	case "AWSConfig.persistentDNS":
		if e.complexity.AWSConfig.PersistentDNS == nil {
			break
		}

		return e.complexity.AWSConfig.PersistentDNS(childComplexity), true
	case "AWSConfig.pod":
		if e.complexity.AWSConfig.Pod == nil {
			break
		}

		return e.complexity.AWSConfig.Pod(childComplexity), true
	case "AWSConfig.subnets":
		if e.complexity.AWSConfig.Subnets == nil {
			break
		}

		return e.complexity.AWSConfig.Subnets(childComplexity), true

	case "AWSPodConfig.ecs":
		if e.complexity.AWSPodConfig.ECS == nil {
			break
		}

		return e.complexity.AWSPodConfig.ECS(childComplexity), true
	case "AWSPodConfig.region":
		if e.complexity.AWSPodConfig.Region == nil {
			break
		}

		return e.complexity.AWSPodConfig.Region(childComplexity), true
	case "AWSPodConfig.role":
		if e.complexity.AWSPodConfig.Role == nil {
			break
		}

		return e.complexity.AWSPodConfig.Role(childComplexity), true
	case "AWSPodConfig.secretsManager":
		if e.complexity.AWSPodConfig.SecretsManager == nil {
			break
		}

		return e.complexity.AWSPodConfig.SecretsManager(childComplexity), true

	case "AWSVPCConfig.securityGroups":
		if e.complexity.AWSVPCConfig.SecurityGroups == nil {
			break
		}

		return e.complexity.AWSVPCConfig.SecurityGroups(childComplexity), true
	case "AWSVPCConfig.subnets":
		if e.complexity.AWSVPCConfig.Subnets == nil {
			break
		}

		return e.complexity.AWSVPCConfig.Subnets(childComplexity), true

	case "AbortInfo.buildVariantDisplayName":
		if e.complexity.AbortInfo.BuildVariantDisplayName == nil {
			break
		}

		return e.complexity.AbortInfo.BuildVariantDisplayName(childComplexity), true
	case "AbortInfo.newVersion":
		if e.complexity.AbortInfo.NewVersion == nil {
			break
		}

		return e.complexity.AbortInfo.NewVersion(childComplexity), true
	case "AbortInfo.prClosed":
		if e.complexity.AbortInfo.PrClosed == nil {
			break
		}

		return e.complexity.AbortInfo.PrClosed(childComplexity), true
	case "AbortInfo.taskDisplayName":
		if e.complexity.AbortInfo.TaskDisplayName == nil {
			break
		}

		return e.complexity.AbortInfo.TaskDisplayName(childComplexity), true
	case "AbortInfo.taskID":
		if e.complexity.AbortInfo.TaskID == nil {
			break
		}

		return e.complexity.AbortInfo.TaskID(childComplexity), true
	case "AbortInfo.user":
		if e.complexity.AbortInfo.User == nil {
			break
		}

		return e.complexity.AbortInfo.User(childComplexity), true

	case "AdminEvent.after":
		if e.complexity.AdminEvent.After == nil {
			break
		}

		return e.complexity.AdminEvent.After(childComplexity), true
	case "AdminEvent.before":
		if e.complexity.AdminEvent.Before == nil {
			break
		}

		return e.complexity.AdminEvent.Before(childComplexity), true
	case "AdminEvent.section":
		if e.complexity.AdminEvent.Section == nil {
			break
		}

		return e.complexity.AdminEvent.Section(childComplexity), true
	case "AdminEvent.timestamp":
		if e.complexity.AdminEvent.Timestamp == nil {
			break
		}

		return e.complexity.AdminEvent.Timestamp(childComplexity), true
	case "AdminEvent.user":
		if e.complexity.AdminEvent.User == nil {
			break
		}

		return e.complexity.AdminEvent.User(childComplexity), true

	case "AdminEventsPayload.count":
		if e.complexity.AdminEventsPayload.Count == nil {
			break
		}

		return e.complexity.AdminEventsPayload.Count(childComplexity), true
	case "AdminEventsPayload.eventLogEntries":
		if e.complexity.AdminEventsPayload.EventLogEntries == nil {
			break
		}

		return e.complexity.AdminEventsPayload.EventLogEntries(childComplexity), true

	case "AdminSettings.amboy":
		if e.complexity.AdminSettings.Amboy == nil {
			break
		}

		return e.complexity.AdminSettings.Amboy(childComplexity), true
	case "AdminSettings.amboyDB":
		if e.complexity.AdminSettings.AmboyDB == nil {
			break
		}

		return e.complexity.AdminSettings.AmboyDB(childComplexity), true
	case "AdminSettings.api":
		if e.complexity.AdminSettings.Api == nil {
			break
		}

		return e.complexity.AdminSettings.Api(childComplexity), true
	case "AdminSettings.authConfig":
		if e.complexity.AdminSettings.AuthConfig == nil {
			break
		}

		return e.complexity.AdminSettings.AuthConfig(childComplexity), true
	case "AdminSettings.banner":
		if e.complexity.AdminSettings.Banner == nil {
			break
		}

		return e.complexity.AdminSettings.Banner(childComplexity), true
	case "AdminSettings.bannerTheme":
		if e.complexity.AdminSettings.BannerTheme == nil {
			break
		}

		return e.complexity.AdminSettings.BannerTheme(childComplexity), true
	case "AdminSettings.buckets":
		if e.complexity.AdminSettings.Buckets == nil {
			break
		}

		return e.complexity.AdminSettings.Buckets(childComplexity), true
	case "AdminSettings.cedar":
		if e.complexity.AdminSettings.Cedar == nil {
			break
		}

		return e.complexity.AdminSettings.Cedar(childComplexity), true
	case "AdminSettings.configDir":
		if e.complexity.AdminSettings.ConfigDir == nil {
			break
		}

		return e.complexity.AdminSettings.ConfigDir(childComplexity), true
	case "AdminSettings.containerPools":
		if e.complexity.AdminSettings.ContainerPools == nil {
			break
		}

		return e.complexity.AdminSettings.ContainerPools(childComplexity), true
	case "AdminSettings.cost":
		if e.complexity.AdminSettings.Cost == nil {
			break
		}

		return e.complexity.AdminSettings.Cost(childComplexity), true
	case "AdminSettings.disabledGQLQueries":
		if e.complexity.AdminSettings.DisabledGQLQueries == nil {
			break
		}

		return e.complexity.AdminSettings.DisabledGQLQueries(childComplexity), true
	case "AdminSettings.domainName":
		if e.complexity.AdminSettings.DomainName == nil {
			break
		}

		return e.complexity.AdminSettings.DomainName(childComplexity), true
	case "AdminSettings.expansions":
		if e.complexity.AdminSettings.Expansions == nil {
			break
		}

		return e.complexity.AdminSettings.Expansions(childComplexity), true
	case "AdminSettings.fws":
		if e.complexity.AdminSettings.FWS == nil {
			break
		}

		return e.complexity.AdminSettings.FWS(childComplexity), true
	case "AdminSettings.githubCheckRun":
		if e.complexity.AdminSettings.GitHubCheckRun == nil {
			break
		}

		return e.complexity.AdminSettings.GitHubCheckRun(childComplexity), true
	case "AdminSettings.githubOrgs":
		if e.complexity.AdminSettings.GithubOrgs == nil {
			break
		}

		return e.complexity.AdminSettings.GithubOrgs(childComplexity), true
	case "AdminSettings.githubPRCreatorOrg":
		if e.complexity.AdminSettings.GithubPRCreatorOrg == nil {
			break
		}

		return e.complexity.AdminSettings.GithubPRCreatorOrg(childComplexity), true
	case "AdminSettings.githubWebhookSecret":
		if e.complexity.AdminSettings.GithubWebhookSecret == nil {
			break
		}

		return e.complexity.AdminSettings.GithubWebhookSecret(childComplexity), true
	case "AdminSettings.graphite":
		if e.complexity.AdminSettings.Graphite == nil {
			break
		}

		return e.complexity.AdminSettings.Graphite(childComplexity), true
	case "AdminSettings.hostInit":
		if e.complexity.AdminSettings.HostInit == nil {
			break
		}

		return e.complexity.AdminSettings.HostInit(childComplexity), true
	case "AdminSettings.hostJasper":
		if e.complexity.AdminSettings.HostJasper == nil {
			break
		}

		return e.complexity.AdminSettings.HostJasper(childComplexity), true
	case "AdminSettings.jiraNotifications":
		if e.complexity.AdminSettings.JIRANotifications == nil {
			break
		}

		return e.complexity.AdminSettings.JIRANotifications(childComplexity), true
	case "AdminSettings.jira":
		if e.complexity.AdminSettings.Jira == nil {
			break
		}

		return e.complexity.AdminSettings.Jira(childComplexity), true
	case "AdminSettings.kanopySSHKeyPath":
		if e.complexity.AdminSettings.KanopySSHKeyPath == nil {
			break
		}

		return e.complexity.AdminSettings.KanopySSHKeyPath(childComplexity), true
	case "AdminSettings.logPath":
		if e.complexity.AdminSettings.LogPath == nil {
			break
		}

		return e.complexity.AdminSettings.LogPath(childComplexity), true
	case "AdminSettings.loggerConfig":
		if e.complexity.AdminSettings.LoggerConfig == nil {
			break
		}

		return e.complexity.AdminSettings.LoggerConfig(childComplexity), true
	case "AdminSettings.notify":
		if e.complexity.AdminSettings.Notify == nil {
			break
		}

		return e.complexity.AdminSettings.Notify(childComplexity), true
	case "AdminSettings.oldestAllowedCLIVersion":
		if e.complexity.AdminSettings.OldestAllowedCLIVersion == nil {
			break
		}

		return e.complexity.AdminSettings.OldestAllowedCLIVersion(childComplexity), true
	case "AdminSettings.parameterStore":
		if e.complexity.AdminSettings.ParameterStore == nil {
			break
		}

		return e.complexity.AdminSettings.ParameterStore(childComplexity), true
	case "AdminSettings.perfMonitoringKanopyURL":
		if e.complexity.AdminSettings.PerfMonitoringKanopyURL == nil {
			break
		}

		return e.complexity.AdminSettings.PerfMonitoringKanopyURL(childComplexity), true
	case "AdminSettings.perfMonitoringURL":
		if e.complexity.AdminSettings.PerfMonitoringURL == nil {
			break
		}

		return e.complexity.AdminSettings.PerfMonitoringURL(childComplexity), true
	case "AdminSettings.podLifecycle":
		if e.complexity.AdminSettings.PodLifecycle == nil {
			break
		}

		return e.complexity.AdminSettings.PodLifecycle(childComplexity), true
	case "AdminSettings.pprofPort":
		if e.complexity.AdminSettings.PprofPort == nil {
			break
		}

		return e.complexity.AdminSettings.PprofPort(childComplexity), true
	case "AdminSettings.projectCreation":
		if e.complexity.AdminSettings.ProjectCreation == nil {
			break
		}

		return e.complexity.AdminSettings.ProjectCreation(childComplexity), true
	case "AdminSettings.providers":
		if e.complexity.AdminSettings.Providers == nil {
			break
		}

		return e.complexity.AdminSettings.Providers(childComplexity), true
	case "AdminSettings.releaseMode":
		if e.complexity.AdminSettings.ReleaseMode == nil {
			break
		}

		return e.complexity.AdminSettings.ReleaseMode(childComplexity), true
	case "AdminSettings.repotracker":
		if e.complexity.AdminSettings.RepoTracker == nil {
			break
		}

		return e.complexity.AdminSettings.RepoTracker(childComplexity), true
	case "AdminSettings.runtimeEnvironments":
		if e.complexity.AdminSettings.RuntimeEnvironments == nil {
			break
		}

		return e.complexity.AdminSettings.RuntimeEnvironments(childComplexity), true
	case "AdminSettings.ssh":
		if e.complexity.AdminSettings.SSH == nil {
			break
		}

		return e.complexity.AdminSettings.SSH(childComplexity), true
	case "AdminSettings.scheduler":
		if e.complexity.AdminSettings.Scheduler == nil {
			break
		}

		return e.complexity.AdminSettings.Scheduler(childComplexity), true
	case "AdminSettings.serviceFlags":
		if e.complexity.AdminSettings.ServiceFlags == nil {
			break
		}

		return e.complexity.AdminSettings.ServiceFlags(childComplexity), true
	case "AdminSettings.shutdownWaitSeconds":
		if e.complexity.AdminSettings.ShutdownWaitSeconds == nil {
			break
		}

		return e.complexity.AdminSettings.ShutdownWaitSeconds(childComplexity), true
	case "AdminSettings.singleTaskDistro":
		if e.complexity.AdminSettings.SingleTaskDistro == nil {
			break
		}

		return e.complexity.AdminSettings.SingleTaskDistro(childComplexity), true
	case "AdminSettings.slack":
		if e.complexity.AdminSettings.Slack == nil {
			break
		}

		return e.complexity.AdminSettings.Slack(childComplexity), true
	case "AdminSettings.sleepSchedule":
		if e.complexity.AdminSettings.SleepSchedule == nil {
			break
		}

		return e.complexity.AdminSettings.SleepSchedule(childComplexity), true
	case "AdminSettings.spawnhost":
		if e.complexity.AdminSettings.Spawnhost == nil {
			break
		}

		return e.complexity.AdminSettings.Spawnhost(childComplexity), true
	case "AdminSettings.splunk":
		if e.complexity.AdminSettings.Splunk == nil {
			break
		}

		return e.complexity.AdminSettings.Splunk(childComplexity), true
	case "AdminSettings.taskLimits":
		if e.complexity.AdminSettings.TaskLimits == nil {
			break
		}

		return e.complexity.AdminSettings.TaskLimits(childComplexity), true
	case "AdminSettings.testSelection":
		if e.complexity.AdminSettings.TestSelection == nil {
			break
		}

		return e.complexity.AdminSettings.TestSelection(childComplexity), true
	case "AdminSettings.tracer":
		if e.complexity.AdminSettings.Tracer == nil {
			break
		}

		return e.complexity.AdminSettings.Tracer(childComplexity), true
	case "AdminSettings.triggers":
		if e.complexity.AdminSettings.Triggers == nil {
			break
		}

		return e.complexity.AdminSettings.Triggers(childComplexity), true
	case "AdminSettings.ui":
		if e.complexity.AdminSettings.Ui == nil {
			break
		}

		return e.complexity.AdminSettings.Ui(childComplexity), true

	case "AdminTasksToRestartPayload.tasksToRestart":
		if e.complexity.AdminTasksToRestartPayload.TasksToRestart == nil {
			break
		}

		return e.complexity.AdminTasksToRestartPayload.TasksToRestart(childComplexity), true

	case "AmboyConfig.groupBackgroundCreateFrequencyMinutes":
		if e.complexity.AmboyConfig.GroupBackgroundCreateFrequencyMinutes == nil {
			break
		}

		return e.complexity.AmboyConfig.GroupBackgroundCreateFrequencyMinutes(childComplexity), true
	case "AmboyConfig.groupDefaultWorkers":
		if e.complexity.AmboyConfig.GroupDefaultWorkers == nil {
			break
		}

		return e.complexity.AmboyConfig.GroupDefaultWorkers(childComplexity), true
	case "AmboyConfig.groupPruneFrequencyMinutes":
		if e.complexity.AmboyConfig.GroupPruneFrequencyMinutes == nil {
			break
		}

		return e.complexity.AmboyConfig.GroupPruneFrequencyMinutes(childComplexity), true
	case "AmboyConfig.groupTTLMinutes":
		if e.complexity.AmboyConfig.GroupTTLMinutes == nil {
			break
		}

		return e.complexity.AmboyConfig.GroupTTLMinutes(childComplexity), true
	case "AmboyConfig.localStorage":
		if e.complexity.AmboyConfig.LocalStorage == nil {
			break
		}

		return e.complexity.AmboyConfig.LocalStorage(childComplexity), true
	case "AmboyConfig.lockTimeoutMinutes":
		if e.complexity.AmboyConfig.LockTimeoutMinutes == nil {
			break
		}

		return e.complexity.AmboyConfig.LockTimeoutMinutes(childComplexity), true
	case "AmboyConfig.name":
		if e.complexity.AmboyConfig.Name == nil {
			break
		}

		return e.complexity.AmboyConfig.Name(childComplexity), true
	case "AmboyConfig.namedQueues":
		if e.complexity.AmboyConfig.NamedQueues == nil {
			break
		}

		return e.complexity.AmboyConfig.NamedQueues(childComplexity), true
	case "AmboyConfig.poolSizeLocal":
		if e.complexity.AmboyConfig.PoolSizeLocal == nil {
			break
		}

		return e.complexity.AmboyConfig.PoolSizeLocal(childComplexity), true
	case "AmboyConfig.poolSizeRemote":
		if e.complexity.AmboyConfig.PoolSizeRemote == nil {
			break
		}

		return e.complexity.AmboyConfig.PoolSizeRemote(childComplexity), true
	case "AmboyConfig.retry":
		if e.complexity.AmboyConfig.Retry == nil {
			break
		}

		return e.complexity.AmboyConfig.Retry(childComplexity), true
	case "AmboyConfig.sampleSize":
		if e.complexity.AmboyConfig.SampleSize == nil {
			break
		}

		return e.complexity.AmboyConfig.SampleSize(childComplexity), true
	case "AmboyConfig.singleName":
		if e.complexity.AmboyConfig.SingleName == nil {
			break
		}

		return e.complexity.AmboyConfig.SingleName(childComplexity), true

	case "AmboyDBConfig.database":
		if e.complexity.AmboyDBConfig.Database == nil {
			break
		}

		return e.complexity.AmboyDBConfig.Database(childComplexity), true
	case "AmboyDBConfig.url":
		if e.complexity.AmboyDBConfig.URL == nil {
			break
		}

		return e.complexity.AmboyDBConfig.URL(childComplexity), true

	case "AmboyNamedQueueConfig.lockTimeoutSeconds":
		if e.complexity.AmboyNamedQueueConfig.LockTimeoutSeconds == nil {
			break
		}

		return e.complexity.AmboyNamedQueueConfig.LockTimeoutSeconds(childComplexity), true
	case "AmboyNamedQueueConfig.name":
		if e.complexity.AmboyNamedQueueConfig.Name == nil {
			break
		}

		return e.complexity.AmboyNamedQueueConfig.Name(childComplexity), true
	case "AmboyNamedQueueConfig.numWorkers":
		if e.complexity.AmboyNamedQueueConfig.NumWorkers == nil {
			break
		}

		return e.complexity.AmboyNamedQueueConfig.NumWorkers(childComplexity), true
	case "AmboyNamedQueueConfig.regexp":
		if e.complexity.AmboyNamedQueueConfig.Regexp == nil {
			break
		}

		return e.complexity.AmboyNamedQueueConfig.Regexp(childComplexity), true
	case "AmboyNamedQueueConfig.sampleSize":
		if e.complexity.AmboyNamedQueueConfig.SampleSize == nil {
			break
		}

		return e.complexity.AmboyNamedQueueConfig.SampleSize(childComplexity), true

	case "AmboyRetryConfig.maxCapacity":
		if e.complexity.AmboyRetryConfig.MaxCapacity == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.MaxCapacity(childComplexity), true
	case "AmboyRetryConfig.maxRetryAttempts":
		if e.complexity.AmboyRetryConfig.MaxRetryAttempts == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.MaxRetryAttempts(childComplexity), true
	case "AmboyRetryConfig.maxRetryTimeSeconds":
		if e.complexity.AmboyRetryConfig.MaxRetryTimeSeconds == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.MaxRetryTimeSeconds(childComplexity), true
	case "AmboyRetryConfig.numWorkers":
		if e.complexity.AmboyRetryConfig.NumWorkers == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.NumWorkers(childComplexity), true
	case "AmboyRetryConfig.retryBackoffSeconds":
		if e.complexity.AmboyRetryConfig.RetryBackoffSeconds == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.RetryBackoffSeconds(childComplexity), true
	case "AmboyRetryConfig.staleRetryingMonitorIntervalSeconds":
		if e.complexity.AmboyRetryConfig.StaleRetryingMonitorIntervalSeconds == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.StaleRetryingMonitorIntervalSeconds(childComplexity), true

	case "Annotation.createdIssues":
		if e.complexity.Annotation.CreatedIssues == nil {
			break
		}

		return e.complexity.Annotation.CreatedIssues(childComplexity), true
	case "Annotation.id":
		if e.complexity.Annotation.Id == nil {
			break
		}

		return e.complexity.Annotation.Id(childComplexity), true
	case "Annotation.issues":
		if e.complexity.Annotation.Issues == nil {
			break
		}

		return e.complexity.Annotation.Issues(childComplexity), true
	case "Annotation.metadataLinks":
		if e.complexity.Annotation.MetadataLinks == nil {
			break
		}

		return e.complexity.Annotation.MetadataLinks(childComplexity), true
	case "Annotation.note":
		if e.complexity.Annotation.Note == nil {
			break
		}

		return e.complexity.Annotation.Note(childComplexity), true
	case "Annotation.suspectedIssues":
		if e.complexity.Annotation.SuspectedIssues == nil {
			break
		}

		return e.complexity.Annotation.SuspectedIssues(childComplexity), true
	case "Annotation.taskExecution":
		if e.complexity.Annotation.TaskExecution == nil {
			break
		}

		return e.complexity.Annotation.TaskExecution(childComplexity), true
	case "Annotation.taskId":
		if e.complexity.Annotation.TaskId == nil {
			break
		}

		return e.complexity.Annotation.TaskId(childComplexity), true
	case "Annotation.webhookConfigured":
		if e.complexity.Annotation.WebhookConfigured == nil {
			break
		}

		return e.complexity.Annotation.WebhookConfigured(childComplexity), true

	case "AuthConfig.allowServiceUsers":
		if e.complexity.AuthConfig.AllowServiceUsers == nil {
			break
		}

		return e.complexity.AuthConfig.AllowServiceUsers(childComplexity), true
	case "AuthConfig.backgroundReauthMinutes":
		if e.complexity.AuthConfig.BackgroundReauthMinutes == nil {
			break
		}

		return e.complexity.AuthConfig.BackgroundReauthMinutes(childComplexity), true
	case "AuthConfig.github":
		if e.complexity.AuthConfig.Github == nil {
			break
		}

		return e.complexity.AuthConfig.Github(childComplexity), true
	case "AuthConfig.kanopy":
		if e.complexity.AuthConfig.Kanopy == nil {
			break
		}

		return e.complexity.AuthConfig.Kanopy(childComplexity), true
	case "AuthConfig.multi":
		if e.complexity.AuthConfig.Multi == nil {
			break
		}

		return e.complexity.AuthConfig.Multi(childComplexity), true
	case "AuthConfig.naive":
		if e.complexity.AuthConfig.Naive == nil {
			break
		}

		return e.complexity.AuthConfig.Naive(childComplexity), true
	case "AuthConfig.oauth":
		if e.complexity.AuthConfig.OAuth == nil {
			break
		}

		return e.complexity.AuthConfig.OAuth(childComplexity), true
	case "AuthConfig.okta":
		if e.complexity.AuthConfig.Okta == nil {
			break
		}

		return e.complexity.AuthConfig.Okta(childComplexity), true
	case "AuthConfig.preferredType":
		if e.complexity.AuthConfig.PreferredType == nil {
			break
		}

		return e.complexity.AuthConfig.PreferredType(childComplexity), true

	case "AuthUser.displayName":
		if e.complexity.AuthUser.DisplayName == nil {
			break
		}

		return e.complexity.AuthUser.DisplayName(childComplexity), true
	case "AuthUser.email":
		if e.complexity.AuthUser.Email == nil {
			break
		}

		return e.complexity.AuthUser.Email(childComplexity), true
	case "AuthUser.password":
		if e.complexity.AuthUser.Password == nil {
			break
		}

		return e.complexity.AuthUser.Password(childComplexity), true
	case "AuthUser.username":
		if e.complexity.AuthUser.Username == nil {
			break
		}

		return e.complexity.AuthUser.Username(childComplexity), true

	case "BetaFeatures.parsleyAIEnabled":
		if e.complexity.BetaFeatures.ParsleyAIEnabled == nil {
			break
		}

		return e.complexity.BetaFeatures.ParsleyAIEnabled(childComplexity), true
	case "BetaFeatures.spruceWaterfallEnabled":
		if e.complexity.BetaFeatures.SpruceWaterfallEnabled == nil {
			break
		}

		return e.complexity.BetaFeatures.SpruceWaterfallEnabled(childComplexity), true

	case "BootstrapSettings.clientDir":
		if e.complexity.BootstrapSettings.ClientDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.ClientDir(childComplexity), true
	case "BootstrapSettings.communication":
		if e.complexity.BootstrapSettings.Communication == nil {
			break
		}

		return e.complexity.BootstrapSettings.Communication(childComplexity), true
	case "BootstrapSettings.env":
		if e.complexity.BootstrapSettings.Env == nil {
			break
		}

		return e.complexity.BootstrapSettings.Env(childComplexity), true
	case "BootstrapSettings.jasperBinaryDir":
		if e.complexity.BootstrapSettings.JasperBinaryDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.JasperBinaryDir(childComplexity), true
	case "BootstrapSettings.jasperCredentialsPath":
		if e.complexity.BootstrapSettings.JasperCredentialsPath == nil {
			break
		}

		return e.complexity.BootstrapSettings.JasperCredentialsPath(childComplexity), true
	case "BootstrapSettings.method":
		if e.complexity.BootstrapSettings.Method == nil {
			break
		}

		return e.complexity.BootstrapSettings.Method(childComplexity), true
	case "BootstrapSettings.preconditionScripts":
		if e.complexity.BootstrapSettings.PreconditionScripts == nil {
			break
		}

		return e.complexity.BootstrapSettings.PreconditionScripts(childComplexity), true
	case "BootstrapSettings.resourceLimits":
		if e.complexity.BootstrapSettings.ResourceLimits == nil {
			break
		}

		return e.complexity.BootstrapSettings.ResourceLimits(childComplexity), true
	case "BootstrapSettings.rootDir":
		if e.complexity.BootstrapSettings.RootDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.RootDir(childComplexity), true
	case "BootstrapSettings.serviceUser":
		if e.complexity.BootstrapSettings.ServiceUser == nil {
			break
		}

		return e.complexity.BootstrapSettings.ServiceUser(childComplexity), true
	case "BootstrapSettings.shellPath":
		if e.complexity.BootstrapSettings.ShellPath == nil {
			break
		}

		return e.complexity.BootstrapSettings.ShellPath(childComplexity), true

	case "BucketConfig.name":
		if e.complexity.BucketConfig.Name == nil {
			break
		}

		return e.complexity.BucketConfig.Name(childComplexity), true
	case "BucketConfig.roleARN":
		if e.complexity.BucketConfig.RoleARN == nil {
			break
		}

		return e.complexity.BucketConfig.RoleARN(childComplexity), true
	case "BucketConfig.testResultsPrefix":
		if e.complexity.BucketConfig.TestResultsPrefix == nil {
			break
		}

		return e.complexity.BucketConfig.TestResultsPrefix(childComplexity), true
	case "BucketConfig.type":
		if e.complexity.BucketConfig.Type == nil {
			break
		}

		return e.complexity.BucketConfig.Type(childComplexity), true

	case "BucketsConfig.credentials":
		if e.complexity.BucketsConfig.Credentials == nil {
			break
		}

		return e.complexity.BucketsConfig.Credentials(childComplexity), true
	case "BucketsConfig.internalBuckets":
		if e.complexity.BucketsConfig.InternalBuckets == nil {
			break
		}

		return e.complexity.BucketsConfig.InternalBuckets(childComplexity), true
	case "BucketsConfig.logBucket":
		if e.complexity.BucketsConfig.LogBucket == nil {
			break
		}

		return e.complexity.BucketsConfig.LogBucket(childComplexity), true
	case "BucketsConfig.logBucketFailedTasks":
		if e.complexity.BucketsConfig.LogBucketFailedTasks == nil {
			break
		}

		return e.complexity.BucketsConfig.LogBucketFailedTasks(childComplexity), true
	case "BucketsConfig.logBucketLongRetention":
		if e.complexity.BucketsConfig.LogBucketLongRetention == nil {
			break
		}

		return e.complexity.BucketsConfig.LogBucketLongRetention(childComplexity), true
	case "BucketsConfig.longRetentionProjects":
		if e.complexity.BucketsConfig.LongRetentionProjects == nil {
			break
		}

		return e.complexity.BucketsConfig.LongRetentionProjects(childComplexity), true
	case "BucketsConfig.testResultsBucket":
		if e.complexity.BucketsConfig.TestResultsBucket == nil {
			break
		}

		return e.complexity.BucketsConfig.TestResultsBucket(childComplexity), true

	case "Build.actualMakespan":
		if e.complexity.Build.ActualMakespan == nil {
			break
		}

		return e.complexity.Build.ActualMakespan(childComplexity), true
	case "Build.buildVariant":
		if e.complexity.Build.BuildVariant == nil {
			break
		}

		return e.complexity.Build.BuildVariant(childComplexity), true
	case "Build.id":
		if e.complexity.Build.Id == nil {
			break
		}

		return e.complexity.Build.Id(childComplexity), true
	case "Build.predictedMakespan":
		if e.complexity.Build.PredictedMakespan == nil {
			break
		}

		return e.complexity.Build.PredictedMakespan(childComplexity), true
	case "Build.status":
		if e.complexity.Build.Status == nil {
			break
		}

		return e.complexity.Build.Status(childComplexity), true

	case "BuildBaron.bbTicketCreationDefined":
		if e.complexity.BuildBaron.BbTicketCreationDefined == nil {
			break
		}

		return e.complexity.BuildBaron.BbTicketCreationDefined(childComplexity), true
	case "BuildBaron.buildBaronConfigured":
		if e.complexity.BuildBaron.BuildBaronConfigured == nil {
			break
		}

		return e.complexity.BuildBaron.BuildBaronConfigured(childComplexity), true
	case "BuildBaron.searchReturnInfo":
		if e.complexity.BuildBaron.SearchReturnInfo == nil {
			break
		}

		return e.complexity.BuildBaron.SearchReturnInfo(childComplexity), true

	case "BuildBaronSettings.bfSuggestionFeaturesURL":
		if e.complexity.BuildBaronSettings.BFSuggestionFeaturesURL == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionFeaturesURL(childComplexity), true
	case "BuildBaronSettings.bfSuggestionPassword":
		if e.complexity.BuildBaronSettings.BFSuggestionPassword == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionPassword(childComplexity), true
	case "BuildBaronSettings.bfSuggestionServer":
		if e.complexity.BuildBaronSettings.BFSuggestionServer == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionServer(childComplexity), true
	case "BuildBaronSettings.bfSuggestionTimeoutSecs":
		if e.complexity.BuildBaronSettings.BFSuggestionTimeoutSecs == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionTimeoutSecs(childComplexity), true
	case "BuildBaronSettings.bfSuggestionUsername":
		if e.complexity.BuildBaronSettings.BFSuggestionUsername == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionUsername(childComplexity), true
	case "BuildBaronSettings.ticketCreateIssueType":
		if e.complexity.BuildBaronSettings.TicketCreateIssueType == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketCreateIssueType(childComplexity), true
	case "BuildBaronSettings.ticketCreateProject":
		if e.complexity.BuildBaronSettings.TicketCreateProject == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketCreateProject(childComplexity), true
	case "BuildBaronSettings.ticketSearchProjects":
		if e.complexity.BuildBaronSettings.TicketSearchProjects == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketSearchProjects(childComplexity), true

	case "BuildVariantTuple.buildVariant":
		if e.complexity.BuildVariantTuple.BuildVariant == nil {
			break
		}

		return e.complexity.BuildVariantTuple.BuildVariant(childComplexity), true
	case "BuildVariantTuple.displayName":
		if e.complexity.BuildVariantTuple.DisplayName == nil {
			break
		}

		return e.complexity.BuildVariantTuple.DisplayName(childComplexity), true

	case "CedarConfig.dbName":
		if e.complexity.CedarConfig.DBName == nil {
			break
		}

		return e.complexity.CedarConfig.DBName(childComplexity), true
	case "CedarConfig.dbUrl":
		if e.complexity.CedarConfig.DBURL == nil {
			break
		}

		return e.complexity.CedarConfig.DBURL(childComplexity), true

	case "ChildPatchAlias.alias":
		if e.complexity.ChildPatchAlias.Alias == nil {
			break
		}

		return e.complexity.ChildPatchAlias.Alias(childComplexity), true
	case "ChildPatchAlias.patchId":
		if e.complexity.ChildPatchAlias.PatchID == nil {
			break
		}

		return e.complexity.ChildPatchAlias.PatchID(childComplexity), true

	case "ClientBinary.arch":
		if e.complexity.ClientBinary.Arch == nil {
			break
		}

		return e.complexity.ClientBinary.Arch(childComplexity), true
	case "ClientBinary.displayName":
		if e.complexity.ClientBinary.DisplayName == nil {
			break
		}

		return e.complexity.ClientBinary.DisplayName(childComplexity), true
	case "ClientBinary.os":
		if e.complexity.ClientBinary.OS == nil {
			break
		}

		return e.complexity.ClientBinary.OS(childComplexity), true
	case "ClientBinary.url":
		if e.complexity.ClientBinary.URL == nil {
			break
		}

		return e.complexity.ClientBinary.URL(childComplexity), true

	case "ClientConfig.clientBinaries":
		if e.complexity.ClientConfig.ClientBinaries == nil {
			break
		}

		return e.complexity.ClientConfig.ClientBinaries(childComplexity), true
	case "ClientConfig.latestRevision":
		if e.complexity.ClientConfig.LatestRevision == nil {
			break
		}

		return e.complexity.ClientConfig.LatestRevision(childComplexity), true

	case "CloudProviderConfig.aws":
		if e.complexity.CloudProviderConfig.AWS == nil {
			break
		}

		return e.complexity.CloudProviderConfig.AWS(childComplexity), true
	case "CloudProviderConfig.docker":
		if e.complexity.CloudProviderConfig.Docker == nil {
			break
		}

		return e.complexity.CloudProviderConfig.Docker(childComplexity), true

	case "CommitQueueParams.enabled":
		if e.complexity.CommitQueueParams.Enabled == nil {
			break
		}

		return e.complexity.CommitQueueParams.Enabled(childComplexity), true
	case "CommitQueueParams.mergeMethod":
		if e.complexity.CommitQueueParams.MergeMethod == nil {
			break
		}

		return e.complexity.CommitQueueParams.MergeMethod(childComplexity), true
	case "CommitQueueParams.message":
		if e.complexity.CommitQueueParams.Message == nil {
			break
		}

		return e.complexity.CommitQueueParams.Message(childComplexity), true

	case "ContainerPool.distro":
		if e.complexity.ContainerPool.Distro == nil {
			break
		}

		return e.complexity.ContainerPool.Distro(childComplexity), true
	case "ContainerPool.id":
		if e.complexity.ContainerPool.Id == nil {
			break
		}

		return e.complexity.ContainerPool.Id(childComplexity), true
	case "ContainerPool.maxContainers":
		if e.complexity.ContainerPool.MaxContainers == nil {
			break
		}

		return e.complexity.ContainerPool.MaxContainers(childComplexity), true
	case "ContainerPool.port":
		if e.complexity.ContainerPool.Port == nil {
			break
		}

		return e.complexity.ContainerPool.Port(childComplexity), true

	case "ContainerPoolsConfig.pools":
		if e.complexity.ContainerPoolsConfig.Pools == nil {
			break
		}

		return e.complexity.ContainerPoolsConfig.Pools(childComplexity), true

	case "ContainerResources.cpu":
		if e.complexity.ContainerResources.CPU == nil {
			break
		}

		return e.complexity.ContainerResources.CPU(childComplexity), true
	case "ContainerResources.memoryMb":
		if e.complexity.ContainerResources.MemoryMB == nil {
			break
		}

		return e.complexity.ContainerResources.MemoryMB(childComplexity), true
	case "ContainerResources.name":
		if e.complexity.ContainerResources.Name == nil {
			break
		}

		return e.complexity.ContainerResources.Name(childComplexity), true

	case "Cost.adjustedEC2Cost":
		if e.complexity.Cost.AdjustedEC2Cost == nil {
			break
		}

		return e.complexity.Cost.AdjustedEC2Cost(childComplexity), true
	case "Cost.onDemandEC2Cost":
		if e.complexity.Cost.OnDemandEC2Cost == nil {
			break
		}

		return e.complexity.Cost.OnDemandEC2Cost(childComplexity), true

	case "CostConfig.financeFormula":
		if e.complexity.CostConfig.FinanceFormula == nil {
			break
		}

		return e.complexity.CostConfig.FinanceFormula(childComplexity), true
	case "CostConfig.onDemandDiscount":
		if e.complexity.CostConfig.OnDemandDiscount == nil {
			break
		}

		return e.complexity.CostConfig.OnDemandDiscount(childComplexity), true
	case "CostConfig.savingsPlanDiscount":
		if e.complexity.CostConfig.SavingsPlanDiscount == nil {
			break
		}

		return e.complexity.CostConfig.SavingsPlanDiscount(childComplexity), true

	case "CostData.onDemandRate":
		if e.complexity.CostData.OnDemandRate == nil {
			break
		}

		return e.complexity.CostData.OnDemandRate(childComplexity), true
	case "CostData.savingsPlanRate":
		if e.complexity.CostData.SavingsPlanRate == nil {
			break
		}

		return e.complexity.CostData.SavingsPlanRate(childComplexity), true

	case "DeleteDistroPayload.deletedDistroId":
		if e.complexity.DeleteDistroPayload.DeletedDistroID == nil {
			break
		}

		return e.complexity.DeleteDistroPayload.DeletedDistroID(childComplexity), true

	case "DeleteGithubAppCredentialsPayload.oldAppId":
		if e.complexity.DeleteGithubAppCredentialsPayload.OldAppID == nil {
			break
		}

		return e.complexity.DeleteGithubAppCredentialsPayload.OldAppID(childComplexity), true

	case "Dependency.buildVariant":
		if e.complexity.Dependency.BuildVariant == nil {
			break
		}

		return e.complexity.Dependency.BuildVariant(childComplexity), true
	case "Dependency.metStatus":
		if e.complexity.Dependency.MetStatus == nil {
			break
		}

		return e.complexity.Dependency.MetStatus(childComplexity), true
	case "Dependency.name":
		if e.complexity.Dependency.Name == nil {
			break
		}

		return e.complexity.Dependency.Name(childComplexity), true
	case "Dependency.requiredStatus":
		if e.complexity.Dependency.RequiredStatus == nil {
			break
		}

		return e.complexity.Dependency.RequiredStatus(childComplexity), true
	case "Dependency.taskId":
		if e.complexity.Dependency.TaskID == nil {
			break
		}

		return e.complexity.Dependency.TaskID(childComplexity), true

	case "DispatcherSettings.version":
		if e.complexity.DispatcherSettings.Version == nil {
			break
		}

		return e.complexity.DispatcherSettings.Version(childComplexity), true

	case "Distro.adminOnly":
		if e.complexity.Distro.AdminOnly == nil {
			break
		}

		return e.complexity.Distro.AdminOnly(childComplexity), true
	case "Distro.aliases":
		if e.complexity.Distro.Aliases == nil {
			break
		}

		return e.complexity.Distro.Aliases(childComplexity), true
	case "Distro.arch":
		if e.complexity.Distro.Arch == nil {
			break
		}

		return e.complexity.Distro.Arch(childComplexity), true
	case "Distro.authorizedKeysFile":
		if e.complexity.Distro.AuthorizedKeysFile == nil {
			break
		}

		return e.complexity.Distro.AuthorizedKeysFile(childComplexity), true
	case "Distro.availableRegions":
		if e.complexity.Distro.AvailableRegions == nil {
			break
		}

		return e.complexity.Distro.AvailableRegions(childComplexity), true
	case "Distro.bootstrapSettings":
		if e.complexity.Distro.BootstrapSettings == nil {
			break
		}

		return e.complexity.Distro.BootstrapSettings(childComplexity), true
	case "Distro.containerPool":
		if e.complexity.Distro.ContainerPool == nil {
			break
		}

		return e.complexity.Distro.ContainerPool(childComplexity), true
	case "Distro.costData":
		if e.complexity.Distro.CostData == nil {
			break
		}

		return e.complexity.Distro.CostData(childComplexity), true
	case "Distro.disableShallowClone":
		if e.complexity.Distro.DisableShallowClone == nil {
			break
		}

		return e.complexity.Distro.DisableShallowClone(childComplexity), true
	case "Distro.disabled":
		if e.complexity.Distro.Disabled == nil {
			break
		}

		return e.complexity.Distro.Disabled(childComplexity), true
	case "Distro.dispatcherSettings":
		if e.complexity.Distro.DispatcherSettings == nil {
			break
		}

		return e.complexity.Distro.DispatcherSettings(childComplexity), true
	case "Distro.execUser":
		if e.complexity.Distro.ExecUser == nil {
			break
		}

		return e.complexity.Distro.ExecUser(childComplexity), true
	case "Distro.expansions":
		if e.complexity.Distro.Expansions == nil {
			break
		}

		return e.complexity.Distro.Expansions(childComplexity), true
	case "Distro.finderSettings":
		if e.complexity.Distro.FinderSettings == nil {
			break
		}

		return e.complexity.Distro.FinderSettings(childComplexity), true
	case "Distro.homeVolumeSettings":
		if e.complexity.Distro.HomeVolumeSettings == nil {
			break
		}

		return e.complexity.Distro.HomeVolumeSettings(childComplexity), true
	case "Distro.hostAllocatorSettings":
		if e.complexity.Distro.HostAllocatorSettings == nil {
			break
		}

		return e.complexity.Distro.HostAllocatorSettings(childComplexity), true
	case "Distro.iceCreamSettings":
		if e.complexity.Distro.IcecreamSettings == nil {
			break
		}

		return e.complexity.Distro.IcecreamSettings(childComplexity), true
	case "Distro.imageId":
		if e.complexity.Distro.ImageID == nil {
			break
		}

		return e.complexity.Distro.ImageID(childComplexity), true
	case "Distro.isCluster":
		if e.complexity.Distro.IsCluster == nil {
			break
		}

		return e.complexity.Distro.IsCluster(childComplexity), true
	case "Distro.isVirtualWorkStation":
		if e.complexity.Distro.IsVirtualWorkstation == nil {
			break
		}

		return e.complexity.Distro.IsVirtualWorkstation(childComplexity), true
	case "Distro.mountpoints":
		if e.complexity.Distro.Mountpoints == nil {
			break
		}

		return e.complexity.Distro.Mountpoints(childComplexity), true
	case "Distro.name":
		if e.complexity.Distro.Name == nil {
			break
		}

		return e.complexity.Distro.Name(childComplexity), true
	case "Distro.note":
		if e.complexity.Distro.Note == nil {
			break
		}

		return e.complexity.Distro.Note(childComplexity), true
	case "Distro.plannerSettings":
		if e.complexity.Distro.PlannerSettings == nil {
			break
		}

		return e.complexity.Distro.PlannerSettings(childComplexity), true
	case "Distro.provider":
		if e.complexity.Distro.Provider == nil {
			break
		}

		return e.complexity.Distro.Provider(childComplexity), true
	case "Distro.providerAccount":
		if e.complexity.Distro.ProviderAccount == nil {
			break
		}

		return e.complexity.Distro.ProviderAccount(childComplexity), true
	case "Distro.providerSettingsList":
		if e.complexity.Distro.ProviderSettingsList == nil {
			break
		}

		return e.complexity.Distro.ProviderSettingsList(childComplexity), true
	case "Distro.sshOptions":
		if e.complexity.Distro.SSHOptions == nil {
			break
		}

		return e.complexity.Distro.SSHOptions(childComplexity), true
	case "Distro.setup":
		if e.complexity.Distro.Setup == nil {
			break
		}

		return e.complexity.Distro.Setup(childComplexity), true
	case "Distro.setupAsSudo":
		if e.complexity.Distro.SetupAsSudo == nil {
			break
		}

		return e.complexity.Distro.SetupAsSudo(childComplexity), true
	case "Distro.singleTaskDistro":
		if e.complexity.Distro.SingleTaskDistro == nil {
			break
		}

		return e.complexity.Distro.SingleTaskDistro(childComplexity), true
	case "Distro.user":
		if e.complexity.Distro.User == nil {
			break
		}

		return e.complexity.Distro.User(childComplexity), true
	case "Distro.userSpawnAllowed":
		if e.complexity.Distro.UserSpawnAllowed == nil {
			break
		}

		return e.complexity.Distro.UserSpawnAllowed(childComplexity), true
	case "Distro.validProjects":
		if e.complexity.Distro.ValidProjects == nil {
			break
		}

		return e.complexity.Distro.ValidProjects(childComplexity), true
	case "Distro.warningNote":
		if e.complexity.Distro.WarningNote == nil {
			break
		}

		return e.complexity.Distro.WarningNote(childComplexity), true
	case "Distro.workDir":
		if e.complexity.Distro.WorkDir == nil {
			break
		}

		return e.complexity.Distro.WorkDir(childComplexity), true

	case "DistroEvent.after":
		if e.complexity.DistroEvent.After == nil {
			break
		}

		return e.complexity.DistroEvent.After(childComplexity), true
	case "DistroEvent.before":
		if e.complexity.DistroEvent.Before == nil {
			break
		}

		return e.complexity.DistroEvent.Before(childComplexity), true
	case "DistroEvent.data":
		if e.complexity.DistroEvent.Data == nil {
			break
		}

		return e.complexity.DistroEvent.Data(childComplexity), true
	case "DistroEvent.timestamp":
		if e.complexity.DistroEvent.Timestamp == nil {
			break
		}

		return e.complexity.DistroEvent.Timestamp(childComplexity), true
	case "DistroEvent.user":
		if e.complexity.DistroEvent.User == nil {
			break
		}

		return e.complexity.DistroEvent.User(childComplexity), true

	case "DistroEventsPayload.count":
		if e.complexity.DistroEventsPayload.Count == nil {
			break
		}

		return e.complexity.DistroEventsPayload.Count(childComplexity), true
	case "DistroEventsPayload.eventLogEntries":
		if e.complexity.DistroEventsPayload.EventLogEntries == nil {
			break
		}

		return e.complexity.DistroEventsPayload.EventLogEntries(childComplexity), true

	case "DistroInfo.bootstrapMethod":
		if e.complexity.DistroInfo.BootstrapMethod == nil {
			break
		}

		return e.complexity.DistroInfo.BootstrapMethod(childComplexity), true
	case "DistroInfo.id":
		if e.complexity.DistroInfo.Id == nil {
			break
		}

		return e.complexity.DistroInfo.Id(childComplexity), true
	case "DistroInfo.isVirtualWorkStation":
		if e.complexity.DistroInfo.IsVirtualWorkstation == nil {
			break
		}

		return e.complexity.DistroInfo.IsVirtualWorkstation(childComplexity), true
	case "DistroInfo.isWindows":
		if e.complexity.DistroInfo.IsWindows == nil {
			break
		}

		return e.complexity.DistroInfo.IsWindows(childComplexity), true
	case "DistroInfo.user":
		if e.complexity.DistroInfo.User == nil {
			break
		}

		return e.complexity.DistroInfo.User(childComplexity), true
	case "DistroInfo.workDir":
		if e.complexity.DistroInfo.WorkDir == nil {
			break
		}

		return e.complexity.DistroInfo.WorkDir(childComplexity), true

	case "DistroPermissions.admin":
		if e.complexity.DistroPermissions.Admin == nil {
			break
		}

		return e.complexity.DistroPermissions.Admin(childComplexity), true
	case "DistroPermissions.edit":
		if e.complexity.DistroPermissions.Edit == nil {
			break
		}

		return e.complexity.DistroPermissions.Edit(childComplexity), true
	case "DistroPermissions.view":
		if e.complexity.DistroPermissions.View == nil {
			break
		}

		return e.complexity.DistroPermissions.View(childComplexity), true

	case "DockerConfig.apiVersion":
		if e.complexity.DockerConfig.APIVersion == nil {
			break
		}

		return e.complexity.DockerConfig.APIVersion(childComplexity), true

	case "EC2Key.key":
		if e.complexity.EC2Key.Key == nil {
			break
		}

		return e.complexity.EC2Key.Key(childComplexity), true
	case "EC2Key.name":
		if e.complexity.EC2Key.Name == nil {
			break
		}

		return e.complexity.EC2Key.Name(childComplexity), true
	case "EC2Key.secret":
		if e.complexity.EC2Key.Secret == nil {
			break
		}

		return e.complexity.EC2Key.Secret(childComplexity), true

	case "ECSCapacityProvider.arch":
		if e.complexity.ECSCapacityProvider.Arch == nil {
			break
		}

		return e.complexity.ECSCapacityProvider.Arch(childComplexity), true
	case "ECSCapacityProvider.name":
		if e.complexity.ECSCapacityProvider.Name == nil {
			break
		}

		return e.complexity.ECSCapacityProvider.Name(childComplexity), true
	case "ECSCapacityProvider.os":
		if e.complexity.ECSCapacityProvider.OS == nil {
			break
		}

		return e.complexity.ECSCapacityProvider.OS(childComplexity), true
	case "ECSCapacityProvider.windowsVersion":
		if e.complexity.ECSCapacityProvider.WindowsVersion == nil {
			break
		}

		return e.complexity.ECSCapacityProvider.WindowsVersion(childComplexity), true

	case "ECSClusterConfig.name":
		if e.complexity.ECSClusterConfig.Name == nil {
			break
		}

		return e.complexity.ECSClusterConfig.Name(childComplexity), true
	case "ECSClusterConfig.os":
		if e.complexity.ECSClusterConfig.OS == nil {
			break
		}

		return e.complexity.ECSClusterConfig.OS(childComplexity), true

	case "ECSConfig.awsVPC":
		if e.complexity.ECSConfig.AWSVPC == nil {
			break
		}

		return e.complexity.ECSConfig.AWSVPC(childComplexity), true
	case "ECSConfig.allowedImages":
		if e.complexity.ECSConfig.AllowedImages == nil {
			break
		}

		return e.complexity.ECSConfig.AllowedImages(childComplexity), true
	case "ECSConfig.capacityProviders":
		if e.complexity.ECSConfig.CapacityProviders == nil {
			break
		}

		return e.complexity.ECSConfig.CapacityProviders(childComplexity), true
	case "ECSConfig.clusters":
		if e.complexity.ECSConfig.Clusters == nil {
			break
		}

		return e.complexity.ECSConfig.Clusters(childComplexity), true
	case "ECSConfig.executionRole":
		if e.complexity.ECSConfig.ExecutionRole == nil {
			break
		}

		return e.complexity.ECSConfig.ExecutionRole(childComplexity), true
	case "ECSConfig.logGroup":
		if e.complexity.ECSConfig.LogGroup == nil {
			break
		}

		return e.complexity.ECSConfig.LogGroup(childComplexity), true
	case "ECSConfig.logRegion":
		if e.complexity.ECSConfig.LogRegion == nil {
			break
		}

		return e.complexity.ECSConfig.LogRegion(childComplexity), true
	case "ECSConfig.logStreamPrefix":
		if e.complexity.ECSConfig.LogStreamPrefix == nil {
			break
		}

		return e.complexity.ECSConfig.LogStreamPrefix(childComplexity), true
	case "ECSConfig.maxCPU":
		if e.complexity.ECSConfig.MaxCPU == nil {
			break
		}

		return e.complexity.ECSConfig.MaxCPU(childComplexity), true
	case "ECSConfig.maxMemoryMb":
		if e.complexity.ECSConfig.MaxMemoryMB == nil {
			break
		}

		return e.complexity.ECSConfig.MaxMemoryMB(childComplexity), true
	case "ECSConfig.taskDefinitionPrefix":
		if e.complexity.ECSConfig.TaskDefinitionPrefix == nil {
			break
		}

		return e.complexity.ECSConfig.TaskDefinitionPrefix(childComplexity), true
	case "ECSConfig.taskRole":
		if e.complexity.ECSConfig.TaskRole == nil {
			break
		}

		return e.complexity.ECSConfig.TaskRole(childComplexity), true

	case "EnvVar.key":
		if e.complexity.EnvVar.Key == nil {
			break
		}

		return e.complexity.EnvVar.Key(childComplexity), true
	case "EnvVar.value":
		if e.complexity.EnvVar.Value == nil {
			break
		}

		return e.complexity.EnvVar.Value(childComplexity), true

	case "Expansion.key":
		if e.complexity.Expansion.Key == nil {
			break
		}

		return e.complexity.Expansion.Key(childComplexity), true
	case "Expansion.value":
		if e.complexity.Expansion.Value == nil {
			break
		}

		return e.complexity.Expansion.Value(childComplexity), true

	case "ExternalLink.displayName":
		if e.complexity.ExternalLink.DisplayName == nil {
			break
		}

		return e.complexity.ExternalLink.DisplayName(childComplexity), true
	case "ExternalLink.requesters":
		if e.complexity.ExternalLink.Requesters == nil {
			break
		}

		return e.complexity.ExternalLink.Requesters(childComplexity), true
	case "ExternalLink.urlTemplate":
		if e.complexity.ExternalLink.URLTemplate == nil {
			break
		}

		return e.complexity.ExternalLink.URLTemplate(childComplexity), true

	case "ExternalLinkForMetadata.displayName":
		if e.complexity.ExternalLinkForMetadata.DisplayName == nil {
			break
		}

		return e.complexity.ExternalLinkForMetadata.DisplayName(childComplexity), true
	case "ExternalLinkForMetadata.url":
		if e.complexity.ExternalLinkForMetadata.URL == nil {
			break
		}

		return e.complexity.ExternalLinkForMetadata.URL(childComplexity), true

	case "FWSConfig.url":
		if e.complexity.FWSConfig.URL == nil {
			break
		}

		return e.complexity.FWSConfig.URL(childComplexity), true

	case "FailingCommand.failureMetadataTags":
		if e.complexity.FailingCommand.FailureMetadataTags == nil {
			break
		}

		return e.complexity.FailingCommand.FailureMetadataTags(childComplexity), true
	case "FailingCommand.fullDisplayName":
		if e.complexity.FailingCommand.FullDisplayName == nil {
			break
		}

		return e.complexity.FailingCommand.FullDisplayName(childComplexity), true

	case "File.link":
		if e.complexity.File.Link == nil {
			break
		}

		return e.complexity.File.Link(childComplexity), true
	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true
	case "File.urlParsley":
		if e.complexity.File.URLParsley == nil {
			break
		}

		return e.complexity.File.URLParsley(childComplexity), true
	case "File.visibility":
		if e.complexity.File.Visibility == nil {
			break
		}

		return e.complexity.File.Visibility(childComplexity), true

	case "FileDiff.additions":
		if e.complexity.FileDiff.Additions == nil {
			break
		}

		return e.complexity.FileDiff.Additions(childComplexity), true
	case "FileDiff.deletions":
		if e.complexity.FileDiff.Deletions == nil {
			break
		}

		return e.complexity.FileDiff.Deletions(childComplexity), true
	case "FileDiff.description":
		if e.complexity.FileDiff.Description == nil {
			break
		}

		return e.complexity.FileDiff.Description(childComplexity), true
	case "FileDiff.diffLink":
		if e.complexity.FileDiff.DiffLink == nil {
			break
		}

		return e.complexity.FileDiff.DiffLink(childComplexity), true
	case "FileDiff.fileName":
		if e.complexity.FileDiff.FileName == nil {
			break
		}

		return e.complexity.FileDiff.FileName(childComplexity), true

	case "FinderSettings.version":
		if e.complexity.FinderSettings.Version == nil {
			break
		}

		return e.complexity.FinderSettings.Version(childComplexity), true

	case "GeneralSubscription.id":
		if e.complexity.GeneralSubscription.ID == nil {
			break
		}

		return e.complexity.GeneralSubscription.ID(childComplexity), true
	case "GeneralSubscription.ownerType":
		if e.complexity.GeneralSubscription.OwnerType == nil {
			break
		}

		return e.complexity.GeneralSubscription.OwnerType(childComplexity), true
	case "GeneralSubscription.regexSelectors":
		if e.complexity.GeneralSubscription.RegexSelectors == nil {
			break
		}

		return e.complexity.GeneralSubscription.RegexSelectors(childComplexity), true
	case "GeneralSubscription.resourceType":
		if e.complexity.GeneralSubscription.ResourceType == nil {
			break
		}

		return e.complexity.GeneralSubscription.ResourceType(childComplexity), true
	case "GeneralSubscription.selectors":
		if e.complexity.GeneralSubscription.Selectors == nil {
			break
		}

		return e.complexity.GeneralSubscription.Selectors(childComplexity), true
	case "GeneralSubscription.subscriber":
		if e.complexity.GeneralSubscription.Subscriber == nil {
			break
		}

		return e.complexity.GeneralSubscription.Subscriber(childComplexity), true
	case "GeneralSubscription.trigger":
		if e.complexity.GeneralSubscription.Trigger == nil {
			break
		}

		return e.complexity.GeneralSubscription.Trigger(childComplexity), true
	case "GeneralSubscription.triggerData":
		if e.complexity.GeneralSubscription.TriggerData == nil {
			break
		}

		return e.complexity.GeneralSubscription.TriggerData(childComplexity), true

	case "GeneratedTaskCountResults.buildVariantName":
		if e.complexity.GeneratedTaskCountResults.BuildVariantName == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.BuildVariantName(childComplexity), true
	case "GeneratedTaskCountResults.estimatedTasks":
		if e.complexity.GeneratedTaskCountResults.EstimatedTasks == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.EstimatedTasks(childComplexity), true
	case "GeneratedTaskCountResults.taskId":
		if e.complexity.GeneratedTaskCountResults.TaskID == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.TaskID(childComplexity), true
	case "GeneratedTaskCountResults.taskName":
		if e.complexity.GeneratedTaskCountResults.TaskName == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.TaskName(childComplexity), true

	case "GitHubAuthConfig.appId":
		if e.complexity.GitHubAuthConfig.AppId == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.AppId(childComplexity), true
	case "GitHubAuthConfig.clientId":
		if e.complexity.GitHubAuthConfig.ClientId == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.ClientId(childComplexity), true
	case "GitHubAuthConfig.clientSecret":
		if e.complexity.GitHubAuthConfig.ClientSecret == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.ClientSecret(childComplexity), true
	case "GitHubAuthConfig.defaultOwner":
		if e.complexity.GitHubAuthConfig.DefaultOwner == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.DefaultOwner(childComplexity), true
	case "GitHubAuthConfig.defaultRepo":
		if e.complexity.GitHubAuthConfig.DefaultRepo == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.DefaultRepo(childComplexity), true
	case "GitHubAuthConfig.organization":
		if e.complexity.GitHubAuthConfig.Organization == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.Organization(childComplexity), true
	case "GitHubAuthConfig.users":
		if e.complexity.GitHubAuthConfig.Users == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.Users(childComplexity), true

	case "GitHubCheckRunConfig.checkRunLimit":
		if e.complexity.GitHubCheckRunConfig.CheckRunLimit == nil {
			break
		}

		return e.complexity.GitHubCheckRunConfig.CheckRunLimit(childComplexity), true

	case "GitHubDynamicTokenPermissionGroup.name":
		if e.complexity.GitHubDynamicTokenPermissionGroup.Name == nil {
			break
		}

		return e.complexity.GitHubDynamicTokenPermissionGroup.Name(childComplexity), true
	case "GitHubDynamicTokenPermissionGroup.permissions":
		if e.complexity.GitHubDynamicTokenPermissionGroup.Permissions == nil {
			break
		}

		return e.complexity.GitHubDynamicTokenPermissionGroup.Permissions(childComplexity), true

	case "GitTag.pusher":
		if e.complexity.GitTag.Pusher == nil {
			break
		}

		return e.complexity.GitTag.Pusher(childComplexity), true
	case "GitTag.tag":
		if e.complexity.GitTag.Tag == nil {
			break
		}

		return e.complexity.GitTag.Tag(childComplexity), true

	case "GithubAppAuth.appId":
		if e.complexity.GithubAppAuth.AppID == nil {
			break
		}

		return e.complexity.GithubAppAuth.AppID(childComplexity), true
	case "GithubAppAuth.privateKey":
		if e.complexity.GithubAppAuth.PrivateKey == nil {
			break
		}

		return e.complexity.GithubAppAuth.PrivateKey(childComplexity), true

	case "GithubCheckSubscriber.owner":
		if e.complexity.GithubCheckSubscriber.Owner == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Owner(childComplexity), true
	case "GithubCheckSubscriber.ref":
		if e.complexity.GithubCheckSubscriber.Ref == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Ref(childComplexity), true
	case "GithubCheckSubscriber.repo":
		if e.complexity.GithubCheckSubscriber.Repo == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Repo(childComplexity), true

	case "GithubPRSubscriber.owner":
		if e.complexity.GithubPRSubscriber.Owner == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Owner(childComplexity), true
	case "GithubPRSubscriber.prNumber":
		if e.complexity.GithubPRSubscriber.PRNumber == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.PRNumber(childComplexity), true
	case "GithubPRSubscriber.ref":
		if e.complexity.GithubPRSubscriber.Ref == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Ref(childComplexity), true
	case "GithubPRSubscriber.repo":
		if e.complexity.GithubPRSubscriber.Repo == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Repo(childComplexity), true

	case "GithubPatch.author":
		if e.complexity.GithubPatch.Author == nil {
			break
		}

		return e.complexity.GithubPatch.Author(childComplexity), true
	case "GithubPatch.baseOwner":
		if e.complexity.GithubPatch.BaseOwner == nil {
			break
		}

		return e.complexity.GithubPatch.BaseOwner(childComplexity), true
	case "GithubPatch.baseRepo":
		if e.complexity.GithubPatch.BaseRepo == nil {
			break
		}

		return e.complexity.GithubPatch.BaseRepo(childComplexity), true
	case "GithubPatch.headBranch":
		if e.complexity.GithubPatch.HeadBranch == nil {
			break
		}

		return e.complexity.GithubPatch.HeadBranch(childComplexity), true
	case "GithubPatch.headHash":
		if e.complexity.GithubPatch.HeadHash == nil {
			break
		}

		return e.complexity.GithubPatch.HeadHash(childComplexity), true
	case "GithubPatch.headOwner":
		if e.complexity.GithubPatch.HeadOwner == nil {
			break
		}

		return e.complexity.GithubPatch.HeadOwner(childComplexity), true
	case "GithubPatch.headRepo":
		if e.complexity.GithubPatch.HeadRepo == nil {
			break
		}

		return e.complexity.GithubPatch.HeadRepo(childComplexity), true
	case "GithubPatch.prNumber":
		if e.complexity.GithubPatch.PRNumber == nil {
			break
		}

		return e.complexity.GithubPatch.PRNumber(childComplexity), true

	case "GithubProjectConflicts.commitCheckIdentifiers":
		if e.complexity.GithubProjectConflicts.CommitCheckIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.CommitCheckIdentifiers(childComplexity), true
	case "GithubProjectConflicts.commitQueueIdentifiers":
		if e.complexity.GithubProjectConflicts.CommitQueueIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.CommitQueueIdentifiers(childComplexity), true
	case "GithubProjectConflicts.prTestingIdentifiers":
		if e.complexity.GithubProjectConflicts.PRTestingIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.PRTestingIdentifiers(childComplexity), true

	case "GithubUser.lastKnownAs":
		if e.complexity.GithubUser.LastKnownAs == nil {
			break
		}

		return e.complexity.GithubUser.LastKnownAs(childComplexity), true
	case "GithubUser.uid":
		if e.complexity.GithubUser.UID == nil {
			break
		}

		return e.complexity.GithubUser.UID(childComplexity), true

	case "GraphiteConfig.ciOptimizationToken":
		if e.complexity.GraphiteConfig.CIOptimizationToken == nil {
			break
		}

		return e.complexity.GraphiteConfig.CIOptimizationToken(childComplexity), true
	case "GraphiteConfig.serverUrl":
		if e.complexity.GraphiteConfig.ServerURL == nil {
			break
		}

		return e.complexity.GraphiteConfig.ServerURL(childComplexity), true

	case "GroupedBuildVariant.displayName":
		if e.complexity.GroupedBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.DisplayName(childComplexity), true
	case "GroupedBuildVariant.tasks":
		if e.complexity.GroupedBuildVariant.Tasks == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.Tasks(childComplexity), true
	case "GroupedBuildVariant.variant":
		if e.complexity.GroupedBuildVariant.Variant == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.Variant(childComplexity), true

	case "GroupedFiles.execution":
		if e.complexity.GroupedFiles.Execution == nil {
			break
		}

		return e.complexity.GroupedFiles.Execution(childComplexity), true
	case "GroupedFiles.files":
		if e.complexity.GroupedFiles.Files == nil {
			break
		}

		return e.complexity.GroupedFiles.Files(childComplexity), true
	case "GroupedFiles.taskId":
		if e.complexity.GroupedFiles.TaskID == nil {
			break
		}

		return e.complexity.GroupedFiles.TaskID(childComplexity), true
	case "GroupedFiles.taskName":
		if e.complexity.GroupedFiles.TaskName == nil {
			break
		}

		return e.complexity.GroupedFiles.TaskName(childComplexity), true

	case "GroupedProjects.groupDisplayName":
		if e.complexity.GroupedProjects.GroupDisplayName == nil {
			break
		}

		return e.complexity.GroupedProjects.GroupDisplayName(childComplexity), true
	case "GroupedProjects.projects":
		if e.complexity.GroupedProjects.Projects == nil {
			break
		}

		return e.complexity.GroupedProjects.Projects(childComplexity), true
	case "GroupedProjects.repo":
		if e.complexity.GroupedProjects.Repo == nil {
			break
		}

		return e.complexity.GroupedProjects.Repo(childComplexity), true

	case "GroupedTaskStatusCount.displayName":
		if e.complexity.GroupedTaskStatusCount.DisplayName == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.DisplayName(childComplexity), true
	case "GroupedTaskStatusCount.statusCounts":
		if e.complexity.GroupedTaskStatusCount.StatusCounts == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.StatusCounts(childComplexity), true
	case "GroupedTaskStatusCount.variant":
		if e.complexity.GroupedTaskStatusCount.Variant == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.Variant(childComplexity), true

	case "HomeVolumeSettings.formatCommand":
		if e.complexity.HomeVolumeSettings.FormatCommand == nil {
			break
		}

		return e.complexity.HomeVolumeSettings.FormatCommand(childComplexity), true

	case "Host.ami":
		if e.complexity.Host.Ami == nil {
			break
		}

		return e.complexity.Host.Ami(childComplexity), true
	case "Host.availabilityZone":
		if e.complexity.Host.AvailabilityZone == nil {
			break
		}

		return e.complexity.Host.AvailabilityZone(childComplexity), true
	case "Host.displayName":
		if e.complexity.Host.DisplayName == nil {
			break
		}

		return e.complexity.Host.DisplayName(childComplexity), true
	case "Host.distro":
		if e.complexity.Host.Distro == nil {
			break
		}

		return e.complexity.Host.Distro(childComplexity), true
	case "Host.distroId":
		if e.complexity.Host.DistroID == nil {
			break
		}

		return e.complexity.Host.DistroID(childComplexity), true
	case "Host.elapsed":
		if e.complexity.Host.Elapsed == nil {
			break
		}

		return e.complexity.Host.Elapsed(childComplexity), true
	case "Host.eventTypes":
		if e.complexity.Host.EventTypes == nil {
			break
		}

		return e.complexity.Host.EventTypes(childComplexity), true
	case "Host.events":
		if e.complexity.Host.Events == nil {
			break
		}

		args, err := ec.field_Host_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Events(childComplexity, args["opts"].(HostEventsInput)), true
	case "Host.expiration":
		if e.complexity.Host.Expiration == nil {
			break
		}

		return e.complexity.Host.Expiration(childComplexity), true
	case "Host.homeVolume":
		if e.complexity.Host.HomeVolume == nil {
			break
		}

		return e.complexity.Host.HomeVolume(childComplexity), true
	case "Host.homeVolumeID":
		if e.complexity.Host.HomeVolumeID == nil {
			break
		}

		return e.complexity.Host.HomeVolumeID(childComplexity), true
	case "Host.hostUrl":
		if e.complexity.Host.HostURL == nil {
			break
		}

		return e.complexity.Host.HostURL(childComplexity), true
	case "Host.id":
		if e.complexity.Host.Id == nil {
			break
		}

		return e.complexity.Host.Id(childComplexity), true
	case "Host.instanceTags":
		if e.complexity.Host.InstanceTags == nil {
			break
		}

		return e.complexity.Host.InstanceTags(childComplexity), true
	case "Host.instanceType":
		if e.complexity.Host.InstanceType == nil {
			break
		}

		return e.complexity.Host.InstanceType(childComplexity), true
	case "Host.lastCommunicationTime":
		if e.complexity.Host.LastCommunicationTime == nil {
			break
		}

		return e.complexity.Host.LastCommunicationTime(childComplexity), true
	case "Host.noExpiration":
		if e.complexity.Host.NoExpiration == nil {
			break
		}

		return e.complexity.Host.NoExpiration(childComplexity), true
	case "Host.persistentDnsName":
		if e.complexity.Host.PersistentDNSName == nil {
			break
		}

		return e.complexity.Host.PersistentDNSName(childComplexity), true
	case "Host.provider":
		if e.complexity.Host.Provider == nil {
			break
		}

		return e.complexity.Host.Provider(childComplexity), true
	case "Host.runningTask":
		if e.complexity.Host.RunningTask == nil {
			break
		}

		return e.complexity.Host.RunningTask(childComplexity), true
	case "Host.sleepSchedule":
		if e.complexity.Host.SleepSchedule == nil {
			break
		}

		return e.complexity.Host.SleepSchedule(childComplexity), true
	case "Host.startedBy":
		if e.complexity.Host.StartedBy == nil {
			break
		}

		return e.complexity.Host.StartedBy(childComplexity), true
	case "Host.status":
		if e.complexity.Host.Status == nil {
			break
		}

		return e.complexity.Host.Status(childComplexity), true
	case "Host.tag":
		if e.complexity.Host.Tag == nil {
			break
		}

		return e.complexity.Host.Tag(childComplexity), true
	case "Host.totalIdleTime":
		if e.complexity.Host.TotalIdleTime == nil {
			break
		}

		return e.complexity.Host.TotalIdleTime(childComplexity), true
	case "Host.uptime":
		if e.complexity.Host.Uptime == nil {
			break
		}

		return e.complexity.Host.Uptime(childComplexity), true
	case "Host.user":
		if e.complexity.Host.User == nil {
			break
		}

		return e.complexity.Host.User(childComplexity), true
	case "Host.volumes":
		if e.complexity.Host.Volumes == nil {
			break
		}

		return e.complexity.Host.Volumes(childComplexity), true

	case "HostAllocatorSettings.acceptableHostIdleTime":
		if e.complexity.HostAllocatorSettings.AcceptableHostIdleTime == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.AcceptableHostIdleTime(childComplexity), true
	case "HostAllocatorSettings.autoTuneMaximumHosts":
		if e.complexity.HostAllocatorSettings.AutoTuneMaximumHosts == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.AutoTuneMaximumHosts(childComplexity), true
	case "HostAllocatorSettings.feedbackRule":
		if e.complexity.HostAllocatorSettings.FeedbackRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.FeedbackRule(childComplexity), true
	case "HostAllocatorSettings.futureHostFraction":
		if e.complexity.HostAllocatorSettings.FutureHostFraction == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.FutureHostFraction(childComplexity), true
	case "HostAllocatorSettings.hostsOverallocatedRule":
		if e.complexity.HostAllocatorSettings.HostsOverallocatedRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.HostsOverallocatedRule(childComplexity), true
	case "HostAllocatorSettings.maximumHosts":
		if e.complexity.HostAllocatorSettings.MaximumHosts == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.MaximumHosts(childComplexity), true
	case "HostAllocatorSettings.minimumHosts":
		if e.complexity.HostAllocatorSettings.MinimumHosts == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.MinimumHosts(childComplexity), true
	case "HostAllocatorSettings.roundingRule":
		if e.complexity.HostAllocatorSettings.RoundingRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.RoundingRule(childComplexity), true
	case "HostAllocatorSettings.version":
		if e.complexity.HostAllocatorSettings.Version == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.Version(childComplexity), true

	case "HostEventLogData.agentBuild":
		if e.complexity.HostEventLogData.AgentBuild == nil {
			break
		}

		return e.complexity.HostEventLogData.AgentBuild(childComplexity), true
	case "HostEventLogData.agentRevision":
		if e.complexity.HostEventLogData.AgentRevision == nil {
			break
		}

		return e.complexity.HostEventLogData.AgentRevision(childComplexity), true
	case "HostEventLogData.duration":
		if e.complexity.HostEventLogData.Duration == nil {
			break
		}

		return e.complexity.HostEventLogData.Duration(childComplexity), true
	case "HostEventLogData.execution":
		if e.complexity.HostEventLogData.Execution == nil {
			break
		}

		return e.complexity.HostEventLogData.Execution(childComplexity), true
	case "HostEventLogData.hostname":
		if e.complexity.HostEventLogData.Hostname == nil {
			break
		}

		return e.complexity.HostEventLogData.Hostname(childComplexity), true
	case "HostEventLogData.jasperRevision":
		if e.complexity.HostEventLogData.JasperRevision == nil {
			break
		}

		return e.complexity.HostEventLogData.JasperRevision(childComplexity), true
	case "HostEventLogData.logs":
		if e.complexity.HostEventLogData.Logs == nil {
			break
		}

		return e.complexity.HostEventLogData.Logs(childComplexity), true
	case "HostEventLogData.monitorOp":
		if e.complexity.HostEventLogData.MonitorOp == nil {
			break
		}

		return e.complexity.HostEventLogData.MonitorOp(childComplexity), true
	case "HostEventLogData.newStatus":
		if e.complexity.HostEventLogData.NewStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.NewStatus(childComplexity), true
	case "HostEventLogData.oldStatus":
		if e.complexity.HostEventLogData.OldStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.OldStatus(childComplexity), true
	case "HostEventLogData.provisioningMethod":
		if e.complexity.HostEventLogData.ProvisioningMethod == nil {
			break
		}

		return e.complexity.HostEventLogData.ProvisioningMethod(childComplexity), true
	case "HostEventLogData.successful":
		if e.complexity.HostEventLogData.Successful == nil {
			break
		}

		return e.complexity.HostEventLogData.Successful(childComplexity), true
	case "HostEventLogData.taskId":
		if e.complexity.HostEventLogData.TaskId == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskId(childComplexity), true
	case "HostEventLogData.taskPid":
		if e.complexity.HostEventLogData.TaskPid == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskPid(childComplexity), true
	case "HostEventLogData.taskStatus":
		if e.complexity.HostEventLogData.TaskStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskStatus(childComplexity), true
	case "HostEventLogData.user":
		if e.complexity.HostEventLogData.User == nil {
			break
		}

		return e.complexity.HostEventLogData.User(childComplexity), true

	case "HostEventLogEntry.data":
		if e.complexity.HostEventLogEntry.Data == nil {
			break
		}

		return e.complexity.HostEventLogEntry.Data(childComplexity), true
	case "HostEventLogEntry.eventType":
		if e.complexity.HostEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.HostEventLogEntry.EventType(childComplexity), true
	case "HostEventLogEntry.id":
		if e.complexity.HostEventLogEntry.ID == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ID(childComplexity), true
	case "HostEventLogEntry.processedAt":
		if e.complexity.HostEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ProcessedAt(childComplexity), true
	case "HostEventLogEntry.resourceId":
		if e.complexity.HostEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ResourceId(childComplexity), true
	case "HostEventLogEntry.resourceType":
		if e.complexity.HostEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ResourceType(childComplexity), true
	case "HostEventLogEntry.timestamp":
		if e.complexity.HostEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.HostEventLogEntry.Timestamp(childComplexity), true

	case "HostEvents.count":
		if e.complexity.HostEvents.Count == nil {
			break
		}

		return e.complexity.HostEvents.Count(childComplexity), true
	case "HostEvents.eventLogEntries":
		if e.complexity.HostEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.HostEvents.EventLogEntries(childComplexity), true

	case "HostInitConfig.cloudStatusBatchSize":
		if e.complexity.HostInitConfig.CloudStatusBatchSize == nil {
			break
		}

		return e.complexity.HostInitConfig.CloudStatusBatchSize(childComplexity), true
	case "HostInitConfig.hostThrottle":
		if e.complexity.HostInitConfig.HostThrottle == nil {
			break
		}

		return e.complexity.HostInitConfig.HostThrottle(childComplexity), true
	case "HostInitConfig.maxTotalDynamicHosts":
		if e.complexity.HostInitConfig.MaxTotalDynamicHosts == nil {
			break
		}

		return e.complexity.HostInitConfig.MaxTotalDynamicHosts(childComplexity), true
	case "HostInitConfig.provisioningThrottle":
		if e.complexity.HostInitConfig.ProvisioningThrottle == nil {
			break
		}

		return e.complexity.HostInitConfig.ProvisioningThrottle(childComplexity), true

	case "HostJasperConfig.binaryName":
		if e.complexity.HostJasperConfig.BinaryName == nil {
			break
		}

		return e.complexity.HostJasperConfig.BinaryName(childComplexity), true
	case "HostJasperConfig.downloadFileName":
		if e.complexity.HostJasperConfig.DownloadFileName == nil {
			break
		}

		return e.complexity.HostJasperConfig.DownloadFileName(childComplexity), true
	case "HostJasperConfig.port":
		if e.complexity.HostJasperConfig.Port == nil {
			break
		}

		return e.complexity.HostJasperConfig.Port(childComplexity), true
	case "HostJasperConfig.url":
		if e.complexity.HostJasperConfig.URL == nil {
			break
		}

		return e.complexity.HostJasperConfig.URL(childComplexity), true
	case "HostJasperConfig.version":
		if e.complexity.HostJasperConfig.Version == nil {
			break
		}

		return e.complexity.HostJasperConfig.Version(childComplexity), true

	case "HostsResponse.filteredHostsCount":
		if e.complexity.HostsResponse.FilteredHostsCount == nil {
			break
		}

		return e.complexity.HostsResponse.FilteredHostsCount(childComplexity), true
	case "HostsResponse.hosts":
		if e.complexity.HostsResponse.Hosts == nil {
			break
		}

		return e.complexity.HostsResponse.Hosts(childComplexity), true
	case "HostsResponse.totalHostsCount":
		if e.complexity.HostsResponse.TotalHostsCount == nil {
			break
		}

		return e.complexity.HostsResponse.TotalHostsCount(childComplexity), true

	case "IceCreamSettings.configPath":
		if e.complexity.IceCreamSettings.ConfigPath == nil {
			break
		}

		return e.complexity.IceCreamSettings.ConfigPath(childComplexity), true
	case "IceCreamSettings.schedulerHost":
		if e.complexity.IceCreamSettings.SchedulerHost == nil {
			break
		}

		return e.complexity.IceCreamSettings.SchedulerHost(childComplexity), true

	case "Image.ami":
		if e.complexity.Image.AMI == nil {
			break
		}

		return e.complexity.Image.AMI(childComplexity), true
	case "Image.distros":
		if e.complexity.Image.Distros == nil {
			break
		}

		return e.complexity.Image.Distros(childComplexity), true
	case "Image.events":
		if e.complexity.Image.Events == nil {
			break
		}

		args, err := ec.field_Image_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.Events(childComplexity, args["limit"].(int), args["page"].(int)), true
	case "Image.files":
		if e.complexity.Image.Files == nil {
			break
		}

		args, err := ec.field_Image_files_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.Files(childComplexity, args["opts"].(thirdparty.FileFilterOptions)), true
	case "Image.id":
		if e.complexity.Image.ID == nil {
			break
		}

		return e.complexity.Image.ID(childComplexity), true
	case "Image.lastDeployed":
		if e.complexity.Image.LastDeployed == nil {
			break
		}

		return e.complexity.Image.LastDeployed(childComplexity), true
	case "Image.latestTask":
		if e.complexity.Image.LatestTask == nil {
			break
		}

		return e.complexity.Image.LatestTask(childComplexity), true
	case "Image.operatingSystem":
		if e.complexity.Image.OperatingSystem == nil {
			break
		}

		args, err := ec.field_Image_operatingSystem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.OperatingSystem(childComplexity, args["opts"].(thirdparty.OSInfoFilterOptions)), true
	case "Image.packages":
		if e.complexity.Image.Packages == nil {
			break
		}

		args, err := ec.field_Image_packages_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.Packages(childComplexity, args["opts"].(thirdparty.PackageFilterOptions)), true
	case "Image.toolchains":
		if e.complexity.Image.Toolchains == nil {
			break
		}

		args, err := ec.field_Image_toolchains_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.Toolchains(childComplexity, args["opts"].(thirdparty.ToolchainFilterOptions)), true

	case "ImageEvent.amiAfter":
		if e.complexity.ImageEvent.AMIAfter == nil {
			break
		}

		return e.complexity.ImageEvent.AMIAfter(childComplexity), true
	case "ImageEvent.amiBefore":
		if e.complexity.ImageEvent.AMIBefore == nil {
			break
		}

		return e.complexity.ImageEvent.AMIBefore(childComplexity), true
	case "ImageEvent.entries":
		if e.complexity.ImageEvent.Entries == nil {
			break
		}

		return e.complexity.ImageEvent.Entries(childComplexity), true
	case "ImageEvent.timestamp":
		if e.complexity.ImageEvent.Timestamp == nil {
			break
		}

		return e.complexity.ImageEvent.Timestamp(childComplexity), true

	case "ImageEventEntry.action":
		if e.complexity.ImageEventEntry.Action == nil {
			break
		}

		return e.complexity.ImageEventEntry.Action(childComplexity), true
	case "ImageEventEntry.after":
		if e.complexity.ImageEventEntry.After == nil {
			break
		}

		return e.complexity.ImageEventEntry.After(childComplexity), true
	case "ImageEventEntry.before":
		if e.complexity.ImageEventEntry.Before == nil {
			break
		}

		return e.complexity.ImageEventEntry.Before(childComplexity), true
	case "ImageEventEntry.name":
		if e.complexity.ImageEventEntry.Name == nil {
			break
		}

		return e.complexity.ImageEventEntry.Name(childComplexity), true
	case "ImageEventEntry.type":
		if e.complexity.ImageEventEntry.Type == nil {
			break
		}

		return e.complexity.ImageEventEntry.Type(childComplexity), true

	case "ImageEventsPayload.count":
		if e.complexity.ImageEventsPayload.Count == nil {
			break
		}

		return e.complexity.ImageEventsPayload.Count(childComplexity), true
	case "ImageEventsPayload.eventLogEntries":
		if e.complexity.ImageEventsPayload.EventLogEntries == nil {
			break
		}

		return e.complexity.ImageEventsPayload.EventLogEntries(childComplexity), true

	case "ImageFile.name":
		if e.complexity.ImageFile.Name == nil {
			break
		}

		return e.complexity.ImageFile.Name(childComplexity), true
	case "ImageFile.path":
		if e.complexity.ImageFile.Path == nil {
			break
		}

		return e.complexity.ImageFile.Path(childComplexity), true
	case "ImageFile.version":
		if e.complexity.ImageFile.Version == nil {
			break
		}

		return e.complexity.ImageFile.Version(childComplexity), true

	case "ImageFilesPayload.data":
		if e.complexity.ImageFilesPayload.Data == nil {
			break
		}

		return e.complexity.ImageFilesPayload.Data(childComplexity), true
	case "ImageFilesPayload.filteredCount":
		if e.complexity.ImageFilesPayload.FilteredCount == nil {
			break
		}

		return e.complexity.ImageFilesPayload.FilteredCount(childComplexity), true
	case "ImageFilesPayload.totalCount":
		if e.complexity.ImageFilesPayload.TotalCount == nil {
			break
		}

		return e.complexity.ImageFilesPayload.TotalCount(childComplexity), true

	case "ImageOperatingSystemPayload.data":
		if e.complexity.ImageOperatingSystemPayload.Data == nil {
			break
		}

		return e.complexity.ImageOperatingSystemPayload.Data(childComplexity), true
	case "ImageOperatingSystemPayload.filteredCount":
		if e.complexity.ImageOperatingSystemPayload.FilteredCount == nil {
			break
		}

		return e.complexity.ImageOperatingSystemPayload.FilteredCount(childComplexity), true
	case "ImageOperatingSystemPayload.totalCount":
		if e.complexity.ImageOperatingSystemPayload.TotalCount == nil {
			break
		}

		return e.complexity.ImageOperatingSystemPayload.TotalCount(childComplexity), true

	case "ImagePackagesPayload.data":
		if e.complexity.ImagePackagesPayload.Data == nil {
			break
		}

		return e.complexity.ImagePackagesPayload.Data(childComplexity), true
	case "ImagePackagesPayload.filteredCount":
		if e.complexity.ImagePackagesPayload.FilteredCount == nil {
			break
		}

		return e.complexity.ImagePackagesPayload.FilteredCount(childComplexity), true
	case "ImagePackagesPayload.totalCount":
		if e.complexity.ImagePackagesPayload.TotalCount == nil {
			break
		}

		return e.complexity.ImagePackagesPayload.TotalCount(childComplexity), true

	case "ImageToolchainsPayload.data":
		if e.complexity.ImageToolchainsPayload.Data == nil {
			break
		}

		return e.complexity.ImageToolchainsPayload.Data(childComplexity), true
	case "ImageToolchainsPayload.filteredCount":
		if e.complexity.ImageToolchainsPayload.FilteredCount == nil {
			break
		}

		return e.complexity.ImageToolchainsPayload.FilteredCount(childComplexity), true
	case "ImageToolchainsPayload.totalCount":
		if e.complexity.ImageToolchainsPayload.TotalCount == nil {
			break
		}

		return e.complexity.ImageToolchainsPayload.TotalCount(childComplexity), true

	case "IncludedLocalModule.fileName":
		if e.complexity.IncludedLocalModule.FileName == nil {
			break
		}

		return e.complexity.IncludedLocalModule.FileName(childComplexity), true
	case "IncludedLocalModule.module":
		if e.complexity.IncludedLocalModule.Module == nil {
			break
		}

		return e.complexity.IncludedLocalModule.Module(childComplexity), true

	case "InstanceTag.canBeModified":
		if e.complexity.InstanceTag.CanBeModified == nil {
			break
		}

		return e.complexity.InstanceTag.CanBeModified(childComplexity), true
	case "InstanceTag.key":
		if e.complexity.InstanceTag.Key == nil {
			break
		}

		return e.complexity.InstanceTag.Key(childComplexity), true
	case "InstanceTag.value":
		if e.complexity.InstanceTag.Value == nil {
			break
		}

		return e.complexity.InstanceTag.Value(childComplexity), true

	case "IssueLink.confidenceScore":
		if e.complexity.IssueLink.ConfidenceScore == nil {
			break
		}

		return e.complexity.IssueLink.ConfidenceScore(childComplexity), true
	case "IssueLink.issueKey":
		if e.complexity.IssueLink.IssueKey == nil {
			break
		}

		return e.complexity.IssueLink.IssueKey(childComplexity), true
	case "IssueLink.jiraTicket":
		if e.complexity.IssueLink.JiraTicket == nil {
			break
		}

		return e.complexity.IssueLink.JiraTicket(childComplexity), true
	case "IssueLink.source":
		if e.complexity.IssueLink.Source == nil {
			break
		}

		return e.complexity.IssueLink.Source(childComplexity), true
	case "IssueLink.url":
		if e.complexity.IssueLink.URL == nil {
			break
		}

		return e.complexity.IssueLink.URL(childComplexity), true

	case "JiraConfig.email":
		if e.complexity.JiraConfig.Email == nil {
			break
		}

		return e.complexity.JiraConfig.Email(childComplexity), true
	case "JiraConfig.host":
		if e.complexity.JiraConfig.Host == nil {
			break
		}

		return e.complexity.JiraConfig.Host(childComplexity), true
	case "JiraConfig.personalAccessToken":
		if e.complexity.JiraConfig.PersonalAccessToken == nil {
			break
		}

		return e.complexity.JiraConfig.PersonalAccessToken(childComplexity), true

	case "JiraIssueSubscriber.issueType":
		if e.complexity.JiraIssueSubscriber.IssueType == nil {
			break
		}

		return e.complexity.JiraIssueSubscriber.IssueType(childComplexity), true
	case "JiraIssueSubscriber.project":
		if e.complexity.JiraIssueSubscriber.Project == nil {
			break
		}

		return e.complexity.JiraIssueSubscriber.Project(childComplexity), true

	case "JiraNotificationsConfig.customFields":
		if e.complexity.JiraNotificationsConfig.CustomFields == nil {
			break
		}

		return e.complexity.JiraNotificationsConfig.CustomFields(childComplexity), true

	case "JiraNotificationsProject.components":
		if e.complexity.JiraNotificationsProject.Components == nil {
			break
		}

		return e.complexity.JiraNotificationsProject.Components(childComplexity), true
	case "JiraNotificationsProject.fields":
		if e.complexity.JiraNotificationsProject.Fields == nil {
			break
		}

		return e.complexity.JiraNotificationsProject.Fields(childComplexity), true
	case "JiraNotificationsProject.labels":
		if e.complexity.JiraNotificationsProject.Labels == nil {
			break
		}

		return e.complexity.JiraNotificationsProject.Labels(childComplexity), true

	case "JiraNotificationsProjectEntry.components":
		if e.complexity.JiraNotificationsProjectEntry.Components == nil {
			break
		}

		return e.complexity.JiraNotificationsProjectEntry.Components(childComplexity), true
	case "JiraNotificationsProjectEntry.fields":
		if e.complexity.JiraNotificationsProjectEntry.Fields == nil {
			break
		}

		return e.complexity.JiraNotificationsProjectEntry.Fields(childComplexity), true
	case "JiraNotificationsProjectEntry.labels":
		if e.complexity.JiraNotificationsProjectEntry.Labels == nil {
			break
		}

		return e.complexity.JiraNotificationsProjectEntry.Labels(childComplexity), true
	case "JiraNotificationsProjectEntry.project":
		if e.complexity.JiraNotificationsProjectEntry.Project == nil {
			break
		}

		return e.complexity.JiraNotificationsProjectEntry.Project(childComplexity), true

	case "JiraStatus.id":
		if e.complexity.JiraStatus.Id == nil {
			break
		}

		return e.complexity.JiraStatus.Id(childComplexity), true
	case "JiraStatus.name":
		if e.complexity.JiraStatus.Name == nil {
			break
		}

		return e.complexity.JiraStatus.Name(childComplexity), true

	case "JiraTicket.fields":
		if e.complexity.JiraTicket.Fields == nil {
			break
		}

		return e.complexity.JiraTicket.Fields(childComplexity), true
	case "JiraTicket.key":
		if e.complexity.JiraTicket.Key == nil {
			break
		}

		return e.complexity.JiraTicket.Key(childComplexity), true

	case "KanopyAuthConfig.headerName":
		if e.complexity.KanopyAuthConfig.HeaderName == nil {
			break
		}

		return e.complexity.KanopyAuthConfig.HeaderName(childComplexity), true
	case "KanopyAuthConfig.issuer":
		if e.complexity.KanopyAuthConfig.Issuer == nil {
			break
		}

		return e.complexity.KanopyAuthConfig.Issuer(childComplexity), true
	case "KanopyAuthConfig.keysetURL":
		if e.complexity.KanopyAuthConfig.KeysetURL == nil {
			break
		}

		return e.complexity.KanopyAuthConfig.KeysetURL(childComplexity), true

	case "LogBuffering.count":
		if e.complexity.LogBuffering.Count == nil {
			break
		}

		return e.complexity.LogBuffering.Count(childComplexity), true
	case "LogBuffering.durationSeconds":
		if e.complexity.LogBuffering.DurationSeconds == nil {
			break
		}

		return e.complexity.LogBuffering.DurationSeconds(childComplexity), true
	case "LogBuffering.incomingBufferFactor":
		if e.complexity.LogBuffering.IncomingBufferFactor == nil {
			break
		}

		return e.complexity.LogBuffering.IncomingBufferFactor(childComplexity), true
	case "LogBuffering.useAsync":
		if e.complexity.LogBuffering.UseAsync == nil {
			break
		}

		return e.complexity.LogBuffering.UseAsync(childComplexity), true

	case "LogMessage.message":
		if e.complexity.LogMessage.Message == nil {
			break
		}

		return e.complexity.LogMessage.Message(childComplexity), true
	case "LogMessage.severity":
		if e.complexity.LogMessage.Severity == nil {
			break
		}

		return e.complexity.LogMessage.Severity(childComplexity), true
	case "LogMessage.timestamp":
		if e.complexity.LogMessage.Timestamp == nil {
			break
		}

		return e.complexity.LogMessage.Timestamp(childComplexity), true
	case "LogMessage.type":
		if e.complexity.LogMessage.Type == nil {
			break
		}

		return e.complexity.LogMessage.Type(childComplexity), true
	case "LogMessage.version":
		if e.complexity.LogMessage.Version == nil {
			break
		}

		return e.complexity.LogMessage.Version(childComplexity), true

	case "LoggerConfig.buffer":
		if e.complexity.LoggerConfig.Buffer == nil {
			break
		}

		return e.complexity.LoggerConfig.Buffer(childComplexity), true
	case "LoggerConfig.defaultLevel":
		if e.complexity.LoggerConfig.DefaultLevel == nil {
			break
		}

		return e.complexity.LoggerConfig.DefaultLevel(childComplexity), true
	case "LoggerConfig.logkeeperURL":
		if e.complexity.LoggerConfig.LogkeeperURL == nil {
			break
		}

		return e.complexity.LoggerConfig.LogkeeperURL(childComplexity), true
	case "LoggerConfig.redactKeys":
		if e.complexity.LoggerConfig.RedactKeys == nil {
			break
		}

		return e.complexity.LoggerConfig.RedactKeys(childComplexity), true
	case "LoggerConfig.thresholdLevel":
		if e.complexity.LoggerConfig.ThresholdLevel == nil {
			break
		}

		return e.complexity.LoggerConfig.ThresholdLevel(childComplexity), true

	case "LogkeeperBuild.buildNum":
		if e.complexity.LogkeeperBuild.BuildNum == nil {
			break
		}

		return e.complexity.LogkeeperBuild.BuildNum(childComplexity), true
	case "LogkeeperBuild.builder":
		if e.complexity.LogkeeperBuild.Builder == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Builder(childComplexity), true
	case "LogkeeperBuild.id":
		if e.complexity.LogkeeperBuild.ID == nil {
			break
		}

		return e.complexity.LogkeeperBuild.ID(childComplexity), true
	case "LogkeeperBuild.task":
		if e.complexity.LogkeeperBuild.Task == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Task(childComplexity), true
	case "LogkeeperBuild.taskExecution":
		if e.complexity.LogkeeperBuild.TaskExecution == nil {
			break
		}

		return e.complexity.LogkeeperBuild.TaskExecution(childComplexity), true
	case "LogkeeperBuild.taskId":
		if e.complexity.LogkeeperBuild.TaskID == nil {
			break
		}

		return e.complexity.LogkeeperBuild.TaskID(childComplexity), true
	case "LogkeeperBuild.tests":
		if e.complexity.LogkeeperBuild.Tests == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Tests(childComplexity), true

	case "LogkeeperTest.buildId":
		if e.complexity.LogkeeperTest.BuildID == nil {
			break
		}

		return e.complexity.LogkeeperTest.BuildID(childComplexity), true
	case "LogkeeperTest.command":
		if e.complexity.LogkeeperTest.Command == nil {
			break
		}

		return e.complexity.LogkeeperTest.Command(childComplexity), true
	case "LogkeeperTest.id":
		if e.complexity.LogkeeperTest.ID == nil {
			break
		}

		return e.complexity.LogkeeperTest.ID(childComplexity), true
	case "LogkeeperTest.name":
		if e.complexity.LogkeeperTest.Name == nil {
			break
		}

		return e.complexity.LogkeeperTest.Name(childComplexity), true
	case "LogkeeperTest.phase":
		if e.complexity.LogkeeperTest.Phase == nil {
			break
		}

		return e.complexity.LogkeeperTest.Phase(childComplexity), true
	case "LogkeeperTest.taskExecution":
		if e.complexity.LogkeeperTest.TaskExecution == nil {
			break
		}

		return e.complexity.LogkeeperTest.TaskExecution(childComplexity), true
	case "LogkeeperTest.taskId":
		if e.complexity.LogkeeperTest.TaskID == nil {
			break
		}

		return e.complexity.LogkeeperTest.TaskID(childComplexity), true

	case "MainlineCommitVersion.rolledUpVersions":
		if e.complexity.MainlineCommitVersion.RolledUpVersions == nil {
			break
		}

		return e.complexity.MainlineCommitVersion.RolledUpVersions(childComplexity), true
	case "MainlineCommitVersion.version":
		if e.complexity.MainlineCommitVersion.Version == nil {
			break
		}

		return e.complexity.MainlineCommitVersion.Version(childComplexity), true

	case "MainlineCommits.nextPageOrderNumber":
		if e.complexity.MainlineCommits.NextPageOrderNumber == nil {
			break
		}

		return e.complexity.MainlineCommits.NextPageOrderNumber(childComplexity), true
	case "MainlineCommits.prevPageOrderNumber":
		if e.complexity.MainlineCommits.PrevPageOrderNumber == nil {
			break
		}

		return e.complexity.MainlineCommits.PrevPageOrderNumber(childComplexity), true
	case "MainlineCommits.versions":
		if e.complexity.MainlineCommits.Versions == nil {
			break
		}

		return e.complexity.MainlineCommits.Versions(childComplexity), true

	case "Manifest.branch":
		if e.complexity.Manifest.Branch == nil {
			break
		}

		return e.complexity.Manifest.Branch(childComplexity), true
	case "Manifest.id":
		if e.complexity.Manifest.ID == nil {
			break
		}

		return e.complexity.Manifest.ID(childComplexity), true
	case "Manifest.isBase":
		if e.complexity.Manifest.IsBase == nil {
			break
		}

		return e.complexity.Manifest.IsBase(childComplexity), true
	case "Manifest.moduleOverrides":
		if e.complexity.Manifest.ModuleOverrides == nil {
			break
		}

		return e.complexity.Manifest.ModuleOverrides(childComplexity), true
	case "Manifest.modules":
		if e.complexity.Manifest.Modules == nil {
			break
		}

		return e.complexity.Manifest.Modules(childComplexity), true
	case "Manifest.project":
		if e.complexity.Manifest.Project == nil {
			break
		}

		return e.complexity.Manifest.Project(childComplexity), true
	case "Manifest.revision":
		if e.complexity.Manifest.Revision == nil {
			break
		}

		return e.complexity.Manifest.Revision(childComplexity), true

	case "MetadataLink.source":
		if e.complexity.MetadataLink.Source == nil {
			break
		}

		return e.complexity.MetadataLink.Source(childComplexity), true
	case "MetadataLink.text":
		if e.complexity.MetadataLink.Text == nil {
			break
		}

		return e.complexity.MetadataLink.Text(childComplexity), true
	case "MetadataLink.url":
		if e.complexity.MetadataLink.URL == nil {
			break
		}

		return e.complexity.MetadataLink.URL(childComplexity), true

	case "ModuleCodeChange.branchName":
		if e.complexity.ModuleCodeChange.BranchName == nil {
			break
		}

		return e.complexity.ModuleCodeChange.BranchName(childComplexity), true
	case "ModuleCodeChange.fileDiffs":
		if e.complexity.ModuleCodeChange.FileDiffs == nil {
			break
		}

		return e.complexity.ModuleCodeChange.FileDiffs(childComplexity), true
	case "ModuleCodeChange.htmlLink":
		if e.complexity.ModuleCodeChange.HTMLLink == nil {
			break
		}

		return e.complexity.ModuleCodeChange.HTMLLink(childComplexity), true
	case "ModuleCodeChange.rawLink":
		if e.complexity.ModuleCodeChange.RawLink == nil {
			break
		}

		return e.complexity.ModuleCodeChange.RawLink(childComplexity), true

	case "MultiAuthConfig.readOnly":
		if e.complexity.MultiAuthConfig.ReadOnly == nil {
			break
		}

		return e.complexity.MultiAuthConfig.ReadOnly(childComplexity), true
	case "MultiAuthConfig.readWrite":
		if e.complexity.MultiAuthConfig.ReadWrite == nil {
			break
		}

		return e.complexity.MultiAuthConfig.ReadWrite(childComplexity), true

	case "Mutation.abortTask":
		if e.complexity.Mutation.AbortTask == nil {
			break
		}

		args, err := ec.field_Mutation_abortTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AbortTask(childComplexity, args["taskId"].(string)), true
	case "Mutation.addAnnotationIssue":
		if e.complexity.Mutation.AddAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_addAnnotationIssue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true
	case "Mutation.addFavoriteProject":
		if e.complexity.Mutation.AddFavoriteProject == nil {
			break
		}

		args, err := ec.field_Mutation_addFavoriteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddFavoriteProject(childComplexity, args["opts"].(AddFavoriteProjectInput)), true
	case "Mutation.attachProjectToNewRepo":
		if e.complexity.Mutation.AttachProjectToNewRepo == nil {
			break
		}

		args, err := ec.field_Mutation_attachProjectToNewRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachProjectToNewRepo(childComplexity, args["project"].(MoveProjectInput)), true
	case "Mutation.attachProjectToRepo":
		if e.complexity.Mutation.AttachProjectToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_attachProjectToRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachProjectToRepo(childComplexity, args["projectId"].(string)), true
	case "Mutation.attachVolumeToHost":
		if e.complexity.Mutation.AttachVolumeToHost == nil {
			break
		}

		args, err := ec.field_Mutation_attachVolumeToHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachVolumeToHost(childComplexity, args["volumeAndHost"].(VolumeHost)), true
	case "Mutation.bbCreateTicket":
		if e.complexity.Mutation.BbCreateTicket == nil {
			break
		}

		args, err := ec.field_Mutation_bbCreateTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BbCreateTicket(childComplexity, args["taskId"].(string), args["execution"].(*int)), true
	case "Mutation.clearMySubscriptions":
		if e.complexity.Mutation.ClearMySubscriptions == nil {
			break
		}

		return e.complexity.Mutation.ClearMySubscriptions(childComplexity), true
	case "Mutation.copyDistro":
		if e.complexity.Mutation.CopyDistro == nil {
			break
		}

		args, err := ec.field_Mutation_copyDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CopyDistro(childComplexity, args["opts"].(model.CopyDistroOpts)), true
	case "Mutation.copyProject":
		if e.complexity.Mutation.CopyProject == nil {
			break
		}

		args, err := ec.field_Mutation_copyProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CopyProject(childComplexity, args["project"].(model.CopyProjectOpts), args["requestS3Creds"].(*bool)), true
	case "Mutation.createDistro":
		if e.complexity.Mutation.CreateDistro == nil {
			break
		}

		args, err := ec.field_Mutation_createDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDistro(childComplexity, args["opts"].(CreateDistroInput)), true
	case "Mutation.createProject":
		if e.complexity.Mutation.CreateProject == nil {
			break
		}

		args, err := ec.field_Mutation_createProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProject(childComplexity, args["project"].(model.APIProjectRef), args["requestS3Creds"].(*bool)), true
	case "Mutation.createPublicKey":
		if e.complexity.Mutation.CreatePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_createPublicKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePublicKey(childComplexity, args["publicKeyInput"].(PublicKeyInput)), true
	case "Mutation.deactivateStepbackTask":
		if e.complexity.Mutation.DeactivateStepbackTask == nil {
			break
		}

		args, err := ec.field_Mutation_deactivateStepbackTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeactivateStepbackTask(childComplexity, args["opts"].(DeactivateStepbackTaskInput)), true
	case "Mutation.defaultSectionToRepo":
		if e.complexity.Mutation.DefaultSectionToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_defaultSectionToRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DefaultSectionToRepo(childComplexity, args["opts"].(DefaultSectionToRepoInput)), true
	case "Mutation.deleteDistro":
		if e.complexity.Mutation.DeleteDistro == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDistro(childComplexity, args["opts"].(DeleteDistroInput)), true
	case "Mutation.deleteGithubAppCredentials":
		if e.complexity.Mutation.DeleteGithubAppCredentials == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGithubAppCredentials_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGithubAppCredentials(childComplexity, args["opts"].(DeleteGithubAppCredentialsInput)), true
	case "Mutation.deleteProject":
		if e.complexity.Mutation.DeleteProject == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProject(childComplexity, args["projectId"].(string)), true
	case "Mutation.deleteSubscriptions":
		if e.complexity.Mutation.DeleteSubscriptions == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSubscriptions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSubscriptions(childComplexity, args["subscriptionIds"].([]string)), true
	case "Mutation.detachProjectFromRepo":
		if e.complexity.Mutation.DetachProjectFromRepo == nil {
			break
		}

		args, err := ec.field_Mutation_detachProjectFromRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DetachProjectFromRepo(childComplexity, args["projectId"].(string)), true
	case "Mutation.detachVolumeFromHost":
		if e.complexity.Mutation.DetachVolumeFromHost == nil {
			break
		}

		args, err := ec.field_Mutation_detachVolumeFromHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DetachVolumeFromHost(childComplexity, args["volumeId"].(string)), true
	case "Mutation.editAnnotationNote":
		if e.complexity.Mutation.EditAnnotationNote == nil {
			break
		}

		args, err := ec.field_Mutation_editAnnotationNote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditAnnotationNote(childComplexity, args["taskId"].(string), args["execution"].(int), args["originalMessage"].(string), args["newMessage"].(string)), true
	case "Mutation.editSpawnHost":
		if e.complexity.Mutation.EditSpawnHost == nil {
			break
		}

		args, err := ec.field_Mutation_editSpawnHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditSpawnHost(childComplexity, args["spawnHost"].(*EditSpawnHostInput)), true
	case "Mutation.forceRepotrackerRun":
		if e.complexity.Mutation.ForceRepotrackerRun == nil {
			break
		}

		args, err := ec.field_Mutation_forceRepotrackerRun_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ForceRepotrackerRun(childComplexity, args["projectId"].(string)), true
	case "Mutation.migrateVolume":
		if e.complexity.Mutation.MigrateVolume == nil {
			break
		}

		args, err := ec.field_Mutation_migrateVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MigrateVolume(childComplexity, args["volumeId"].(string), args["spawnHostInput"].(*SpawnHostInput)), true
	case "Mutation.moveAnnotationIssue":
		if e.complexity.Mutation.MoveAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_moveAnnotationIssue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MoveAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true
	case "Mutation.overrideTaskDependencies":
		if e.complexity.Mutation.OverrideTaskDependencies == nil {
			break
		}

		args, err := ec.field_Mutation_overrideTaskDependencies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OverrideTaskDependencies(childComplexity, args["taskId"].(string)), true
	case "Mutation.promoteVarsToRepo":
		if e.complexity.Mutation.PromoteVarsToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_promoteVarsToRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PromoteVarsToRepo(childComplexity, args["opts"].(PromoteVarsToRepoInput)), true
	case "Mutation.quarantineTest":
		if e.complexity.Mutation.QuarantineTest == nil {
			break
		}

		args, err := ec.field_Mutation_quarantineTest_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.QuarantineTest(childComplexity, args["opts"].(QuarantineTestInput)), true
	case "Mutation.removeAnnotationIssue":
		if e.complexity.Mutation.RemoveAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_removeAnnotationIssue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true
	case "Mutation.removeFavoriteProject":
		if e.complexity.Mutation.RemoveFavoriteProject == nil {
			break
		}

		args, err := ec.field_Mutation_removeFavoriteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveFavoriteProject(childComplexity, args["opts"].(RemoveFavoriteProjectInput)), true
	case "Mutation.removePublicKey":
		if e.complexity.Mutation.RemovePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_removePublicKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemovePublicKey(childComplexity, args["keyName"].(string)), true
	case "Mutation.removeVolume":
		if e.complexity.Mutation.RemoveVolume == nil {
			break
		}

		args, err := ec.field_Mutation_removeVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveVolume(childComplexity, args["volumeId"].(string)), true
	case "Mutation.reprovisionToNew":
		if e.complexity.Mutation.ReprovisionToNew == nil {
			break
		}

		args, err := ec.field_Mutation_reprovisionToNew_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReprovisionToNew(childComplexity, args["hostIds"].([]string)), true
	case "Mutation.resetAPIKey":
		if e.complexity.Mutation.ResetAPIKey == nil {
			break
		}

		return e.complexity.Mutation.ResetAPIKey(childComplexity), true
	case "Mutation.restartAdminTasks":
		if e.complexity.Mutation.RestartAdminTasks == nil {
			break
		}

		args, err := ec.field_Mutation_restartAdminTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartAdminTasks(childComplexity, args["opts"].(model1.RestartOptions)), true
	case "Mutation.restartJasper":
		if e.complexity.Mutation.RestartJasper == nil {
			break
		}

		args, err := ec.field_Mutation_restartJasper_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartJasper(childComplexity, args["hostIds"].([]string)), true
	case "Mutation.restartTask":
		if e.complexity.Mutation.RestartTask == nil {
			break
		}

		args, err := ec.field_Mutation_restartTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartTask(childComplexity, args["taskId"].(string), args["failedOnly"].(bool)), true
	case "Mutation.restartVersions":
		if e.complexity.Mutation.RestartVersions == nil {
			break
		}

		args, err := ec.field_Mutation_restartVersions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartVersions(childComplexity, args["versionId"].(string), args["abort"].(bool), args["versionsToRestart"].([]*model1.VersionToRestart)), true
	case "Mutation.saveAdminSettings":
		if e.complexity.Mutation.SaveAdminSettings == nil {
			break
		}

		args, err := ec.field_Mutation_saveAdminSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveAdminSettings(childComplexity, args["adminSettings"].(model.APIAdminSettings)), true
	case "Mutation.saveDistro":
		if e.complexity.Mutation.SaveDistro == nil {
			break
		}

		args, err := ec.field_Mutation_saveDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveDistro(childComplexity, args["opts"].(SaveDistroInput)), true
	case "Mutation.saveProjectSettingsForSection":
		if e.complexity.Mutation.SaveProjectSettingsForSection == nil {
			break
		}

		args, err := ec.field_Mutation_saveProjectSettingsForSection_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveProjectSettingsForSection(childComplexity, args["projectSettings"].(*model.APIProjectSettings), args["section"].(ProjectSettingsSection)), true
	case "Mutation.saveRepoSettingsForSection":
		if e.complexity.Mutation.SaveRepoSettingsForSection == nil {
			break
		}

		args, err := ec.field_Mutation_saveRepoSettingsForSection_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveRepoSettingsForSection(childComplexity, args["repoSettings"].(*model.APIProjectSettings), args["section"].(ProjectSettingsSection)), true
	case "Mutation.saveSubscription":
		if e.complexity.Mutation.SaveSubscription == nil {
			break
		}

		args, err := ec.field_Mutation_saveSubscription_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveSubscription(childComplexity, args["subscription"].(model.APISubscription)), true
	case "Mutation.schedulePatch":
		if e.complexity.Mutation.SchedulePatch == nil {
			break
		}

		args, err := ec.field_Mutation_schedulePatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SchedulePatch(childComplexity, args["patchId"].(string), args["configure"].(PatchConfigure)), true
	case "Mutation.scheduleTasks":
		if e.complexity.Mutation.ScheduleTasks == nil {
			break
		}

		args, err := ec.field_Mutation_scheduleTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScheduleTasks(childComplexity, args["versionId"].(string), args["taskIds"].([]string)), true
	case "Mutation.scheduleUndispatchedBaseTasks":
		if e.complexity.Mutation.ScheduleUndispatchedBaseTasks == nil {
			break
		}

		args, err := ec.field_Mutation_scheduleUndispatchedBaseTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScheduleUndispatchedBaseTasks(childComplexity, args["versionId"].(string)), true
	case "Mutation.setAnnotationMetadataLinks":
		if e.complexity.Mutation.SetAnnotationMetadataLinks == nil {
			break
		}

		args, err := ec.field_Mutation_setAnnotationMetadataLinks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetAnnotationMetadataLinks(childComplexity, args["taskId"].(string), args["execution"].(int), args["metadataLinks"].([]*model.APIMetadataLink)), true
	case "Mutation.setLastRevision":
		if e.complexity.Mutation.SetLastRevision == nil {
			break
		}

		args, err := ec.field_Mutation_setLastRevision_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetLastRevision(childComplexity, args["opts"].(SetLastRevisionInput)), true
	case "Mutation.setPatchVisibility":
		if e.complexity.Mutation.SetPatchVisibility == nil {
			break
		}

		args, err := ec.field_Mutation_setPatchVisibility_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetPatchVisibility(childComplexity, args["patchIds"].([]string), args["hidden"].(bool)), true
	case "Mutation.setTaskPriorities":
		if e.complexity.Mutation.SetTaskPriorities == nil {
			break
		}

		args, err := ec.field_Mutation_setTaskPriorities_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTaskPriorities(childComplexity, args["taskPriorities"].([]*TaskPriority)), true
	case "Mutation.setTaskPriority":
		if e.complexity.Mutation.SetTaskPriority == nil {
			break
		}

		args, err := ec.field_Mutation_setTaskPriority_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTaskPriority(childComplexity, args["taskId"].(string), args["priority"].(int)), true
	case "Mutation.setVersionPriority":
		if e.complexity.Mutation.SetVersionPriority == nil {
			break
		}

		args, err := ec.field_Mutation_setVersionPriority_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetVersionPriority(childComplexity, args["versionId"].(string), args["priority"].(int)), true
	case "Mutation.spawnHost":
		if e.complexity.Mutation.SpawnHost == nil {
			break
		}

		args, err := ec.field_Mutation_spawnHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SpawnHost(childComplexity, args["spawnHostInput"].(*SpawnHostInput)), true
	case "Mutation.spawnVolume":
		if e.complexity.Mutation.SpawnVolume == nil {
			break
		}

		args, err := ec.field_Mutation_spawnVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SpawnVolume(childComplexity, args["spawnVolumeInput"].(SpawnVolumeInput)), true
	case "Mutation.unscheduleTask":
		if e.complexity.Mutation.UnscheduleTask == nil {
			break
		}

		args, err := ec.field_Mutation_unscheduleTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnscheduleTask(childComplexity, args["taskId"].(string)), true
	case "Mutation.unscheduleVersionTasks":
		if e.complexity.Mutation.UnscheduleVersionTasks == nil {
			break
		}

		args, err := ec.field_Mutation_unscheduleVersionTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnscheduleVersionTasks(childComplexity, args["versionId"].(string), args["abort"].(bool)), true
	case "Mutation.updateBetaFeatures":
		if e.complexity.Mutation.UpdateBetaFeatures == nil {
			break
		}

		args, err := ec.field_Mutation_updateBetaFeatures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBetaFeatures(childComplexity, args["opts"].(UpdateBetaFeaturesInput)), true
	case "Mutation.updateHostStatus":
		if e.complexity.Mutation.UpdateHostStatus == nil {
			break
		}

		args, err := ec.field_Mutation_updateHostStatus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateHostStatus(childComplexity, args["hostIds"].([]string), args["status"].(string), args["notes"].(*string)), true
	case "Mutation.updateParsleySettings":
		if e.complexity.Mutation.UpdateParsleySettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateParsleySettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateParsleySettings(childComplexity, args["opts"].(UpdateParsleySettingsInput)), true
	case "Mutation.updatePublicKey":
		if e.complexity.Mutation.UpdatePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_updatePublicKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePublicKey(childComplexity, args["targetKeyName"].(string), args["updateInfo"].(PublicKeyInput)), true
	case "Mutation.updateSpawnHostStatus":
		if e.complexity.Mutation.UpdateSpawnHostStatus == nil {
			break
		}

		args, err := ec.field_Mutation_updateSpawnHostStatus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSpawnHostStatus(childComplexity, args["updateSpawnHostStatusInput"].(UpdateSpawnHostStatusInput)), true
	case "Mutation.updateUserSettings":
		if e.complexity.Mutation.UpdateUserSettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserSettings(childComplexity, args["userSettings"].(*model.APIUserSettings)), true
	case "Mutation.updateVolume":
		if e.complexity.Mutation.UpdateVolume == nil {
			break
		}

		args, err := ec.field_Mutation_updateVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVolume(childComplexity, args["updateVolumeInput"].(UpdateVolumeInput)), true

	case "NaiveAuthConfig.users":
		if e.complexity.NaiveAuthConfig.Users == nil {
			break
		}

		return e.complexity.NaiveAuthConfig.Users(childComplexity), true

	case "NewDistroPayload.newDistroId":
		if e.complexity.NewDistroPayload.NewDistroID == nil {
			break
		}

		return e.complexity.NewDistroPayload.NewDistroID(childComplexity), true

	case "Note.message":
		if e.complexity.Note.Message == nil {
			break
		}

		return e.complexity.Note.Message(childComplexity), true
	case "Note.source":
		if e.complexity.Note.Source == nil {
			break
		}

		return e.complexity.Note.Source(childComplexity), true

	case "Notifications.buildBreak":
		if e.complexity.Notifications.BuildBreak == nil {
			break
		}

		return e.complexity.Notifications.BuildBreak(childComplexity), true
	case "Notifications.buildBreakId":
		if e.complexity.Notifications.BuildBreakID == nil {
			break
		}

		return e.complexity.Notifications.BuildBreakID(childComplexity), true
	case "Notifications.patchFinish":
		if e.complexity.Notifications.PatchFinish == nil {
			break
		}

		return e.complexity.Notifications.PatchFinish(childComplexity), true
	case "Notifications.patchFinishId":
		if e.complexity.Notifications.PatchFinishID == nil {
			break
		}

		return e.complexity.Notifications.PatchFinishID(childComplexity), true
	case "Notifications.patchFirstFailure":
		if e.complexity.Notifications.PatchFirstFailure == nil {
			break
		}

		return e.complexity.Notifications.PatchFirstFailure(childComplexity), true
	case "Notifications.patchFirstFailureId":
		if e.complexity.Notifications.PatchFirstFailureID == nil {
			break
		}

		return e.complexity.Notifications.PatchFirstFailureID(childComplexity), true
	case "Notifications.spawnHostExpiration":
		if e.complexity.Notifications.SpawnHostExpiration == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostExpiration(childComplexity), true
	case "Notifications.spawnHostExpirationId":
		if e.complexity.Notifications.SpawnHostExpirationID == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostExpirationID(childComplexity), true
	case "Notifications.spawnHostOutcome":
		if e.complexity.Notifications.SpawnHostOutcome == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostOutcome(childComplexity), true
	case "Notifications.spawnHostOutcomeId":
		if e.complexity.Notifications.SpawnHostOutcomeID == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostOutcomeID(childComplexity), true

	case "NotifyConfig.bufferIntervalSeconds":
		if e.complexity.NotifyConfig.BufferIntervalSeconds == nil {
			break
		}

		return e.complexity.NotifyConfig.BufferIntervalSeconds(childComplexity), true
	case "NotifyConfig.bufferTargetPerInterval":
		if e.complexity.NotifyConfig.BufferTargetPerInterval == nil {
			break
		}

		return e.complexity.NotifyConfig.BufferTargetPerInterval(childComplexity), true
	case "NotifyConfig.ses":
		if e.complexity.NotifyConfig.SES == nil {
			break
		}

		return e.complexity.NotifyConfig.SES(childComplexity), true

	case "OAuthConfig.clientId":
		if e.complexity.OAuthConfig.ClientID == nil {
			break
		}

		return e.complexity.OAuthConfig.ClientID(childComplexity), true
	case "OAuthConfig.connectorId":
		if e.complexity.OAuthConfig.ConnectorID == nil {
			break
		}

		return e.complexity.OAuthConfig.ConnectorID(childComplexity), true
	case "OAuthConfig.issuer":
		if e.complexity.OAuthConfig.Issuer == nil {
			break
		}

		return e.complexity.OAuthConfig.Issuer(childComplexity), true

	case "OSInfo.name":
		if e.complexity.OSInfo.Name == nil {
			break
		}

		return e.complexity.OSInfo.Name(childComplexity), true
	case "OSInfo.version":
		if e.complexity.OSInfo.Version == nil {
			break
		}

		return e.complexity.OSInfo.Version(childComplexity), true

	case "OktaConfig.clientId":
		if e.complexity.OktaConfig.ClientID == nil {
			break
		}

		return e.complexity.OktaConfig.ClientID(childComplexity), true
	case "OktaConfig.clientSecret":
		if e.complexity.OktaConfig.ClientSecret == nil {
			break
		}

		return e.complexity.OktaConfig.ClientSecret(childComplexity), true
	case "OktaConfig.expireAfterMinutes":
		if e.complexity.OktaConfig.ExpireAfterMinutes == nil {
			break
		}

		return e.complexity.OktaConfig.ExpireAfterMinutes(childComplexity), true
	case "OktaConfig.issuer":
		if e.complexity.OktaConfig.Issuer == nil {
			break
		}

		return e.complexity.OktaConfig.Issuer(childComplexity), true
	case "OktaConfig.scopes":
		if e.complexity.OktaConfig.Scopes == nil {
			break
		}

		return e.complexity.OktaConfig.Scopes(childComplexity), true
	case "OktaConfig.userGroup":
		if e.complexity.OktaConfig.UserGroup == nil {
			break
		}

		return e.complexity.OktaConfig.UserGroup(childComplexity), true

	case "OomTrackerInfo.detected":
		if e.complexity.OomTrackerInfo.Detected == nil {
			break
		}

		return e.complexity.OomTrackerInfo.Detected(childComplexity), true
	case "OomTrackerInfo.pids":
		if e.complexity.OomTrackerInfo.Pids == nil {
			break
		}

		return e.complexity.OomTrackerInfo.Pids(childComplexity), true

	case "OwnerRepo.owner":
		if e.complexity.OwnerRepo.Owner == nil {
			break
		}

		return e.complexity.OwnerRepo.Owner(childComplexity), true
	case "OwnerRepo.repo":
		if e.complexity.OwnerRepo.Repo == nil {
			break
		}

		return e.complexity.OwnerRepo.Repo(childComplexity), true

	case "Package.manager":
		if e.complexity.Package.Manager == nil {
			break
		}

		return e.complexity.Package.Manager(childComplexity), true
	case "Package.name":
		if e.complexity.Package.Name == nil {
			break
		}

		return e.complexity.Package.Name(childComplexity), true
	case "Package.version":
		if e.complexity.Package.Version == nil {
			break
		}

		return e.complexity.Package.Version(childComplexity), true

	case "Parameter.key":
		if e.complexity.Parameter.Key == nil {
			break
		}

		return e.complexity.Parameter.Key(childComplexity), true
	case "Parameter.value":
		if e.complexity.Parameter.Value == nil {
			break
		}

		return e.complexity.Parameter.Value(childComplexity), true

	case "ParameterStoreConfig.prefix":
		if e.complexity.ParameterStoreConfig.Prefix == nil {
			break
		}

		return e.complexity.ParameterStoreConfig.Prefix(childComplexity), true

	case "ParserProjectS3Config.bucket":
		if e.complexity.ParserProjectS3Config.Bucket == nil {
			break
		}

		return e.complexity.ParserProjectS3Config.Bucket(childComplexity), true
	case "ParserProjectS3Config.generatedJSONPrefix":
		if e.complexity.ParserProjectS3Config.GeneratedJSONPrefix == nil {
			break
		}

		return e.complexity.ParserProjectS3Config.GeneratedJSONPrefix(childComplexity), true
	case "ParserProjectS3Config.key":
		if e.complexity.ParserProjectS3Config.Key == nil {
			break
		}

		return e.complexity.ParserProjectS3Config.Key(childComplexity), true
	case "ParserProjectS3Config.prefix":
		if e.complexity.ParserProjectS3Config.Prefix == nil {
			break
		}

		return e.complexity.ParserProjectS3Config.Prefix(childComplexity), true
	case "ParserProjectS3Config.secret":
		if e.complexity.ParserProjectS3Config.Secret == nil {
			break
		}

		return e.complexity.ParserProjectS3Config.Secret(childComplexity), true

	case "ParsleyFilter.caseSensitive":
		if e.complexity.ParsleyFilter.CaseSensitive == nil {
			break
		}

		return e.complexity.ParsleyFilter.CaseSensitive(childComplexity), true
	case "ParsleyFilter.description":
		if e.complexity.ParsleyFilter.Description == nil {
			break
		}

		return e.complexity.ParsleyFilter.Description(childComplexity), true
	case "ParsleyFilter.exactMatch":
		if e.complexity.ParsleyFilter.ExactMatch == nil {
			break
		}

		return e.complexity.ParsleyFilter.ExactMatch(childComplexity), true
	case "ParsleyFilter.expression":
		if e.complexity.ParsleyFilter.Expression == nil {
			break
		}

		return e.complexity.ParsleyFilter.Expression(childComplexity), true

	case "ParsleySettings.jumpToFailingLineEnabled":
		if e.complexity.ParsleySettings.JumpToFailingLineEnabled == nil {
			break
		}

		return e.complexity.ParsleySettings.JumpToFailingLineEnabled(childComplexity), true
	case "ParsleySettings.sectionsEnabled":
		if e.complexity.ParsleySettings.SectionsEnabled == nil {
			break
		}

		return e.complexity.ParsleySettings.SectionsEnabled(childComplexity), true

	case "Patch.activated":
		if e.complexity.Patch.Activated == nil {
			break
		}

		return e.complexity.Patch.Activated(childComplexity), true
	case "Patch.alias":
		if e.complexity.Patch.Alias == nil {
			break
		}

		return e.complexity.Patch.Alias(childComplexity), true
	case "Patch.author":
		if e.complexity.Patch.Author == nil {
			break
		}

		return e.complexity.Patch.Author(childComplexity), true
	case "Patch.authorDisplayName":
		if e.complexity.Patch.AuthorDisplayName == nil {
			break
		}

		return e.complexity.Patch.AuthorDisplayName(childComplexity), true
	case "Patch.baseTaskStatuses":
		if e.complexity.Patch.BaseTaskStatuses == nil {
			break
		}

		return e.complexity.Patch.BaseTaskStatuses(childComplexity), true
	case "Patch.builds":
		if e.complexity.Patch.Builds == nil {
			break
		}

		return e.complexity.Patch.Builds(childComplexity), true
	case "Patch.childPatchAliases":
		if e.complexity.Patch.ChildPatchAliases == nil {
			break
		}

		return e.complexity.Patch.ChildPatchAliases(childComplexity), true
	case "Patch.childPatches":
		if e.complexity.Patch.ChildPatches == nil {
			break
		}

		return e.complexity.Patch.ChildPatches(childComplexity), true
	case "Patch.createTime":
		if e.complexity.Patch.CreateTime == nil {
			break
		}

		return e.complexity.Patch.CreateTime(childComplexity), true
	case "Patch.description":
		if e.complexity.Patch.Description == nil {
			break
		}

		return e.complexity.Patch.Description(childComplexity), true
	case "Patch.duration":
		if e.complexity.Patch.Duration == nil {
			break
		}

		return e.complexity.Patch.Duration(childComplexity), true
	case "Patch.generatedTaskCounts":
		if e.complexity.Patch.GeneratedTaskCounts == nil {
			break
		}

		return e.complexity.Patch.GeneratedTaskCounts(childComplexity), true
	case "Patch.githash":
		if e.complexity.Patch.Githash == nil {
			break
		}

		return e.complexity.Patch.Githash(childComplexity), true
	case "Patch.githubPatchData":
		if e.complexity.Patch.GithubPatchData == nil {
			break
		}

		return e.complexity.Patch.GithubPatchData(childComplexity), true
	case "Patch.hidden":
		if e.complexity.Patch.Hidden == nil {
			break
		}

		return e.complexity.Patch.Hidden(childComplexity), true
	case "Patch.id":
		if e.complexity.Patch.Id == nil {
			break
		}

		return e.complexity.Patch.Id(childComplexity), true
	case "Patch.includedLocalModules":
		if e.complexity.Patch.IncludedLocalModules == nil {
			break
		}

		return e.complexity.Patch.IncludedLocalModules(childComplexity), true
	case "Patch.moduleCodeChanges":
		if e.complexity.Patch.ModuleCodeChanges == nil {
			break
		}

		return e.complexity.Patch.ModuleCodeChanges(childComplexity), true
	case "Patch.parameters":
		if e.complexity.Patch.Parameters == nil {
			break
		}

		return e.complexity.Patch.Parameters(childComplexity), true
	case "Patch.patchNumber":
		if e.complexity.Patch.PatchNumber == nil {
			break
		}

		return e.complexity.Patch.PatchNumber(childComplexity), true
	case "Patch.patchTriggerAliases":
		if e.complexity.Patch.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.Patch.PatchTriggerAliases(childComplexity), true
	case "Patch.project":
		if e.complexity.Patch.Project == nil {
			break
		}

		return e.complexity.Patch.Project(childComplexity), true
	case "Patch.projectID":
		if e.complexity.Patch.ProjectId == nil {
			break
		}

		return e.complexity.Patch.ProjectId(childComplexity), true
	case "Patch.projectIdentifier":
		if e.complexity.Patch.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Patch.ProjectIdentifier(childComplexity), true
	case "Patch.projectMetadata":
		if e.complexity.Patch.ProjectMetadata == nil {
			break
		}

		return e.complexity.Patch.ProjectMetadata(childComplexity), true
	case "Patch.status":
		if e.complexity.Patch.Status == nil {
			break
		}

		return e.complexity.Patch.Status(childComplexity), true
	case "Patch.taskCount":
		if e.complexity.Patch.TaskCount == nil {
			break
		}

		return e.complexity.Patch.TaskCount(childComplexity), true
	case "Patch.taskStatuses":
		if e.complexity.Patch.TaskStatuses == nil {
			break
		}

		return e.complexity.Patch.TaskStatuses(childComplexity), true
	case "Patch.tasks":
		if e.complexity.Patch.Tasks == nil {
			break
		}

		return e.complexity.Patch.Tasks(childComplexity), true
	case "Patch.time":
		if e.complexity.Patch.Time == nil {
			break
		}

		return e.complexity.Patch.Time(childComplexity), true
	case "Patch.user":
		if e.complexity.Patch.User == nil {
			break
		}

		return e.complexity.Patch.User(childComplexity), true
	case "Patch.variants":
		if e.complexity.Patch.Variants == nil {
			break
		}

		return e.complexity.Patch.Variants(childComplexity), true
	case "Patch.variantsTasks":
		if e.complexity.Patch.VariantsTasks == nil {
			break
		}

		return e.complexity.Patch.VariantsTasks(childComplexity), true
	case "Patch.versionFull":
		if e.complexity.Patch.VersionFull == nil {
			break
		}

		return e.complexity.Patch.VersionFull(childComplexity), true

	case "PatchDuration.makespan":
		if e.complexity.PatchDuration.Makespan == nil {
			break
		}

		return e.complexity.PatchDuration.Makespan(childComplexity), true
	case "PatchDuration.time":
		if e.complexity.PatchDuration.Time == nil {
			break
		}

		return e.complexity.PatchDuration.Time(childComplexity), true
	case "PatchDuration.timeTaken":
		if e.complexity.PatchDuration.TimeTaken == nil {
			break
		}

		return e.complexity.PatchDuration.TimeTaken(childComplexity), true

	case "PatchProject.variants":
		if e.complexity.PatchProject.Variants == nil {
			break
		}

		return e.complexity.PatchProject.Variants(childComplexity), true

	case "PatchTime.finished":
		if e.complexity.PatchTime.Finished == nil {
			break
		}

		return e.complexity.PatchTime.Finished(childComplexity), true
	case "PatchTime.started":
		if e.complexity.PatchTime.Started == nil {
			break
		}

		return e.complexity.PatchTime.Started(childComplexity), true
	case "PatchTime.submittedAt":
		if e.complexity.PatchTime.SubmittedAt == nil {
			break
		}

		return e.complexity.PatchTime.SubmittedAt(childComplexity), true

	case "PatchTriggerAlias.alias":
		if e.complexity.PatchTriggerAlias.Alias == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.Alias(childComplexity), true
	case "PatchTriggerAlias.childProjectId":
		if e.complexity.PatchTriggerAlias.ChildProjectId == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ChildProjectId(childComplexity), true
	case "PatchTriggerAlias.childProjectIdentifier":
		if e.complexity.PatchTriggerAlias.ChildProjectIdentifier == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ChildProjectIdentifier(childComplexity), true
	case "PatchTriggerAlias.downstreamRevision":
		if e.complexity.PatchTriggerAlias.DownstreamRevision == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.DownstreamRevision(childComplexity), true
	case "PatchTriggerAlias.parentAsModule":
		if e.complexity.PatchTriggerAlias.ParentAsModule == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ParentAsModule(childComplexity), true
	case "PatchTriggerAlias.status":
		if e.complexity.PatchTriggerAlias.Status == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.Status(childComplexity), true
	case "PatchTriggerAlias.taskSpecifiers":
		if e.complexity.PatchTriggerAlias.TaskSpecifiers == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.TaskSpecifiers(childComplexity), true
	case "PatchTriggerAlias.variantsTasks":
		if e.complexity.PatchTriggerAlias.VariantsTasks == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.VariantsTasks(childComplexity), true

	case "Patches.filteredPatchCount":
		if e.complexity.Patches.FilteredPatchCount == nil {
			break
		}

		return e.complexity.Patches.FilteredPatchCount(childComplexity), true
	case "Patches.patches":
		if e.complexity.Patches.Patches == nil {
			break
		}

		return e.complexity.Patches.Patches(childComplexity), true

	case "PeriodicBuild.alias":
		if e.complexity.PeriodicBuild.Alias == nil {
			break
		}

		return e.complexity.PeriodicBuild.Alias(childComplexity), true
	case "PeriodicBuild.configFile":
		if e.complexity.PeriodicBuild.ConfigFile == nil {
			break
		}

		return e.complexity.PeriodicBuild.ConfigFile(childComplexity), true
	case "PeriodicBuild.cron":
		if e.complexity.PeriodicBuild.Cron == nil {
			break
		}

		return e.complexity.PeriodicBuild.Cron(childComplexity), true
	case "PeriodicBuild.id":
		if e.complexity.PeriodicBuild.ID == nil {
			break
		}

		return e.complexity.PeriodicBuild.ID(childComplexity), true
	case "PeriodicBuild.intervalHours":
		if e.complexity.PeriodicBuild.IntervalHours == nil {
			break
		}

		return e.complexity.PeriodicBuild.IntervalHours(childComplexity), true
	case "PeriodicBuild.message":
		if e.complexity.PeriodicBuild.Message == nil {
			break
		}

		return e.complexity.PeriodicBuild.Message(childComplexity), true
	case "PeriodicBuild.nextRunTime":
		if e.complexity.PeriodicBuild.NextRunTime == nil {
			break
		}

		return e.complexity.PeriodicBuild.NextRunTime(childComplexity), true

	case "Permissions.canCreateDistro":
		if e.complexity.Permissions.CanCreateDistro == nil {
			break
		}

		return e.complexity.Permissions.CanCreateDistro(childComplexity), true
	case "Permissions.canCreateProject":
		if e.complexity.Permissions.CanCreateProject == nil {
			break
		}

		return e.complexity.Permissions.CanCreateProject(childComplexity), true
	case "Permissions.canEditAdminSettings":
		if e.complexity.Permissions.CanEditAdminSettings == nil {
			break
		}

		return e.complexity.Permissions.CanEditAdminSettings(childComplexity), true
	case "Permissions.distroPermissions":
		if e.complexity.Permissions.DistroPermissions == nil {
			break
		}

		args, err := ec.field_Permissions_distroPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Permissions.DistroPermissions(childComplexity, args["options"].(DistroPermissionsOptions)), true
	case "Permissions.projectPermissions":
		if e.complexity.Permissions.ProjectPermissions == nil {
			break
		}

		args, err := ec.field_Permissions_projectPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Permissions.ProjectPermissions(childComplexity, args["options"].(ProjectPermissionsOptions)), true
	case "Permissions.repoPermissions":
		if e.complexity.Permissions.RepoPermissions == nil {
			break
		}

		args, err := ec.field_Permissions_repoPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Permissions.RepoPermissions(childComplexity, args["options"].(RepoPermissionsOptions)), true
	case "Permissions.userId":
		if e.complexity.Permissions.UserID == nil {
			break
		}

		return e.complexity.Permissions.UserID(childComplexity), true

	case "PersistentDNSConfig.domain":
		if e.complexity.PersistentDNSConfig.Domain == nil {
			break
		}

		return e.complexity.PersistentDNSConfig.Domain(childComplexity), true
	case "PersistentDNSConfig.hostedZoneID":
		if e.complexity.PersistentDNSConfig.HostedZoneID == nil {
			break
		}

		return e.complexity.PersistentDNSConfig.HostedZoneID(childComplexity), true

	case "PlannerSettings.commitQueueFactor":
		if e.complexity.PlannerSettings.CommitQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.CommitQueueFactor(childComplexity), true
	case "PlannerSettings.expectedRuntimeFactor":
		if e.complexity.PlannerSettings.ExpectedRuntimeFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.ExpectedRuntimeFactor(childComplexity), true
	case "PlannerSettings.generateTaskFactor":
		if e.complexity.PlannerSettings.GenerateTaskFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.GenerateTaskFactor(childComplexity), true
	case "PlannerSettings.groupVersions":
		if e.complexity.PlannerSettings.GroupVersions == nil {
			break
		}

		return e.complexity.PlannerSettings.GroupVersions(childComplexity), true
	case "PlannerSettings.mainlineTimeInQueueFactor":
		if e.complexity.PlannerSettings.MainlineTimeInQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.MainlineTimeInQueueFactor(childComplexity), true
	case "PlannerSettings.numDependentsFactor":
		if e.complexity.PlannerSettings.NumDependentsFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.NumDependentsFactor(childComplexity), true
	case "PlannerSettings.patchFactor":
		if e.complexity.PlannerSettings.PatchFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.PatchFactor(childComplexity), true
	case "PlannerSettings.patchTimeInQueueFactor":
		if e.complexity.PlannerSettings.PatchTimeInQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.PatchTimeInQueueFactor(childComplexity), true
	case "PlannerSettings.targetTime":
		if e.complexity.PlannerSettings.TargetTime == nil {
			break
		}

		return e.complexity.PlannerSettings.TargetTime(childComplexity), true
	case "PlannerSettings.version":
		if e.complexity.PlannerSettings.Version == nil {
			break
		}

		return e.complexity.PlannerSettings.Version(childComplexity), true

	case "Pod.events":
		if e.complexity.Pod.Events == nil {
			break
		}

		args, err := ec.field_Pod_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Pod.Events(childComplexity, args["limit"].(*int), args["page"].(*int)), true
	case "Pod.id":
		if e.complexity.Pod.ID == nil {
			break
		}

		return e.complexity.Pod.ID(childComplexity), true
	case "Pod.status":
		if e.complexity.Pod.Status == nil {
			break
		}

		return e.complexity.Pod.Status(childComplexity), true
	case "Pod.task":
		if e.complexity.Pod.Task == nil {
			break
		}

		return e.complexity.Pod.Task(childComplexity), true
	case "Pod.taskContainerCreationOpts":
		if e.complexity.Pod.TaskContainerCreationOpts == nil {
			break
		}

		return e.complexity.Pod.TaskContainerCreationOpts(childComplexity), true
	case "Pod.type":
		if e.complexity.Pod.Type == nil {
			break
		}

		return e.complexity.Pod.Type(childComplexity), true

	case "PodEventLogData.newStatus":
		if e.complexity.PodEventLogData.NewStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.NewStatus(childComplexity), true
	case "PodEventLogData.oldStatus":
		if e.complexity.PodEventLogData.OldStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.OldStatus(childComplexity), true
	case "PodEventLogData.reason":
		if e.complexity.PodEventLogData.Reason == nil {
			break
		}

		return e.complexity.PodEventLogData.Reason(childComplexity), true
	case "PodEventLogData.task":
		if e.complexity.PodEventLogData.Task == nil {
			break
		}

		return e.complexity.PodEventLogData.Task(childComplexity), true
	case "PodEventLogData.taskExecution":
		if e.complexity.PodEventLogData.TaskExecution == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskExecution(childComplexity), true
	case "PodEventLogData.taskID":
		if e.complexity.PodEventLogData.TaskID == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskID(childComplexity), true
	case "PodEventLogData.taskStatus":
		if e.complexity.PodEventLogData.TaskStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskStatus(childComplexity), true

	case "PodEventLogEntry.data":
		if e.complexity.PodEventLogEntry.Data == nil {
			break
		}

		return e.complexity.PodEventLogEntry.Data(childComplexity), true
	case "PodEventLogEntry.eventType":
		if e.complexity.PodEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.PodEventLogEntry.EventType(childComplexity), true
	case "PodEventLogEntry.id":
		if e.complexity.PodEventLogEntry.ID == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ID(childComplexity), true
	case "PodEventLogEntry.processedAt":
		if e.complexity.PodEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ProcessedAt(childComplexity), true
	case "PodEventLogEntry.resourceId":
		if e.complexity.PodEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ResourceId(childComplexity), true
	case "PodEventLogEntry.resourceType":
		if e.complexity.PodEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ResourceType(childComplexity), true
	case "PodEventLogEntry.timestamp":
		if e.complexity.PodEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.PodEventLogEntry.Timestamp(childComplexity), true

	case "PodEvents.count":
		if e.complexity.PodEvents.Count == nil {
			break
		}

		return e.complexity.PodEvents.Count(childComplexity), true
	case "PodEvents.eventLogEntries":
		if e.complexity.PodEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.PodEvents.EventLogEntries(childComplexity), true

	case "PodLifecycleConfig.maxParallelPodRequests":
		if e.complexity.PodLifecycleConfig.MaxParallelPodRequests == nil {
			break
		}

		return e.complexity.PodLifecycleConfig.MaxParallelPodRequests(childComplexity), true
	case "PodLifecycleConfig.maxPodDefinitionCleanupRate":
		if e.complexity.PodLifecycleConfig.MaxPodDefinitionCleanupRate == nil {
			break
		}

		return e.complexity.PodLifecycleConfig.MaxPodDefinitionCleanupRate(childComplexity), true
	case "PodLifecycleConfig.maxSecretCleanupRate":
		if e.complexity.PodLifecycleConfig.MaxSecretCleanupRate == nil {
			break
		}

		return e.complexity.PodLifecycleConfig.MaxSecretCleanupRate(childComplexity), true

	case "PreconditionScript.path":
		if e.complexity.PreconditionScript.Path == nil {
			break
		}

		return e.complexity.PreconditionScript.Path(childComplexity), true
	case "PreconditionScript.script":
		if e.complexity.PreconditionScript.Script == nil {
			break
		}

		return e.complexity.PreconditionScript.Script(childComplexity), true

	case "Project.admins":
		if e.complexity.Project.Admins == nil {
			break
		}

		return e.complexity.Project.Admins(childComplexity), true
	case "Project.banner":
		if e.complexity.Project.Banner == nil {
			break
		}

		return e.complexity.Project.Banner(childComplexity), true
	case "Project.batchTime":
		if e.complexity.Project.BatchTime == nil {
			break
		}

		return e.complexity.Project.BatchTime(childComplexity), true
	case "Project.branch":
		if e.complexity.Project.Branch == nil {
			break
		}

		return e.complexity.Project.Branch(childComplexity), true
	case "Project.buildBaronSettings":
		if e.complexity.Project.BuildBaronSettings == nil {
			break
		}

		return e.complexity.Project.BuildBaronSettings(childComplexity), true
	case "Project.commitQueue":
		if e.complexity.Project.CommitQueue == nil {
			break
		}

		return e.complexity.Project.CommitQueue(childComplexity), true
	case "Project.containerSizeDefinitions":
		if e.complexity.Project.ContainerSizeDefinitions == nil {
			break
		}

		return e.complexity.Project.ContainerSizeDefinitions(childComplexity), true
	case "Project.deactivatePrevious":
		if e.complexity.Project.DeactivatePrevious == nil {
			break
		}

		return e.complexity.Project.DeactivatePrevious(childComplexity), true
	case "Project.debugSpawnHostsDisabled":
		if e.complexity.Project.DebugSpawnHostsDisabled == nil {
			break
		}

		return e.complexity.Project.DebugSpawnHostsDisabled(childComplexity), true
	case "Project.disabledStatsCache":
		if e.complexity.Project.DisabledStatsCache == nil {
			break
		}

		return e.complexity.Project.DisabledStatsCache(childComplexity), true
	case "Project.dispatchingDisabled":
		if e.complexity.Project.DispatchingDisabled == nil {
			break
		}

		return e.complexity.Project.DispatchingDisabled(childComplexity), true
	case "Project.displayName":
		if e.complexity.Project.DisplayName == nil {
			break
		}

		return e.complexity.Project.DisplayName(childComplexity), true
	case "Project.enabled":
		if e.complexity.Project.Enabled == nil {
			break
		}

		return e.complexity.Project.Enabled(childComplexity), true
	case "Project.externalLinks":
		if e.complexity.Project.ExternalLinks == nil {
			break
		}

		return e.complexity.Project.ExternalLinks(childComplexity), true
	case "Project.githubDynamicTokenPermissionGroups":
		if e.complexity.Project.GitHubDynamicTokenPermissionGroups == nil {
			break
		}

		return e.complexity.Project.GitHubDynamicTokenPermissionGroups(childComplexity), true
	case "Project.githubPermissionGroupByRequester":
		if e.complexity.Project.GitHubPermissionGroupByRequester == nil {
			break
		}

		return e.complexity.Project.GitHubPermissionGroupByRequester(childComplexity), true
	case "Project.gitTagAuthorizedTeams":
		if e.complexity.Project.GitTagAuthorizedTeams == nil {
			break
		}

		return e.complexity.Project.GitTagAuthorizedTeams(childComplexity), true
	case "Project.gitTagAuthorizedUsers":
		if e.complexity.Project.GitTagAuthorizedUsers == nil {
			break
		}

		return e.complexity.Project.GitTagAuthorizedUsers(childComplexity), true
	case "Project.gitTagVersionsEnabled":
		if e.complexity.Project.GitTagVersionsEnabled == nil {
			break
		}

		return e.complexity.Project.GitTagVersionsEnabled(childComplexity), true
	case "Project.githubChecksEnabled":
		if e.complexity.Project.GithubChecksEnabled == nil {
			break
		}

		return e.complexity.Project.GithubChecksEnabled(childComplexity), true
	case "Project.githubMQTriggerAliases":
		if e.complexity.Project.GithubMQTriggerAliases == nil {
			break
		}

		return e.complexity.Project.GithubMQTriggerAliases(childComplexity), true
	case "Project.githubPRTriggerAliases":
		if e.complexity.Project.GithubPRTriggerAliases == nil {
			break
		}

		return e.complexity.Project.GithubPRTriggerAliases(childComplexity), true
	case "Project.hidden":
		if e.complexity.Project.Hidden == nil {
			break
		}

		return e.complexity.Project.Hidden(childComplexity), true
	case "Project.id":
		if e.complexity.Project.Id == nil {
			break
		}

		return e.complexity.Project.Id(childComplexity), true
	case "Project.identifier":
		if e.complexity.Project.Identifier == nil {
			break
		}

		return e.complexity.Project.Identifier(childComplexity), true
	case "Project.isFavorite":
		if e.complexity.Project.IsFavorite == nil {
			break
		}

		return e.complexity.Project.IsFavorite(childComplexity), true
	case "Project.manualPrTestingEnabled":
		if e.complexity.Project.ManualPRTestingEnabled == nil {
			break
		}

		return e.complexity.Project.ManualPRTestingEnabled(childComplexity), true
	case "Project.notifyOnBuildFailure":
		if e.complexity.Project.NotifyOnBuildFailure == nil {
			break
		}

		return e.complexity.Project.NotifyOnBuildFailure(childComplexity), true
	case "Project.oldestAllowedMergeBase":
		if e.complexity.Project.OldestAllowedMergeBase == nil {
			break
		}

		return e.complexity.Project.OldestAllowedMergeBase(childComplexity), true
	case "Project.owner":
		if e.complexity.Project.Owner == nil {
			break
		}

		return e.complexity.Project.Owner(childComplexity), true
	case "Project.prTestingEnabled":
		if e.complexity.Project.PRTestingEnabled == nil {
			break
		}

		return e.complexity.Project.PRTestingEnabled(childComplexity), true
	case "Project.parsleyFilters":
		if e.complexity.Project.ParsleyFilters == nil {
			break
		}

		return e.complexity.Project.ParsleyFilters(childComplexity), true
	case "Project.patchTriggerAliases":
		if e.complexity.Project.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.Project.PatchTriggerAliases(childComplexity), true
	case "Project.patches":
		if e.complexity.Project.Patches == nil {
			break
		}

		args, err := ec.field_Project_patches_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.Patches(childComplexity, args["patchesInput"].(PatchesInput)), true
	case "Project.patchingDisabled":
		if e.complexity.Project.PatchingDisabled == nil {
			break
		}

		return e.complexity.Project.PatchingDisabled(childComplexity), true
	case "Project.perfEnabled":
		if e.complexity.Project.PerfEnabled == nil {
			break
		}

		return e.complexity.Project.PerfEnabled(childComplexity), true
	case "Project.periodicBuilds":
		if e.complexity.Project.PeriodicBuilds == nil {
			break
		}

		return e.complexity.Project.PeriodicBuilds(childComplexity), true
	case "Project.projectHealthView":
		if e.complexity.Project.ProjectHealthView == nil {
			break
		}

		return e.complexity.Project.ProjectHealthView(childComplexity), true
	case "Project.remotePath":
		if e.complexity.Project.RemotePath == nil {
			break
		}

		return e.complexity.Project.RemotePath(childComplexity), true
	case "Project.repo":
		if e.complexity.Project.Repo == nil {
			break
		}

		return e.complexity.Project.Repo(childComplexity), true
	case "Project.repoRefId":
		if e.complexity.Project.RepoRefId == nil {
			break
		}

		return e.complexity.Project.RepoRefId(childComplexity), true
	case "Project.repotrackerDisabled":
		if e.complexity.Project.RepotrackerDisabled == nil {
			break
		}

		return e.complexity.Project.RepotrackerDisabled(childComplexity), true
	case "Project.repotrackerError":
		if e.complexity.Project.RepotrackerError == nil {
			break
		}

		return e.complexity.Project.RepotrackerError(childComplexity), true
	case "Project.restricted":
		if e.complexity.Project.Restricted == nil {
			break
		}

		return e.complexity.Project.Restricted(childComplexity), true
	case "Project.spawnHostScriptPath":
		if e.complexity.Project.SpawnHostScriptPath == nil {
			break
		}

		return e.complexity.Project.SpawnHostScriptPath(childComplexity), true
	case "Project.stepbackBisect":
		if e.complexity.Project.StepbackBisect == nil {
			break
		}

		return e.complexity.Project.StepbackBisect(childComplexity), true
	case "Project.stepbackDisabled":
		if e.complexity.Project.StepbackDisabled == nil {
			break
		}

		return e.complexity.Project.StepbackDisabled(childComplexity), true
	case "Project.taskAnnotationSettings":
		if e.complexity.Project.TaskAnnotationSettings == nil {
			break
		}

		return e.complexity.Project.TaskAnnotationSettings(childComplexity), true
	case "Project.testSelection":
		if e.complexity.Project.TestSelection == nil {
			break
		}

		return e.complexity.Project.TestSelection(childComplexity), true
	case "Project.tracksPushEvents":
		if e.complexity.Project.TracksPushEvents == nil {
			break
		}

		return e.complexity.Project.TracksPushEvents(childComplexity), true
	case "Project.triggers":
		if e.complexity.Project.Triggers == nil {
			break
		}

		return e.complexity.Project.Triggers(childComplexity), true
	case "Project.versionControlEnabled":
		if e.complexity.Project.VersionControlEnabled == nil {
			break
		}

		return e.complexity.Project.VersionControlEnabled(childComplexity), true
	case "Project.workstationConfig":
		if e.complexity.Project.WorkstationConfig == nil {
			break
		}

		return e.complexity.Project.WorkstationConfig(childComplexity), true

	case "ProjectAlias.alias":
		if e.complexity.ProjectAlias.Alias == nil {
			break
		}

		return e.complexity.ProjectAlias.Alias(childComplexity), true
	case "ProjectAlias.description":
		if e.complexity.ProjectAlias.Description == nil {
			break
		}

		return e.complexity.ProjectAlias.Description(childComplexity), true
	case "ProjectAlias.gitTag":
		if e.complexity.ProjectAlias.GitTag == nil {
			break
		}

		return e.complexity.ProjectAlias.GitTag(childComplexity), true
	case "ProjectAlias.id":
		if e.complexity.ProjectAlias.ID == nil {
			break
		}

		return e.complexity.ProjectAlias.ID(childComplexity), true
	case "ProjectAlias.parameters":
		if e.complexity.ProjectAlias.Parameters == nil {
			break
		}

		return e.complexity.ProjectAlias.Parameters(childComplexity), true
	case "ProjectAlias.remotePath":
		if e.complexity.ProjectAlias.RemotePath == nil {
			break
		}

		return e.complexity.ProjectAlias.RemotePath(childComplexity), true
	case "ProjectAlias.task":
		if e.complexity.ProjectAlias.Task == nil {
			break
		}

		return e.complexity.ProjectAlias.Task(childComplexity), true
	case "ProjectAlias.taskTags":
		if e.complexity.ProjectAlias.TaskTags == nil {
			break
		}

		return e.complexity.ProjectAlias.TaskTags(childComplexity), true
	case "ProjectAlias.variant":
		if e.complexity.ProjectAlias.Variant == nil {
			break
		}

		return e.complexity.ProjectAlias.Variant(childComplexity), true
	case "ProjectAlias.variantTags":
		if e.complexity.ProjectAlias.VariantTags == nil {
			break
		}

		return e.complexity.ProjectAlias.VariantTags(childComplexity), true

	case "ProjectBanner.text":
		if e.complexity.ProjectBanner.Text == nil {
			break
		}

		return e.complexity.ProjectBanner.Text(childComplexity), true
	case "ProjectBanner.theme":
		if e.complexity.ProjectBanner.Theme == nil {
			break
		}

		return e.complexity.ProjectBanner.Theme(childComplexity), true

	case "ProjectBuildVariant.displayName":
		if e.complexity.ProjectBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.DisplayName(childComplexity), true
	case "ProjectBuildVariant.name":
		if e.complexity.ProjectBuildVariant.Name == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.Name(childComplexity), true
	case "ProjectBuildVariant.tasks":
		if e.complexity.ProjectBuildVariant.Tasks == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.Tasks(childComplexity), true

	case "ProjectCreationConfig.jiraProject":
		if e.complexity.ProjectCreationConfig.JiraProject == nil {
			break
		}

		return e.complexity.ProjectCreationConfig.JiraProject(childComplexity), true
	case "ProjectCreationConfig.repoExceptions":
		if e.complexity.ProjectCreationConfig.RepoExceptions == nil {
			break
		}

		return e.complexity.ProjectCreationConfig.RepoExceptions(childComplexity), true
	case "ProjectCreationConfig.repoProjectLimit":
		if e.complexity.ProjectCreationConfig.RepoProjectLimit == nil {
			break
		}

		return e.complexity.ProjectCreationConfig.RepoProjectLimit(childComplexity), true
	case "ProjectCreationConfig.totalProjectLimit":
		if e.complexity.ProjectCreationConfig.TotalProjectLimit == nil {
			break
		}

		return e.complexity.ProjectCreationConfig.TotalProjectLimit(childComplexity), true

	case "ProjectEventLogEntry.after":
		if e.complexity.ProjectEventLogEntry.After == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.After(childComplexity), true
	case "ProjectEventLogEntry.before":
		if e.complexity.ProjectEventLogEntry.Before == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.Before(childComplexity), true
	case "ProjectEventLogEntry.timestamp":
		if e.complexity.ProjectEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.Timestamp(childComplexity), true
	case "ProjectEventLogEntry.user":
		if e.complexity.ProjectEventLogEntry.User == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.User(childComplexity), true

	case "ProjectEventSettings.aliases":
		if e.complexity.ProjectEventSettings.Aliases == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Aliases(childComplexity), true
	case "ProjectEventSettings.githubAppAuth":
		if e.complexity.ProjectEventSettings.GithubAppAuth == nil {
			break
		}

		return e.complexity.ProjectEventSettings.GithubAppAuth(childComplexity), true
	case "ProjectEventSettings.githubWebhooksEnabled":
		if e.complexity.ProjectEventSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.ProjectEventSettings.GithubWebhooksEnabled(childComplexity), true
	case "ProjectEventSettings.projectRef":
		if e.complexity.ProjectEventSettings.ProjectRef == nil {
			break
		}

		return e.complexity.ProjectEventSettings.ProjectRef(childComplexity), true
	case "ProjectEventSettings.subscriptions":
		if e.complexity.ProjectEventSettings.Subscriptions == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Subscriptions(childComplexity), true
	case "ProjectEventSettings.vars":
		if e.complexity.ProjectEventSettings.Vars == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Vars(childComplexity), true

	case "ProjectEvents.count":
		if e.complexity.ProjectEvents.Count == nil {
			break
		}

		return e.complexity.ProjectEvents.Count(childComplexity), true
	case "ProjectEvents.eventLogEntries":
		if e.complexity.ProjectEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.ProjectEvents.EventLogEntries(childComplexity), true

	case "ProjectPermissions.edit":
		if e.complexity.ProjectPermissions.Edit == nil {
			break
		}

		return e.complexity.ProjectPermissions.Edit(childComplexity), true
	case "ProjectPermissions.view":
		if e.complexity.ProjectPermissions.View == nil {
			break
		}

		return e.complexity.ProjectPermissions.View(childComplexity), true

	case "ProjectSettings.aliases":
		if e.complexity.ProjectSettings.Aliases == nil {
			break
		}

		return e.complexity.ProjectSettings.Aliases(childComplexity), true
	case "ProjectSettings.githubAppAuth":
		if e.complexity.ProjectSettings.GithubAppAuth == nil {
			break
		}

		return e.complexity.ProjectSettings.GithubAppAuth(childComplexity), true
	case "ProjectSettings.githubWebhooksEnabled":
		if e.complexity.ProjectSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.ProjectSettings.GithubWebhooksEnabled(childComplexity), true
	case "ProjectSettings.projectRef":
		if e.complexity.ProjectSettings.ProjectRef == nil {
			break
		}

		return e.complexity.ProjectSettings.ProjectRef(childComplexity), true
	case "ProjectSettings.subscriptions":
		if e.complexity.ProjectSettings.Subscriptions == nil {
			break
		}

		return e.complexity.ProjectSettings.Subscriptions(childComplexity), true
	case "ProjectSettings.vars":
		if e.complexity.ProjectSettings.Vars == nil {
			break
		}

		return e.complexity.ProjectSettings.Vars(childComplexity), true

	case "ProjectTasksPair.allowedBVs":
		if e.complexity.ProjectTasksPair.AllowedBVs == nil {
			break
		}

		return e.complexity.ProjectTasksPair.AllowedBVs(childComplexity), true
	case "ProjectTasksPair.allowedTasks":
		if e.complexity.ProjectTasksPair.AllowedTasks == nil {
			break
		}

		return e.complexity.ProjectTasksPair.AllowedTasks(childComplexity), true
	case "ProjectTasksPair.projectId":
		if e.complexity.ProjectTasksPair.ProjectID == nil {
			break
		}

		return e.complexity.ProjectTasksPair.ProjectID(childComplexity), true

	case "ProjectVars.adminOnlyVars":
		if e.complexity.ProjectVars.AdminOnlyVars == nil {
			break
		}

		return e.complexity.ProjectVars.AdminOnlyVars(childComplexity), true
	case "ProjectVars.privateVars":
		if e.complexity.ProjectVars.PrivateVars == nil {
			break
		}

		return e.complexity.ProjectVars.PrivateVars(childComplexity), true
	case "ProjectVars.vars":
		if e.complexity.ProjectVars.Vars == nil {
			break
		}

		return e.complexity.ProjectVars.Vars(childComplexity), true

	case "PublicKey.key":
		if e.complexity.PublicKey.Key == nil {
			break
		}

		return e.complexity.PublicKey.Key(childComplexity), true
	case "PublicKey.name":
		if e.complexity.PublicKey.Name == nil {
			break
		}

		return e.complexity.PublicKey.Name(childComplexity), true

	case "QuarantineTestPayload.success":
		if e.complexity.QuarantineTestPayload.Success == nil {
			break
		}

		return e.complexity.QuarantineTestPayload.Success(childComplexity), true

	case "Query.awsRegions":
		if e.complexity.Query.AWSRegions == nil {
			break
		}

		return e.complexity.Query.AWSRegions(childComplexity), true
	case "Query.adminEvents":
		if e.complexity.Query.AdminEvents == nil {
			break
		}

		args, err := ec.field_Query_adminEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdminEvents(childComplexity, args["opts"].(AdminEventsInput)), true
	case "Query.adminSettings":
		if e.complexity.Query.AdminSettings == nil {
			break
		}

		return e.complexity.Query.AdminSettings(childComplexity), true
	case "Query.adminTasksToRestart":
		if e.complexity.Query.AdminTasksToRestart == nil {
			break
		}

		args, err := ec.field_Query_adminTasksToRestart_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdminTasksToRestart(childComplexity, args["opts"].(model1.RestartOptions)), true
	case "Query.bbGetCreatedTickets":
		if e.complexity.Query.BbGetCreatedTickets == nil {
			break
		}

		args, err := ec.field_Query_bbGetCreatedTickets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BbGetCreatedTickets(childComplexity, args["taskId"].(string)), true
	case "Query.buildBaron":
		if e.complexity.Query.BuildBaron == nil {
			break
		}

		args, err := ec.field_Query_buildBaron_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildBaron(childComplexity, args["taskId"].(string), args["execution"].(int)), true
	case "Query.buildVariantsForTaskName":
		if e.complexity.Query.BuildVariantsForTaskName == nil {
			break
		}

		args, err := ec.field_Query_buildVariantsForTaskName_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildVariantsForTaskName(childComplexity, args["projectIdentifier"].(string), args["taskName"].(string)), true
	case "Query.clientConfig":
		if e.complexity.Query.ClientConfig == nil {
			break
		}

		return e.complexity.Query.ClientConfig(childComplexity), true
	case "Query.distro":
		if e.complexity.Query.Distro == nil {
			break
		}

		args, err := ec.field_Query_distro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Distro(childComplexity, args["distroId"].(string)), true
	case "Query.distroEvents":
		if e.complexity.Query.DistroEvents == nil {
			break
		}

		args, err := ec.field_Query_distroEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DistroEvents(childComplexity, args["opts"].(DistroEventsInput)), true
	case "Query.distroTaskQueue":
		if e.complexity.Query.DistroTaskQueue == nil {
			break
		}

		args, err := ec.field_Query_distroTaskQueue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DistroTaskQueue(childComplexity, args["distroId"].(string)), true
	case "Query.distros":
		if e.complexity.Query.Distros == nil {
			break
		}

		args, err := ec.field_Query_distros_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Distros(childComplexity, args["onlySpawnable"].(bool)), true
	case "Query.githubProjectConflicts":
		if e.complexity.Query.GithubProjectConflicts == nil {
			break
		}

		args, err := ec.field_Query_githubProjectConflicts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubProjectConflicts(childComplexity, args["projectId"].(string)), true
	case "Query.hasVersion":
		if e.complexity.Query.HasVersion == nil {
			break
		}

		args, err := ec.field_Query_hasVersion_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasVersion(childComplexity, args["patchId"].(string)), true
	case "Query.host":
		if e.complexity.Query.Host == nil {
			break
		}

		args, err := ec.field_Query_host_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Host(childComplexity, args["hostId"].(string)), true
	case "Query.hostEvents":
		if e.complexity.Query.HostEvents == nil {
			break
		}

		args, err := ec.field_Query_hostEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HostEvents(childComplexity, args["hostId"].(string), args["hostTag"].(*string), args["limit"].(*int), args["page"].(*int)), true
	case "Query.hosts":
		if e.complexity.Query.Hosts == nil {
			break
		}

		args, err := ec.field_Query_hosts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hosts(childComplexity, args["hostId"].(*string), args["distroId"].(*string), args["currentTaskId"].(*string), args["statuses"].([]string), args["startedBy"].(*string), args["sortBy"].(*HostSortBy), args["sortDir"].(*SortDirection), args["page"].(*int), args["limit"].(*int)), true
	case "Query.image":
		if e.complexity.Query.Image == nil {
			break
		}

		args, err := ec.field_Query_image_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Image(childComplexity, args["imageId"].(string)), true
	case "Query.images":
		if e.complexity.Query.Images == nil {
			break
		}

		return e.complexity.Query.Images(childComplexity), true
	case "Query.instanceTypes":
		if e.complexity.Query.InstanceTypes == nil {
			break
		}

		return e.complexity.Query.InstanceTypes(childComplexity), true
	case "Query.isRepo":
		if e.complexity.Query.IsRepo == nil {
			break
		}

		args, err := ec.field_Query_isRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsRepo(childComplexity, args["projectOrRepoId"].(string)), true
	case "Query.logkeeperBuildMetadata":
		if e.complexity.Query.LogkeeperBuildMetadata == nil {
			break
		}

		args, err := ec.field_Query_logkeeperBuildMetadata_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LogkeeperBuildMetadata(childComplexity, args["buildId"].(string)), true
	case "Query.mainlineCommits":
		if e.complexity.Query.MainlineCommits == nil {
			break
		}

		args, err := ec.field_Query_mainlineCommits_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MainlineCommits(childComplexity, args["options"].(MainlineCommitsOptions), args["buildVariantOptions"].(*BuildVariantOptions)), true
	case "Query.myHosts":
		if e.complexity.Query.MyHosts == nil {
			break
		}

		return e.complexity.Query.MyHosts(childComplexity), true
	case "Query.myPublicKeys":
		if e.complexity.Query.MyPublicKeys == nil {
			break
		}

		return e.complexity.Query.MyPublicKeys(childComplexity), true
	case "Query.myVolumes":
		if e.complexity.Query.MyVolumes == nil {
			break
		}

		return e.complexity.Query.MyVolumes(childComplexity), true
	case "Query.patch":
		if e.complexity.Query.Patch == nil {
			break
		}

		args, err := ec.field_Query_patch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Patch(childComplexity, args["patchId"].(string)), true
	case "Query.pod":
		if e.complexity.Query.Pod == nil {
			break
		}

		args, err := ec.field_Query_pod_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Pod(childComplexity, args["podId"].(string)), true
	case "Query.project":
		if e.complexity.Query.Project == nil {
			break
		}

		args, err := ec.field_Query_project_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Project(childComplexity, args["projectIdentifier"].(string)), true
	case "Query.projectEvents":
		if e.complexity.Query.ProjectEvents == nil {
			break
		}

		args, err := ec.field_Query_projectEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectEvents(childComplexity, args["projectIdentifier"].(string), args["limit"].(*int), args["before"].(*time.Time)), true
	case "Query.projectSettings":
		if e.complexity.Query.ProjectSettings == nil {
			break
		}

		args, err := ec.field_Query_projectSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectSettings(childComplexity, args["projectIdentifier"].(string)), true
	case "Query.projects":
		if e.complexity.Query.Projects == nil {
			break
		}

		return e.complexity.Query.Projects(childComplexity), true
	case "Query.repoEvents":
		if e.complexity.Query.RepoEvents == nil {
			break
		}

		args, err := ec.field_Query_repoEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RepoEvents(childComplexity, args["repoId"].(string), args["limit"].(*int), args["before"].(*time.Time)), true
	case "Query.repoSettings":
		if e.complexity.Query.RepoSettings == nil {
			break
		}

		args, err := ec.field_Query_repoSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RepoSettings(childComplexity, args["repoId"].(string)), true
	case "Query.spruceConfig":
		if e.complexity.Query.SpruceConfig == nil {
			break
		}

		return e.complexity.Query.SpruceConfig(childComplexity), true
	case "Query.subnetAvailabilityZones":
		if e.complexity.Query.SubnetAvailabilityZones == nil {
			break
		}

		return e.complexity.Query.SubnetAvailabilityZones(childComplexity), true
	case "Query.task":
		if e.complexity.Query.Task == nil {
			break
		}

		args, err := ec.field_Query_task_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Task(childComplexity, args["taskId"].(string), args["execution"].(*int)), true
	case "Query.taskAllExecutions":
		if e.complexity.Query.TaskAllExecutions == nil {
			break
		}

		args, err := ec.field_Query_taskAllExecutions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskAllExecutions(childComplexity, args["taskId"].(string)), true
	case "Query.taskHistory":
		if e.complexity.Query.TaskHistory == nil {
			break
		}

		args, err := ec.field_Query_taskHistory_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskHistory(childComplexity, args["options"].(TaskHistoryOpts)), true
	case "Query.taskNamesForBuildVariant":
		if e.complexity.Query.TaskNamesForBuildVariant == nil {
			break
		}

		args, err := ec.field_Query_taskNamesForBuildVariant_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskNamesForBuildVariant(childComplexity, args["projectIdentifier"].(string), args["buildVariant"].(string)), true
	case "Query.taskQueueDistros":
		if e.complexity.Query.TaskQueueDistros == nil {
			break
		}

		return e.complexity.Query.TaskQueueDistros(childComplexity), true
	case "Query.taskTestSample":
		if e.complexity.Query.TaskTestSample == nil {
			break
		}

		args, err := ec.field_Query_taskTestSample_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskTestSample(childComplexity, args["versionId"].(string), args["taskIds"].([]string), args["filters"].([]*TestFilter)), true
	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["userId"].(*string)), true
	case "Query.userConfig":
		if e.complexity.Query.UserConfig == nil {
			break
		}

		return e.complexity.Query.UserConfig(childComplexity), true
	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		args, err := ec.field_Query_version_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Version(childComplexity, args["versionId"].(string)), true
	case "Query.viewableProjectRefs":
		if e.complexity.Query.ViewableProjectRefs == nil {
			break
		}

		return e.complexity.Query.ViewableProjectRefs(childComplexity), true
	case "Query.waterfall":
		if e.complexity.Query.Waterfall == nil {
			break
		}

		args, err := ec.field_Query_waterfall_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Waterfall(childComplexity, args["options"].(WaterfallOptions)), true

	case "ReleaseModeConfig.distroMaxHostsFactor":
		if e.complexity.ReleaseModeConfig.DistroMaxHostsFactor == nil {
			break
		}

		return e.complexity.ReleaseModeConfig.DistroMaxHostsFactor(childComplexity), true
	case "ReleaseModeConfig.idleTimeSecondsOverride":
		if e.complexity.ReleaseModeConfig.IdleTimeSecondsOverride == nil {
			break
		}

		return e.complexity.ReleaseModeConfig.IdleTimeSecondsOverride(childComplexity), true
	case "ReleaseModeConfig.targetTimeSecondsOverride":
		if e.complexity.ReleaseModeConfig.TargetTimeSecondsOverride == nil {
			break
		}

		return e.complexity.ReleaseModeConfig.TargetTimeSecondsOverride(childComplexity), true

	case "RepoCommitQueueParams.enabled":
		if e.complexity.RepoCommitQueueParams.Enabled == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.Enabled(childComplexity), true
	case "RepoCommitQueueParams.mergeMethod":
		if e.complexity.RepoCommitQueueParams.MergeMethod == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.MergeMethod(childComplexity), true
	case "RepoCommitQueueParams.message":
		if e.complexity.RepoCommitQueueParams.Message == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.Message(childComplexity), true

	case "RepoPermissions.edit":
		if e.complexity.RepoPermissions.Edit == nil {
			break
		}

		return e.complexity.RepoPermissions.Edit(childComplexity), true
	case "RepoPermissions.view":
		if e.complexity.RepoPermissions.View == nil {
			break
		}

		return e.complexity.RepoPermissions.View(childComplexity), true

	case "RepoRef.admins":
		if e.complexity.RepoRef.Admins == nil {
			break
		}

		return e.complexity.RepoRef.Admins(childComplexity), true
	case "RepoRef.batchTime":
		if e.complexity.RepoRef.BatchTime == nil {
			break
		}

		return e.complexity.RepoRef.BatchTime(childComplexity), true
	case "RepoRef.buildBaronSettings":
		if e.complexity.RepoRef.BuildBaronSettings == nil {
			break
		}

		return e.complexity.RepoRef.BuildBaronSettings(childComplexity), true
	case "RepoRef.commitQueue":
		if e.complexity.RepoRef.CommitQueue == nil {
			break
		}

		return e.complexity.RepoRef.CommitQueue(childComplexity), true
	case "RepoRef.containerSizeDefinitions":
		if e.complexity.RepoRef.ContainerSizeDefinitions == nil {
			break
		}

		return e.complexity.RepoRef.ContainerSizeDefinitions(childComplexity), true
	case "RepoRef.deactivatePrevious":
		if e.complexity.RepoRef.DeactivatePrevious == nil {
			break
		}

		return e.complexity.RepoRef.DeactivatePrevious(childComplexity), true
	case "RepoRef.debugSpawnHostsDisabled":
		if e.complexity.RepoRef.DebugSpawnHostsDisabled == nil {
			break
		}

		return e.complexity.RepoRef.DebugSpawnHostsDisabled(childComplexity), true
	case "RepoRef.disabledStatsCache":
		if e.complexity.RepoRef.DisabledStatsCache == nil {
			break
		}

		return e.complexity.RepoRef.DisabledStatsCache(childComplexity), true
	case "RepoRef.dispatchingDisabled":
		if e.complexity.RepoRef.DispatchingDisabled == nil {
			break
		}

		return e.complexity.RepoRef.DispatchingDisabled(childComplexity), true
	case "RepoRef.displayName":
		if e.complexity.RepoRef.DisplayName == nil {
			break
		}

		return e.complexity.RepoRef.DisplayName(childComplexity), true
	case "RepoRef.enabled":
		if e.complexity.RepoRef.Enabled == nil {
			break
		}

		return e.complexity.RepoRef.Enabled(childComplexity), true
	case "RepoRef.externalLinks":
		if e.complexity.RepoRef.ExternalLinks == nil {
			break
		}

		return e.complexity.RepoRef.ExternalLinks(childComplexity), true
	case "RepoRef.githubDynamicTokenPermissionGroups":
		if e.complexity.RepoRef.GitHubDynamicTokenPermissionGroups == nil {
			break
		}

		return e.complexity.RepoRef.GitHubDynamicTokenPermissionGroups(childComplexity), true
	case "RepoRef.githubPermissionGroupByRequester":
		if e.complexity.RepoRef.GitHubPermissionGroupByRequester == nil {
			break
		}

		return e.complexity.RepoRef.GitHubPermissionGroupByRequester(childComplexity), true
	case "RepoRef.gitTagAuthorizedTeams":
		if e.complexity.RepoRef.GitTagAuthorizedTeams == nil {
			break
		}

		return e.complexity.RepoRef.GitTagAuthorizedTeams(childComplexity), true
	case "RepoRef.gitTagAuthorizedUsers":
		if e.complexity.RepoRef.GitTagAuthorizedUsers == nil {
			break
		}

		return e.complexity.RepoRef.GitTagAuthorizedUsers(childComplexity), true
	case "RepoRef.gitTagVersionsEnabled":
		if e.complexity.RepoRef.GitTagVersionsEnabled == nil {
			break
		}

		return e.complexity.RepoRef.GitTagVersionsEnabled(childComplexity), true
	case "RepoRef.githubChecksEnabled":
		if e.complexity.RepoRef.GithubChecksEnabled == nil {
			break
		}

		return e.complexity.RepoRef.GithubChecksEnabled(childComplexity), true
	case "RepoRef.githubMQTriggerAliases":
		if e.complexity.RepoRef.GithubMQTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.GithubMQTriggerAliases(childComplexity), true
	case "RepoRef.githubPRTriggerAliases":
		if e.complexity.RepoRef.GithubPRTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.GithubPRTriggerAliases(childComplexity), true
	case "RepoRef.id":
		if e.complexity.RepoRef.Id == nil {
			break
		}

		return e.complexity.RepoRef.Id(childComplexity), true
	case "RepoRef.manualPrTestingEnabled":
		if e.complexity.RepoRef.ManualPRTestingEnabled == nil {
			break
		}

		return e.complexity.RepoRef.ManualPRTestingEnabled(childComplexity), true
	case "RepoRef.notifyOnBuildFailure":
		if e.complexity.RepoRef.NotifyOnBuildFailure == nil {
			break
		}

		return e.complexity.RepoRef.NotifyOnBuildFailure(childComplexity), true
	case "RepoRef.oldestAllowedMergeBase":
		if e.complexity.RepoRef.OldestAllowedMergeBase == nil {
			break
		}

		return e.complexity.RepoRef.OldestAllowedMergeBase(childComplexity), true
	case "RepoRef.owner":
		if e.complexity.RepoRef.Owner == nil {
			break
		}

		return e.complexity.RepoRef.Owner(childComplexity), true
	case "RepoRef.prTestingEnabled":
		if e.complexity.RepoRef.PRTestingEnabled == nil {
			break
		}

		return e.complexity.RepoRef.PRTestingEnabled(childComplexity), true
	case "RepoRef.parsleyFilters":
		if e.complexity.RepoRef.ParsleyFilters == nil {
			break
		}

		return e.complexity.RepoRef.ParsleyFilters(childComplexity), true
	case "RepoRef.patchTriggerAliases":
		if e.complexity.RepoRef.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.PatchTriggerAliases(childComplexity), true
	case "RepoRef.patchingDisabled":
		if e.complexity.RepoRef.PatchingDisabled == nil {
			break
		}

		return e.complexity.RepoRef.PatchingDisabled(childComplexity), true
	case "RepoRef.perfEnabled":
		if e.complexity.RepoRef.PerfEnabled == nil {
			break
		}

		return e.complexity.RepoRef.PerfEnabled(childComplexity), true
	case "RepoRef.periodicBuilds":
		if e.complexity.RepoRef.PeriodicBuilds == nil {
			break
		}

		return e.complexity.RepoRef.PeriodicBuilds(childComplexity), true
	case "RepoRef.remotePath":
		if e.complexity.RepoRef.RemotePath == nil {
			break
		}

		return e.complexity.RepoRef.RemotePath(childComplexity), true
	case "RepoRef.repo":
		if e.complexity.RepoRef.Repo == nil {
			break
		}

		return e.complexity.RepoRef.Repo(childComplexity), true
	case "RepoRef.repotrackerDisabled":
		if e.complexity.RepoRef.RepotrackerDisabled == nil {
			break
		}

		return e.complexity.RepoRef.RepotrackerDisabled(childComplexity), true
	case "RepoRef.restricted":
		if e.complexity.RepoRef.Restricted == nil {
			break
		}

		return e.complexity.RepoRef.Restricted(childComplexity), true
	case "RepoRef.spawnHostScriptPath":
		if e.complexity.RepoRef.SpawnHostScriptPath == nil {
			break
		}

		return e.complexity.RepoRef.SpawnHostScriptPath(childComplexity), true
	case "RepoRef.stepbackBisect":
		if e.complexity.RepoRef.StepbackBisect == nil {
			break
		}

		return e.complexity.RepoRef.StepbackBisect(childComplexity), true
	case "RepoRef.stepbackDisabled":
		if e.complexity.RepoRef.StepbackDisabled == nil {
			break
		}

		return e.complexity.RepoRef.StepbackDisabled(childComplexity), true
	case "RepoRef.taskAnnotationSettings":
		if e.complexity.RepoRef.TaskAnnotationSettings == nil {
			break
		}

		return e.complexity.RepoRef.TaskAnnotationSettings(childComplexity), true
	case "RepoRef.testSelection":
		if e.complexity.RepoRef.TestSelection == nil {
			break
		}

		return e.complexity.RepoRef.TestSelection(childComplexity), true
	case "RepoRef.tracksPushEvents":
		if e.complexity.RepoRef.TracksPushEvents == nil {
			break
		}

		return e.complexity.RepoRef.TracksPushEvents(childComplexity), true
	case "RepoRef.triggers":
		if e.complexity.RepoRef.Triggers == nil {
			break
		}

		return e.complexity.RepoRef.Triggers(childComplexity), true
	case "RepoRef.versionControlEnabled":
		if e.complexity.RepoRef.VersionControlEnabled == nil {
			break
		}

		return e.complexity.RepoRef.VersionControlEnabled(childComplexity), true
	case "RepoRef.workstationConfig":
		if e.complexity.RepoRef.WorkstationConfig == nil {
			break
		}

		return e.complexity.RepoRef.WorkstationConfig(childComplexity), true

	case "RepoSettings.aliases":
		if e.complexity.RepoSettings.Aliases == nil {
			break
		}

		return e.complexity.RepoSettings.Aliases(childComplexity), true
	case "RepoSettings.githubAppAuth":
		if e.complexity.RepoSettings.GithubAppAuth == nil {
			break
		}

		return e.complexity.RepoSettings.GithubAppAuth(childComplexity), true
	case "RepoSettings.githubWebhooksEnabled":
		if e.complexity.RepoSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.RepoSettings.GithubWebhooksEnabled(childComplexity), true
	case "RepoSettings.projectRef":
		if e.complexity.RepoSettings.ProjectRef == nil {
			break
		}

		return e.complexity.RepoSettings.ProjectRef(childComplexity), true
	case "RepoSettings.subscriptions":
		if e.complexity.RepoSettings.Subscriptions == nil {
			break
		}

		return e.complexity.RepoSettings.Subscriptions(childComplexity), true
	case "RepoSettings.vars":
		if e.complexity.RepoSettings.Vars == nil {
			break
		}

		return e.complexity.RepoSettings.Vars(childComplexity), true

	case "RepoTestSelectionSettings.allowed":
		if e.complexity.RepoTestSelectionSettings.Allowed == nil {
			break
		}

		return e.complexity.RepoTestSelectionSettings.Allowed(childComplexity), true
	case "RepoTestSelectionSettings.defaultEnabled":
		if e.complexity.RepoTestSelectionSettings.DefaultEnabled == nil {
			break
		}

		return e.complexity.RepoTestSelectionSettings.DefaultEnabled(childComplexity), true

	case "RepoWorkstationConfig.gitClone":
		if e.complexity.RepoWorkstationConfig.GitClone == nil {
			break
		}

		return e.complexity.RepoWorkstationConfig.GitClone(childComplexity), true
	case "RepoWorkstationConfig.setupCommands":
		if e.complexity.RepoWorkstationConfig.SetupCommands == nil {
			break
		}

		return e.complexity.RepoWorkstationConfig.SetupCommands(childComplexity), true

	case "RepotrackerConfig.maxConcurrentRequests":
		if e.complexity.RepotrackerConfig.MaxConcurrentRequests == nil {
			break
		}

		return e.complexity.RepotrackerConfig.MaxConcurrentRequests(childComplexity), true
	case "RepotrackerConfig.maxRepoRevisionsToSearch":
		if e.complexity.RepotrackerConfig.MaxRepoRevisionsToSearch == nil {
			break
		}

		return e.complexity.RepotrackerConfig.MaxRepoRevisionsToSearch(childComplexity), true
	case "RepotrackerConfig.numNewRepoRevisionsToFetch":
		if e.complexity.RepotrackerConfig.NumNewRepoRevisionsToFetch == nil {
			break
		}

		return e.complexity.RepotrackerConfig.NumNewRepoRevisionsToFetch(childComplexity), true

	case "RepotrackerError.exists":
		if e.complexity.RepotrackerError.Exists == nil {
			break
		}

		return e.complexity.RepotrackerError.Exists(childComplexity), true
	case "RepotrackerError.invalidRevision":
		if e.complexity.RepotrackerError.InvalidRevision == nil {
			break
		}

		return e.complexity.RepotrackerError.InvalidRevision(childComplexity), true
	case "RepotrackerError.mergeBaseRevision":
		if e.complexity.RepotrackerError.MergeBaseRevision == nil {
			break
		}

		return e.complexity.RepotrackerError.MergeBaseRevision(childComplexity), true

	case "ResourceLimits.lockedMemoryKb":
		if e.complexity.ResourceLimits.LockedMemoryKB == nil {
			break
		}

		return e.complexity.ResourceLimits.LockedMemoryKB(childComplexity), true
	case "ResourceLimits.numFiles":
		if e.complexity.ResourceLimits.NumFiles == nil {
			break
		}

		return e.complexity.ResourceLimits.NumFiles(childComplexity), true
	case "ResourceLimits.numProcesses":
		if e.complexity.ResourceLimits.NumProcesses == nil {
			break
		}

		return e.complexity.ResourceLimits.NumProcesses(childComplexity), true
	case "ResourceLimits.numTasks":
		if e.complexity.ResourceLimits.NumTasks == nil {
			break
		}

		return e.complexity.ResourceLimits.NumTasks(childComplexity), true
	case "ResourceLimits.virtualMemoryKb":
		if e.complexity.ResourceLimits.VirtualMemoryKB == nil {
			break
		}

		return e.complexity.ResourceLimits.VirtualMemoryKB(childComplexity), true

	case "RestartAdminTasksPayload.numRestartedTasks":
		if e.complexity.RestartAdminTasksPayload.NumRestartedTasks == nil {
			break
		}

		return e.complexity.RestartAdminTasksPayload.NumRestartedTasks(childComplexity), true

	case "RuntimeEnvironmentConfig.apiKey":
		if e.complexity.RuntimeEnvironmentConfig.APIKey == nil {
			break
		}

		return e.complexity.RuntimeEnvironmentConfig.APIKey(childComplexity), true
	case "RuntimeEnvironmentConfig.baseUrl":
		if e.complexity.RuntimeEnvironmentConfig.BaseURL == nil {
			break
		}

		return e.complexity.RuntimeEnvironmentConfig.BaseURL(childComplexity), true

	case "S3Credentials.bucket":
		if e.complexity.S3Credentials.Bucket == nil {
			break
		}

		return e.complexity.S3Credentials.Bucket(childComplexity), true
	case "S3Credentials.key":
		if e.complexity.S3Credentials.Key == nil {
			break
		}

		return e.complexity.S3Credentials.Key(childComplexity), true
	case "S3Credentials.secret":
		if e.complexity.S3Credentials.Secret == nil {
			break
		}

		return e.complexity.S3Credentials.Secret(childComplexity), true

	case "SESConfig.senderAddress":
		if e.complexity.SESConfig.SenderAddress == nil {
			break
		}

		return e.complexity.SESConfig.SenderAddress(childComplexity), true

	case "SSHConfig.spawnHostKey":
		if e.complexity.SSHConfig.SpawnHostKey == nil {
			break
		}

		return e.complexity.SSHConfig.SpawnHostKey(childComplexity), true
	case "SSHConfig.taskHostKey":
		if e.complexity.SSHConfig.TaskHostKey == nil {
			break
		}

		return e.complexity.SSHConfig.TaskHostKey(childComplexity), true

	case "SSHKeyPair.name":
		if e.complexity.SSHKeyPair.Name == nil {
			break
		}

		return e.complexity.SSHKeyPair.Name(childComplexity), true
	case "SSHKeyPair.secretARN":
		if e.complexity.SSHKeyPair.SecretARN == nil {
			break
		}

		return e.complexity.SSHKeyPair.SecretARN(childComplexity), true

	case "SaveDistroPayload.distro":
		if e.complexity.SaveDistroPayload.Distro == nil {
			break
		}

		return e.complexity.SaveDistroPayload.Distro(childComplexity), true
	case "SaveDistroPayload.hostCount":
		if e.complexity.SaveDistroPayload.HostCount == nil {
			break
		}

		return e.complexity.SaveDistroPayload.HostCount(childComplexity), true

	case "SchedulerConfig.acceptableHostIdleTimeSeconds":
		if e.complexity.SchedulerConfig.AcceptableHostIdleTimeSeconds == nil {
			break
		}

		return e.complexity.SchedulerConfig.AcceptableHostIdleTimeSeconds(childComplexity), true
	case "SchedulerConfig.cacheDurationSeconds":
		if e.complexity.SchedulerConfig.CacheDurationSeconds == nil {
			break
		}

		return e.complexity.SchedulerConfig.CacheDurationSeconds(childComplexity), true
	case "SchedulerConfig.commitQueueFactor":
		if e.complexity.SchedulerConfig.CommitQueueFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.CommitQueueFactor(childComplexity), true
	case "SchedulerConfig.expectedRuntimeFactor":
		if e.complexity.SchedulerConfig.ExpectedRuntimeFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.ExpectedRuntimeFactor(childComplexity), true
	case "SchedulerConfig.futureHostFraction":
		if e.complexity.SchedulerConfig.FutureHostFraction == nil {
			break
		}

		return e.complexity.SchedulerConfig.FutureHostFraction(childComplexity), true
	case "SchedulerConfig.generateTaskFactor":
		if e.complexity.SchedulerConfig.GenerateTaskFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.GenerateTaskFactor(childComplexity), true
	case "SchedulerConfig.groupVersions":
		if e.complexity.SchedulerConfig.GroupVersions == nil {
			break
		}

		return e.complexity.SchedulerConfig.GroupVersions(childComplexity), true
	case "SchedulerConfig.hostAllocator":
		if e.complexity.SchedulerConfig.HostAllocator == nil {
			break
		}

		return e.complexity.SchedulerConfig.HostAllocator(childComplexity), true
	case "SchedulerConfig.hostAllocatorFeedbackRule":
		if e.complexity.SchedulerConfig.HostAllocatorFeedbackRule == nil {
			break
		}

		return e.complexity.SchedulerConfig.HostAllocatorFeedbackRule(childComplexity), true
	case "SchedulerConfig.hostAllocatorRoundingRule":
		if e.complexity.SchedulerConfig.HostAllocatorRoundingRule == nil {
			break
		}

		return e.complexity.SchedulerConfig.HostAllocatorRoundingRule(childComplexity), true
	case "SchedulerConfig.hostsOverallocatedRule":
		if e.complexity.SchedulerConfig.HostsOverallocatedRule == nil {
			break
		}

		return e.complexity.SchedulerConfig.HostsOverallocatedRule(childComplexity), true
	case "SchedulerConfig.mainlineTimeInQueueFactor":
		if e.complexity.SchedulerConfig.MainlineTimeInQueueFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.MainlineTimeInQueueFactor(childComplexity), true
	case "SchedulerConfig.numDependentsFactor":
		if e.complexity.SchedulerConfig.NumDependentsFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.NumDependentsFactor(childComplexity), true
	case "SchedulerConfig.patchFactor":
		if e.complexity.SchedulerConfig.PatchFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.PatchFactor(childComplexity), true
	case "SchedulerConfig.patchTimeInQueueFactor":
		if e.complexity.SchedulerConfig.PatchTimeInQueueFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.PatchTimeInQueueFactor(childComplexity), true
	case "SchedulerConfig.stepbackTaskFactor":
		if e.complexity.SchedulerConfig.StepbackTaskFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.StepbackTaskFactor(childComplexity), true
	case "SchedulerConfig.targetTimeSeconds":
		if e.complexity.SchedulerConfig.TargetTimeSeconds == nil {
			break
		}

		return e.complexity.SchedulerConfig.TargetTimeSeconds(childComplexity), true
	case "SchedulerConfig.taskFinder":
		if e.complexity.SchedulerConfig.TaskFinder == nil {
			break
		}

		return e.complexity.SchedulerConfig.TaskFinder(childComplexity), true

	case "SearchReturnInfo.featuresURL":
		if e.complexity.SearchReturnInfo.FeaturesURL == nil {
			break
		}

		return e.complexity.SearchReturnInfo.FeaturesURL(childComplexity), true
	case "SearchReturnInfo.issues":
		if e.complexity.SearchReturnInfo.Issues == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Issues(childComplexity), true
	case "SearchReturnInfo.search":
		if e.complexity.SearchReturnInfo.Search == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Search(childComplexity), true
	case "SearchReturnInfo.source":
		if e.complexity.SearchReturnInfo.Source == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Source(childComplexity), true

	case "SecretsManagerConfig.secretPrefix":
		if e.complexity.SecretsManagerConfig.SecretPrefix == nil {
			break
		}

		return e.complexity.SecretsManagerConfig.SecretPrefix(childComplexity), true

	case "Selector.data":
		if e.complexity.Selector.Data == nil {
			break
		}

		return e.complexity.Selector.Data(childComplexity), true
	case "Selector.type":
		if e.complexity.Selector.Type == nil {
			break
		}

		return e.complexity.Selector.Type(childComplexity), true

	case "ServiceFlags.agentStartDisabled":
		if e.complexity.ServiceFlags.AgentStartDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.AgentStartDisabled(childComplexity), true
	case "ServiceFlags.alertsDisabled":
		if e.complexity.ServiceFlags.AlertsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.AlertsDisabled(childComplexity), true
	case "ServiceFlags.backgroundReauthDisabled":
		if e.complexity.ServiceFlags.BackgroundReauthDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.BackgroundReauthDisabled(childComplexity), true
	case "ServiceFlags.backgroundStatsDisabled":
		if e.complexity.ServiceFlags.BackgroundStatsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.BackgroundStatsDisabled(childComplexity), true
	case "ServiceFlags.cliUpdatesDisabled":
		if e.complexity.ServiceFlags.CLIUpdatesDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.CLIUpdatesDisabled(childComplexity), true
	case "ServiceFlags.cacheStatsEndpointDisabled":
		if e.complexity.ServiceFlags.CacheStatsEndpointDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.CacheStatsEndpointDisabled(childComplexity), true
	case "ServiceFlags.cacheStatsJobDisabled":
		if e.complexity.ServiceFlags.CacheStatsJobDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.CacheStatsJobDisabled(childComplexity), true
	case "ServiceFlags.checkBlockedTasksDisabled":
		if e.complexity.ServiceFlags.CheckBlockedTasksDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.CheckBlockedTasksDisabled(childComplexity), true
	case "ServiceFlags.cloudCleanupDisabled":
		if e.complexity.ServiceFlags.CloudCleanupDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.CloudCleanupDisabled(childComplexity), true
	case "ServiceFlags.debugSpawnHostDisabled":
		if e.complexity.ServiceFlags.DebugSpawnHostDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.DebugSpawnHostDisabled(childComplexity), true
	case "ServiceFlags.degradedModeDisabled":
		if e.complexity.ServiceFlags.DegradedModeDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.DegradedModeDisabled(childComplexity), true
	case "ServiceFlags.elasticIPsDisabled":
		if e.complexity.ServiceFlags.ElasticIPsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.ElasticIPsDisabled(childComplexity), true
	case "ServiceFlags.emailNotificationsDisabled":
		if e.complexity.ServiceFlags.EmailNotificationsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.EmailNotificationsDisabled(childComplexity), true
	case "ServiceFlags.eventProcessingDisabled":
		if e.complexity.ServiceFlags.EventProcessingDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.EventProcessingDisabled(childComplexity), true
	case "ServiceFlags.githubPRTestingDisabled":
		if e.complexity.ServiceFlags.GithubPRTestingDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.GithubPRTestingDisabled(childComplexity), true
	case "ServiceFlags.githubStatusAPIDisabled":
		if e.complexity.ServiceFlags.GithubStatusAPIDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.GithubStatusAPIDisabled(childComplexity), true
	case "ServiceFlags.hostAllocatorDisabled":
		if e.complexity.ServiceFlags.HostAllocatorDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.HostAllocatorDisabled(childComplexity), true
	case "ServiceFlags.hostInitDisabled":
		if e.complexity.ServiceFlags.HostInitDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.HostInitDisabled(childComplexity), true
	case "ServiceFlags.jiraNotificationsDisabled":
		if e.complexity.ServiceFlags.JIRANotificationsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.JIRANotificationsDisabled(childComplexity), true
	case "ServiceFlags.jwtTokenForCLIDisabled":
		if e.complexity.ServiceFlags.JWTTokenForCLIDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.JWTTokenForCLIDisabled(childComplexity), true
	case "ServiceFlags.largeParserProjectsDisabled":
		if e.complexity.ServiceFlags.LargeParserProjectsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.LargeParserProjectsDisabled(childComplexity), true
	case "ServiceFlags.monitorDisabled":
		if e.complexity.ServiceFlags.MonitorDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.MonitorDisabled(childComplexity), true
	case "ServiceFlags.podAllocatorDisabled":
		if e.complexity.ServiceFlags.PodAllocatorDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.PodAllocatorDisabled(childComplexity), true
	case "ServiceFlags.podInitDisabled":
		if e.complexity.ServiceFlags.PodInitDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.PodInitDisabled(childComplexity), true
	case "ServiceFlags.releaseModeDisabled":
		if e.complexity.ServiceFlags.ReleaseModeDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.ReleaseModeDisabled(childComplexity), true
	case "ServiceFlags.repotrackerDisabled":
		if e.complexity.ServiceFlags.RepotrackerDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.RepotrackerDisabled(childComplexity), true
	case "ServiceFlags.s3LifecycleSyncDisabled":
		if e.complexity.ServiceFlags.S3LifecycleSyncDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.S3LifecycleSyncDisabled(childComplexity), true
	case "ServiceFlags.schedulerDisabled":
		if e.complexity.ServiceFlags.SchedulerDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.SchedulerDisabled(childComplexity), true
	case "ServiceFlags.slackNotificationsDisabled":
		if e.complexity.ServiceFlags.SlackNotificationsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.SlackNotificationsDisabled(childComplexity), true
	case "ServiceFlags.sleepScheduleDisabled":
		if e.complexity.ServiceFlags.SleepScheduleDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.SleepScheduleDisabled(childComplexity), true
	case "ServiceFlags.staticAPIKeysDisabled":
		if e.complexity.ServiceFlags.StaticAPIKeysDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.StaticAPIKeysDisabled(childComplexity), true
	case "ServiceFlags.systemFailedTaskRestartDisabled":
		if e.complexity.ServiceFlags.SystemFailedTaskRestartDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.SystemFailedTaskRestartDisabled(childComplexity), true
	case "ServiceFlags.taskDispatchDisabled":
		if e.complexity.ServiceFlags.TaskDispatchDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.TaskDispatchDisabled(childComplexity), true
	case "ServiceFlags.taskLoggingDisabled":
		if e.complexity.ServiceFlags.TaskLoggingDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.TaskLoggingDisabled(childComplexity), true
	case "ServiceFlags.taskReliabilityDisabled":
		if e.complexity.ServiceFlags.TaskReliabilityDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.TaskReliabilityDisabled(childComplexity), true
	case "ServiceFlags.unrecognizedPodCleanupDisabled":
		if e.complexity.ServiceFlags.UnrecognizedPodCleanupDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.UnrecognizedPodCleanupDisabled(childComplexity), true
	case "ServiceFlags.useGitForGitHubFilesDisabled":
		if e.complexity.ServiceFlags.UseGitForGitHubFilesDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.UseGitForGitHubFilesDisabled(childComplexity), true
	case "ServiceFlags.webhookNotificationsDisabled":
		if e.complexity.ServiceFlags.WebhookNotificationsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.WebhookNotificationsDisabled(childComplexity), true

	case "SetLastRevisionPayload.mergeBaseRevision":
		if e.complexity.SetLastRevisionPayload.MergeBaseRevision == nil {
			break
		}

		return e.complexity.SetLastRevisionPayload.MergeBaseRevision(childComplexity), true

	case "SingleTaskDistroConfig.projectTasksPairs":
		if e.complexity.SingleTaskDistroConfig.ProjectTasksPairs == nil {
			break
		}

		return e.complexity.SingleTaskDistroConfig.ProjectTasksPairs(childComplexity), true

	case "SlackConfig.level":
		if e.complexity.SlackConfig.Level == nil {
			break
		}

		return e.complexity.SlackConfig.Level(childComplexity), true
	case "SlackConfig.name":
		if e.complexity.SlackConfig.Name == nil {
			break
		}

		return e.complexity.SlackConfig.Name(childComplexity), true
	case "SlackConfig.options":
		if e.complexity.SlackConfig.Options == nil {
			break
		}

		return e.complexity.SlackConfig.Options(childComplexity), true
	case "SlackConfig.token":
		if e.complexity.SlackConfig.Token == nil {
			break
		}

		return e.complexity.SlackConfig.Token(childComplexity), true

	case "SlackOptions.allFields":
		if e.complexity.SlackOptions.AllFields == nil {
			break
		}

		return e.complexity.SlackOptions.AllFields(childComplexity), true
	case "SlackOptions.basicMetadata":
		if e.complexity.SlackOptions.BasicMetadata == nil {
			break
		}

		return e.complexity.SlackOptions.BasicMetadata(childComplexity), true
	case "SlackOptions.channel":
		if e.complexity.SlackOptions.Channel == nil {
			break
		}

		return e.complexity.SlackOptions.Channel(childComplexity), true
	case "SlackOptions.fields":
		if e.complexity.SlackOptions.Fields == nil {
			break
		}

		return e.complexity.SlackOptions.Fields(childComplexity), true
	case "SlackOptions.fieldsSet":
		if e.complexity.SlackOptions.FieldsSet == nil {
			break
		}

		return e.complexity.SlackOptions.FieldsSet(childComplexity), true
	case "SlackOptions.hostname":
		if e.complexity.SlackOptions.Hostname == nil {
			break
		}

		return e.complexity.SlackOptions.Hostname(childComplexity), true
	case "SlackOptions.name":
		if e.complexity.SlackOptions.Name == nil {
			break
		}

		return e.complexity.SlackOptions.Name(childComplexity), true
	case "SlackOptions.username":
		if e.complexity.SlackOptions.Username == nil {
			break
		}

		return e.complexity.SlackOptions.Username(childComplexity), true

	case "SleepSchedule.dailyStartTime":
		if e.complexity.SleepSchedule.DailyStartTime == nil {
			break
		}

		return e.complexity.SleepSchedule.DailyStartTime(childComplexity), true
	case "SleepSchedule.dailyStopTime":
		if e.complexity.SleepSchedule.DailyStopTime == nil {
			break
		}

		return e.complexity.SleepSchedule.DailyStopTime(childComplexity), true
	case "SleepSchedule.nextStartTime":
		if e.complexity.SleepSchedule.NextStartTime == nil {
			break
		}

		return e.complexity.SleepSchedule.NextStartTime(childComplexity), true
	case "SleepSchedule.nextStopTime":
		if e.complexity.SleepSchedule.NextStopTime == nil {
			break
		}

		return e.complexity.SleepSchedule.NextStopTime(childComplexity), true
	case "SleepSchedule.permanentlyExempt":
		if e.complexity.SleepSchedule.PermanentlyExempt == nil {
			break
		}

		return e.complexity.SleepSchedule.PermanentlyExempt(childComplexity), true
	case "SleepSchedule.shouldKeepOff":
		if e.complexity.SleepSchedule.ShouldKeepOff == nil {
			break
		}

		return e.complexity.SleepSchedule.ShouldKeepOff(childComplexity), true
	case "SleepSchedule.temporarilyExemptUntil":
		if e.complexity.SleepSchedule.TemporarilyExemptUntil == nil {
			break
		}

		return e.complexity.SleepSchedule.TemporarilyExemptUntil(childComplexity), true
	case "SleepSchedule.timeZone":
		if e.complexity.SleepSchedule.TimeZone == nil {
			break
		}

		return e.complexity.SleepSchedule.TimeZone(childComplexity), true
	case "SleepSchedule.wholeWeekdaysOff":
		if e.complexity.SleepSchedule.WholeWeekdaysOff == nil {
			break
		}

		return e.complexity.SleepSchedule.WholeWeekdaysOff(childComplexity), true

	case "SleepScheduleConfig.permanentlyExemptHosts":
		if e.complexity.SleepScheduleConfig.PermanentlyExemptHosts == nil {
			break
		}

		return e.complexity.SleepScheduleConfig.PermanentlyExemptHosts(childComplexity), true

	case "Source.author":
		if e.complexity.Source.Author == nil {
			break
		}

		return e.complexity.Source.Author(childComplexity), true
	case "Source.requester":
		if e.complexity.Source.Requester == nil {
			break
		}

		return e.complexity.Source.Requester(childComplexity), true
	case "Source.time":
		if e.complexity.Source.Time == nil {
			break
		}

		return e.complexity.Source.Time(childComplexity), true

	case "SpawnHostConfig.spawnHostsPerUser":
		if e.complexity.SpawnHostConfig.SpawnHostsPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.SpawnHostsPerUser(childComplexity), true
	case "SpawnHostConfig.unexpirableHostsPerUser":
		if e.complexity.SpawnHostConfig.UnexpirableHostsPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.UnexpirableHostsPerUser(childComplexity), true
	case "SpawnHostConfig.unexpirableVolumesPerUser":
		if e.complexity.SpawnHostConfig.UnexpirableVolumesPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.UnexpirableVolumesPerUser(childComplexity), true

	case "SplunkConfig.splunkConnectionInfo":
		if e.complexity.SplunkConfig.SplunkConnectionInfo == nil {
			break
		}

		return e.complexity.SplunkConfig.SplunkConnectionInfo(childComplexity), true

	case "SplunkConnectionInfo.channel":
		if e.complexity.SplunkConnectionInfo.Channel == nil {
			break
		}

		return e.complexity.SplunkConnectionInfo.Channel(childComplexity), true
	case "SplunkConnectionInfo.serverUrl":
		if e.complexity.SplunkConnectionInfo.ServerURL == nil {
			break
		}

		return e.complexity.SplunkConnectionInfo.ServerURL(childComplexity), true
	case "SplunkConnectionInfo.token":
		if e.complexity.SplunkConnectionInfo.Token == nil {
			break
		}

		return e.complexity.SplunkConnectionInfo.Token(childComplexity), true

	case "SpruceConfig.banner":
		if e.complexity.SpruceConfig.Banner == nil {
			break
		}

		return e.complexity.SpruceConfig.Banner(childComplexity), true
	case "SpruceConfig.bannerTheme":
		if e.complexity.SpruceConfig.BannerTheme == nil {
			break
		}

		return e.complexity.SpruceConfig.BannerTheme(childComplexity), true
	case "SpruceConfig.containerPools":
		if e.complexity.SpruceConfig.ContainerPools == nil {
			break
		}

		return e.complexity.SpruceConfig.ContainerPools(childComplexity), true
	case "SpruceConfig.githubOrgs":
		if e.complexity.SpruceConfig.GithubOrgs == nil {
			break
		}

		return e.complexity.SpruceConfig.GithubOrgs(childComplexity), true
	case "SpruceConfig.jira":
		if e.complexity.SpruceConfig.Jira == nil {
			break
		}

		return e.complexity.SpruceConfig.Jira(childComplexity), true
	case "SpruceConfig.providers":
		if e.complexity.SpruceConfig.Providers == nil {
			break
		}

		return e.complexity.SpruceConfig.Providers(childComplexity), true
	case "SpruceConfig.secretFields":
		if e.complexity.SpruceConfig.SecretFields == nil {
			break
		}

		return e.complexity.SpruceConfig.SecretFields(childComplexity), true
	case "SpruceConfig.serviceFlags":
		if e.complexity.SpruceConfig.ServiceFlags == nil {
			break
		}

		return e.complexity.SpruceConfig.ServiceFlags(childComplexity), true
	case "SpruceConfig.singleTaskDistro":
		if e.complexity.SpruceConfig.SingleTaskDistro == nil {
			break
		}

		return e.complexity.SpruceConfig.SingleTaskDistro(childComplexity), true
	case "SpruceConfig.slack":
		if e.complexity.SpruceConfig.Slack == nil {
			break
		}

		return e.complexity.SpruceConfig.Slack(childComplexity), true
	case "SpruceConfig.spawnHost":
		if e.complexity.SpruceConfig.Spawnhost == nil {
			break
		}

		return e.complexity.SpruceConfig.Spawnhost(childComplexity), true
	case "SpruceConfig.ui":
		if e.complexity.SpruceConfig.Ui == nil {
			break
		}

		return e.complexity.SpruceConfig.Ui(childComplexity), true

	case "StatusCount.count":
		if e.complexity.StatusCount.Count == nil {
			break
		}

		return e.complexity.StatusCount.Count(childComplexity), true
	case "StatusCount.status":
		if e.complexity.StatusCount.Status == nil {
			break
		}

		return e.complexity.StatusCount.Status(childComplexity), true

	case "StepbackInfo.lastFailingStepbackTaskId":
		if e.complexity.StepbackInfo.LastFailingStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.LastFailingStepbackTaskId(childComplexity), true
	case "StepbackInfo.lastPassingStepbackTaskId":
		if e.complexity.StepbackInfo.LastPassingStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.LastPassingStepbackTaskId(childComplexity), true
	case "StepbackInfo.nextStepbackTaskId":
		if e.complexity.StepbackInfo.NextStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.NextStepbackTaskId(childComplexity), true
	case "StepbackInfo.previousStepbackTaskId":
		if e.complexity.StepbackInfo.PreviousStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.PreviousStepbackTaskId(childComplexity), true

	case "Subnet.az":
		if e.complexity.Subnet.AZ == nil {
			break
		}

		return e.complexity.Subnet.AZ(childComplexity), true
	case "Subnet.subnetId":
		if e.complexity.Subnet.SubnetID == nil {
			break
		}

		return e.complexity.Subnet.SubnetID(childComplexity), true

	case "Subscriber.emailSubscriber":
		if e.complexity.Subscriber.EmailSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.EmailSubscriber(childComplexity), true
	case "Subscriber.githubCheckSubscriber":
		if e.complexity.Subscriber.GithubCheckSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.GithubCheckSubscriber(childComplexity), true
	case "Subscriber.githubPRSubscriber":
		if e.complexity.Subscriber.GithubPRSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.GithubPRSubscriber(childComplexity), true
	case "Subscriber.jiraCommentSubscriber":
		if e.complexity.Subscriber.JiraCommentSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.JiraCommentSubscriber(childComplexity), true
	case "Subscriber.jiraIssueSubscriber":
		if e.complexity.Subscriber.JiraIssueSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.JiraIssueSubscriber(childComplexity), true
	case "Subscriber.slackSubscriber":
		if e.complexity.Subscriber.SlackSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.SlackSubscriber(childComplexity), true
	case "Subscriber.webhookSubscriber":
		if e.complexity.Subscriber.WebhookSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.WebhookSubscriber(childComplexity), true

	case "SubscriberWrapper.subscriber":
		if e.complexity.SubscriberWrapper.Subscriber == nil {
			break
		}

		return e.complexity.SubscriberWrapper.Subscriber(childComplexity), true
	case "SubscriberWrapper.type":
		if e.complexity.SubscriberWrapper.Type == nil {
			break
		}

		return e.complexity.SubscriberWrapper.Type(childComplexity), true

	case "Task.abortInfo":
		if e.complexity.Task.AbortInfo == nil {
			break
		}

		return e.complexity.Task.AbortInfo(childComplexity), true
	case "Task.aborted":
		if e.complexity.Task.Aborted == nil {
			break
		}

		return e.complexity.Task.Aborted(childComplexity), true
	case "Task.activated":
		if e.complexity.Task.Activated == nil {
			break
		}

		return e.complexity.Task.Activated(childComplexity), true
	case "Task.activatedBy":
		if e.complexity.Task.ActivatedBy == nil {
			break
		}

		return e.complexity.Task.ActivatedBy(childComplexity), true
	case "Task.activatedTime":
		if e.complexity.Task.ActivatedTime == nil {
			break
		}

		return e.complexity.Task.ActivatedTime(childComplexity), true
	case "Task.ami":
		if e.complexity.Task.Ami == nil {
			break
		}

		return e.complexity.Task.Ami(childComplexity), true
	case "Task.annotation":
		if e.complexity.Task.Annotation == nil {
			break
		}

		return e.complexity.Task.Annotation(childComplexity), true
	case "Task.baseStatus":
		if e.complexity.Task.BaseStatus == nil {
			break
		}

		return e.complexity.Task.BaseStatus(childComplexity), true
	case "Task.baseTask":
		if e.complexity.Task.BaseTask == nil {
			break
		}

		return e.complexity.Task.BaseTask(childComplexity), true
	case "Task.blocked":
		if e.complexity.Task.Blocked == nil {
			break
		}

		return e.complexity.Task.Blocked(childComplexity), true
	case "Task.buildId":
		if e.complexity.Task.BuildId == nil {
			break
		}

		return e.complexity.Task.BuildId(childComplexity), true
	case "Task.buildVariant":
		if e.complexity.Task.BuildVariant == nil {
			break
		}

		return e.complexity.Task.BuildVariant(childComplexity), true
	case "Task.buildVariantDisplayName":
		if e.complexity.Task.BuildVariantDisplayName == nil {
			break
		}

		return e.complexity.Task.BuildVariantDisplayName(childComplexity), true
	case "Task.canAbort":
		if e.complexity.Task.CanAbort == nil {
			break
		}

		return e.complexity.Task.CanAbort(childComplexity), true
	case "Task.canDisable":
		if e.complexity.Task.CanDisable == nil {
			break
		}

		return e.complexity.Task.CanDisable(childComplexity), true
	case "Task.canModifyAnnotation":
		if e.complexity.Task.CanModifyAnnotation == nil {
			break
		}

		return e.complexity.Task.CanModifyAnnotation(childComplexity), true
	case "Task.canOverrideDependencies":
		if e.complexity.Task.CanOverrideDependencies == nil {
			break
		}

		return e.complexity.Task.CanOverrideDependencies(childComplexity), true
	case "Task.canRestart":
		if e.complexity.Task.CanRestart == nil {
			break
		}

		return e.complexity.Task.CanRestart(childComplexity), true
	case "Task.canSchedule":
		if e.complexity.Task.CanSchedule == nil {
			break
		}

		return e.complexity.Task.CanSchedule(childComplexity), true
	case "Task.canSetPriority":
		if e.complexity.Task.CanSetPriority == nil {
			break
		}

		return e.complexity.Task.CanSetPriority(childComplexity), true
	case "Task.canUnschedule":
		if e.complexity.Task.CanUnschedule == nil {
			break
		}

		return e.complexity.Task.CanUnschedule(childComplexity), true
	case "Task.containerAllocatedTime":
		if e.complexity.Task.ContainerAllocatedTime == nil {
			break
		}

		return e.complexity.Task.ContainerAllocatedTime(childComplexity), true
	case "Task.createTime":
		if e.complexity.Task.CreateTime == nil {
			break
		}

		return e.complexity.Task.CreateTime(childComplexity), true
	case "Task.dependsOn":
		if e.complexity.Task.DependsOn == nil {
			break
		}

		return e.complexity.Task.DependsOn(childComplexity), true
	case "Task.details":
		if e.complexity.Task.Details == nil {
			break
		}

		return e.complexity.Task.Details(childComplexity), true
	case "Task.dispatchTime":
		if e.complexity.Task.DispatchTime == nil {
			break
		}

		return e.complexity.Task.DispatchTime(childComplexity), true
	case "Task.displayName":
		if e.complexity.Task.DisplayName == nil {
			break
		}

		return e.complexity.Task.DisplayName(childComplexity), true
	case "Task.displayOnly":
		if e.complexity.Task.DisplayOnly == nil {
			break
		}

		return e.complexity.Task.DisplayOnly(childComplexity), true
	case "Task.displayStatus":
		if e.complexity.Task.DisplayStatus == nil {
			break
		}

		return e.complexity.Task.DisplayStatus(childComplexity), true
	case "Task.displayTask":
		if e.complexity.Task.DisplayTask == nil {
			break
		}

		return e.complexity.Task.DisplayTask(childComplexity), true
	case "Task.distroId":
		if e.complexity.Task.DistroId == nil {
			break
		}

		return e.complexity.Task.DistroId(childComplexity), true
	case "Task.estimatedStart":
		if e.complexity.Task.EstimatedStart == nil {
			break
		}

		return e.complexity.Task.EstimatedStart(childComplexity), true
	case "Task.execution":
		if e.complexity.Task.Execution == nil {
			break
		}

		return e.complexity.Task.Execution(childComplexity), true
	case "Task.executionTasks":
		if e.complexity.Task.ExecutionTasks == nil {
			break
		}

		return e.complexity.Task.ExecutionTasks(childComplexity), true
	case "Task.executionTasksFull":
		if e.complexity.Task.ExecutionTasksFull == nil {
			break
		}

		return e.complexity.Task.ExecutionTasksFull(childComplexity), true
	case "Task.expectedDuration":
		if e.complexity.Task.ExpectedDuration == nil {
			break
		}

		return e.complexity.Task.ExpectedDuration(childComplexity), true
	case "Task.failedTestCount":
		if e.complexity.Task.FailedTestCount == nil {
			break
		}

		return e.complexity.Task.FailedTestCount(childComplexity), true
	case "Task.files":
		if e.complexity.Task.Files == nil {
			break
		}

		return e.complexity.Task.Files(childComplexity), true
	case "Task.finishTime":
		if e.complexity.Task.FinishTime == nil {
			break
		}

		return e.complexity.Task.FinishTime(childComplexity), true
	case "Task.generateTask":
		if e.complexity.Task.GenerateTask == nil {
			break
		}

		return e.complexity.Task.GenerateTask(childComplexity), true
	case "Task.generatedBy":
		if e.complexity.Task.GeneratedBy == nil {
			break
		}

		return e.complexity.Task.GeneratedBy(childComplexity), true
	case "Task.generatedByName":
		if e.complexity.Task.GeneratedByName == nil {
			break
		}

		return e.complexity.Task.GeneratedByName(childComplexity), true
	case "Task.hasTestResults":
		if e.complexity.Task.HasTestResults == nil {
			break
		}

		return e.complexity.Task.HasTestResults(childComplexity), true
	case "Task.hostId":
		if e.complexity.Task.HostId == nil {
			break
		}

		return e.complexity.Task.HostId(childComplexity), true
	case "Task.id":
		if e.complexity.Task.Id == nil {
			break
		}

		return e.complexity.Task.Id(childComplexity), true
	case "Task.imageId":
		if e.complexity.Task.ImageID == nil {
			break
		}

		return e.complexity.Task.ImageID(childComplexity), true
	case "Task.ingestTime":
		if e.complexity.Task.IngestTime == nil {
			break
		}

		return e.complexity.Task.IngestTime(childComplexity), true
	case "Task.isPerfPluginEnabled":
		if e.complexity.Task.IsPerfPluginEnabled == nil {
			break
		}

		return e.complexity.Task.IsPerfPluginEnabled(childComplexity), true
	case "Task.latestExecution":
		if e.complexity.Task.LatestExecution == nil {
			break
		}

		return e.complexity.Task.LatestExecution(childComplexity), true
	case "Task.logs":
		if e.complexity.Task.Logs == nil {
			break
		}

		return e.complexity.Task.Logs(childComplexity), true
	case "Task.minQueuePosition":
		if e.complexity.Task.MinQueuePosition == nil {
			break
		}

		return e.complexity.Task.MinQueuePosition(childComplexity), true
	case "Task.order":
		if e.complexity.Task.Order == nil {
			break
		}

		return e.complexity.Task.Order(childComplexity), true
	case "Task.patch":
		if e.complexity.Task.Patch == nil {
			break
		}

		return e.complexity.Task.Patch(childComplexity), true
	case "Task.patchNumber":
		if e.complexity.Task.PatchNumber == nil {
			break
		}

		return e.complexity.Task.PatchNumber(childComplexity), true
	case "Task.pod":
		if e.complexity.Task.Pod == nil {
			break
		}

		return e.complexity.Task.Pod(childComplexity), true
	case "Task.predictedTaskCost":
		if e.complexity.Task.PredictedTaskCost == nil {
			break
		}

		return e.complexity.Task.PredictedTaskCost(childComplexity), true
	case "Task.priority":
		if e.complexity.Task.Priority == nil {
			break
		}

		return e.complexity.Task.Priority(childComplexity), true
	case "Task.project":
		if e.complexity.Task.Project == nil {
			break
		}

		return e.complexity.Task.Project(childComplexity), true
	case "Task.projectId":
		if e.complexity.Task.ProjectId == nil {
			break
		}

		return e.complexity.Task.ProjectId(childComplexity), true
	case "Task.projectIdentifier":
		if e.complexity.Task.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Task.ProjectIdentifier(childComplexity), true
	case "Task.requester":
		if e.complexity.Task.Requester == nil {
			break
		}

		return e.complexity.Task.Requester(childComplexity), true
	case "Task.resetWhenFinished":
		if e.complexity.Task.ResetWhenFinished == nil {
			break
		}

		return e.complexity.Task.ResetWhenFinished(childComplexity), true
	case "Task.revision":
		if e.complexity.Task.Revision == nil {
			break
		}

		return e.complexity.Task.Revision(childComplexity), true
	case "Task.scheduledTime":
		if e.complexity.Task.ScheduledTime == nil {
			break
		}

		return e.complexity.Task.ScheduledTime(childComplexity), true
	case "Task.spawnHostLink":
		if e.complexity.Task.SpawnHostLink == nil {
			break
		}

		return e.complexity.Task.SpawnHostLink(childComplexity), true
	case "Task.startTime":
		if e.complexity.Task.StartTime == nil {
			break
		}

		return e.complexity.Task.StartTime(childComplexity), true
	case "Task.status":
		if e.complexity.Task.Status == nil {
			break
		}

		return e.complexity.Task.Status(childComplexity), true
	case "Task.stepbackInfo":
		if e.complexity.Task.StepbackInfo == nil {
			break
		}

		return e.complexity.Task.StepbackInfo(childComplexity), true
	case "Task.tags":
		if e.complexity.Task.Tags == nil {
			break
		}

		return e.complexity.Task.Tags(childComplexity), true
	case "Task.taskCost":
		if e.complexity.Task.TaskCost == nil {
			break
		}

		return e.complexity.Task.TaskCost(childComplexity), true
	case "Task.taskGroup":
		if e.complexity.Task.TaskGroup == nil {
			break
		}

		return e.complexity.Task.TaskGroup(childComplexity), true
	case "Task.taskGroupMaxHosts":
		if e.complexity.Task.TaskGroupMaxHosts == nil {
			break
		}

		return e.complexity.Task.TaskGroupMaxHosts(childComplexity), true
	case "Task.taskLogs":
		if e.complexity.Task.TaskLogs == nil {
			break
		}

		return e.complexity.Task.TaskLogs(childComplexity), true
	case "Task.taskOwnerTeam":
		if e.complexity.Task.TaskOwnerTeam == nil {
			break
		}

		return e.complexity.Task.TaskOwnerTeam(childComplexity), true
	case "Task.testSelectionEnabled":
		if e.complexity.Task.TestSelectionEnabled == nil {
			break
		}

		return e.complexity.Task.TestSelectionEnabled(childComplexity), true
	case "Task.tests":
		if e.complexity.Task.Tests == nil {
			break
		}

		args, err := ec.field_Task_tests_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.Tests(childComplexity, args["opts"].(*TestFilterOptions)), true
	case "Task.timeTaken":
		if e.complexity.Task.TimeTaken == nil {
			break
		}

		return e.complexity.Task.TimeTaken(childComplexity), true
	case "Task.totalTestCount":
		if e.complexity.Task.TotalTestCount == nil {
			break
		}

		return e.complexity.Task.TotalTestCount(childComplexity), true
	case "Task.versionMetadata":
		if e.complexity.Task.VersionMetadata == nil {
			break
		}

		return e.complexity.Task.VersionMetadata(childComplexity), true

	case "TaskAnnotationSettings.fileTicketWebhook":
		if e.complexity.TaskAnnotationSettings.FileTicketWebhook == nil {
			break
		}

		return e.complexity.TaskAnnotationSettings.FileTicketWebhook(childComplexity), true

	case "TaskContainerCreationOpts.arch":
		if e.complexity.TaskContainerCreationOpts.Arch == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Arch(childComplexity), true
	case "TaskContainerCreationOpts.cpu":
		if e.complexity.TaskContainerCreationOpts.CPU == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.CPU(childComplexity), true
	case "TaskContainerCreationOpts.image":
		if e.complexity.TaskContainerCreationOpts.Image == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Image(childComplexity), true
	case "TaskContainerCreationOpts.memoryMB":
		if e.complexity.TaskContainerCreationOpts.MemoryMB == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.MemoryMB(childComplexity), true
	case "TaskContainerCreationOpts.os":
		if e.complexity.TaskContainerCreationOpts.Os == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Os(childComplexity), true
	case "TaskContainerCreationOpts.workingDir":
		if e.complexity.TaskContainerCreationOpts.WorkingDir == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.WorkingDir(childComplexity), true

	case "TaskEndDetail.description":
		if e.complexity.TaskEndDetail.Description == nil {
			break
		}

		return e.complexity.TaskEndDetail.Description(childComplexity), true
	case "TaskEndDetail.diskDevices":
		if e.complexity.TaskEndDetail.DiskDevices == nil {
			break
		}

		return e.complexity.TaskEndDetail.DiskDevices(childComplexity), true
	case "TaskEndDetail.failingCommand":
		if e.complexity.TaskEndDetail.FailingCommand == nil {
			break
		}

		return e.complexity.TaskEndDetail.FailingCommand(childComplexity), true
	case "TaskEndDetail.failureMetadataTags":
		if e.complexity.TaskEndDetail.FailureMetadataTags == nil {
			break
		}

		return e.complexity.TaskEndDetail.FailureMetadataTags(childComplexity), true
	case "TaskEndDetail.oomTracker":
		if e.complexity.TaskEndDetail.OOMTracker == nil {
			break
		}

		return e.complexity.TaskEndDetail.OOMTracker(childComplexity), true
	case "TaskEndDetail.otherFailingCommands":
		if e.complexity.TaskEndDetail.OtherFailingCommands == nil {
			break
		}

		return e.complexity.TaskEndDetail.OtherFailingCommands(childComplexity), true
	case "TaskEndDetail.status":
		if e.complexity.TaskEndDetail.Status == nil {
			break
		}

		return e.complexity.TaskEndDetail.Status(childComplexity), true
	case "TaskEndDetail.timedOut":
		if e.complexity.TaskEndDetail.TimedOut == nil {
			break
		}

		return e.complexity.TaskEndDetail.TimedOut(childComplexity), true
	case "TaskEndDetail.timeoutType":
		if e.complexity.TaskEndDetail.TimeoutType == nil {
			break
		}

		return e.complexity.TaskEndDetail.TimeoutType(childComplexity), true
	case "TaskEndDetail.traceID":
		if e.complexity.TaskEndDetail.TraceID == nil {
			break
		}

		return e.complexity.TaskEndDetail.TraceID(childComplexity), true
	case "TaskEndDetail.type":
		if e.complexity.TaskEndDetail.Type == nil {
			break
		}

		return e.complexity.TaskEndDetail.Type(childComplexity), true

	case "TaskEventLogData.blockedOn":
		if e.complexity.TaskEventLogData.BlockedOn == nil {
			break
		}

		return e.complexity.TaskEventLogData.BlockedOn(childComplexity), true
	case "TaskEventLogData.hostId":
		if e.complexity.TaskEventLogData.HostId == nil {
			break
		}

		return e.complexity.TaskEventLogData.HostId(childComplexity), true
	case "TaskEventLogData.jiraIssue":
		if e.complexity.TaskEventLogData.JiraIssue == nil {
			break
		}

		return e.complexity.TaskEventLogData.JiraIssue(childComplexity), true
	case "TaskEventLogData.jiraLink":
		if e.complexity.TaskEventLogData.JiraLink == nil {
			break
		}

		return e.complexity.TaskEventLogData.JiraLink(childComplexity), true
	case "TaskEventLogData.podId":
		if e.complexity.TaskEventLogData.PodId == nil {
			break
		}

		return e.complexity.TaskEventLogData.PodId(childComplexity), true
	case "TaskEventLogData.priority":
		if e.complexity.TaskEventLogData.Priority == nil {
			break
		}

		return e.complexity.TaskEventLogData.Priority(childComplexity), true
	case "TaskEventLogData.status":
		if e.complexity.TaskEventLogData.Status == nil {
			break
		}

		return e.complexity.TaskEventLogData.Status(childComplexity), true
	case "TaskEventLogData.timestamp":
		if e.complexity.TaskEventLogData.Timestamp == nil {
			break
		}

		return e.complexity.TaskEventLogData.Timestamp(childComplexity), true
	case "TaskEventLogData.userId":
		if e.complexity.TaskEventLogData.UserId == nil {
			break
		}

		return e.complexity.TaskEventLogData.UserId(childComplexity), true

	case "TaskEventLogEntry.data":
		if e.complexity.TaskEventLogEntry.Data == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.Data(childComplexity), true
	case "TaskEventLogEntry.eventType":
		if e.complexity.TaskEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.EventType(childComplexity), true
	case "TaskEventLogEntry.id":
		if e.complexity.TaskEventLogEntry.ID == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ID(childComplexity), true
	case "TaskEventLogEntry.processedAt":
		if e.complexity.TaskEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ProcessedAt(childComplexity), true
	case "TaskEventLogEntry.resourceId":
		if e.complexity.TaskEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ResourceId(childComplexity), true
	case "TaskEventLogEntry.resourceType":
		if e.complexity.TaskEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ResourceType(childComplexity), true
	case "TaskEventLogEntry.timestamp":
		if e.complexity.TaskEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.Timestamp(childComplexity), true

	case "TaskFiles.fileCount":
		if e.complexity.TaskFiles.FileCount == nil {
			break
		}

		return e.complexity.TaskFiles.FileCount(childComplexity), true
	case "TaskFiles.groupedFiles":
		if e.complexity.TaskFiles.GroupedFiles == nil {
			break
		}

		return e.complexity.TaskFiles.GroupedFiles(childComplexity), true

	case "TaskHistory.pagination":
		if e.complexity.TaskHistory.Pagination == nil {
			break
		}

		return e.complexity.TaskHistory.Pagination(childComplexity), true
	case "TaskHistory.tasks":
		if e.complexity.TaskHistory.Tasks == nil {
			break
		}

		return e.complexity.TaskHistory.Tasks(childComplexity), true

	case "TaskHistoryPagination.mostRecentTaskOrder":
		if e.complexity.TaskHistoryPagination.MostRecentTaskOrder == nil {
			break
		}

		return e.complexity.TaskHistoryPagination.MostRecentTaskOrder(childComplexity), true
	case "TaskHistoryPagination.oldestTaskOrder":
		if e.complexity.TaskHistoryPagination.OldestTaskOrder == nil {
			break
		}

		return e.complexity.TaskHistoryPagination.OldestTaskOrder(childComplexity), true

	case "TaskInfo.id":
		if e.complexity.TaskInfo.Id == nil {
			break
		}

		return e.complexity.TaskInfo.Id(childComplexity), true
	case "TaskInfo.name":
		if e.complexity.TaskInfo.Name == nil {
			break
		}

		return e.complexity.TaskInfo.Name(childComplexity), true

	case "TaskLimitsConfig.maxConcurrentLargeParserProjectTasks":
		if e.complexity.TaskLimitsConfig.MaxConcurrentLargeParserProjectTasks == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxConcurrentLargeParserProjectTasks(childComplexity), true
	case "TaskLimitsConfig.maxDailyAutomaticRestarts":
		if e.complexity.TaskLimitsConfig.MaxDailyAutomaticRestarts == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxDailyAutomaticRestarts(childComplexity), true
	case "TaskLimitsConfig.maxDegradedModeConcurrentLargeParserProjectTasks":
		if e.complexity.TaskLimitsConfig.MaxDegradedModeConcurrentLargeParserProjectTasks == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxDegradedModeConcurrentLargeParserProjectTasks(childComplexity), true
	case "TaskLimitsConfig.maxDegradedModeParserProjectSize":
		if e.complexity.TaskLimitsConfig.MaxDegradedModeParserProjectSize == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxDegradedModeParserProjectSize(childComplexity), true
	case "TaskLimitsConfig.maxExecTimeoutSecs":
		if e.complexity.TaskLimitsConfig.MaxExecTimeoutSecs == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxExecTimeoutSecs(childComplexity), true
	case "TaskLimitsConfig.maxGenerateTaskJSONSize":
		if e.complexity.TaskLimitsConfig.MaxGenerateTaskJSONSize == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxGenerateTaskJSONSize(childComplexity), true
	case "TaskLimitsConfig.maxHourlyPatchTasks":
		if e.complexity.TaskLimitsConfig.MaxHourlyPatchTasks == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxHourlyPatchTasks(childComplexity), true
	case "TaskLimitsConfig.maxIncludesPerVersion":
		if e.complexity.TaskLimitsConfig.MaxIncludesPerVersion == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxIncludesPerVersion(childComplexity), true
	case "TaskLimitsConfig.maxParserProjectSize":
		if e.complexity.TaskLimitsConfig.MaxParserProjectSize == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxParserProjectSize(childComplexity), true
	case "TaskLimitsConfig.maxPendingGeneratedTasks":
		if e.complexity.TaskLimitsConfig.MaxPendingGeneratedTasks == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxPendingGeneratedTasks(childComplexity), true
	case "TaskLimitsConfig.maxTaskExecution":
		if e.complexity.TaskLimitsConfig.MaxTaskExecution == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxTaskExecution(childComplexity), true
	case "TaskLimitsConfig.maxTasksPerVersion":
		if e.complexity.TaskLimitsConfig.MaxTasksPerVersion == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxTasksPerVersion(childComplexity), true

	case "TaskLogLinks.agentLogLink":
		if e.complexity.TaskLogLinks.AgentLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.AgentLogLink(childComplexity), true
	case "TaskLogLinks.allLogLink":
		if e.complexity.TaskLogLinks.AllLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.AllLogLink(childComplexity), true
	case "TaskLogLinks.systemLogLink":
		if e.complexity.TaskLogLinks.SystemLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.SystemLogLink(childComplexity), true
	case "TaskLogLinks.taskLogLink":
		if e.complexity.TaskLogLinks.TaskLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.TaskLogLink(childComplexity), true

	case "TaskLogs.agentLogs":
		if e.complexity.TaskLogs.AgentLogs == nil {
			break
		}

		return e.complexity.TaskLogs.AgentLogs(childComplexity), true
	case "TaskLogs.allLogs":
		if e.complexity.TaskLogs.AllLogs == nil {
			break
		}

		return e.complexity.TaskLogs.AllLogs(childComplexity), true
	case "TaskLogs.eventLogs":
		if e.complexity.TaskLogs.EventLogs == nil {
			break
		}

		return e.complexity.TaskLogs.EventLogs(childComplexity), true
	case "TaskLogs.execution":
		if e.complexity.TaskLogs.Execution == nil {
			break
		}

		return e.complexity.TaskLogs.Execution(childComplexity), true
	case "TaskLogs.systemLogs":
		if e.complexity.TaskLogs.SystemLogs == nil {
			break
		}

		return e.complexity.TaskLogs.SystemLogs(childComplexity), true
	case "TaskLogs.taskId":
		if e.complexity.TaskLogs.TaskID == nil {
			break
		}

		return e.complexity.TaskLogs.TaskID(childComplexity), true
	case "TaskLogs.taskLogs":
		if e.complexity.TaskLogs.TaskLogs == nil {
			break
		}

		return e.complexity.TaskLogs.TaskLogs(childComplexity), true

	case "TaskOwnerTeam.assignmentType":
		if e.complexity.TaskOwnerTeam.AssignmentType == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.AssignmentType(childComplexity), true
	case "TaskOwnerTeam.jiraProject":
		if e.complexity.TaskOwnerTeam.JiraProject == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.JiraProject(childComplexity), true
	case "TaskOwnerTeam.messages":
		if e.complexity.TaskOwnerTeam.Messages == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.Messages(childComplexity), true
	case "TaskOwnerTeam.teamName":
		if e.complexity.TaskOwnerTeam.TeamName == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.TeamName(childComplexity), true

	case "TaskQueueDistro.hostCount":
		if e.complexity.TaskQueueDistro.HostCount == nil {
			break
		}

		return e.complexity.TaskQueueDistro.HostCount(childComplexity), true
	case "TaskQueueDistro.id":
		if e.complexity.TaskQueueDistro.ID == nil {
			break
		}

		return e.complexity.TaskQueueDistro.ID(childComplexity), true
	case "TaskQueueDistro.taskCount":
		if e.complexity.TaskQueueDistro.TaskCount == nil {
			break
		}

		return e.complexity.TaskQueueDistro.TaskCount(childComplexity), true

	case "TaskQueueItem.activatedBy":
		if e.complexity.TaskQueueItem.ActivatedBy == nil {
			break
		}

		return e.complexity.TaskQueueItem.ActivatedBy(childComplexity), true
	case "TaskQueueItem.buildVariant":
		if e.complexity.TaskQueueItem.BuildVariant == nil {
			break
		}

		return e.complexity.TaskQueueItem.BuildVariant(childComplexity), true
	case "TaskQueueItem.displayName":
		if e.complexity.TaskQueueItem.DisplayName == nil {
			break
		}

		return e.complexity.TaskQueueItem.DisplayName(childComplexity), true
	case "TaskQueueItem.expectedDuration":
		if e.complexity.TaskQueueItem.ExpectedDuration == nil {
			break
		}

		return e.complexity.TaskQueueItem.ExpectedDuration(childComplexity), true
	case "TaskQueueItem.id":
		if e.complexity.TaskQueueItem.Id == nil {
			break
		}

		return e.complexity.TaskQueueItem.Id(childComplexity), true
	case "TaskQueueItem.priority":
		if e.complexity.TaskQueueItem.Priority == nil {
			break
		}

		return e.complexity.TaskQueueItem.Priority(childComplexity), true
	case "TaskQueueItem.project":
		if e.complexity.TaskQueueItem.Project == nil {
			break
		}

		return e.complexity.TaskQueueItem.Project(childComplexity), true
	case "TaskQueueItem.projectIdentifier":
		if e.complexity.TaskQueueItem.ProjectIdentifier == nil {
			break
		}

		return e.complexity.TaskQueueItem.ProjectIdentifier(childComplexity), true
	case "TaskQueueItem.requester":
		if e.complexity.TaskQueueItem.Requester == nil {
			break
		}

		return e.complexity.TaskQueueItem.Requester(childComplexity), true
	case "TaskQueueItem.revision":
		if e.complexity.TaskQueueItem.Revision == nil {
			break
		}

		return e.complexity.TaskQueueItem.Revision(childComplexity), true
	case "TaskQueueItem.version":
		if e.complexity.TaskQueueItem.Version == nil {
			break
		}

		return e.complexity.TaskQueueItem.Version(childComplexity), true

	case "TaskSpecifier.patchAlias":
		if e.complexity.TaskSpecifier.PatchAlias == nil {
			break
		}

		return e.complexity.TaskSpecifier.PatchAlias(childComplexity), true
	case "TaskSpecifier.taskRegex":
		if e.complexity.TaskSpecifier.TaskRegex == nil {
			break
		}

		return e.complexity.TaskSpecifier.TaskRegex(childComplexity), true
	case "TaskSpecifier.variantRegex":
		if e.complexity.TaskSpecifier.VariantRegex == nil {
			break
		}

		return e.complexity.TaskSpecifier.VariantRegex(childComplexity), true

	case "TaskStats.counts":
		if e.complexity.TaskStats.Counts == nil {
			break
		}

		return e.complexity.TaskStats.Counts(childComplexity), true
	case "TaskStats.eta":
		if e.complexity.TaskStats.ETA == nil {
			break
		}

		return e.complexity.TaskStats.ETA(childComplexity), true

	case "TaskTestResult.filteredTestCount":
		if e.complexity.TaskTestResult.FilteredTestCount == nil {
			break
		}

		return e.complexity.TaskTestResult.FilteredTestCount(childComplexity), true
	case "TaskTestResult.testResults":
		if e.complexity.TaskTestResult.TestResults == nil {
			break
		}

		return e.complexity.TaskTestResult.TestResults(childComplexity), true
	case "TaskTestResult.totalTestCount":
		if e.complexity.TaskTestResult.TotalTestCount == nil {
			break
		}

		return e.complexity.TaskTestResult.TotalTestCount(childComplexity), true

	case "TaskTestResultSample.execution":
		if e.complexity.TaskTestResultSample.Execution == nil {
			break
		}

		return e.complexity.TaskTestResultSample.Execution(childComplexity), true
	case "TaskTestResultSample.matchingFailedTestNames":
		if e.complexity.TaskTestResultSample.MatchingFailedTestNames == nil {
			break
		}

		return e.complexity.TaskTestResultSample.MatchingFailedTestNames(childComplexity), true
	case "TaskTestResultSample.taskId":
		if e.complexity.TaskTestResultSample.TaskID == nil {
			break
		}

		return e.complexity.TaskTestResultSample.TaskID(childComplexity), true
	case "TaskTestResultSample.totalTestCount":
		if e.complexity.TaskTestResultSample.TotalTestCount == nil {
			break
		}

		return e.complexity.TaskTestResultSample.TotalTestCount(childComplexity), true

	case "TestLog.lineNum":
		if e.complexity.TestLog.LineNum == nil {
			break
		}

		return e.complexity.TestLog.LineNum(childComplexity), true
	case "TestLog.renderingType":
		if e.complexity.TestLog.RenderingType == nil {
			break
		}

		return e.complexity.TestLog.RenderingType(childComplexity), true
	case "TestLog.testName":
		if e.complexity.TestLog.TestName == nil {
			break
		}

		return e.complexity.TestLog.TestName(childComplexity), true
	case "TestLog.url":
		if e.complexity.TestLog.URL == nil {
			break
		}

		return e.complexity.TestLog.URL(childComplexity), true
	case "TestLog.urlParsley":
		if e.complexity.TestLog.URLParsley == nil {
			break
		}

		return e.complexity.TestLog.URLParsley(childComplexity), true
	case "TestLog.urlRaw":
		if e.complexity.TestLog.URLRaw == nil {
			break
		}

		return e.complexity.TestLog.URLRaw(childComplexity), true
	case "TestLog.version":
		if e.complexity.TestLog.Version == nil {
			break
		}

		return e.complexity.TestLog.Version(childComplexity), true

	case "TestResult.baseStatus":
		if e.complexity.TestResult.BaseStatus == nil {
			break
		}

		return e.complexity.TestResult.BaseStatus(childComplexity), true
	case "TestResult.duration":
		if e.complexity.TestResult.Duration == nil {
			break
		}

		return e.complexity.TestResult.Duration(childComplexity), true
	case "TestResult.endTime":
		if e.complexity.TestResult.EndTime == nil {
			break
		}

		return e.complexity.TestResult.EndTime(childComplexity), true
	case "TestResult.execution":
		if e.complexity.TestResult.Execution == nil {
			break
		}

		return e.complexity.TestResult.Execution(childComplexity), true
	case "TestResult.exitCode":
		if e.complexity.TestResult.ExitCode == nil {
			break
		}

		return e.complexity.TestResult.ExitCode(childComplexity), true
	case "TestResult.groupID":
		if e.complexity.TestResult.GroupID == nil {
			break
		}

		return e.complexity.TestResult.GroupID(childComplexity), true
	case "TestResult.id":
		if e.complexity.TestResult.ID == nil {
			break
		}

		return e.complexity.TestResult.ID(childComplexity), true
	case "TestResult.logs":
		if e.complexity.TestResult.Logs == nil {
			break
		}

		return e.complexity.TestResult.Logs(childComplexity), true
	case "TestResult.startTime":
		if e.complexity.TestResult.StartTime == nil {
			break
		}

		return e.complexity.TestResult.StartTime(childComplexity), true
	case "TestResult.status":
		if e.complexity.TestResult.Status == nil {
			break
		}

		return e.complexity.TestResult.Status(childComplexity), true
	case "TestResult.taskId":
		if e.complexity.TestResult.TaskID == nil {
			break
		}

		return e.complexity.TestResult.TaskID(childComplexity), true
	case "TestResult.testFile":
		if e.complexity.TestResult.TestFile == nil {
			break
		}

		return e.complexity.TestResult.TestFile(childComplexity), true

	case "TestSelectionConfig.url":
		if e.complexity.TestSelectionConfig.URL == nil {
			break
		}

		return e.complexity.TestSelectionConfig.URL(childComplexity), true

	case "TestSelectionSettings.allowed":
		if e.complexity.TestSelectionSettings.Allowed == nil {
			break
		}

		return e.complexity.TestSelectionSettings.Allowed(childComplexity), true
	case "TestSelectionSettings.defaultEnabled":
		if e.complexity.TestSelectionSettings.DefaultEnabled == nil {
			break
		}

		return e.complexity.TestSelectionSettings.DefaultEnabled(childComplexity), true

	case "TicketFields.assignedTeam":
		if e.complexity.TicketFields.AssignedTeam == nil {
			break
		}

		return e.complexity.TicketFields.AssignedTeam(childComplexity), true
	case "TicketFields.assigneeDisplayName":
		if e.complexity.TicketFields.AssigneeDisplayName == nil {
			break
		}

		return e.complexity.TicketFields.AssigneeDisplayName(childComplexity), true
	case "TicketFields.created":
		if e.complexity.TicketFields.Created == nil {
			break
		}

		return e.complexity.TicketFields.Created(childComplexity), true
	case "TicketFields.resolutionName":
		if e.complexity.TicketFields.ResolutionName == nil {
			break
		}

		return e.complexity.TicketFields.ResolutionName(childComplexity), true
	case "TicketFields.status":
		if e.complexity.TicketFields.Status == nil {
			break
		}

		return e.complexity.TicketFields.Status(childComplexity), true
	case "TicketFields.summary":
		if e.complexity.TicketFields.Summary == nil {
			break
		}

		return e.complexity.TicketFields.Summary(childComplexity), true
	case "TicketFields.updated":
		if e.complexity.TicketFields.Updated == nil {
			break
		}

		return e.complexity.TicketFields.Updated(childComplexity), true

	case "Toolchain.name":
		if e.complexity.Toolchain.Name == nil {
			break
		}

		return e.complexity.Toolchain.Name(childComplexity), true
	case "Toolchain.path":
		if e.complexity.Toolchain.Path == nil {
			break
		}

		return e.complexity.Toolchain.Path(childComplexity), true
	case "Toolchain.version":
		if e.complexity.Toolchain.Version == nil {
			break
		}

		return e.complexity.Toolchain.Version(childComplexity), true

	case "TracerSettings.collectorAPIKey":
		if e.complexity.TracerSettings.CollectorAPIKey == nil {
			break
		}

		return e.complexity.TracerSettings.CollectorAPIKey(childComplexity), true
	case "TracerSettings.collectorEndpoint":
		if e.complexity.TracerSettings.CollectorEndpoint == nil {
			break
		}

		return e.complexity.TracerSettings.CollectorEndpoint(childComplexity), true
	case "TracerSettings.collectorInternalEndpoint":
		if e.complexity.TracerSettings.CollectorInternalEndpoint == nil {
			break
		}

		return e.complexity.TracerSettings.CollectorInternalEndpoint(childComplexity), true
	case "TracerSettings.enabled":
		if e.complexity.TracerSettings.Enabled == nil {
			break
		}

		return e.complexity.TracerSettings.Enabled(childComplexity), true

	case "TriggerAlias.alias":
		if e.complexity.TriggerAlias.Alias == nil {
			break
		}

		return e.complexity.TriggerAlias.Alias(childComplexity), true
	case "TriggerAlias.buildVariantRegex":
		if e.complexity.TriggerAlias.BuildVariantRegex == nil {
			break
		}

		return e.complexity.TriggerAlias.BuildVariantRegex(childComplexity), true
	case "TriggerAlias.configFile":
		if e.complexity.TriggerAlias.ConfigFile == nil {
			break
		}

		return e.complexity.TriggerAlias.ConfigFile(childComplexity), true
	case "TriggerAlias.dateCutoff":
		if e.complexity.TriggerAlias.DateCutoff == nil {
			break
		}

		return e.complexity.TriggerAlias.DateCutoff(childComplexity), true
	case "TriggerAlias.level":
		if e.complexity.TriggerAlias.Level == nil {
			break
		}

		return e.complexity.TriggerAlias.Level(childComplexity), true
	case "TriggerAlias.project":
		if e.complexity.TriggerAlias.Project == nil {
			break
		}

		return e.complexity.TriggerAlias.Project(childComplexity), true
	case "TriggerAlias.status":
		if e.complexity.TriggerAlias.Status == nil {
			break
		}

		return e.complexity.TriggerAlias.Status(childComplexity), true
	case "TriggerAlias.taskRegex":
		if e.complexity.TriggerAlias.TaskRegex == nil {
			break
		}

		return e.complexity.TriggerAlias.TaskRegex(childComplexity), true
	case "TriggerAlias.unscheduleDownstreamVersions":
		if e.complexity.TriggerAlias.UnscheduleDownstreamVersions == nil {
			break
		}

		return e.complexity.TriggerAlias.UnscheduleDownstreamVersions(childComplexity), true

	case "TriggerConfig.generateTaskDistro":
		if e.complexity.TriggerConfig.GenerateTaskDistro == nil {
			break
		}

		return e.complexity.TriggerConfig.GenerateTaskDistro(childComplexity), true

	case "UIConfig.betaFeatures":
		if e.complexity.UIConfig.BetaFeatures == nil {
			break
		}

		return e.complexity.UIConfig.BetaFeatures(childComplexity), true
	case "UIConfig.corsOrigins":
		if e.complexity.UIConfig.CORSOrigins == nil {
			break
		}

		return e.complexity.UIConfig.CORSOrigins(childComplexity), true
	case "UIConfig.cacheTemplates":
		if e.complexity.UIConfig.CacheTemplates == nil {
			break
		}

		return e.complexity.UIConfig.CacheTemplates(childComplexity), true
	case "UIConfig.csrfKey":
		if e.complexity.UIConfig.CsrfKey == nil {
			break
		}

		return e.complexity.UIConfig.CsrfKey(childComplexity), true
	case "UIConfig.defaultProject":
		if e.complexity.UIConfig.DefaultProject == nil {
			break
		}

		return e.complexity.UIConfig.DefaultProject(childComplexity), true
	case "UIConfig.fileStreamingContentTypes":
		if e.complexity.UIConfig.FileStreamingContentTypes == nil {
			break
		}

		return e.complexity.UIConfig.FileStreamingContentTypes(childComplexity), true
	case "UIConfig.helpUrl":
		if e.complexity.UIConfig.HelpUrl == nil {
			break
		}

		return e.complexity.UIConfig.HelpUrl(childComplexity), true
	case "UIConfig.httpListenAddr":
		if e.complexity.UIConfig.HttpListenAddr == nil {
			break
		}

		return e.complexity.UIConfig.HttpListenAddr(childComplexity), true
	case "UIConfig.loginDomain":
		if e.complexity.UIConfig.LoginDomain == nil {
			break
		}

		return e.complexity.UIConfig.LoginDomain(childComplexity), true
	case "UIConfig.parsleyUrl":
		if e.complexity.UIConfig.ParsleyUrl == nil {
			break
		}

		return e.complexity.UIConfig.ParsleyUrl(childComplexity), true
	case "UIConfig.secret":
		if e.complexity.UIConfig.Secret == nil {
			break
		}

		return e.complexity.UIConfig.Secret(childComplexity), true
	case "UIConfig.stagingEnvironment":
		if e.complexity.UIConfig.StagingEnvironment == nil {
			break
		}

		return e.complexity.UIConfig.StagingEnvironment(childComplexity), true
	case "UIConfig.uiv2Url":
		if e.complexity.UIConfig.UIv2Url == nil {
			break
		}

		return e.complexity.UIConfig.UIv2Url(childComplexity), true
	case "UIConfig.url":
		if e.complexity.UIConfig.Url == nil {
			break
		}

		return e.complexity.UIConfig.Url(childComplexity), true
	case "UIConfig.userVoice":
		if e.complexity.UIConfig.UserVoice == nil {
			break
		}

		return e.complexity.UIConfig.UserVoice(childComplexity), true

	case "UpdateBetaFeaturesPayload.betaFeatures":
		if e.complexity.UpdateBetaFeaturesPayload.BetaFeatures == nil {
			break
		}

		return e.complexity.UpdateBetaFeaturesPayload.BetaFeatures(childComplexity), true

	case "UpdateParsleySettingsPayload.parsleySettings":
		if e.complexity.UpdateParsleySettingsPayload.ParsleySettings == nil {
			break
		}

		return e.complexity.UpdateParsleySettingsPayload.ParsleySettings(childComplexity), true

	case "UpstreamProject.owner":
		if e.complexity.UpstreamProject.Owner == nil {
			break
		}

		return e.complexity.UpstreamProject.Owner(childComplexity), true
	case "UpstreamProject.project":
		if e.complexity.UpstreamProject.Project == nil {
			break
		}

		return e.complexity.UpstreamProject.Project(childComplexity), true
	case "UpstreamProject.repo":
		if e.complexity.UpstreamProject.Repo == nil {
			break
		}

		return e.complexity.UpstreamProject.Repo(childComplexity), true
	case "UpstreamProject.resourceID":
		if e.complexity.UpstreamProject.ResourceID == nil {
			break
		}

		return e.complexity.UpstreamProject.ResourceID(childComplexity), true
	case "UpstreamProject.revision":
		if e.complexity.UpstreamProject.Revision == nil {
			break
		}

		return e.complexity.UpstreamProject.Revision(childComplexity), true
	case "UpstreamProject.task":
		if e.complexity.UpstreamProject.Task == nil {
			break
		}

		return e.complexity.UpstreamProject.Task(childComplexity), true
	case "UpstreamProject.triggerID":
		if e.complexity.UpstreamProject.TriggerID == nil {
			break
		}

		return e.complexity.UpstreamProject.TriggerID(childComplexity), true
	case "UpstreamProject.triggerType":
		if e.complexity.UpstreamProject.TriggerType == nil {
			break
		}

		return e.complexity.UpstreamProject.TriggerType(childComplexity), true
	case "UpstreamProject.version":
		if e.complexity.UpstreamProject.Version == nil {
			break
		}

		return e.complexity.UpstreamProject.Version(childComplexity), true

	case "UseSpruceOptions.spruceV1":
		if e.complexity.UseSpruceOptions.SpruceV1 == nil {
			break
		}

		return e.complexity.UseSpruceOptions.SpruceV1(childComplexity), true

	case "User.betaFeatures":
		if e.complexity.User.BetaFeatures == nil {
			break
		}

		return e.complexity.User.BetaFeatures(childComplexity), true
	case "User.displayName":
		if e.complexity.User.DisplayName == nil {
			break
		}

		return e.complexity.User.DisplayName(childComplexity), true
	case "User.emailAddress":
		if e.complexity.User.EmailAddress == nil {
			break
		}

		return e.complexity.User.EmailAddress(childComplexity), true
	case "User.parsleyFilters":
		if e.complexity.User.ParsleyFilters == nil {
			break
		}

		return e.complexity.User.ParsleyFilters(childComplexity), true
	case "User.parsleySettings":
		if e.complexity.User.ParsleySettings == nil {
			break
		}

		return e.complexity.User.ParsleySettings(childComplexity), true
	case "User.patches":
		if e.complexity.User.Patches == nil {
			break
		}

		args, err := ec.field_User_patches_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Patches(childComplexity, args["patchesInput"].(PatchesInput)), true
	case "User.permissions":
		if e.complexity.User.Permissions == nil {
			break
		}

		return e.complexity.User.Permissions(childComplexity), true
	case "User.settings":
		if e.complexity.User.Settings == nil {
			break
		}

		return e.complexity.User.Settings(childComplexity), true
	case "User.subscriptions":
		if e.complexity.User.Subscriptions == nil {
			break
		}

		return e.complexity.User.Subscriptions(childComplexity), true
	case "User.userId":
		if e.complexity.User.UserID == nil {
			break
		}

		return e.complexity.User.UserID(childComplexity), true

	case "UserConfig.api_key":
		if e.complexity.UserConfig.APIKey == nil {
			break
		}

		return e.complexity.UserConfig.APIKey(childComplexity), true
	case "UserConfig.api_server_host":
		if e.complexity.UserConfig.APIServerHost == nil {
			break
		}

		return e.complexity.UserConfig.APIServerHost(childComplexity), true
	case "UserConfig.oauth_client_id":
		if e.complexity.UserConfig.OauthClientID == nil {
			break
		}

		return e.complexity.UserConfig.OauthClientID(childComplexity), true
	case "UserConfig.oauth_connector_id":
		if e.complexity.UserConfig.OauthConnectorID == nil {
			break
		}

		return e.complexity.UserConfig.OauthConnectorID(childComplexity), true
	case "UserConfig.oauth_issuer":
		if e.complexity.UserConfig.OauthIssuer == nil {
			break
		}

		return e.complexity.UserConfig.OauthIssuer(childComplexity), true
	case "UserConfig.ui_server_host":
		if e.complexity.UserConfig.UIServerHost == nil {
			break
		}

		return e.complexity.UserConfig.UIServerHost(childComplexity), true
	case "UserConfig.user":
		if e.complexity.UserConfig.User == nil {
			break
		}

		return e.complexity.UserConfig.User(childComplexity), true

	case "UserServiceFlags.jwtTokenForCLIDisabled":
		if e.complexity.UserServiceFlags.JWTTokenForCLIDisabled == nil {
			break
		}

		return e.complexity.UserServiceFlags.JWTTokenForCLIDisabled(childComplexity), true

	case "UserSettings.dateFormat":
		if e.complexity.UserSettings.DateFormat == nil {
			break
		}

		return e.complexity.UserSettings.DateFormat(childComplexity), true
	case "UserSettings.githubUser":
		if e.complexity.UserSettings.GithubUser == nil {
			break
		}

		return e.complexity.UserSettings.GithubUser(childComplexity), true
	case "UserSettings.notifications":
		if e.complexity.UserSettings.Notifications == nil {
			break
		}

		return e.complexity.UserSettings.Notifications(childComplexity), true
	case "UserSettings.region":
		if e.complexity.UserSettings.Region == nil {
			break
		}

		return e.complexity.UserSettings.Region(childComplexity), true
	case "UserSettings.slackMemberId":
		if e.complexity.UserSettings.SlackMemberId == nil {
			break
		}

		return e.complexity.UserSettings.SlackMemberId(childComplexity), true
	case "UserSettings.slackUsername":
		if e.complexity.UserSettings.SlackUsername == nil {
			break
		}

		return e.complexity.UserSettings.SlackUsername(childComplexity), true
	case "UserSettings.timeFormat":
		if e.complexity.UserSettings.TimeFormat == nil {
			break
		}

		return e.complexity.UserSettings.TimeFormat(childComplexity), true
	case "UserSettings.timezone":
		if e.complexity.UserSettings.Timezone == nil {
			break
		}

		return e.complexity.UserSettings.Timezone(childComplexity), true
	case "UserSettings.useSpruceOptions":
		if e.complexity.UserSettings.UseSpruceOptions == nil {
			break
		}

		return e.complexity.UserSettings.UseSpruceOptions(childComplexity), true

	case "VariantTask.name":
		if e.complexity.VariantTask.Name == nil {
			break
		}

		return e.complexity.VariantTask.Name(childComplexity), true
	case "VariantTask.tasks":
		if e.complexity.VariantTask.Tasks == nil {
			break
		}

		return e.complexity.VariantTask.Tasks(childComplexity), true

	case "Version.activated":
		if e.complexity.Version.Activated == nil {
			break
		}

		return e.complexity.Version.Activated(childComplexity), true
	case "Version.author":
		if e.complexity.Version.Author == nil {
			break
		}

		return e.complexity.Version.Author(childComplexity), true
	case "Version.authorEmail":
		if e.complexity.Version.AuthorEmail == nil {
			break
		}

		return e.complexity.Version.AuthorEmail(childComplexity), true
	case "Version.baseTaskStatuses":
		if e.complexity.Version.BaseTaskStatuses == nil {
			break
		}

		return e.complexity.Version.BaseTaskStatuses(childComplexity), true
	case "Version.baseVersion":
		if e.complexity.Version.BaseVersion == nil {
			break
		}

		return e.complexity.Version.BaseVersion(childComplexity), true
	case "Version.branch":
		if e.complexity.Version.Branch == nil {
			break
		}

		return e.complexity.Version.Branch(childComplexity), true
	case "Version.buildVariantStats":
		if e.complexity.Version.BuildVariantStats == nil {
			break
		}

		args, err := ec.field_Version_buildVariantStats_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.BuildVariantStats(childComplexity, args["options"].(BuildVariantOptions)), true
	case "Version.buildVariants":
		if e.complexity.Version.BuildVariants == nil {
			break
		}

		args, err := ec.field_Version_buildVariants_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.BuildVariants(childComplexity, args["options"].(BuildVariantOptions)), true
	case "Version.childVersions":
		if e.complexity.Version.ChildVersions == nil {
			break
		}

		return e.complexity.Version.ChildVersions(childComplexity), true
	case "Version.createTime":
		if e.complexity.Version.CreateTime == nil {
			break
		}

		return e.complexity.Version.CreateTime(childComplexity), true
	case "Version.errors":
		if e.complexity.Version.Errors == nil {
			break
		}

		return e.complexity.Version.Errors(childComplexity), true
	case "Version.externalLinksForMetadata":
		if e.complexity.Version.ExternalLinksForMetadata == nil {
			break
		}

		return e.complexity.Version.ExternalLinksForMetadata(childComplexity), true
	case "Version.finishTime":
		if e.complexity.Version.FinishTime == nil {
			break
		}

		return e.complexity.Version.FinishTime(childComplexity), true
	case "Version.generatedTaskCounts":
		if e.complexity.Version.GeneratedTaskCounts == nil {
			break
		}

		return e.complexity.Version.GeneratedTaskCounts(childComplexity), true
	case "Version.gitTags":
		if e.complexity.Version.GitTags == nil {
			break
		}

		return e.complexity.Version.GitTags(childComplexity), true
	case "Version.id":
		if e.complexity.Version.Id == nil {
			break
		}

		return e.complexity.Version.Id(childComplexity), true
	case "Version.ignored":
		if e.complexity.Version.Ignored == nil {
			break
		}

		return e.complexity.Version.Ignored(childComplexity), true
	case "Version.isPatch":
		if e.complexity.Version.IsPatch == nil {
			break
		}

		return e.complexity.Version.IsPatch(childComplexity), true
	case "Version.manifest":
		if e.complexity.Version.Manifest == nil {
			break
		}

		return e.complexity.Version.Manifest(childComplexity), true
	case "Version.message":
		if e.complexity.Version.Message == nil {
			break
		}

		return e.complexity.Version.Message(childComplexity), true
	case "Version.order":
		if e.complexity.Version.Order == nil {
			break
		}

		return e.complexity.Version.Order(childComplexity), true
	case "Version.parameters":
		if e.complexity.Version.Parameters == nil {
			break
		}

		return e.complexity.Version.Parameters(childComplexity), true
	case "Version.patch":
		if e.complexity.Version.Patch == nil {
			break
		}

		return e.complexity.Version.Patch(childComplexity), true
	case "Version.predictedCost":
		if e.complexity.Version.PredictedCost == nil {
			break
		}

		return e.complexity.Version.PredictedCost(childComplexity), true
	case "Version.previousVersion":
		if e.complexity.Version.PreviousVersion == nil {
			break
		}

		return e.complexity.Version.PreviousVersion(childComplexity), true
	case "Version.project":
		if e.complexity.Version.Project == nil {
			break
		}

		return e.complexity.Version.Project(childComplexity), true
	case "Version.projectIdentifier":
		if e.complexity.Version.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Version.ProjectIdentifier(childComplexity), true
	case "Version.projectMetadata":
		if e.complexity.Version.ProjectMetadata == nil {
			break
		}

		return e.complexity.Version.ProjectMetadata(childComplexity), true
	case "Version.repo":
		if e.complexity.Version.Repo == nil {
			break
		}

		return e.complexity.Version.Repo(childComplexity), true
	case "Version.requester":
		if e.complexity.Version.Requester == nil {
			break
		}

		return e.complexity.Version.Requester(childComplexity), true
	case "Version.revision":
		if e.complexity.Version.Revision == nil {
			break
		}

		return e.complexity.Version.Revision(childComplexity), true
	case "Version.startTime":
		if e.complexity.Version.StartTime == nil {
			break
		}

		return e.complexity.Version.StartTime(childComplexity), true
	case "Version.status":
		if e.complexity.Version.Status == nil {
			break
		}

		return e.complexity.Version.Status(childComplexity), true
	case "Version.taskCount":
		if e.complexity.Version.TaskCount == nil {
			break
		}

		args, err := ec.field_Version_taskCount_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.TaskCount(childComplexity, args["options"].(*TaskCountOptions)), true
	case "Version.taskStatusStats":
		if e.complexity.Version.TaskStatusStats == nil {
			break
		}

		args, err := ec.field_Version_taskStatusStats_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.TaskStatusStats(childComplexity, args["options"].(BuildVariantOptions)), true
	case "Version.taskStatuses":
		if e.complexity.Version.TaskStatuses == nil {
			break
		}

		return e.complexity.Version.TaskStatuses(childComplexity), true
	case "Version.tasks":
		if e.complexity.Version.Tasks == nil {
			break
		}

		args, err := ec.field_Version_tasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.Tasks(childComplexity, args["options"].(TaskFilterOptions)), true
	case "Version.upstreamProject":
		if e.complexity.Version.UpstreamProject == nil {
			break
		}

		return e.complexity.Version.UpstreamProject(childComplexity), true
	case "Version.user":
		if e.complexity.Version.User == nil {
			break
		}

		return e.complexity.Version.User(childComplexity), true
	case "Version.versionTiming":
		if e.complexity.Version.VersionTiming == nil {
			break
		}

		return e.complexity.Version.VersionTiming(childComplexity), true
	case "Version.warnings":
		if e.complexity.Version.Warnings == nil {
			break
		}

		return e.complexity.Version.Warnings(childComplexity), true
	case "Version.waterfallBuilds":
		if e.complexity.Version.WaterfallBuilds == nil {
			break
		}

		return e.complexity.Version.WaterfallBuilds(childComplexity), true

	case "VersionTasks.count":
		if e.complexity.VersionTasks.Count == nil {
			break
		}

		return e.complexity.VersionTasks.Count(childComplexity), true
	case "VersionTasks.data":
		if e.complexity.VersionTasks.Data == nil {
			break
		}

		return e.complexity.VersionTasks.Data(childComplexity), true

	case "VersionTiming.makespan":
		if e.complexity.VersionTiming.Makespan == nil {
			break
		}

		return e.complexity.VersionTiming.Makespan(childComplexity), true
	case "VersionTiming.timeTaken":
		if e.complexity.VersionTiming.TimeTaken == nil {
			break
		}

		return e.complexity.VersionTiming.TimeTaken(childComplexity), true

	case "Volume.availabilityZone":
		if e.complexity.Volume.AvailabilityZone == nil {
			break
		}

		return e.complexity.Volume.AvailabilityZone(childComplexity), true
	case "Volume.createdBy":
		if e.complexity.Volume.CreatedBy == nil {
			break
		}

		return e.complexity.Volume.CreatedBy(childComplexity), true
	case "Volume.creationTime":
		if e.complexity.Volume.CreationTime == nil {
			break
		}

		return e.complexity.Volume.CreationTime(childComplexity), true
	case "Volume.deviceName":
		if e.complexity.Volume.DeviceName == nil {
			break
		}

		return e.complexity.Volume.DeviceName(childComplexity), true
	case "Volume.displayName":
		if e.complexity.Volume.DisplayName == nil {
			break
		}

		return e.complexity.Volume.DisplayName(childComplexity), true
	case "Volume.expiration":
		if e.complexity.Volume.Expiration == nil {
			break
		}

		return e.complexity.Volume.Expiration(childComplexity), true
	case "Volume.homeVolume":
		if e.complexity.Volume.HomeVolume == nil {
			break
		}

		return e.complexity.Volume.HomeVolume(childComplexity), true
	case "Volume.host":
		if e.complexity.Volume.Host == nil {
			break
		}

		return e.complexity.Volume.Host(childComplexity), true
	case "Volume.hostID":
		if e.complexity.Volume.HostID == nil {
			break
		}

		return e.complexity.Volume.HostID(childComplexity), true
	case "Volume.id":
		if e.complexity.Volume.ID == nil {
			break
		}

		return e.complexity.Volume.ID(childComplexity), true
	case "Volume.migrating":
		if e.complexity.Volume.Migrating == nil {
			break
		}

		return e.complexity.Volume.Migrating(childComplexity), true
	case "Volume.noExpiration":
		if e.complexity.Volume.NoExpiration == nil {
			break
		}

		return e.complexity.Volume.NoExpiration(childComplexity), true
	case "Volume.size":
		if e.complexity.Volume.Size == nil {
			break
		}

		return e.complexity.Volume.Size(childComplexity), true
	case "Volume.type":
		if e.complexity.Volume.Type == nil {
			break
		}

		return e.complexity.Volume.Type(childComplexity), true

	case "Waterfall.flattenedVersions":
		if e.complexity.Waterfall.FlattenedVersions == nil {
			break
		}

		return e.complexity.Waterfall.FlattenedVersions(childComplexity), true
	case "Waterfall.pagination":
		if e.complexity.Waterfall.Pagination == nil {
			break
		}

		return e.complexity.Waterfall.Pagination(childComplexity), true

	case "WaterfallBuild.activated":
		if e.complexity.WaterfallBuild.Activated == nil {
			break
		}

		return e.complexity.WaterfallBuild.Activated(childComplexity), true
	case "WaterfallBuild.buildVariant":
		if e.complexity.WaterfallBuild.BuildVariant == nil {
			break
		}

		return e.complexity.WaterfallBuild.BuildVariant(childComplexity), true
	case "WaterfallBuild.displayName":
		if e.complexity.WaterfallBuild.DisplayName == nil {
			break
		}

		return e.complexity.WaterfallBuild.DisplayName(childComplexity), true
	case "WaterfallBuild.id":
		if e.complexity.WaterfallBuild.Id == nil {
			break
		}

		return e.complexity.WaterfallBuild.Id(childComplexity), true
	case "WaterfallBuild.tasks":
		if e.complexity.WaterfallBuild.Tasks == nil {
			break
		}

		return e.complexity.WaterfallBuild.Tasks(childComplexity), true
	case "WaterfallBuild.version":
		if e.complexity.WaterfallBuild.Version == nil {
			break
		}

		return e.complexity.WaterfallBuild.Version(childComplexity), true

	case "WaterfallBuildVariant.builds":
		if e.complexity.WaterfallBuildVariant.Builds == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.Builds(childComplexity), true
	case "WaterfallBuildVariant.displayName":
		if e.complexity.WaterfallBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.DisplayName(childComplexity), true
	case "WaterfallBuildVariant.id":
		if e.complexity.WaterfallBuildVariant.Id == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.Id(childComplexity), true
	case "WaterfallBuildVariant.version":
		if e.complexity.WaterfallBuildVariant.Version == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.Version(childComplexity), true

	case "WaterfallPagination.activeVersionIds":
		if e.complexity.WaterfallPagination.ActiveVersionIds == nil {
			break
		}

		return e.complexity.WaterfallPagination.ActiveVersionIds(childComplexity), true
	case "WaterfallPagination.hasNextPage":
		if e.complexity.WaterfallPagination.HasNextPage == nil {
			break
		}

		return e.complexity.WaterfallPagination.HasNextPage(childComplexity), true
	case "WaterfallPagination.hasPrevPage":
		if e.complexity.WaterfallPagination.HasPrevPage == nil {
			break
		}

		return e.complexity.WaterfallPagination.HasPrevPage(childComplexity), true
	case "WaterfallPagination.mostRecentVersionOrder":
		if e.complexity.WaterfallPagination.MostRecentVersionOrder == nil {
			break
		}

		return e.complexity.WaterfallPagination.MostRecentVersionOrder(childComplexity), true
	case "WaterfallPagination.nextPageOrder":
		if e.complexity.WaterfallPagination.NextPageOrder == nil {
			break
		}

		return e.complexity.WaterfallPagination.NextPageOrder(childComplexity), true
	case "WaterfallPagination.prevPageOrder":
		if e.complexity.WaterfallPagination.PrevPageOrder == nil {
			break
		}

		return e.complexity.WaterfallPagination.PrevPageOrder(childComplexity), true

	case "WaterfallTask.displayName":
		if e.complexity.WaterfallTask.DisplayName == nil {
			break
		}

		return e.complexity.WaterfallTask.DisplayName(childComplexity), true
	case "WaterfallTask.displayStatusCache":
		if e.complexity.WaterfallTask.DisplayStatusCache == nil {
			break
		}

		return e.complexity.WaterfallTask.DisplayStatusCache(childComplexity), true
	case "WaterfallTask.execution":
		if e.complexity.WaterfallTask.Execution == nil {
			break
		}

		return e.complexity.WaterfallTask.Execution(childComplexity), true
	case "WaterfallTask.id":
		if e.complexity.WaterfallTask.Id == nil {
			break
		}

		return e.complexity.WaterfallTask.Id(childComplexity), true
	case "WaterfallTask.status":
		if e.complexity.WaterfallTask.Status == nil {
			break
		}

		return e.complexity.WaterfallTask.Status(childComplexity), true

	case "WaterfallVersion.inactiveVersions":
		if e.complexity.WaterfallVersion.InactiveVersions == nil {
			break
		}

		return e.complexity.WaterfallVersion.InactiveVersions(childComplexity), true
	case "WaterfallVersion.version":
		if e.complexity.WaterfallVersion.Version == nil {
			break
		}

		return e.complexity.WaterfallVersion.Version(childComplexity), true

	case "Webhook.endpoint":
		if e.complexity.Webhook.Endpoint == nil {
			break
		}

		return e.complexity.Webhook.Endpoint(childComplexity), true
	case "Webhook.secret":
		if e.complexity.Webhook.Secret == nil {
			break
		}

		return e.complexity.Webhook.Secret(childComplexity), true

	case "WebhookHeader.key":
		if e.complexity.WebhookHeader.Key == nil {
			break
		}

		return e.complexity.WebhookHeader.Key(childComplexity), true
	case "WebhookHeader.value":
		if e.complexity.WebhookHeader.Value == nil {
			break
		}

		return e.complexity.WebhookHeader.Value(childComplexity), true

	case "WebhookSubscriber.headers":
		if e.complexity.WebhookSubscriber.Headers == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Headers(childComplexity), true
	case "WebhookSubscriber.minDelayMs":
		if e.complexity.WebhookSubscriber.MinDelayMS == nil {
			break
		}

		return e.complexity.WebhookSubscriber.MinDelayMS(childComplexity), true
	case "WebhookSubscriber.retries":
		if e.complexity.WebhookSubscriber.Retries == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Retries(childComplexity), true
	case "WebhookSubscriber.secret":
		if e.complexity.WebhookSubscriber.Secret == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Secret(childComplexity), true
	case "WebhookSubscriber.timeoutMs":
		if e.complexity.WebhookSubscriber.TimeoutMS == nil {
			break
		}

		return e.complexity.WebhookSubscriber.TimeoutMS(childComplexity), true
	case "WebhookSubscriber.url":
		if e.complexity.WebhookSubscriber.URL == nil {
			break
		}

		return e.complexity.WebhookSubscriber.URL(childComplexity), true

	case "WorkstationConfig.gitClone":
		if e.complexity.WorkstationConfig.GitClone == nil {
			break
		}

		return e.complexity.WorkstationConfig.GitClone(childComplexity), true
	case "WorkstationConfig.setupCommands":
		if e.complexity.WorkstationConfig.SetupCommands == nil {
			break
		}

		return e.complexity.WorkstationConfig.SetupCommands(childComplexity), true

	case "WorkstationSetupCommand.command":
		if e.complexity.WorkstationSetupCommand.Command == nil {
			break
		}

		return e.complexity.WorkstationSetupCommand.Command(childComplexity), true
	case "WorkstationSetupCommand.directory":
		if e.complexity.WorkstationSetupCommand.Directory == nil {
			break
		}

		return e.complexity.WorkstationSetupCommand.Directory(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAPIConfigInput,
		ec.unmarshalInputAWSAccountRoleMappingInput,
		ec.unmarshalInputAWSConfigInput,
		ec.unmarshalInputAWSPodConfigInput,
		ec.unmarshalInputAWSVPCConfigInput,
		ec.unmarshalInputAddFavoriteProjectInput,
		ec.unmarshalInputAdminEventsInput,
		ec.unmarshalInputAdminSettingsInput,
		ec.unmarshalInputAmboyConfigInput,
		ec.unmarshalInputAmboyDBConfigInput,
		ec.unmarshalInputAmboyNamedQueueConfigInput,
		ec.unmarshalInputAmboyRetryConfigInput,
		ec.unmarshalInputAuthConfigInput,
		ec.unmarshalInputAuthUserInput,
		ec.unmarshalInputBetaFeaturesInput,
		ec.unmarshalInputBootstrapSettingsInput,
		ec.unmarshalInputBucketConfigInput,
		ec.unmarshalInputBucketsConfigInput,
		ec.unmarshalInputBuildBaronSettingsInput,
		ec.unmarshalInputBuildVariantOptions,
		ec.unmarshalInputCedarConfigInput,
		ec.unmarshalInputCloudProviderConfigInput,
		ec.unmarshalInputCommitQueueParamsInput,
		ec.unmarshalInputContainerPoolInput,
		ec.unmarshalInputContainerPoolsConfigInput,
		ec.unmarshalInputContainerResourcesInput,
		ec.unmarshalInputCopyDistroInput,
		ec.unmarshalInputCopyProjectInput,
		ec.unmarshalInputCostConfigInput,
		ec.unmarshalInputCostDataInput,
		ec.unmarshalInputCreateDistroInput,
		ec.unmarshalInputCreateProjectInput,
		ec.unmarshalInputCursorParams,
		ec.unmarshalInputDeactivateStepbackTaskInput,
		ec.unmarshalInputDefaultSectionToRepoInput,
		ec.unmarshalInputDeleteDistroInput,
		ec.unmarshalInputDeleteGithubAppCredentialsInput,
		ec.unmarshalInputDispatcherSettingsInput,
		ec.unmarshalInputDisplayTask,
		ec.unmarshalInputDistroEventsInput,
		ec.unmarshalInputDistroInput,
		ec.unmarshalInputDistroPermissionsOptions,
		ec.unmarshalInputDockerConfigInput,
		ec.unmarshalInputEC2KeyInput,
		ec.unmarshalInputECSCapacityProviderInput,
		ec.unmarshalInputECSClusterConfigInput,
		ec.unmarshalInputECSConfigInput,
		ec.unmarshalInputEditSpawnHostInput,
		ec.unmarshalInputEnvVarInput,
		ec.unmarshalInputExpansionInput,
		ec.unmarshalInputExternalLinkInput,
		ec.unmarshalInputFWSConfigInput,
		ec.unmarshalInputFinderSettingsInput,
		ec.unmarshalInputGitHubAuthConfigInput,
		ec.unmarshalInputGitHubCheckRunConfigInput,
		ec.unmarshalInputGitHubDynamicTokenPermissionGroupInput,
		ec.unmarshalInputGithubAppAuthInput,
		ec.unmarshalInputGithubUserInput,
		ec.unmarshalInputGraphiteConfigInput,
		ec.unmarshalInputHomeVolumeSettingsInput,
		ec.unmarshalInputHostAllocatorSettingsInput,
		ec.unmarshalInputHostEventsInput,
		ec.unmarshalInputHostInitConfigInput,
		ec.unmarshalInputHostJasperConfigInput,
		ec.unmarshalInputIceCreamSettingsInput,
		ec.unmarshalInputImageFileOpts,
		ec.unmarshalInputInstanceTagInput,
		ec.unmarshalInputIssueLinkInput,
		ec.unmarshalInputJiraConfigInput,
		ec.unmarshalInputJiraIssueSubscriberInput,
		ec.unmarshalInputJiraNotificationsConfigInput,
		ec.unmarshalInputJiraNotificationsProjectEntryInput,
		ec.unmarshalInputJiraNotificationsProjectInput,
		ec.unmarshalInputKanopyAuthConfigInput,
		ec.unmarshalInputLogBufferingInput,
		ec.unmarshalInputLoggerConfigInput,
		ec.unmarshalInputMainlineCommitsOptions,
		ec.unmarshalInputMetadataLinkInput,
		ec.unmarshalInputMoveProjectInput,
		ec.unmarshalInputMultiAuthConfigInput,
		ec.unmarshalInputNaiveAuthConfigInput,
		ec.unmarshalInputNotificationsInput,
		ec.unmarshalInputNotifyConfigInput,
		ec.unmarshalInputOAuthConfigInput,
		ec.unmarshalInputOktaConfigInput,
		ec.unmarshalInputOperatingSystemOpts,
		ec.unmarshalInputOwnerRepoInput,
		ec.unmarshalInputPackageOpts,
		ec.unmarshalInputParameterInput,
		ec.unmarshalInputParameterStoreConfigInput,
		ec.unmarshalInputParserProjectS3ConfigInput,
		ec.unmarshalInputParsleyFilterInput,
		ec.unmarshalInputParsleySettingsInput,
		ec.unmarshalInputPatchConfigure,
		ec.unmarshalInputPatchTriggerAliasInput,
		ec.unmarshalInputPatchesInput,
		ec.unmarshalInputPeriodicBuildInput,
		ec.unmarshalInputPersistentDNSConfigInput,
		ec.unmarshalInputPlannerSettingsInput,
		ec.unmarshalInputPodLifecycleConfigInput,
		ec.unmarshalInputPreconditionScriptInput,
		ec.unmarshalInputProjectAliasInput,
		ec.unmarshalInputProjectBannerInput,
		ec.unmarshalInputProjectCreationConfigInput,
		ec.unmarshalInputProjectInput,
		ec.unmarshalInputProjectPermissionsOptions,
		ec.unmarshalInputProjectSettingsInput,
		ec.unmarshalInputProjectTasksPairInput,
		ec.unmarshalInputProjectVarsInput,
		ec.unmarshalInputPromoteVarsToRepoInput,
		ec.unmarshalInputPublicKeyInput,
		ec.unmarshalInputQuarantineTestInput,
		ec.unmarshalInputReleaseModeConfigInput,
		ec.unmarshalInputRemoveFavoriteProjectInput,
		ec.unmarshalInputRepoPermissionsOptions,
		ec.unmarshalInputRepoRefInput,
		ec.unmarshalInputRepoSettingsInput,
		ec.unmarshalInputRepotrackerConfigInput,
		ec.unmarshalInputResourceLimitsInput,
		ec.unmarshalInputRestartAdminTasksOptions,
		ec.unmarshalInputRuntimeEnvironmentConfigInput,
		ec.unmarshalInputS3CredentialsInput,
		ec.unmarshalInputSESConfigInput,
		ec.unmarshalInputSSHConfigInput,
		ec.unmarshalInputSSHKeyPairInput,
		ec.unmarshalInputSaveAdminSettingsInput,
		ec.unmarshalInputSaveDistroInput,
		ec.unmarshalInputSchedulerConfigInput,
		ec.unmarshalInputSecretsManagerConfigInput,
		ec.unmarshalInputSelectorInput,
		ec.unmarshalInputServiceFlagsInput,
		ec.unmarshalInputSetLastRevisionInput,
		ec.unmarshalInputSingleTaskDistroConfigInput,
		ec.unmarshalInputSlackConfigInput,
		ec.unmarshalInputSlackOptionsInput,
		ec.unmarshalInputSleepScheduleConfigInput,
		ec.unmarshalInputSleepScheduleInput,
		ec.unmarshalInputSortOrder,
		ec.unmarshalInputSpawnHostConfigInput,
		ec.unmarshalInputSpawnHostInput,
		ec.unmarshalInputSpawnVolumeInput,
		ec.unmarshalInputSplunkConfigInput,
		ec.unmarshalInputSplunkConnectionInfoInput,
		ec.unmarshalInputSubnetInput,
		ec.unmarshalInputSubscriberInput,
		ec.unmarshalInputSubscriptionInput,
		ec.unmarshalInputTaskAnnotationSettingsInput,
		ec.unmarshalInputTaskCountOptions,
		ec.unmarshalInputTaskFilterOptions,
		ec.unmarshalInputTaskHistoryOpts,
		ec.unmarshalInputTaskLimitsConfigInput,
		ec.unmarshalInputTaskPriority,
		ec.unmarshalInputTaskSpecifierInput,
		ec.unmarshalInputTestFilter,
		ec.unmarshalInputTestFilterOptions,
		ec.unmarshalInputTestSelectionConfigInput,
		ec.unmarshalInputTestSelectionSettingsInput,
		ec.unmarshalInputTestSortOptions,
		ec.unmarshalInputToolchainOpts,
		ec.unmarshalInputTracerSettingsInput,
		ec.unmarshalInputTriggerAliasInput,
		ec.unmarshalInputTriggerConfigInput,
		ec.unmarshalInputUIConfigInput,
		ec.unmarshalInputUpdateBetaFeaturesInput,
		ec.unmarshalInputUpdateParsleySettingsInput,
		ec.unmarshalInputUpdateSpawnHostStatusInput,
		ec.unmarshalInputUpdateVolumeInput,
		ec.unmarshalInputUseSpruceOptionsInput,
		ec.unmarshalInputUserSettingsInput,
		ec.unmarshalInputVariantTasks,
		ec.unmarshalInputVersionToRestart,
		ec.unmarshalInputVolumeHost,
		ec.unmarshalInputWaterfallOptions,
		ec.unmarshalInputWebhookHeaderInput,
		ec.unmarshalInputWebhookInput,
		ec.unmarshalInputWebhookSubscriberInput,
		ec.unmarshalInputWorkstationConfigInput,
		ec.unmarshalInputWorkstationSetupCommandInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "schema/directives.graphql" "schema/mutation.graphql" "schema/query.graphql" "schema/scalars.graphql" "schema/types/adminSettings/auth.graphql" "schema/types/adminSettings/background_processing.graphql" "schema/types/adminSettings/external_communications.graphql" "schema/types/adminSettings/other.graphql" "schema/types/adminSettings/providers.graphql" "schema/types/adminSettings/runners.graphql" "schema/types/adminSettings/service_flags.graphql" "schema/types/adminSettings/web.graphql" "schema/types/annotation.graphql" "schema/types/config.graphql" "schema/types/distro.graphql" "schema/types/host.graphql" "schema/types/image.graphql" "schema/types/issue_link.graphql" "schema/types/logkeeper.graphql" "schema/types/mainline_commits.graphql" "schema/types/patch.graphql" "schema/types/permissions.graphql" "schema/types/pod.graphql" "schema/types/project.graphql" "schema/types/project_settings.graphql" "schema/types/project_vars.graphql" "schema/types/repo_ref.graphql" "schema/types/repo_settings.graphql" "schema/types/spawn.graphql" "schema/types/subscriptions.graphql" "schema/types/task.graphql" "schema/types/task_history.graphql" "schema/types/task_logs.graphql" "schema/types/task_queue_item.graphql" "schema/types/ticket_fields.graphql" "schema/types/user.graphql" "schema/types/version.graphql" "schema/types/volume.graphql" "schema/types/waterfall.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema/directives.graphql", Input: sourceData("schema/directives.graphql"), BuiltIn: false},
	{Name: "schema/mutation.graphql", Input: sourceData("schema/mutation.graphql"), BuiltIn: false},
	{Name: "schema/query.graphql", Input: sourceData("schema/query.graphql"), BuiltIn: false},
	{Name: "schema/scalars.graphql", Input: sourceData("schema/scalars.graphql"), BuiltIn: false},
	{Name: "schema/types/adminSettings/auth.graphql", Input: sourceData("schema/types/adminSettings/auth.graphql"), BuiltIn: false},
	{Name: "schema/types/adminSettings/background_processing.graphql", Input: sourceData("schema/types/adminSettings/background_processing.graphql"), BuiltIn: false},
	{Name: "schema/types/adminSettings/external_communications.graphql", Input: sourceData("schema/types/adminSettings/external_communications.graphql"), BuiltIn: false},
	{Name: "schema/types/adminSettings/other.graphql", Input: sourceData("schema/types/adminSettings/other.graphql"), BuiltIn: false},
	{Name: "schema/types/adminSettings/providers.graphql", Input: sourceData("schema/types/adminSettings/providers.graphql"), BuiltIn: false},
	{Name: "schema/types/adminSettings/runners.graphql", Input: sourceData("schema/types/adminSettings/runners.graphql"), BuiltIn: false},
	{Name: "schema/types/adminSettings/service_flags.graphql", Input: sourceData("schema/types/adminSettings/service_flags.graphql"), BuiltIn: false},
	{Name: "schema/types/adminSettings/web.graphql", Input: sourceData("schema/types/adminSettings/web.graphql"), BuiltIn: false},
	{Name: "schema/types/annotation.graphql", Input: sourceData("schema/types/annotation.graphql"), BuiltIn: false},
	{Name: "schema/types/config.graphql", Input: sourceData("schema/types/config.graphql"), BuiltIn: false},
	{Name: "schema/types/distro.graphql", Input: sourceData("schema/types/distro.graphql"), BuiltIn: false},
	{Name: "schema/types/host.graphql", Input: sourceData("schema/types/host.graphql"), BuiltIn: false},
	{Name: "schema/types/image.graphql", Input: sourceData("schema/types/image.graphql"), BuiltIn: false},
	{Name: "schema/types/issue_link.graphql", Input: sourceData("schema/types/issue_link.graphql"), BuiltIn: false},
	{Name: "schema/types/logkeeper.graphql", Input: sourceData("schema/types/logkeeper.graphql"), BuiltIn: false},
	{Name: "schema/types/mainline_commits.graphql", Input: sourceData("schema/types/mainline_commits.graphql"), BuiltIn: false},
	{Name: "schema/types/patch.graphql", Input: sourceData("schema/types/patch.graphql"), BuiltIn: false},
	{Name: "schema/types/permissions.graphql", Input: sourceData("schema/types/permissions.graphql"), BuiltIn: false},
	{Name: "schema/types/pod.graphql", Input: sourceData("schema/types/pod.graphql"), BuiltIn: false},
	{Name: "schema/types/project.graphql", Input: sourceData("schema/types/project.graphql"), BuiltIn: false},
	{Name: "schema/types/project_settings.graphql", Input: sourceData("schema/types/project_settings.graphql"), BuiltIn: false},
	{Name: "schema/types/project_vars.graphql", Input: sourceData("schema/types/project_vars.graphql"), BuiltIn: false},
	{Name: "schema/types/repo_ref.graphql", Input: sourceData("schema/types/repo_ref.graphql"), BuiltIn: false},
	{Name: "schema/types/repo_settings.graphql", Input: sourceData("schema/types/repo_settings.graphql"), BuiltIn: false},
	{Name: "schema/types/spawn.graphql", Input: sourceData("schema/types/spawn.graphql"), BuiltIn: false},
	{Name: "schema/types/subscriptions.graphql", Input: sourceData("schema/types/subscriptions.graphql"), BuiltIn: false},
	{Name: "schema/types/task.graphql", Input: sourceData("schema/types/task.graphql"), BuiltIn: false},
	{Name: "schema/types/task_history.graphql", Input: sourceData("schema/types/task_history.graphql"), BuiltIn: false},
	{Name: "schema/types/task_logs.graphql", Input: sourceData("schema/types/task_logs.graphql"), BuiltIn: false},
	{Name: "schema/types/task_queue_item.graphql", Input: sourceData("schema/types/task_queue_item.graphql"), BuiltIn: false},
	{Name: "schema/types/ticket_fields.graphql", Input: sourceData("schema/types/ticket_fields.graphql"), BuiltIn: false},
	{Name: "schema/types/user.graphql", Input: sourceData("schema/types/user.graphql"), BuiltIn: false},
	{Name: "schema/types/version.graphql", Input: sourceData("schema/types/version.graphql"), BuiltIn: false},
	{Name: "schema/types/volume.graphql", Input: sourceData("schema/types/volume.graphql"), BuiltIn: false},
	{Name: "schema/types/waterfall.graphql", Input: sourceData("schema/types/waterfall.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_requireDistroAccess_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "access", ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess)
	if err != nil {
		return nil, err
	}
	args["access"] = arg0
	return args, nil
}

func (ec *executionContext) dir_requireHostAccess_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "access", ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel)
	if err != nil {
		return nil, err
	}
	args["access"] = arg0
	return args, nil
}

func (ec *executionContext) dir_requireProjectAccess_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "permission", ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission)
	if err != nil {
		return nil, err
	}
	args["permission"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "access", ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel)
	if err != nil {
		return nil, err
	}
	args["access"] = arg1
	return args, nil
}

func (ec *executionContext) field_Host_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNHostEventsInput2githubcomevergreencievergreengraphqlHostEventsInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Image_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "page", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["page"] = arg1
	return args, nil
}

func (ec *executionContext) field_Image_files_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNImageFileOpts2githubcomevergreencievergreenthirdpartyFileFilterOptions)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Image_operatingSystem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNOperatingSystemOpts2githubcomevergreencievergreenthirdpartyOSInfoFilterOptions)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Image_packages_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNPackageOpts2githubcomevergreencievergreenthirdpartyPackageFilterOptions)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Image_toolchains_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNToolchainOpts2githubcomevergreencievergreenthirdpartyToolchainFilterOptions)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_abortTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_abortTask_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_abortTask_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_addAnnotationIssue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "execution", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "apiIssue", ec.unmarshalNIssueLinkInput2githubcomevergreencievergreenrestmodelAPIIssueLink)
	if err != nil {
		return nil, err
	}
	args["apiIssue"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "isIssue", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["isIssue"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_addFavoriteProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNAddFavoriteProjectInput2githubcomevergreencievergreengraphqlAddFavoriteProjectInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_attachProjectToNewRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "project", ec.unmarshalNMoveProjectInput2githubcomevergreencievergreengraphqlMoveProjectInput)
	if err != nil {
		return nil, err
	}
	args["project"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_attachProjectToRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_attachProjectToRepo_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_attachProjectToRepo_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_attachVolumeToHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "volumeAndHost", ec.unmarshalNVolumeHost2githubcomevergreencievergreengraphqlVolumeHost)
	if err != nil {
		return nil, err
	}
	args["volumeAndHost"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bbCreateTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "execution", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_copyDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_copyDistro_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_copyDistro_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (model.CopyDistroOpts, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal model.CopyDistroOpts
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["opts"]
		if !ok {
			var zeroVal model.CopyDistroOpts
			return zeroVal, nil
		}
		return ec.unmarshalNCopyDistroInput2githubcomevergreencievergreenrestmodelCopyDistroOpts(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "CREATE")
		if err != nil {
			var zeroVal model.CopyDistroOpts
			return zeroVal, err
		}
		if ec.directives.RequireDistroAccess == nil {
			var zeroVal model.CopyDistroOpts
			return zeroVal, errors.New("directive requireDistroAccess is not implemented")
		}
		return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal model.CopyDistroOpts
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(model.CopyDistroOpts); ok {
		return data, nil
	} else {
		var zeroVal model.CopyDistroOpts
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.CopyDistroOpts`, tmp))
	}
}

func (ec *executionContext) field_Mutation_copyProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_copyProject_argsProject(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["project"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "requestS3Creds", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["requestS3Creds"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_copyProject_argsProject(
	ctx context.Context,
	rawArgs map[string]any,
) (model.CopyProjectOpts, error) {
	if _, ok := rawArgs["project"]; !ok {
		var zeroVal model.CopyProjectOpts
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["project"]
		if !ok {
			var zeroVal model.CopyProjectOpts
			return zeroVal, nil
		}
		return ec.unmarshalNCopyProjectInput2githubcomevergreencievergreenrestmodelCopyProjectOpts(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal model.CopyProjectOpts
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal model.CopyProjectOpts
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(model.CopyProjectOpts); ok {
		return data, nil
	} else {
		var zeroVal model.CopyProjectOpts
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.CopyProjectOpts`, tmp))
	}
}

func (ec *executionContext) field_Mutation_createDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_createDistro_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createDistro_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (CreateDistroInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal CreateDistroInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["opts"]
		if !ok {
			var zeroVal CreateDistroInput
			return zeroVal, nil
		}
		return ec.unmarshalNCreateDistroInput2githubcomevergreencievergreengraphqlCreateDistroInput(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "CREATE")
		if err != nil {
			var zeroVal CreateDistroInput
			return zeroVal, err
		}
		if ec.directives.RequireDistroAccess == nil {
			var zeroVal CreateDistroInput
			return zeroVal, errors.New("directive requireDistroAccess is not implemented")
		}
		return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal CreateDistroInput
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(CreateDistroInput); ok {
		return data, nil
	} else {
		var zeroVal CreateDistroInput
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/graphql.CreateDistroInput`, tmp))
	}
}

func (ec *executionContext) field_Mutation_createProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_createProject_argsProject(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["project"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "requestS3Creds", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["requestS3Creds"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createProject_argsProject(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APIProjectRef, error) {
	if _, ok := rawArgs["project"]; !ok {
		var zeroVal model.APIProjectRef
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["project"]
		if !ok {
			var zeroVal model.APIProjectRef
			return zeroVal, nil
		}
		return ec.unmarshalNCreateProjectInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal model.APIProjectRef
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal model.APIProjectRef
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(model.APIProjectRef); ok {
		return data, nil
	} else {
		var zeroVal model.APIProjectRef
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectRef`, tmp))
	}
}

func (ec *executionContext) field_Mutation_createPublicKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "publicKeyInput", ec.unmarshalNPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput)
	if err != nil {
		return nil, err
	}
	args["publicKeyInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deactivateStepbackTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNDeactivateStepbackTaskInput2githubcomevergreencievergreengraphqlDeactivateStepbackTaskInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_defaultSectionToRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNDefaultSectionToRepoInput2githubcomevergreencievergreengraphqlDefaultSectionToRepoInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNDeleteDistroInput2githubcomevergreencievergreengraphqlDeleteDistroInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGithubAppCredentials_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNDeleteGithubAppCredentialsInput2githubcomevergreencievergreengraphqlDeleteGithubAppCredentialsInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_deleteProject_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteProject_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_deleteSubscriptions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "subscriptionIds", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["subscriptionIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_detachProjectFromRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_detachProjectFromRepo_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_detachProjectFromRepo_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_detachVolumeFromHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "volumeId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["volumeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_editAnnotationNote_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "execution", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "originalMessage", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["originalMessage"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "newMessage", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["newMessage"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_editSpawnHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "spawnHost", ec.unmarshalOEditSpawnHostInput2githubcomevergreencievergreengraphqlEditSpawnHostInput)
	if err != nil {
		return nil, err
	}
	args["spawnHost"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_forceRepotrackerRun_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_forceRepotrackerRun_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_forceRepotrackerRun_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_migrateVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "volumeId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["volumeId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "spawnHostInput", ec.unmarshalOSpawnHostInput2githubcomevergreencievergreengraphqlSpawnHostInput)
	if err != nil {
		return nil, err
	}
	args["spawnHostInput"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_moveAnnotationIssue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "execution", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "apiIssue", ec.unmarshalNIssueLinkInput2githubcomevergreencievergreenrestmodelAPIIssueLink)
	if err != nil {
		return nil, err
	}
	args["apiIssue"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "isIssue", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["isIssue"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_overrideTaskDependencies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_overrideTaskDependencies_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_overrideTaskDependencies_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_promoteVarsToRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNPromoteVarsToRepoInput2githubcomevergreencievergreengraphqlPromoteVarsToRepoInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_quarantineTest_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNQuarantineTestInput2githubcomevergreencievergreengraphqlQuarantineTestInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeAnnotationIssue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "execution", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "apiIssue", ec.unmarshalNIssueLinkInput2githubcomevergreencievergreenrestmodelAPIIssueLink)
	if err != nil {
		return nil, err
	}
	args["apiIssue"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "isIssue", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["isIssue"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_removeFavoriteProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNRemoveFavoriteProjectInput2githubcomevergreencievergreengraphqlRemoveFavoriteProjectInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removePublicKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "keyName", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["keyName"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "volumeId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["volumeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_reprovisionToNew_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_reprovisionToNew_argsHostIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_reprovisionToNew_argsHostIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["hostIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal []string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartAdminTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNRestartAdminTasksOptions2githubcomevergreencievergreenmodelRestartOptions)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_restartJasper_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_restartJasper_argsHostIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_restartJasper_argsHostIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["hostIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal []string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_restartTask_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "failedOnly", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["failedOnly"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_restartTask_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartVersions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_restartVersions_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "abort", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["abort"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "versionsToRestart", ec.unmarshalNVersionToRestart2githubcomevergreencievergreenmodelVersionToRestart)
	if err != nil {
		return nil, err
	}
	args["versionsToRestart"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_restartVersions_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_saveAdminSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "adminSettings", ec.unmarshalNAdminSettingsInput2githubcomevergreencievergreenrestmodelAPIAdminSettings)
	if err != nil {
		return nil, err
	}
	args["adminSettings"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_saveDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNSaveDistroInput2githubcomevergreencievergreengraphqlSaveDistroInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_saveProjectSettingsForSection_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectSettings", ec.unmarshalOProjectSettingsInput2githubcomevergreencievergreenrestmodelAPIProjectSettings)
	if err != nil {
		return nil, err
	}
	args["projectSettings"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "section", ec.unmarshalNProjectSettingsSection2githubcomevergreencievergreengraphqlProjectSettingsSection)
	if err != nil {
		return nil, err
	}
	args["section"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_saveRepoSettingsForSection_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "repoSettings", ec.unmarshalORepoSettingsInput2githubcomevergreencievergreenrestmodelAPIProjectSettings)
	if err != nil {
		return nil, err
	}
	args["repoSettings"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "section", ec.unmarshalNProjectSettingsSection2githubcomevergreencievergreengraphqlProjectSettingsSection)
	if err != nil {
		return nil, err
	}
	args["section"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_saveSubscription_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "subscription", ec.unmarshalNSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription)
	if err != nil {
		return nil, err
	}
	args["subscription"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_schedulePatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_schedulePatch_argsPatchID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "configure", ec.unmarshalNPatchConfigure2githubcomevergreencievergreengraphqlPatchConfigure)
	if err != nil {
		return nil, err
	}
	args["configure"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_schedulePatch_argsPatchID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["patchId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["patchId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "PATCHES")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_scheduleTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_scheduleTasks_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "taskIds", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["taskIds"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_scheduleTasks_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_scheduleUndispatchedBaseTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_scheduleUndispatchedBaseTasks_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_scheduleUndispatchedBaseTasks_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setAnnotationMetadataLinks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "taskId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "execution", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "metadataLinks", ec.unmarshalNMetadataLinkInput2githubcomevergreencievergreenrestmodelAPIMetadataLink)
	if err != nil {
		return nil, err
	}
	args["metadataLinks"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_setLastRevision_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_setLastRevision_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setLastRevision_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (SetLastRevisionInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal SetLastRevisionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["opts"]
		if !ok {
			var zeroVal SetLastRevisionInput
			return zeroVal, nil
		}
		return ec.unmarshalNSetLastRevisionInput2githubcomevergreencievergreengraphqlSetLastRevisionInput(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal SetLastRevisionInput
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal SetLastRevisionInput
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(SetLastRevisionInput); ok {
		return data, nil
	} else {
		var zeroVal SetLastRevisionInput
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/graphql.SetLastRevisionInput`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setPatchVisibility_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_setPatchVisibility_argsPatchIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchIds"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "hidden", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["hidden"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setPatchVisibility_argsPatchIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["patchIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["patchIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequirePatchOwner == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requirePatchOwner is not implemented")
		}
		return ec.directives.RequirePatchOwner(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setTaskPriorities_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "taskPriorities", ec.unmarshalNTaskPriority2githubcomevergreencievergreengraphqlTaskPriority)
	if err != nil {
		return nil, err
	}
	args["taskPriorities"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setTaskPriority_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_setTaskPriority_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "priority", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["priority"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setTaskPriority_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setVersionPriority_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_setVersionPriority_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "priority", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["priority"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setVersionPriority_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_spawnHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "spawnHostInput", ec.unmarshalOSpawnHostInput2githubcomevergreencievergreengraphqlSpawnHostInput)
	if err != nil {
		return nil, err
	}
	args["spawnHostInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_spawnVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "spawnVolumeInput", ec.unmarshalNSpawnVolumeInput2githubcomevergreencievergreengraphqlSpawnVolumeInput)
	if err != nil {
		return nil, err
	}
	args["spawnVolumeInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unscheduleTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_unscheduleTask_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unscheduleTask_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_unscheduleVersionTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_unscheduleVersionTasks_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "abort", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["abort"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_unscheduleVersionTasks_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_updateBetaFeatures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNUpdateBetaFeaturesInput2githubcomevergreencievergreengraphqlUpdateBetaFeaturesInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateHostStatus_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Mutation_updateHostStatus_argsHostIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostIds"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "status", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["status"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "notes", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["notes"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updateHostStatus_argsHostIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["hostIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal []string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_updateParsleySettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNUpdateParsleySettingsInput2githubcomevergreencievergreengraphqlUpdateParsleySettingsInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePublicKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "targetKeyName", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["targetKeyName"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "updateInfo", ec.unmarshalNPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput)
	if err != nil {
		return nil, err
	}
	args["updateInfo"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSpawnHostStatus_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "updateSpawnHostStatusInput", ec.unmarshalNUpdateSpawnHostStatusInput2githubcomevergreencievergreengraphqlUpdateSpawnHostStatusInput)
	if err != nil {
		return nil, err
	}
	args["updateSpawnHostStatusInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "userSettings", ec.unmarshalOUserSettingsInput2githubcomevergreencievergreenrestmodelAPIUserSettings)
	if err != nil {
		return nil, err
	}
	args["userSettings"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "updateVolumeInput", ec.unmarshalNUpdateVolumeInput2githubcomevergreencievergreengraphqlUpdateVolumeInput)
	if err != nil {
		return nil, err
	}
	args["updateVolumeInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Permissions_distroPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNDistroPermissionsOptions2githubcomevergreencievergreengraphqlDistroPermissionsOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Permissions_projectPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNProjectPermissionsOptions2githubcomevergreencievergreengraphqlProjectPermissionsOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Permissions_repoPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNRepoPermissionsOptions2githubcomevergreencievergreengraphqlRepoPermissionsOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Pod_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "page", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["page"] = arg1
	return args, nil
}

func (ec *executionContext) field_Project_patches_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "patchesInput", ec.unmarshalNPatchesInput2githubcomevergreencievergreengraphqlPatchesInput)
	if err != nil {
		return nil, err
	}
	args["patchesInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_adminEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNAdminEventsInput2githubcomevergreencievergreengraphqlAdminEventsInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_adminTasksToRestart_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNRestartAdminTasksOptions2githubcomevergreencievergreenmodelRestartOptions)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_bbGetCreatedTickets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_bbGetCreatedTickets_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_bbGetCreatedTickets_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "ANNOTATIONS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_buildBaron_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_buildBaron_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "execution", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_buildBaron_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "ANNOTATIONS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_buildVariantsForTaskName_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_buildVariantsForTaskName_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "taskName", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["taskName"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_buildVariantsForTaskName_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_distroEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalNDistroEventsInput2githubcomevergreencievergreengraphqlDistroEventsInput)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_distroTaskQueue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "distroId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["distroId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_distro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_distro_argsDistroID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["distroId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_distro_argsDistroID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["distroId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["distroId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireDistroAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireDistroAccess is not implemented")
		}
		return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_distros_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "onlySpawnable", ec.unmarshalNBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["onlySpawnable"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_githubProjectConflicts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_githubProjectConflicts_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_githubProjectConflicts_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_hasVersion_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "patchId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["patchId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hostEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_hostEvents_argsHostID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "hostTag", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["hostTag"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "page", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["page"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_hostEvents_argsHostID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["hostId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_host_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_host_argsHostID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_host_argsHostID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["hostId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_hosts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "hostId", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["hostId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "distroId", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["distroId"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "currentTaskId", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["currentTaskId"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "statuses", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["statuses"] = arg3
	arg4, err := graphql.ProcessArgField(ctx, rawArgs, "startedBy", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["startedBy"] = arg4
	arg5, err := graphql.ProcessArgField(ctx, rawArgs, "sortBy", ec.unmarshalOHostSortBy2githubcomevergreencievergreengraphqlHostSortBy)
	if err != nil {
		return nil, err
	}
	args["sortBy"] = arg5
	arg6, err := graphql.ProcessArgField(ctx, rawArgs, "sortDir", ec.unmarshalOSortDirection2githubcomevergreencievergreengraphqlSortDirection)
	if err != nil {
		return nil, err
	}
	args["sortDir"] = arg6
	arg7, err := graphql.ProcessArgField(ctx, rawArgs, "page", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["page"] = arg7
	arg8, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg8
	return args, nil
}

func (ec *executionContext) field_Query_image_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "imageId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["imageId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_isRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "projectOrRepoId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["projectOrRepoId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_logkeeperBuildMetadata_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "buildId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["buildId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_mainlineCommits_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNMainlineCommitsOptions2githubcomevergreencievergreengraphqlMainlineCommitsOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "buildVariantOptions", ec.unmarshalOBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions)
	if err != nil {
		return nil, err
	}
	args["buildVariantOptions"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_patch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_patch_argsPatchID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_patch_argsPatchID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["patchId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["patchId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_pod_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "podId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["podId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_projectEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_projectEvents_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOTime2timeTime)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_projectEvents_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_projectSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_projectSettings_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_projectSettings_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_project_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_project_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_project_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_repoEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_repoEvents_argsRepoID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["repoId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "before", ec.unmarshalOTime2timeTime)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_repoEvents_argsRepoID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["repoId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["repoId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_repoSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_repoSettings_argsRepoID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["repoId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_repoSettings_argsRepoID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["repoId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["repoId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskAllExecutions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_taskAllExecutions_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_taskAllExecutions_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskHistory_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNTaskHistoryOpts2githubcomevergreencievergreengraphqlTaskHistoryOpts)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_taskNamesForBuildVariant_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_taskNamesForBuildVariant_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "buildVariant", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["buildVariant"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_taskNamesForBuildVariant_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskTestSample_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_taskTestSample_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "taskIds", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["taskIds"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "filters", ec.unmarshalNTestFilter2githubcomevergreencievergreengraphqlTestFilter)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_taskTestSample_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_task_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_task_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "execution", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_task_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "userId", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_version_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}

	arg0, err := ec.field_Query_version_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_version_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_waterfall_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNWaterfallOptions2githubcomevergreencievergreengraphqlWaterfallOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Task_tests_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "opts", ec.unmarshalOTestFilterOptions2githubcomevergreencievergreengraphqlTestFilterOptions)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_User_patches_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "patchesInput", ec.unmarshalNPatchesInput2githubcomevergreencievergreengraphqlPatchesInput)
	if err != nil {
		return nil, err
	}
	args["patchesInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Version_buildVariantStats_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Version_buildVariants_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Version_taskCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalOTaskCountOptions2githubcomevergreencievergreengraphqlTaskCountOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Version_taskStatusStats_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Version_tasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "options", ec.unmarshalNTaskFilterOptions2githubcomevergreencievergreengraphqlTaskFilterOptions)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _APIConfig_httpListenAddr(ctx context.Context, field graphql.CollectedField, obj *model.APIapiConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_APIConfig_httpListenAddr,
		func(ctx context.Context) (any, error) {
			return obj.HttpListenAddr, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_APIConfig_httpListenAddr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APIapiConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_APIConfig_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_APIConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIConfig_corpUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIapiConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_APIConfig_corpUrl,
		func(ctx context.Context) (any, error) {
			return obj.CorpURL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_APIConfig_corpUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSAccountRoleMapping_account(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSAccountRoleMapping) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSAccountRoleMapping_account,
		func(ctx context.Context) (any, error) {
			return obj.Account, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AWSAccountRoleMapping_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSAccountRoleMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSAccountRoleMapping_role(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSAccountRoleMapping) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSAccountRoleMapping_role,
		func(ctx context.Context) (any, error) {
			return obj.Role, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AWSAccountRoleMapping_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSAccountRoleMapping",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_ec2Keys(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_ec2Keys,
		func(ctx context.Context) (any, error) {
			return obj.EC2Keys, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal []model.APIEC2Key
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNEC2Key2githubcomevergreencievergreenrestmodelAPIEC2Key,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_ec2Keys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_EC2Key_name(ctx, field)
			case "key":
				return ec.fieldContext_EC2Key_key(ctx, field)
			case "secret":
				return ec.fieldContext_EC2Key_secret(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EC2Key", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_subnets(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_subnets,
		func(ctx context.Context) (any, error) {
			return obj.Subnets, nil
		},
		nil,
		ec.marshalNSubnet2githubcomevergreencievergreenrestmodelAPISubnet,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_subnets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "az":
				return ec.fieldContext_Subnet_az(ctx, field)
			case "subnetId":
				return ec.fieldContext_Subnet_subnetId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Subnet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_parserProject(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_parserProject,
		func(ctx context.Context) (any, error) {
			return obj.ParserProject, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *model.APIParserProjectS3Config
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOParserProjectS3Config2githubcomevergreencievergreenrestmodelAPIParserProjectS3Config,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_parserProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ParserProjectS3Config_key(ctx, field)
			case "secret":
				return ec.fieldContext_ParserProjectS3Config_secret(ctx, field)
			case "bucket":
				return ec.fieldContext_ParserProjectS3Config_bucket(ctx, field)
			case "prefix":
				return ec.fieldContext_ParserProjectS3Config_prefix(ctx, field)
			case "generatedJSONPrefix":
				return ec.fieldContext_ParserProjectS3Config_generatedJSONPrefix(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParserProjectS3Config", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_persistentDNS(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_persistentDNS,
		func(ctx context.Context) (any, error) {
			return obj.PersistentDNS, nil
		},
		nil,
		ec.marshalOPersistentDNSConfig2githubcomevergreencievergreenrestmodelAPIPersistentDNSConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_persistentDNS(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hostedZoneID":
				return ec.fieldContext_PersistentDNSConfig_hostedZoneID(ctx, field)
			case "domain":
				return ec.fieldContext_PersistentDNSConfig_domain(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PersistentDNSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_defaultSecurityGroup(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_defaultSecurityGroup,
		func(ctx context.Context) (any, error) {
			return obj.DefaultSecurityGroup, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_defaultSecurityGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_allowedInstanceTypes(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_allowedInstanceTypes,
		func(ctx context.Context) (any, error) {
			return obj.AllowedInstanceTypes, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_allowedInstanceTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_alertableInstanceTypes(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_alertableInstanceTypes,
		func(ctx context.Context) (any, error) {
			return obj.AlertableInstanceTypes, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_alertableInstanceTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_allowedRegions(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_allowedRegions,
		func(ctx context.Context) (any, error) {
			return obj.AllowedRegions, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_allowedRegions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_maxVolumeSizePerUser(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_maxVolumeSizePerUser,
		func(ctx context.Context) (any, error) {
			return obj.MaxVolumeSizePerUser, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_maxVolumeSizePerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_pod(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_pod,
		func(ctx context.Context) (any, error) {
			return obj.Pod, nil
		},
		nil,
		ec.marshalOAWSPodConfig2githubcomevergreencievergreenrestmodelAPIAWSPodConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_pod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "role":
				return ec.fieldContext_AWSPodConfig_role(ctx, field)
			case "region":
				return ec.fieldContext_AWSPodConfig_region(ctx, field)
			case "ecs":
				return ec.fieldContext_AWSPodConfig_ecs(ctx, field)
			case "secretsManager":
				return ec.fieldContext_AWSPodConfig_secretsManager(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AWSPodConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_accountRoles(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_accountRoles,
		func(ctx context.Context) (any, error) {
			return obj.AccountRoles, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal []model.APIAWSAccountRoleMapping
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNAWSAccountRoleMapping2githubcomevergreencievergreenrestmodelAPIAWSAccountRoleMapping,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_accountRoles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "account":
				return ec.fieldContext_AWSAccountRoleMapping_account(ctx, field)
			case "role":
				return ec.fieldContext_AWSAccountRoleMapping_role(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AWSAccountRoleMapping", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_ipamPoolID(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_ipamPoolID,
		func(ctx context.Context) (any, error) {
			return obj.IPAMPoolID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_ipamPoolID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_elasticIPUsageRate(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSConfig_elasticIPUsageRate,
		func(ctx context.Context) (any, error) {
			return obj.ElasticIPUsageRate, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSConfig_elasticIPUsageRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSPodConfig_role(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSPodConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSPodConfig_role,
		func(ctx context.Context) (any, error) {
			return obj.Role, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSPodConfig_role(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSPodConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSPodConfig_region(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSPodConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSPodConfig_region,
		func(ctx context.Context) (any, error) {
			return obj.Region, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSPodConfig_region(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSPodConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSPodConfig_ecs(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSPodConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSPodConfig_ecs,
		func(ctx context.Context) (any, error) {
			return obj.ECS, nil
		},
		nil,
		ec.marshalOECSConfig2githubcomevergreencievergreenrestmodelAPIECSConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSPodConfig_ecs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSPodConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxCPU":
				return ec.fieldContext_ECSConfig_maxCPU(ctx, field)
			case "maxMemoryMb":
				return ec.fieldContext_ECSConfig_maxMemoryMb(ctx, field)
			case "taskDefinitionPrefix":
				return ec.fieldContext_ECSConfig_taskDefinitionPrefix(ctx, field)
			case "taskRole":
				return ec.fieldContext_ECSConfig_taskRole(ctx, field)
			case "executionRole":
				return ec.fieldContext_ECSConfig_executionRole(ctx, field)
			case "logRegion":
				return ec.fieldContext_ECSConfig_logRegion(ctx, field)
			case "logGroup":
				return ec.fieldContext_ECSConfig_logGroup(ctx, field)
			case "logStreamPrefix":
				return ec.fieldContext_ECSConfig_logStreamPrefix(ctx, field)
			case "awsVPC":
				return ec.fieldContext_ECSConfig_awsVPC(ctx, field)
			case "clusters":
				return ec.fieldContext_ECSConfig_clusters(ctx, field)
			case "capacityProviders":
				return ec.fieldContext_ECSConfig_capacityProviders(ctx, field)
			case "allowedImages":
				return ec.fieldContext_ECSConfig_allowedImages(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ECSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSPodConfig_secretsManager(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSPodConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSPodConfig_secretsManager,
		func(ctx context.Context) (any, error) {
			return obj.SecretsManager, nil
		},
		nil,
		ec.marshalOSecretsManagerConfig2githubcomevergreencievergreenrestmodelAPISecretsManagerConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AWSPodConfig_secretsManager(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSPodConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "secretPrefix":
				return ec.fieldContext_SecretsManagerConfig_secretPrefix(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SecretsManagerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSVPCConfig_subnets(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSVPCConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSVPCConfig_subnets,
		func(ctx context.Context) (any, error) {
			return obj.Subnets, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AWSVPCConfig_subnets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSVPCConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSVPCConfig_securityGroups(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSVPCConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AWSVPCConfig_securityGroups,
		func(ctx context.Context) (any, error) {
			return obj.SecurityGroups, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal []string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AWSVPCConfig_securityGroups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSVPCConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_buildVariantDisplayName(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AbortInfo_buildVariantDisplayName,
		func(ctx context.Context) (any, error) {
			return obj.BuildVariantDisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AbortInfo_buildVariantDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_newVersion(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AbortInfo_newVersion,
		func(ctx context.Context) (any, error) {
			return obj.NewVersion, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AbortInfo_newVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_prClosed(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AbortInfo_prClosed,
		func(ctx context.Context) (any, error) {
			return obj.PrClosed, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AbortInfo_prClosed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_taskDisplayName(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AbortInfo_taskDisplayName,
		func(ctx context.Context) (any, error) {
			return obj.TaskDisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AbortInfo_taskDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_taskID(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AbortInfo_taskID,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AbortInfo_taskID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_user(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AbortInfo_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AbortInfo_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEvent_section(ctx context.Context, field graphql.CollectedField, obj *AdminEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminEvent_section,
		func(ctx context.Context) (any, error) {
			return obj.Section, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminEvent_section(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEvent_after(ctx context.Context, field graphql.CollectedField, obj *AdminEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminEvent_after,
		func(ctx context.Context) (any, error) {
			return obj.After, nil
		},
		nil,
		ec.marshalOMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminEvent_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEvent_before(ctx context.Context, field graphql.CollectedField, obj *AdminEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminEvent_before,
		func(ctx context.Context) (any, error) {
			return obj.Before, nil
		},
		nil,
		ec.marshalOMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminEvent_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *AdminEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminEvent_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AdminEvent_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEvent_user(ctx context.Context, field graphql.CollectedField, obj *AdminEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminEvent_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AdminEvent_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEventsPayload_count(ctx context.Context, field graphql.CollectedField, obj *AdminEventsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminEventsPayload_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AdminEventsPayload_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEventsPayload_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *AdminEventsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminEventsPayload_eventLogEntries,
		func(ctx context.Context) (any, error) {
			return obj.EventLogEntries, nil
		},
		nil,
		ec.marshalNAdminEvent2githubcomevergreencievergreengraphqlAdminEvent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AdminEventsPayload_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "section":
				return ec.fieldContext_AdminEvent_section(ctx, field)
			case "after":
				return ec.fieldContext_AdminEvent_after(ctx, field)
			case "before":
				return ec.fieldContext_AdminEvent_before(ctx, field)
			case "timestamp":
				return ec.fieldContext_AdminEvent_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_AdminEvent_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_amboy(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_amboy,
		func(ctx context.Context) (any, error) {
			return obj.Amboy, nil
		},
		nil,
		ec.marshalOAmboyConfig2githubcomevergreencievergreenrestmodelAPIAmboyConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_amboy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_AmboyConfig_name(ctx, field)
			case "singleName":
				return ec.fieldContext_AmboyConfig_singleName(ctx, field)
			case "poolSizeLocal":
				return ec.fieldContext_AmboyConfig_poolSizeLocal(ctx, field)
			case "poolSizeRemote":
				return ec.fieldContext_AmboyConfig_poolSizeRemote(ctx, field)
			case "localStorage":
				return ec.fieldContext_AmboyConfig_localStorage(ctx, field)
			case "groupDefaultWorkers":
				return ec.fieldContext_AmboyConfig_groupDefaultWorkers(ctx, field)
			case "groupBackgroundCreateFrequencyMinutes":
				return ec.fieldContext_AmboyConfig_groupBackgroundCreateFrequencyMinutes(ctx, field)
			case "groupPruneFrequencyMinutes":
				return ec.fieldContext_AmboyConfig_groupPruneFrequencyMinutes(ctx, field)
			case "groupTTLMinutes":
				return ec.fieldContext_AmboyConfig_groupTTLMinutes(ctx, field)
			case "lockTimeoutMinutes":
				return ec.fieldContext_AmboyConfig_lockTimeoutMinutes(ctx, field)
			case "sampleSize":
				return ec.fieldContext_AmboyConfig_sampleSize(ctx, field)
			case "retry":
				return ec.fieldContext_AmboyConfig_retry(ctx, field)
			case "namedQueues":
				return ec.fieldContext_AmboyConfig_namedQueues(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AmboyConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_amboyDB(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_amboyDB,
		func(ctx context.Context) (any, error) {
			return obj.AmboyDB, nil
		},
		nil,
		ec.marshalOAmboyDBConfig2githubcomevergreencievergreenrestmodelAPIAmboyDBConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_amboyDB(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_AmboyDBConfig_url(ctx, field)
			case "database":
				return ec.fieldContext_AmboyDBConfig_database(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AmboyDBConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_api(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_api,
		func(ctx context.Context) (any, error) {
			return obj.Api, nil
		},
		nil,
		ec.marshalOAPIConfig2githubcomevergreencievergreenrestmodelAPIapiConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_api(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "httpListenAddr":
				return ec.fieldContext_APIConfig_httpListenAddr(ctx, field)
			case "url":
				return ec.fieldContext_APIConfig_url(ctx, field)
			case "corpUrl":
				return ec.fieldContext_APIConfig_corpUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_authConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_authConfig,
		func(ctx context.Context) (any, error) {
			return obj.AuthConfig, nil
		},
		nil,
		ec.marshalOAuthConfig2githubcomevergreencievergreenrestmodelAPIAuthConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_authConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "okta":
				return ec.fieldContext_AuthConfig_okta(ctx, field)
			case "naive":
				return ec.fieldContext_AuthConfig_naive(ctx, field)
			case "github":
				return ec.fieldContext_AuthConfig_github(ctx, field)
			case "multi":
				return ec.fieldContext_AuthConfig_multi(ctx, field)
			case "kanopy":
				return ec.fieldContext_AuthConfig_kanopy(ctx, field)
			case "oauth":
				return ec.fieldContext_AuthConfig_oauth(ctx, field)
			case "preferredType":
				return ec.fieldContext_AuthConfig_preferredType(ctx, field)
			case "backgroundReauthMinutes":
				return ec.fieldContext_AuthConfig_backgroundReauthMinutes(ctx, field)
			case "allowServiceUsers":
				return ec.fieldContext_AuthConfig_allowServiceUsers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_banner,
		func(ctx context.Context) (any, error) {
			return obj.Banner, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_banner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_bannerTheme(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_bannerTheme,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.AdminSettings().BannerTheme(ctx, obj)
		},
		nil,
		ec.marshalOBannerTheme2githubcomevergreencievergreenBannerTheme,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_bannerTheme(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BannerTheme does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_buckets(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_buckets,
		func(ctx context.Context) (any, error) {
			return obj.Buckets, nil
		},
		nil,
		ec.marshalOBucketsConfig2githubcomevergreencievergreenrestmodelAPIBucketsConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_buckets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "logBucket":
				return ec.fieldContext_BucketsConfig_logBucket(ctx, field)
			case "logBucketLongRetention":
				return ec.fieldContext_BucketsConfig_logBucketLongRetention(ctx, field)
			case "logBucketFailedTasks":
				return ec.fieldContext_BucketsConfig_logBucketFailedTasks(ctx, field)
			case "longRetentionProjects":
				return ec.fieldContext_BucketsConfig_longRetentionProjects(ctx, field)
			case "testResultsBucket":
				return ec.fieldContext_BucketsConfig_testResultsBucket(ctx, field)
			case "internalBuckets":
				return ec.fieldContext_BucketsConfig_internalBuckets(ctx, field)
			case "credentials":
				return ec.fieldContext_BucketsConfig_credentials(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketsConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_cedar(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_cedar,
		func(ctx context.Context) (any, error) {
			return obj.Cedar, nil
		},
		nil,
		ec.marshalOCedarConfig2githubcomevergreencievergreenrestmodelAPICedarConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_cedar(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dbUrl":
				return ec.fieldContext_CedarConfig_dbUrl(ctx, field)
			case "dbName":
				return ec.fieldContext_CedarConfig_dbName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CedarConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_configDir(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_configDir,
		func(ctx context.Context) (any, error) {
			return obj.ConfigDir, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_configDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_containerPools(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_containerPools,
		func(ctx context.Context) (any, error) {
			return obj.ContainerPools, nil
		},
		nil,
		ec.marshalOContainerPoolsConfig2githubcomevergreencievergreenrestmodelAPIContainerPoolsConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_containerPools(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pools":
				return ec.fieldContext_ContainerPoolsConfig_pools(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerPoolsConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_cost(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_cost,
		func(ctx context.Context) (any, error) {
			return obj.Cost, nil
		},
		nil,
		ec.marshalOCostConfig2githubcomevergreencievergreenrestmodelAPICostConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "financeFormula":
				return ec.fieldContext_CostConfig_financeFormula(ctx, field)
			case "savingsPlanDiscount":
				return ec.fieldContext_CostConfig_savingsPlanDiscount(ctx, field)
			case "onDemandDiscount":
				return ec.fieldContext_CostConfig_onDemandDiscount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CostConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_disabledGQLQueries(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_disabledGQLQueries,
		func(ctx context.Context) (any, error) {
			return obj.DisabledGQLQueries, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_disabledGQLQueries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_domainName(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_domainName,
		func(ctx context.Context) (any, error) {
			return obj.DomainName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_domainName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_expansions(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_expansions,
		func(ctx context.Context) (any, error) {
			return obj.Expansions, nil
		},
		nil,
		ec.marshalOStringMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_expansions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_fws(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_fws,
		func(ctx context.Context) (any, error) {
			return obj.FWS, nil
		},
		nil,
		ec.marshalOFWSConfig2githubcomevergreencievergreenrestmodelAPIFWSConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_fws(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_FWSConfig_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FWSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_graphite(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_graphite,
		func(ctx context.Context) (any, error) {
			return obj.Graphite, nil
		},
		nil,
		ec.marshalOGraphiteConfig2githubcomevergreencievergreenrestmodelAPIGraphiteConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_graphite(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ciOptimizationToken":
				return ec.fieldContext_GraphiteConfig_ciOptimizationToken(ctx, field)
			case "serverUrl":
				return ec.fieldContext_GraphiteConfig_serverUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GraphiteConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_githubCheckRun(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_githubCheckRun,
		func(ctx context.Context) (any, error) {
			return obj.GitHubCheckRun, nil
		},
		nil,
		ec.marshalOGitHubCheckRunConfig2githubcomevergreencievergreenrestmodelAPIGitHubCheckRunConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_githubCheckRun(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "checkRunLimit":
				return ec.fieldContext_GitHubCheckRunConfig_checkRunLimit(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitHubCheckRunConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_githubOrgs(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_githubOrgs,
		func(ctx context.Context) (any, error) {
			return obj.GithubOrgs, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_githubOrgs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_githubPRCreatorOrg(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_githubPRCreatorOrg,
		func(ctx context.Context) (any, error) {
			return obj.GithubPRCreatorOrg, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_githubPRCreatorOrg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_githubWebhookSecret(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_githubWebhookSecret,
		func(ctx context.Context) (any, error) {
			return obj.GithubWebhookSecret, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_githubWebhookSecret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_hostInit(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_hostInit,
		func(ctx context.Context) (any, error) {
			return obj.HostInit, nil
		},
		nil,
		ec.marshalOHostInitConfig2githubcomevergreencievergreenrestmodelAPIHostInitConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_hostInit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hostThrottle":
				return ec.fieldContext_HostInitConfig_hostThrottle(ctx, field)
			case "provisioningThrottle":
				return ec.fieldContext_HostInitConfig_provisioningThrottle(ctx, field)
			case "cloudStatusBatchSize":
				return ec.fieldContext_HostInitConfig_cloudStatusBatchSize(ctx, field)
			case "maxTotalDynamicHosts":
				return ec.fieldContext_HostInitConfig_maxTotalDynamicHosts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostInitConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_hostJasper(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_hostJasper,
		func(ctx context.Context) (any, error) {
			return obj.HostJasper, nil
		},
		nil,
		ec.marshalOHostJasperConfig2githubcomevergreencievergreenrestmodelAPIHostJasperConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_hostJasper(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "binaryName":
				return ec.fieldContext_HostJasperConfig_binaryName(ctx, field)
			case "downloadFileName":
				return ec.fieldContext_HostJasperConfig_downloadFileName(ctx, field)
			case "port":
				return ec.fieldContext_HostJasperConfig_port(ctx, field)
			case "url":
				return ec.fieldContext_HostJasperConfig_url(ctx, field)
			case "version":
				return ec.fieldContext_HostJasperConfig_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostJasperConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_jira(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_jira,
		func(ctx context.Context) (any, error) {
			return obj.Jira, nil
		},
		nil,
		ec.marshalOJiraConfig2githubcomevergreencievergreenrestmodelAPIJiraConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_jira(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "email":
				return ec.fieldContext_JiraConfig_email(ctx, field)
			case "host":
				return ec.fieldContext_JiraConfig_host(ctx, field)
			case "personalAccessToken":
				return ec.fieldContext_JiraConfig_personalAccessToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_jiraNotifications(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_jiraNotifications,
		func(ctx context.Context) (any, error) {
			return obj.JIRANotifications, nil
		},
		nil,
		ec.marshalOJiraNotificationsConfig2githubcomevergreencievergreenrestmodelAPIJIRANotificationsConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_jiraNotifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "customFields":
				return ec.fieldContext_JiraNotificationsConfig_customFields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraNotificationsConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_kanopySSHKeyPath(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_kanopySSHKeyPath,
		func(ctx context.Context) (any, error) {
			return obj.KanopySSHKeyPath, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_kanopySSHKeyPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_logPath(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_logPath,
		func(ctx context.Context) (any, error) {
			return obj.LogPath, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_logPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_loggerConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_loggerConfig,
		func(ctx context.Context) (any, error) {
			return obj.LoggerConfig, nil
		},
		nil,
		ec.marshalOLoggerConfig2githubcomevergreencievergreenrestmodelAPILoggerConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_loggerConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buffer":
				return ec.fieldContext_LoggerConfig_buffer(ctx, field)
			case "defaultLevel":
				return ec.fieldContext_LoggerConfig_defaultLevel(ctx, field)
			case "thresholdLevel":
				return ec.fieldContext_LoggerConfig_thresholdLevel(ctx, field)
			case "logkeeperURL":
				return ec.fieldContext_LoggerConfig_logkeeperURL(ctx, field)
			case "redactKeys":
				return ec.fieldContext_LoggerConfig_redactKeys(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoggerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_notify(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_notify,
		func(ctx context.Context) (any, error) {
			return obj.Notify, nil
		},
		nil,
		ec.marshalONotifyConfig2githubcomevergreencievergreenrestmodelAPINotifyConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_notify(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ses":
				return ec.fieldContext_NotifyConfig_ses(ctx, field)
			case "bufferTargetPerInterval":
				return ec.fieldContext_NotifyConfig_bufferTargetPerInterval(ctx, field)
			case "bufferIntervalSeconds":
				return ec.fieldContext_NotifyConfig_bufferIntervalSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotifyConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_oldestAllowedCLIVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_oldestAllowedCLIVersion,
		func(ctx context.Context) (any, error) {
			return obj.OldestAllowedCLIVersion, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_oldestAllowedCLIVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_parameterStore(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_parameterStore,
		func(ctx context.Context) (any, error) {
			return obj.ParameterStore, nil
		},
		nil,
		ec.marshalOParameterStoreConfig2githubcomevergreencievergreenrestmodelAPIParameterStoreConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_parameterStore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "prefix":
				return ec.fieldContext_ParameterStoreConfig_prefix(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParameterStoreConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_perfMonitoringKanopyURL(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_perfMonitoringKanopyURL,
		func(ctx context.Context) (any, error) {
			return obj.PerfMonitoringKanopyURL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_perfMonitoringKanopyURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_perfMonitoringURL(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_perfMonitoringURL,
		func(ctx context.Context) (any, error) {
			return obj.PerfMonitoringURL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_perfMonitoringURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_podLifecycle(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_podLifecycle,
		func(ctx context.Context) (any, error) {
			return obj.PodLifecycle, nil
		},
		nil,
		ec.marshalOPodLifecycleConfig2githubcomevergreencievergreenrestmodelAPIPodLifecycleConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_podLifecycle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxParallelPodRequests":
				return ec.fieldContext_PodLifecycleConfig_maxParallelPodRequests(ctx, field)
			case "maxPodDefinitionCleanupRate":
				return ec.fieldContext_PodLifecycleConfig_maxPodDefinitionCleanupRate(ctx, field)
			case "maxSecretCleanupRate":
				return ec.fieldContext_PodLifecycleConfig_maxSecretCleanupRate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodLifecycleConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_pprofPort(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_pprofPort,
		func(ctx context.Context) (any, error) {
			return obj.PprofPort, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_pprofPort(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_projectCreation(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_projectCreation,
		func(ctx context.Context) (any, error) {
			return obj.ProjectCreation, nil
		},
		nil,
		ec.marshalOProjectCreationConfig2githubcomevergreencievergreenrestmodelAPIProjectCreationConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_projectCreation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalProjectLimit":
				return ec.fieldContext_ProjectCreationConfig_totalProjectLimit(ctx, field)
			case "repoProjectLimit":
				return ec.fieldContext_ProjectCreationConfig_repoProjectLimit(ctx, field)
			case "repoExceptions":
				return ec.fieldContext_ProjectCreationConfig_repoExceptions(ctx, field)
			case "jiraProject":
				return ec.fieldContext_ProjectCreationConfig_jiraProject(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectCreationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_providers(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_providers,
		func(ctx context.Context) (any, error) {
			return obj.Providers, nil
		},
		nil,
		ec.marshalOCloudProviderConfig2githubcomevergreencievergreenrestmodelAPICloudProviders,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_providers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aws":
				return ec.fieldContext_CloudProviderConfig_aws(ctx, field)
			case "docker":
				return ec.fieldContext_CloudProviderConfig_docker(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CloudProviderConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_releaseMode(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_releaseMode,
		func(ctx context.Context) (any, error) {
			return obj.ReleaseMode, nil
		},
		nil,
		ec.marshalOReleaseModeConfig2githubcomevergreencievergreenrestmodelAPIReleaseModeConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_releaseMode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distroMaxHostsFactor":
				return ec.fieldContext_ReleaseModeConfig_distroMaxHostsFactor(ctx, field)
			case "targetTimeSecondsOverride":
				return ec.fieldContext_ReleaseModeConfig_targetTimeSecondsOverride(ctx, field)
			case "idleTimeSecondsOverride":
				return ec.fieldContext_ReleaseModeConfig_idleTimeSecondsOverride(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReleaseModeConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_repotracker(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_repotracker,
		func(ctx context.Context) (any, error) {
			return obj.RepoTracker, nil
		},
		nil,
		ec.marshalORepotrackerConfig2githubcomevergreencievergreenrestmodelAPIRepoTrackerConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_repotracker(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "numNewRepoRevisionsToFetch":
				return ec.fieldContext_RepotrackerConfig_numNewRepoRevisionsToFetch(ctx, field)
			case "maxRepoRevisionsToSearch":
				return ec.fieldContext_RepotrackerConfig_maxRepoRevisionsToSearch(ctx, field)
			case "maxConcurrentRequests":
				return ec.fieldContext_RepotrackerConfig_maxConcurrentRequests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepotrackerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_runtimeEnvironments(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_runtimeEnvironments,
		func(ctx context.Context) (any, error) {
			return obj.RuntimeEnvironments, nil
		},
		nil,
		ec.marshalORuntimeEnvironmentConfig2githubcomevergreencievergreenrestmodelAPIRuntimeEnvironmentsConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_runtimeEnvironments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "baseUrl":
				return ec.fieldContext_RuntimeEnvironmentConfig_baseUrl(ctx, field)
			case "apiKey":
				return ec.fieldContext_RuntimeEnvironmentConfig_apiKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeEnvironmentConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_scheduler(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_scheduler,
		func(ctx context.Context) (any, error) {
			return obj.Scheduler, nil
		},
		nil,
		ec.marshalOSchedulerConfig2githubcomevergreencievergreenrestmodelAPISchedulerConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_scheduler(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "taskFinder":
				return ec.fieldContext_SchedulerConfig_taskFinder(ctx, field)
			case "hostAllocator":
				return ec.fieldContext_SchedulerConfig_hostAllocator(ctx, field)
			case "hostAllocatorRoundingRule":
				return ec.fieldContext_SchedulerConfig_hostAllocatorRoundingRule(ctx, field)
			case "hostAllocatorFeedbackRule":
				return ec.fieldContext_SchedulerConfig_hostAllocatorFeedbackRule(ctx, field)
			case "hostsOverallocatedRule":
				return ec.fieldContext_SchedulerConfig_hostsOverallocatedRule(ctx, field)
			case "futureHostFraction":
				return ec.fieldContext_SchedulerConfig_futureHostFraction(ctx, field)
			case "cacheDurationSeconds":
				return ec.fieldContext_SchedulerConfig_cacheDurationSeconds(ctx, field)
			case "targetTimeSeconds":
				return ec.fieldContext_SchedulerConfig_targetTimeSeconds(ctx, field)
			case "acceptableHostIdleTimeSeconds":
				return ec.fieldContext_SchedulerConfig_acceptableHostIdleTimeSeconds(ctx, field)
			case "groupVersions":
				return ec.fieldContext_SchedulerConfig_groupVersions(ctx, field)
			case "patchFactor":
				return ec.fieldContext_SchedulerConfig_patchFactor(ctx, field)
			case "patchTimeInQueueFactor":
				return ec.fieldContext_SchedulerConfig_patchTimeInQueueFactor(ctx, field)
			case "commitQueueFactor":
				return ec.fieldContext_SchedulerConfig_commitQueueFactor(ctx, field)
			case "mainlineTimeInQueueFactor":
				return ec.fieldContext_SchedulerConfig_mainlineTimeInQueueFactor(ctx, field)
			case "expectedRuntimeFactor":
				return ec.fieldContext_SchedulerConfig_expectedRuntimeFactor(ctx, field)
			case "generateTaskFactor":
				return ec.fieldContext_SchedulerConfig_generateTaskFactor(ctx, field)
			case "numDependentsFactor":
				return ec.fieldContext_SchedulerConfig_numDependentsFactor(ctx, field)
			case "stepbackTaskFactor":
				return ec.fieldContext_SchedulerConfig_stepbackTaskFactor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SchedulerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_serviceFlags(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_serviceFlags,
		func(ctx context.Context) (any, error) {
			return obj.ServiceFlags, nil
		},
		nil,
		ec.marshalOServiceFlags2githubcomevergreencievergreenrestmodelAPIServiceFlags,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_serviceFlags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "taskDispatchDisabled":
				return ec.fieldContext_ServiceFlags_taskDispatchDisabled(ctx, field)
			case "hostInitDisabled":
				return ec.fieldContext_ServiceFlags_hostInitDisabled(ctx, field)
			case "podInitDisabled":
				return ec.fieldContext_ServiceFlags_podInitDisabled(ctx, field)
			case "largeParserProjectsDisabled":
				return ec.fieldContext_ServiceFlags_largeParserProjectsDisabled(ctx, field)
			case "monitorDisabled":
				return ec.fieldContext_ServiceFlags_monitorDisabled(ctx, field)
			case "alertsDisabled":
				return ec.fieldContext_ServiceFlags_alertsDisabled(ctx, field)
			case "agentStartDisabled":
				return ec.fieldContext_ServiceFlags_agentStartDisabled(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_ServiceFlags_repotrackerDisabled(ctx, field)
			case "schedulerDisabled":
				return ec.fieldContext_ServiceFlags_schedulerDisabled(ctx, field)
			case "checkBlockedTasksDisabled":
				return ec.fieldContext_ServiceFlags_checkBlockedTasksDisabled(ctx, field)
			case "githubPRTestingDisabled":
				return ec.fieldContext_ServiceFlags_githubPRTestingDisabled(ctx, field)
			case "cliUpdatesDisabled":
				return ec.fieldContext_ServiceFlags_cliUpdatesDisabled(ctx, field)
			case "backgroundStatsDisabled":
				return ec.fieldContext_ServiceFlags_backgroundStatsDisabled(ctx, field)
			case "taskLoggingDisabled":
				return ec.fieldContext_ServiceFlags_taskLoggingDisabled(ctx, field)
			case "cacheStatsJobDisabled":
				return ec.fieldContext_ServiceFlags_cacheStatsJobDisabled(ctx, field)
			case "cacheStatsEndpointDisabled":
				return ec.fieldContext_ServiceFlags_cacheStatsEndpointDisabled(ctx, field)
			case "taskReliabilityDisabled":
				return ec.fieldContext_ServiceFlags_taskReliabilityDisabled(ctx, field)
			case "hostAllocatorDisabled":
				return ec.fieldContext_ServiceFlags_hostAllocatorDisabled(ctx, field)
			case "podAllocatorDisabled":
				return ec.fieldContext_ServiceFlags_podAllocatorDisabled(ctx, field)
			case "unrecognizedPodCleanupDisabled":
				return ec.fieldContext_ServiceFlags_unrecognizedPodCleanupDisabled(ctx, field)
			case "backgroundReauthDisabled":
				return ec.fieldContext_ServiceFlags_backgroundReauthDisabled(ctx, field)
			case "cloudCleanupDisabled":
				return ec.fieldContext_ServiceFlags_cloudCleanupDisabled(ctx, field)
			case "debugSpawnHostDisabled":
				return ec.fieldContext_ServiceFlags_debugSpawnHostDisabled(ctx, field)
			case "sleepScheduleDisabled":
				return ec.fieldContext_ServiceFlags_sleepScheduleDisabled(ctx, field)
			case "staticAPIKeysDisabled":
				return ec.fieldContext_ServiceFlags_staticAPIKeysDisabled(ctx, field)
			case "jwtTokenForCLIDisabled":
				return ec.fieldContext_ServiceFlags_jwtTokenForCLIDisabled(ctx, field)
			case "systemFailedTaskRestartDisabled":
				return ec.fieldContext_ServiceFlags_systemFailedTaskRestartDisabled(ctx, field)
			case "degradedModeDisabled":
				return ec.fieldContext_ServiceFlags_degradedModeDisabled(ctx, field)
			case "elasticIPsDisabled":
				return ec.fieldContext_ServiceFlags_elasticIPsDisabled(ctx, field)
			case "useGitForGitHubFilesDisabled":
				return ec.fieldContext_ServiceFlags_useGitForGitHubFilesDisabled(ctx, field)
			case "releaseModeDisabled":
				return ec.fieldContext_ServiceFlags_releaseModeDisabled(ctx, field)
			case "eventProcessingDisabled":
				return ec.fieldContext_ServiceFlags_eventProcessingDisabled(ctx, field)
			case "jiraNotificationsDisabled":
				return ec.fieldContext_ServiceFlags_jiraNotificationsDisabled(ctx, field)
			case "slackNotificationsDisabled":
				return ec.fieldContext_ServiceFlags_slackNotificationsDisabled(ctx, field)
			case "emailNotificationsDisabled":
				return ec.fieldContext_ServiceFlags_emailNotificationsDisabled(ctx, field)
			case "webhookNotificationsDisabled":
				return ec.fieldContext_ServiceFlags_webhookNotificationsDisabled(ctx, field)
			case "githubStatusAPIDisabled":
				return ec.fieldContext_ServiceFlags_githubStatusAPIDisabled(ctx, field)
			case "s3LifecycleSyncDisabled":
				return ec.fieldContext_ServiceFlags_s3LifecycleSyncDisabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceFlags", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_shutdownWaitSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_shutdownWaitSeconds,
		func(ctx context.Context) (any, error) {
			return obj.ShutdownWaitSeconds, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_shutdownWaitSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_singleTaskDistro(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_singleTaskDistro,
		func(ctx context.Context) (any, error) {
			return obj.SingleTaskDistro, nil
		},
		nil,
		ec.marshalOSingleTaskDistroConfig2githubcomevergreencievergreenrestmodelAPISingleTaskDistroConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_singleTaskDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectTasksPairs":
				return ec.fieldContext_SingleTaskDistroConfig_projectTasksPairs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SingleTaskDistroConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_slack(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_slack,
		func(ctx context.Context) (any, error) {
			return obj.Slack, nil
		},
		nil,
		ec.marshalOSlackConfig2githubcomevergreencievergreenrestmodelAPISlackConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_slack(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "options":
				return ec.fieldContext_SlackConfig_options(ctx, field)
			case "token":
				return ec.fieldContext_SlackConfig_token(ctx, field)
			case "level":
				return ec.fieldContext_SlackConfig_level(ctx, field)
			case "name":
				return ec.fieldContext_SlackConfig_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlackConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_sleepSchedule(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_sleepSchedule,
		func(ctx context.Context) (any, error) {
			return obj.SleepSchedule, nil
		},
		nil,
		ec.marshalOSleepScheduleConfig2githubcomevergreencievergreenrestmodelAPISleepScheduleConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_sleepSchedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "permanentlyExemptHosts":
				return ec.fieldContext_SleepScheduleConfig_permanentlyExemptHosts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SleepScheduleConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_spawnhost(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_spawnhost,
		func(ctx context.Context) (any, error) {
			return obj.Spawnhost, nil
		},
		nil,
		ec.marshalOSpawnHostConfig2githubcomevergreencievergreenrestmodelAPISpawnHostConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_spawnhost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unexpirableHostsPerUser":
				return ec.fieldContext_SpawnHostConfig_unexpirableHostsPerUser(ctx, field)
			case "unexpirableVolumesPerUser":
				return ec.fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(ctx, field)
			case "spawnHostsPerUser":
				return ec.fieldContext_SpawnHostConfig_spawnHostsPerUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpawnHostConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_splunk(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_splunk,
		func(ctx context.Context) (any, error) {
			return obj.Splunk, nil
		},
		nil,
		ec.marshalOSplunkConfig2githubcomevergreencievergreenrestmodelAPISplunkConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_splunk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "splunkConnectionInfo":
				return ec.fieldContext_SplunkConfig_splunkConnectionInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplunkConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_ssh(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_ssh,
		func(ctx context.Context) (any, error) {
			return obj.SSH, nil
		},
		nil,
		ec.marshalOSSHConfig2githubcomevergreencievergreenrestmodelAPISSHConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_ssh(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "taskHostKey":
				return ec.fieldContext_SSHConfig_taskHostKey(ctx, field)
			case "spawnHostKey":
				return ec.fieldContext_SSHConfig_spawnHostKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SSHConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_taskLimits(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_taskLimits,
		func(ctx context.Context) (any, error) {
			return obj.TaskLimits, nil
		},
		nil,
		ec.marshalOTaskLimitsConfig2githubcomevergreencievergreenrestmodelAPITaskLimitsConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_taskLimits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxTasksPerVersion":
				return ec.fieldContext_TaskLimitsConfig_maxTasksPerVersion(ctx, field)
			case "maxIncludesPerVersion":
				return ec.fieldContext_TaskLimitsConfig_maxIncludesPerVersion(ctx, field)
			case "maxHourlyPatchTasks":
				return ec.fieldContext_TaskLimitsConfig_maxHourlyPatchTasks(ctx, field)
			case "maxPendingGeneratedTasks":
				return ec.fieldContext_TaskLimitsConfig_maxPendingGeneratedTasks(ctx, field)
			case "maxGenerateTaskJSONSize":
				return ec.fieldContext_TaskLimitsConfig_maxGenerateTaskJSONSize(ctx, field)
			case "maxConcurrentLargeParserProjectTasks":
				return ec.fieldContext_TaskLimitsConfig_maxConcurrentLargeParserProjectTasks(ctx, field)
			case "maxDegradedModeConcurrentLargeParserProjectTasks":
				return ec.fieldContext_TaskLimitsConfig_maxDegradedModeConcurrentLargeParserProjectTasks(ctx, field)
			case "maxDegradedModeParserProjectSize":
				return ec.fieldContext_TaskLimitsConfig_maxDegradedModeParserProjectSize(ctx, field)
			case "maxParserProjectSize":
				return ec.fieldContext_TaskLimitsConfig_maxParserProjectSize(ctx, field)
			case "maxExecTimeoutSecs":
				return ec.fieldContext_TaskLimitsConfig_maxExecTimeoutSecs(ctx, field)
			case "maxTaskExecution":
				return ec.fieldContext_TaskLimitsConfig_maxTaskExecution(ctx, field)
			case "maxDailyAutomaticRestarts":
				return ec.fieldContext_TaskLimitsConfig_maxDailyAutomaticRestarts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskLimitsConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_testSelection(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_testSelection,
		func(ctx context.Context) (any, error) {
			return obj.TestSelection, nil
		},
		nil,
		ec.marshalOTestSelectionConfig2githubcomevergreencievergreenrestmodelAPITestSelectionConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_testSelection(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_TestSelectionConfig_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestSelectionConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_tracer(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_tracer,
		func(ctx context.Context) (any, error) {
			return obj.Tracer, nil
		},
		nil,
		ec.marshalOTracerSettings2githubcomevergreencievergreenrestmodelAPITracerSettings,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_tracer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_TracerSettings_enabled(ctx, field)
			case "collectorEndpoint":
				return ec.fieldContext_TracerSettings_collectorEndpoint(ctx, field)
			case "collectorInternalEndpoint":
				return ec.fieldContext_TracerSettings_collectorInternalEndpoint(ctx, field)
			case "collectorAPIKey":
				return ec.fieldContext_TracerSettings_collectorAPIKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TracerSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_triggers(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_triggers,
		func(ctx context.Context) (any, error) {
			return obj.Triggers, nil
		},
		nil,
		ec.marshalOTriggerConfig2githubcomevergreencievergreenrestmodelAPITriggerConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_triggers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "generateTaskDistro":
				return ec.fieldContext_TriggerConfig_generateTaskDistro(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_ui(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminSettings_ui,
		func(ctx context.Context) (any, error) {
			return obj.Ui, nil
		},
		nil,
		ec.marshalOUIConfig2githubcomevergreencievergreenrestmodelAPIUIConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AdminSettings_ui(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_UIConfig_betaFeatures(ctx, field)
			case "url":
				return ec.fieldContext_UIConfig_url(ctx, field)
			case "helpUrl":
				return ec.fieldContext_UIConfig_helpUrl(ctx, field)
			case "uiv2Url":
				return ec.fieldContext_UIConfig_uiv2Url(ctx, field)
			case "parsleyUrl":
				return ec.fieldContext_UIConfig_parsleyUrl(ctx, field)
			case "httpListenAddr":
				return ec.fieldContext_UIConfig_httpListenAddr(ctx, field)
			case "secret":
				return ec.fieldContext_UIConfig_secret(ctx, field)
			case "defaultProject":
				return ec.fieldContext_UIConfig_defaultProject(ctx, field)
			case "corsOrigins":
				return ec.fieldContext_UIConfig_corsOrigins(ctx, field)
			case "fileStreamingContentTypes":
				return ec.fieldContext_UIConfig_fileStreamingContentTypes(ctx, field)
			case "loginDomain":
				return ec.fieldContext_UIConfig_loginDomain(ctx, field)
			case "userVoice":
				return ec.fieldContext_UIConfig_userVoice(ctx, field)
			case "csrfKey":
				return ec.fieldContext_UIConfig_csrfKey(ctx, field)
			case "cacheTemplates":
				return ec.fieldContext_UIConfig_cacheTemplates(ctx, field)
			case "stagingEnvironment":
				return ec.fieldContext_UIConfig_stagingEnvironment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UIConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminTasksToRestartPayload_tasksToRestart(ctx context.Context, field graphql.CollectedField, obj *AdminTasksToRestartPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AdminTasksToRestartPayload_tasksToRestart,
		func(ctx context.Context) (any, error) {
			return obj.TasksToRestart, nil
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AdminTasksToRestartPayload_tasksToRestart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminTasksToRestartPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_singleName(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_singleName,
		func(ctx context.Context) (any, error) {
			return obj.SingleName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_singleName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_poolSizeLocal(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_poolSizeLocal,
		func(ctx context.Context) (any, error) {
			return obj.PoolSizeLocal, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_poolSizeLocal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_poolSizeRemote(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_poolSizeRemote,
		func(ctx context.Context) (any, error) {
			return obj.PoolSizeRemote, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_poolSizeRemote(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_localStorage(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_localStorage,
		func(ctx context.Context) (any, error) {
			return obj.LocalStorage, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_localStorage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_groupDefaultWorkers(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_groupDefaultWorkers,
		func(ctx context.Context) (any, error) {
			return obj.GroupDefaultWorkers, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_groupDefaultWorkers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_groupBackgroundCreateFrequencyMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_groupBackgroundCreateFrequencyMinutes,
		func(ctx context.Context) (any, error) {
			return obj.GroupBackgroundCreateFrequencyMinutes, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_groupBackgroundCreateFrequencyMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_groupPruneFrequencyMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_groupPruneFrequencyMinutes,
		func(ctx context.Context) (any, error) {
			return obj.GroupPruneFrequencyMinutes, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_groupPruneFrequencyMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_groupTTLMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_groupTTLMinutes,
		func(ctx context.Context) (any, error) {
			return obj.GroupTTLMinutes, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_groupTTLMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_lockTimeoutMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_lockTimeoutMinutes,
		func(ctx context.Context) (any, error) {
			return obj.LockTimeoutMinutes, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_lockTimeoutMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_sampleSize(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_sampleSize,
		func(ctx context.Context) (any, error) {
			return obj.SampleSize, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_sampleSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_retry(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_retry,
		func(ctx context.Context) (any, error) {
			return obj.Retry, nil
		},
		nil,
		ec.marshalOAmboyRetryConfig2githubcomevergreencievergreenrestmodelAPIAmboyRetryConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_retry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "numWorkers":
				return ec.fieldContext_AmboyRetryConfig_numWorkers(ctx, field)
			case "maxCapacity":
				return ec.fieldContext_AmboyRetryConfig_maxCapacity(ctx, field)
			case "maxRetryAttempts":
				return ec.fieldContext_AmboyRetryConfig_maxRetryAttempts(ctx, field)
			case "maxRetryTimeSeconds":
				return ec.fieldContext_AmboyRetryConfig_maxRetryTimeSeconds(ctx, field)
			case "retryBackoffSeconds":
				return ec.fieldContext_AmboyRetryConfig_retryBackoffSeconds(ctx, field)
			case "staleRetryingMonitorIntervalSeconds":
				return ec.fieldContext_AmboyRetryConfig_staleRetryingMonitorIntervalSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AmboyRetryConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_namedQueues(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyConfig_namedQueues,
		func(ctx context.Context) (any, error) {
			return obj.NamedQueues, nil
		},
		nil,
		ec.marshalNAmboyNamedQueueConfig2githubcomevergreencievergreenrestmodelAPIAmboyNamedQueueConfig,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_AmboyConfig_namedQueues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_AmboyNamedQueueConfig_name(ctx, field)
			case "regexp":
				return ec.fieldContext_AmboyNamedQueueConfig_regexp(ctx, field)
			case "numWorkers":
				return ec.fieldContext_AmboyNamedQueueConfig_numWorkers(ctx, field)
			case "sampleSize":
				return ec.fieldContext_AmboyNamedQueueConfig_sampleSize(ctx, field)
			case "lockTimeoutSeconds":
				return ec.fieldContext_AmboyNamedQueueConfig_lockTimeoutSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AmboyNamedQueueConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyDBConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyDBConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyDBConfig_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyDBConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyDBConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyDBConfig_database(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyDBConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyDBConfig_database,
		func(ctx context.Context) (any, error) {
			return obj.Database, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyDBConfig_database(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyDBConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyNamedQueueConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyNamedQueueConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyNamedQueueConfig_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyNamedQueueConfig_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyNamedQueueConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyNamedQueueConfig_regexp(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyNamedQueueConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyNamedQueueConfig_regexp,
		func(ctx context.Context) (any, error) {
			return obj.Regexp, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyNamedQueueConfig_regexp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyNamedQueueConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyNamedQueueConfig_numWorkers(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyNamedQueueConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyNamedQueueConfig_numWorkers,
		func(ctx context.Context) (any, error) {
			return obj.NumWorkers, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyNamedQueueConfig_numWorkers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyNamedQueueConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyNamedQueueConfig_sampleSize(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyNamedQueueConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyNamedQueueConfig_sampleSize,
		func(ctx context.Context) (any, error) {
			return obj.SampleSize, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyNamedQueueConfig_sampleSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyNamedQueueConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyNamedQueueConfig_lockTimeoutSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyNamedQueueConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyNamedQueueConfig_lockTimeoutSeconds,
		func(ctx context.Context) (any, error) {
			return obj.LockTimeoutSeconds, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyNamedQueueConfig_lockTimeoutSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyNamedQueueConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_numWorkers(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyRetryConfig_numWorkers,
		func(ctx context.Context) (any, error) {
			return obj.NumWorkers, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_numWorkers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_maxCapacity(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyRetryConfig_maxCapacity,
		func(ctx context.Context) (any, error) {
			return obj.MaxCapacity, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_maxCapacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_maxRetryAttempts(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyRetryConfig_maxRetryAttempts,
		func(ctx context.Context) (any, error) {
			return obj.MaxRetryAttempts, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_maxRetryAttempts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_maxRetryTimeSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyRetryConfig_maxRetryTimeSeconds,
		func(ctx context.Context) (any, error) {
			return obj.MaxRetryTimeSeconds, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_maxRetryTimeSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_retryBackoffSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyRetryConfig_retryBackoffSeconds,
		func(ctx context.Context) (any, error) {
			return obj.RetryBackoffSeconds, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_retryBackoffSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_staleRetryingMonitorIntervalSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AmboyRetryConfig_staleRetryingMonitorIntervalSeconds,
		func(ctx context.Context) (any, error) {
			return obj.StaleRetryingMonitorIntervalSeconds, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_staleRetryingMonitorIntervalSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_id(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Annotation_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Annotation_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_createdIssues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Annotation_createdIssues,
		func(ctx context.Context) (any, error) {
			return obj.CreatedIssues, nil
		},
		nil,
		ec.marshalOIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Annotation_createdIssues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_issues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Annotation_issues,
		func(ctx context.Context) (any, error) {
			return obj.Issues, nil
		},
		nil,
		ec.marshalOIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Annotation_issues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_note(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Annotation_note,
		func(ctx context.Context) (any, error) {
			return obj.Note, nil
		},
		nil,
		ec.marshalONote2githubcomevergreencievergreenrestmodelAPINote,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Annotation_note(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Note_message(ctx, field)
			case "source":
				return ec.fieldContext_Note_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Note", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_suspectedIssues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Annotation_suspectedIssues,
		func(ctx context.Context) (any, error) {
			return obj.SuspectedIssues, nil
		},
		nil,
		ec.marshalOIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Annotation_suspectedIssues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_metadataLinks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Annotation_metadataLinks,
		func(ctx context.Context) (any, error) {
			return obj.MetadataLinks, nil
		},
		nil,
		ec.marshalOMetadataLink2githubcomevergreencievergreenrestmodelAPIMetadataLink,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Annotation_metadataLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_MetadataLink_url(ctx, field)
			case "text":
				return ec.fieldContext_MetadataLink_text(ctx, field)
			case "source":
				return ec.fieldContext_MetadataLink_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetadataLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_taskId(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Annotation_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Annotation_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_taskExecution(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Annotation_taskExecution,
		func(ctx context.Context) (any, error) {
			return obj.TaskExecution, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Annotation_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_webhookConfigured(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Annotation_webhookConfigured,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Annotation().WebhookConfigured(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Annotation_webhookConfigured(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_okta(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthConfig_okta,
		func(ctx context.Context) (any, error) {
			return obj.Okta, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *model.APIOktaConfig
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOOktaConfig2githubcomevergreencievergreenrestmodelAPIOktaConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthConfig_okta(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_OktaConfig_clientId(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OktaConfig_clientSecret(ctx, field)
			case "issuer":
				return ec.fieldContext_OktaConfig_issuer(ctx, field)
			case "scopes":
				return ec.fieldContext_OktaConfig_scopes(ctx, field)
			case "userGroup":
				return ec.fieldContext_OktaConfig_userGroup(ctx, field)
			case "expireAfterMinutes":
				return ec.fieldContext_OktaConfig_expireAfterMinutes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OktaConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_naive(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthConfig_naive,
		func(ctx context.Context) (any, error) {
			return obj.Naive, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *model.APINaiveAuthConfig
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalONaiveAuthConfig2githubcomevergreencievergreenrestmodelAPINaiveAuthConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthConfig_naive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_NaiveAuthConfig_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NaiveAuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_github(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthConfig_github,
		func(ctx context.Context) (any, error) {
			return obj.Github, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *model.APIGithubAuthConfig
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOGitHubAuthConfig2githubcomevergreencievergreenrestmodelAPIGithubAuthConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthConfig_github(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GitHubAuthConfig_appId(ctx, field)
			case "clientId":
				return ec.fieldContext_GitHubAuthConfig_clientId(ctx, field)
			case "clientSecret":
				return ec.fieldContext_GitHubAuthConfig_clientSecret(ctx, field)
			case "defaultOwner":
				return ec.fieldContext_GitHubAuthConfig_defaultOwner(ctx, field)
			case "defaultRepo":
				return ec.fieldContext_GitHubAuthConfig_defaultRepo(ctx, field)
			case "organization":
				return ec.fieldContext_GitHubAuthConfig_organization(ctx, field)
			case "users":
				return ec.fieldContext_GitHubAuthConfig_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitHubAuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_multi(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthConfig_multi,
		func(ctx context.Context) (any, error) {
			return obj.Multi, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *model.APIMultiAuthConfig
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOMultiAuthConfig2githubcomevergreencievergreenrestmodelAPIMultiAuthConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthConfig_multi(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "readWrite":
				return ec.fieldContext_MultiAuthConfig_readWrite(ctx, field)
			case "readOnly":
				return ec.fieldContext_MultiAuthConfig_readOnly(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MultiAuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_kanopy(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthConfig_kanopy,
		func(ctx context.Context) (any, error) {
			return obj.Kanopy, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *model.APIKanopyAuthConfig
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOKanopyAuthConfig2githubcomevergreencievergreenrestmodelAPIKanopyAuthConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthConfig_kanopy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "headerName":
				return ec.fieldContext_KanopyAuthConfig_headerName(ctx, field)
			case "issuer":
				return ec.fieldContext_KanopyAuthConfig_issuer(ctx, field)
			case "keysetURL":
				return ec.fieldContext_KanopyAuthConfig_keysetURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KanopyAuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_oauth(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthConfig_oauth,
		func(ctx context.Context) (any, error) {
			return obj.OAuth, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *model.APIOAuthConfig
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOOAuthConfig2githubcomevergreencievergreenrestmodelAPIOAuthConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthConfig_oauth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "issuer":
				return ec.fieldContext_OAuthConfig_issuer(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuthConfig_clientId(ctx, field)
			case "connectorId":
				return ec.fieldContext_OAuthConfig_connectorId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_preferredType(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthConfig_preferredType,
		func(ctx context.Context) (any, error) {
			return obj.PreferredType, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOPreferredAuthType2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthConfig_preferredType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PreferredAuthType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_backgroundReauthMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthConfig_backgroundReauthMinutes,
		func(ctx context.Context) (any, error) {
			return obj.BackgroundReauthMinutes, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthConfig_backgroundReauthMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_allowServiceUsers(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthConfig_allowServiceUsers,
		func(ctx context.Context) (any, error) {
			return obj.AllowServiceUsers, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthConfig_allowServiceUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_username(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthUser_username,
		func(ctx context.Context) (any, error) {
			return obj.Username, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthUser_username(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthUser_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthUser_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_password(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthUser_password,
		func(ctx context.Context) (any, error) {
			return obj.Password, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthUser_password(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_email(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_AuthUser_email,
		func(ctx context.Context) (any, error) {
			return obj.Email, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_AuthUser_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BetaFeatures_spruceWaterfallEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIBetaFeatures) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BetaFeatures_spruceWaterfallEnabled,
		func(ctx context.Context) (any, error) {
			return obj.SpruceWaterfallEnabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BetaFeatures_spruceWaterfallEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BetaFeatures",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BetaFeatures_parsleyAIEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIBetaFeatures) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BetaFeatures_parsleyAIEnabled,
		func(ctx context.Context) (any, error) {
			return obj.ParsleyAIEnabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BetaFeatures_parsleyAIEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BetaFeatures",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_clientDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_clientDir,
		func(ctx context.Context) (any, error) {
			return obj.ClientDir, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_clientDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_communication(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_communication,
		func(ctx context.Context) (any, error) {
			return obj.Communication, nil
		},
		nil,
		ec.marshalNCommunicationMethod2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_communication(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CommunicationMethod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_env(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_env,
		func(ctx context.Context) (any, error) {
			return obj.Env, nil
		},
		nil,
		ec.marshalNEnvVar2githubcomevergreencievergreenrestmodelAPIEnvVar,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_env(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_EnvVar_key(ctx, field)
			case "value":
				return ec.fieldContext_EnvVar_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EnvVar", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_jasperBinaryDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_jasperBinaryDir,
		func(ctx context.Context) (any, error) {
			return obj.JasperBinaryDir, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_jasperBinaryDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_jasperCredentialsPath(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_jasperCredentialsPath,
		func(ctx context.Context) (any, error) {
			return obj.JasperCredentialsPath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_jasperCredentialsPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_method(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_method,
		func(ctx context.Context) (any, error) {
			return obj.Method, nil
		},
		nil,
		ec.marshalNBootstrapMethod2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_method(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BootstrapMethod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_preconditionScripts(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_preconditionScripts,
		func(ctx context.Context) (any, error) {
			return obj.PreconditionScripts, nil
		},
		nil,
		ec.marshalNPreconditionScript2githubcomevergreencievergreenrestmodelAPIPreconditionScript,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_preconditionScripts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "path":
				return ec.fieldContext_PreconditionScript_path(ctx, field)
			case "script":
				return ec.fieldContext_PreconditionScript_script(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreconditionScript", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_resourceLimits(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_resourceLimits,
		func(ctx context.Context) (any, error) {
			return obj.ResourceLimits, nil
		},
		nil,
		ec.marshalNResourceLimits2githubcomevergreencievergreenrestmodelAPIResourceLimits,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_resourceLimits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lockedMemoryKb":
				return ec.fieldContext_ResourceLimits_lockedMemoryKb(ctx, field)
			case "numFiles":
				return ec.fieldContext_ResourceLimits_numFiles(ctx, field)
			case "numProcesses":
				return ec.fieldContext_ResourceLimits_numProcesses(ctx, field)
			case "numTasks":
				return ec.fieldContext_ResourceLimits_numTasks(ctx, field)
			case "virtualMemoryKb":
				return ec.fieldContext_ResourceLimits_virtualMemoryKb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceLimits", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_rootDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_rootDir,
		func(ctx context.Context) (any, error) {
			return obj.RootDir, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_rootDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_serviceUser(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_serviceUser,
		func(ctx context.Context) (any, error) {
			return obj.ServiceUser, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_serviceUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_shellPath(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BootstrapSettings_shellPath,
		func(ctx context.Context) (any, error) {
			return obj.ShellPath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BootstrapSettings_shellPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketConfig_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketConfig_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketConfig_testResultsPrefix(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketConfig_testResultsPrefix,
		func(ctx context.Context) (any, error) {
			return obj.TestResultsPrefix, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketConfig_testResultsPrefix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketConfig_roleARN(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketConfig_roleARN,
		func(ctx context.Context) (any, error) {
			return obj.RoleARN, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketConfig_roleARN(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketConfig_type(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketConfig_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketConfig_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketsConfig_logBucket(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketsConfig_logBucket,
		func(ctx context.Context) (any, error) {
			return obj.LogBucket, nil
		},
		nil,
		ec.marshalOBucketConfig2githubcomevergreencievergreenrestmodelAPIBucketConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketsConfig_logBucket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_BucketConfig_name(ctx, field)
			case "testResultsPrefix":
				return ec.fieldContext_BucketConfig_testResultsPrefix(ctx, field)
			case "roleARN":
				return ec.fieldContext_BucketConfig_roleARN(ctx, field)
			case "type":
				return ec.fieldContext_BucketConfig_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketsConfig_logBucketLongRetention(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketsConfig_logBucketLongRetention,
		func(ctx context.Context) (any, error) {
			return obj.LogBucketLongRetention, nil
		},
		nil,
		ec.marshalOBucketConfig2githubcomevergreencievergreenrestmodelAPIBucketConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketsConfig_logBucketLongRetention(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_BucketConfig_name(ctx, field)
			case "testResultsPrefix":
				return ec.fieldContext_BucketConfig_testResultsPrefix(ctx, field)
			case "roleARN":
				return ec.fieldContext_BucketConfig_roleARN(ctx, field)
			case "type":
				return ec.fieldContext_BucketConfig_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketsConfig_logBucketFailedTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketsConfig_logBucketFailedTasks,
		func(ctx context.Context) (any, error) {
			return obj.LogBucketFailedTasks, nil
		},
		nil,
		ec.marshalOBucketConfig2githubcomevergreencievergreenrestmodelAPIBucketConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketsConfig_logBucketFailedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_BucketConfig_name(ctx, field)
			case "testResultsPrefix":
				return ec.fieldContext_BucketConfig_testResultsPrefix(ctx, field)
			case "roleARN":
				return ec.fieldContext_BucketConfig_roleARN(ctx, field)
			case "type":
				return ec.fieldContext_BucketConfig_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketsConfig_longRetentionProjects(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketsConfig_longRetentionProjects,
		func(ctx context.Context) (any, error) {
			return obj.LongRetentionProjects, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketsConfig_longRetentionProjects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketsConfig_testResultsBucket(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketsConfig_testResultsBucket,
		func(ctx context.Context) (any, error) {
			return obj.TestResultsBucket, nil
		},
		nil,
		ec.marshalOBucketConfig2githubcomevergreencievergreenrestmodelAPIBucketConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketsConfig_testResultsBucket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_BucketConfig_name(ctx, field)
			case "testResultsPrefix":
				return ec.fieldContext_BucketConfig_testResultsPrefix(ctx, field)
			case "roleARN":
				return ec.fieldContext_BucketConfig_roleARN(ctx, field)
			case "type":
				return ec.fieldContext_BucketConfig_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BucketConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketsConfig_internalBuckets(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketsConfig_internalBuckets,
		func(ctx context.Context) (any, error) {
			return obj.InternalBuckets, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketsConfig_internalBuckets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BucketsConfig_credentials(ctx context.Context, field graphql.CollectedField, obj *model.APIBucketsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BucketsConfig_credentials,
		func(ctx context.Context) (any, error) {
			return obj.Credentials, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal model.APIS3Credentials
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOS3Credentials2githubcomevergreencievergreenrestmodelAPIS3Credentials,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BucketsConfig_credentials(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BucketsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_S3Credentials_key(ctx, field)
			case "secret":
				return ec.fieldContext_S3Credentials_secret(ctx, field)
			case "bucket":
				return ec.fieldContext_S3Credentials_bucket(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type S3Credentials", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_id(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Build_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Build_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_actualMakespan(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Build_actualMakespan,
		func(ctx context.Context) (any, error) {
			return obj.ActualMakespan, nil
		},
		nil,
		ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Build_actualMakespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Build_buildVariant,
		func(ctx context.Context) (any, error) {
			return obj.BuildVariant, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Build_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_predictedMakespan(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Build_predictedMakespan,
		func(ctx context.Context) (any, error) {
			return obj.PredictedMakespan, nil
		},
		nil,
		ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Build_predictedMakespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_status(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Build_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Build_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_bbTicketCreationDefined(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaron_bbTicketCreationDefined,
		func(ctx context.Context) (any, error) {
			return obj.BbTicketCreationDefined, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BuildBaron_bbTicketCreationDefined(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_buildBaronConfigured(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaron_buildBaronConfigured,
		func(ctx context.Context) (any, error) {
			return obj.BuildBaronConfigured, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BuildBaron_buildBaronConfigured(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_searchReturnInfo(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaron_searchReturnInfo,
		func(ctx context.Context) (any, error) {
			return obj.SearchReturnInfo, nil
		},
		nil,
		ec.marshalOSearchReturnInfo2githubcomevergreencievergreenthirdpartySearchReturnInfo,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BuildBaron_searchReturnInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featuresURL":
				return ec.fieldContext_SearchReturnInfo_featuresURL(ctx, field)
			case "issues":
				return ec.fieldContext_SearchReturnInfo_issues(ctx, field)
			case "search":
				return ec.fieldContext_SearchReturnInfo_search(ctx, field)
			case "source":
				return ec.fieldContext_SearchReturnInfo_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchReturnInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionFeaturesURL(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL,
		func(ctx context.Context) (any, error) {
			return obj.BFSuggestionFeaturesURL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionPassword(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaronSettings_bfSuggestionPassword,
		func(ctx context.Context) (any, error) {
			return obj.BFSuggestionPassword, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionPassword(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionServer(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaronSettings_bfSuggestionServer,
		func(ctx context.Context) (any, error) {
			return obj.BFSuggestionServer, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionServer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionTimeoutSecs(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs,
		func(ctx context.Context) (any, error) {
			return obj.BFSuggestionTimeoutSecs, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionUsername(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaronSettings_bfSuggestionUsername,
		func(ctx context.Context) (any, error) {
			return obj.BFSuggestionUsername, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionUsername(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketCreateProject(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaronSettings_ticketCreateProject,
		func(ctx context.Context) (any, error) {
			return obj.TicketCreateProject, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketCreateProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketSearchProjects(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaronSettings_ticketSearchProjects,
		func(ctx context.Context) (any, error) {
			return obj.TicketSearchProjects, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketSearchProjects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketCreateIssueType(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildBaronSettings_ticketCreateIssueType,
		func(ctx context.Context) (any, error) {
			return obj.TicketCreateIssueType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketCreateIssueType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildVariantTuple_buildVariant(ctx context.Context, field graphql.CollectedField, obj *task.BuildVariantTuple) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildVariantTuple_buildVariant,
		func(ctx context.Context) (any, error) {
			return obj.BuildVariant, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BuildVariantTuple_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildVariantTuple",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildVariantTuple_displayName(ctx context.Context, field graphql.CollectedField, obj *task.BuildVariantTuple) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BuildVariantTuple_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BuildVariantTuple_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildVariantTuple",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CedarConfig_dbUrl(ctx context.Context, field graphql.CollectedField, obj *model.APICedarConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CedarConfig_dbUrl,
		func(ctx context.Context) (any, error) {
			return obj.DBURL, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CedarConfig_dbUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CedarConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CedarConfig_dbName(ctx context.Context, field graphql.CollectedField, obj *model.APICedarConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CedarConfig_dbName,
		func(ctx context.Context) (any, error) {
			return obj.DBName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CedarConfig_dbName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CedarConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChildPatchAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIChildPatchAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChildPatchAlias_alias,
		func(ctx context.Context) (any, error) {
			return obj.Alias, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChildPatchAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChildPatchAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChildPatchAlias_patchId(ctx context.Context, field graphql.CollectedField, obj *model.APIChildPatchAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ChildPatchAlias_patchId,
		func(ctx context.Context) (any, error) {
			return obj.PatchID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ChildPatchAlias_patchId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChildPatchAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ClientBinary_arch,
		func(ctx context.Context) (any, error) {
			return obj.Arch, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ClientBinary_arch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ClientBinary_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ClientBinary_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_os(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ClientBinary_os,
		func(ctx context.Context) (any, error) {
			return obj.OS, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ClientBinary_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_url(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ClientBinary_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ClientBinary_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientConfig_clientBinaries(ctx context.Context, field graphql.CollectedField, obj *model.APIClientConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ClientConfig_clientBinaries,
		func(ctx context.Context) (any, error) {
			return obj.ClientBinaries, nil
		},
		nil,
		ec.marshalOClientBinary2githubcomevergreencievergreenrestmodelAPIClientBinary,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ClientConfig_clientBinaries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arch":
				return ec.fieldContext_ClientBinary_arch(ctx, field)
			case "displayName":
				return ec.fieldContext_ClientBinary_displayName(ctx, field)
			case "os":
				return ec.fieldContext_ClientBinary_os(ctx, field)
			case "url":
				return ec.fieldContext_ClientBinary_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientBinary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientConfig_latestRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIClientConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ClientConfig_latestRevision,
		func(ctx context.Context) (any, error) {
			return obj.LatestRevision, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ClientConfig_latestRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CloudProviderConfig_aws(ctx context.Context, field graphql.CollectedField, obj *model.APICloudProviders) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CloudProviderConfig_aws,
		func(ctx context.Context) (any, error) {
			return obj.AWS, nil
		},
		nil,
		ec.marshalOAWSConfig2githubcomevergreencievergreenrestmodelAPIAWSConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CloudProviderConfig_aws(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CloudProviderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ec2Keys":
				return ec.fieldContext_AWSConfig_ec2Keys(ctx, field)
			case "subnets":
				return ec.fieldContext_AWSConfig_subnets(ctx, field)
			case "parserProject":
				return ec.fieldContext_AWSConfig_parserProject(ctx, field)
			case "persistentDNS":
				return ec.fieldContext_AWSConfig_persistentDNS(ctx, field)
			case "defaultSecurityGroup":
				return ec.fieldContext_AWSConfig_defaultSecurityGroup(ctx, field)
			case "allowedInstanceTypes":
				return ec.fieldContext_AWSConfig_allowedInstanceTypes(ctx, field)
			case "alertableInstanceTypes":
				return ec.fieldContext_AWSConfig_alertableInstanceTypes(ctx, field)
			case "allowedRegions":
				return ec.fieldContext_AWSConfig_allowedRegions(ctx, field)
			case "maxVolumeSizePerUser":
				return ec.fieldContext_AWSConfig_maxVolumeSizePerUser(ctx, field)
			case "pod":
				return ec.fieldContext_AWSConfig_pod(ctx, field)
			case "accountRoles":
				return ec.fieldContext_AWSConfig_accountRoles(ctx, field)
			case "ipamPoolID":
				return ec.fieldContext_AWSConfig_ipamPoolID(ctx, field)
			case "elasticIPUsageRate":
				return ec.fieldContext_AWSConfig_elasticIPUsageRate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AWSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CloudProviderConfig_docker(ctx context.Context, field graphql.CollectedField, obj *model.APICloudProviders) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CloudProviderConfig_docker,
		func(ctx context.Context) (any, error) {
			return obj.Docker, nil
		},
		nil,
		ec.marshalODockerConfig2githubcomevergreencievergreenrestmodelAPIDockerConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CloudProviderConfig_docker(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CloudProviderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "apiVersion":
				return ec.fieldContext_DockerConfig_apiVersion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DockerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CommitQueueParams_enabled,
		func(ctx context.Context) (any, error) {
			return obj.Enabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CommitQueueParams_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_mergeMethod(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CommitQueueParams_mergeMethod,
		func(ctx context.Context) (any, error) {
			return obj.MergeMethod, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CommitQueueParams_mergeMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_message(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CommitQueueParams_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CommitQueueParams_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_id(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContainerPool_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContainerPool_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_distro(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContainerPool_distro,
		func(ctx context.Context) (any, error) {
			return obj.Distro, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContainerPool_distro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_maxContainers(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContainerPool_maxContainers,
		func(ctx context.Context) (any, error) {
			return obj.MaxContainers, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContainerPool_maxContainers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_port(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContainerPool_port,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ContainerPool().Port(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContainerPool_port(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPoolsConfig_pools(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPoolsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContainerPoolsConfig_pools,
		func(ctx context.Context) (any, error) {
			return obj.Pools, nil
		},
		nil,
		ec.marshalNContainerPool2githubcomevergreencievergreenrestmodelAPIContainerPool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContainerPoolsConfig_pools(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPoolsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerPool_id(ctx, field)
			case "distro":
				return ec.fieldContext_ContainerPool_distro(ctx, field)
			case "maxContainers":
				return ec.fieldContext_ContainerPool_maxContainers(ctx, field)
			case "port":
				return ec.fieldContext_ContainerPool_port(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerPool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_name(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContainerResources_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContainerResources_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_cpu(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContainerResources_cpu,
		func(ctx context.Context) (any, error) {
			return obj.CPU, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContainerResources_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_memoryMb(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContainerResources_memoryMb,
		func(ctx context.Context) (any, error) {
			return obj.MemoryMB, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContainerResources_memoryMb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cost_onDemandEC2Cost(ctx context.Context, field graphql.CollectedField, obj *cost.Cost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cost_onDemandEC2Cost,
		func(ctx context.Context) (any, error) {
			return obj.OnDemandEC2Cost, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Cost_onDemandEC2Cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cost_adjustedEC2Cost(ctx context.Context, field graphql.CollectedField, obj *cost.Cost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Cost_adjustedEC2Cost,
		func(ctx context.Context) (any, error) {
			return obj.AdjustedEC2Cost, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Cost_adjustedEC2Cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostConfig_financeFormula(ctx context.Context, field graphql.CollectedField, obj *model.APICostConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CostConfig_financeFormula,
		func(ctx context.Context) (any, error) {
			return obj.FinanceFormula, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CostConfig_financeFormula(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostConfig_savingsPlanDiscount(ctx context.Context, field graphql.CollectedField, obj *model.APICostConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CostConfig_savingsPlanDiscount,
		func(ctx context.Context) (any, error) {
			return obj.SavingsPlanDiscount, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CostConfig_savingsPlanDiscount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostConfig_onDemandDiscount(ctx context.Context, field graphql.CollectedField, obj *model.APICostConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CostConfig_onDemandDiscount,
		func(ctx context.Context) (any, error) {
			return obj.OnDemandDiscount, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CostConfig_onDemandDiscount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostData_onDemandRate(ctx context.Context, field graphql.CollectedField, obj *model.APICostData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CostData_onDemandRate,
		func(ctx context.Context) (any, error) {
			return obj.OnDemandRate, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CostData_onDemandRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostData_savingsPlanRate(ctx context.Context, field graphql.CollectedField, obj *model.APICostData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CostData_savingsPlanRate,
		func(ctx context.Context) (any, error) {
			return obj.SavingsPlanRate, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_CostData_savingsPlanRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteDistroPayload_deletedDistroId(ctx context.Context, field graphql.CollectedField, obj *DeleteDistroPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeleteDistroPayload_deletedDistroId,
		func(ctx context.Context) (any, error) {
			return obj.DeletedDistroID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeleteDistroPayload_deletedDistroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteGithubAppCredentialsPayload_oldAppId(ctx context.Context, field graphql.CollectedField, obj *DeleteGithubAppCredentialsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DeleteGithubAppCredentialsPayload_oldAppId,
		func(ctx context.Context) (any, error) {
			return obj.OldAppID, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DeleteGithubAppCredentialsPayload_oldAppId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteGithubAppCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_buildVariant(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Dependency_buildVariant,
		func(ctx context.Context) (any, error) {
			return obj.BuildVariant, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Dependency_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_metStatus(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Dependency_metStatus,
		func(ctx context.Context) (any, error) {
			return obj.MetStatus, nil
		},
		nil,
		ec.marshalNMetStatus2githubcomevergreencievergreengraphqlMetStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Dependency_metStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MetStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_name(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Dependency_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Dependency_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_requiredStatus(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Dependency_requiredStatus,
		func(ctx context.Context) (any, error) {
			return obj.RequiredStatus, nil
		},
		nil,
		ec.marshalNRequiredStatus2githubcomevergreencievergreengraphqlRequiredStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Dependency_requiredStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RequiredStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_taskId(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Dependency_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Dependency_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DispatcherSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIDispatcherSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DispatcherSettings_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNDispatcherVersion2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DispatcherSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DispatcherSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DispatcherVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_adminOnly(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_adminOnly,
		func(ctx context.Context) (any, error) {
			return obj.AdminOnly, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_adminOnly(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_aliases,
		func(ctx context.Context) (any, error) {
			return obj.Aliases, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_arch,
		func(ctx context.Context) (any, error) {
			return obj.Arch, nil
		},
		nil,
		ec.marshalNArch2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_arch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Arch does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_authorizedKeysFile(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_authorizedKeysFile,
		func(ctx context.Context) (any, error) {
			return obj.AuthorizedKeysFile, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_authorizedKeysFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_availableRegions(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_availableRegions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Distro().AvailableRegions(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_availableRegions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_bootstrapSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_bootstrapSettings,
		func(ctx context.Context) (any, error) {
			return obj.BootstrapSettings, nil
		},
		nil,
		ec.marshalNBootstrapSettings2githubcomevergreencievergreenrestmodelAPIBootstrapSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_bootstrapSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientDir":
				return ec.fieldContext_BootstrapSettings_clientDir(ctx, field)
			case "communication":
				return ec.fieldContext_BootstrapSettings_communication(ctx, field)
			case "env":
				return ec.fieldContext_BootstrapSettings_env(ctx, field)
			case "jasperBinaryDir":
				return ec.fieldContext_BootstrapSettings_jasperBinaryDir(ctx, field)
			case "jasperCredentialsPath":
				return ec.fieldContext_BootstrapSettings_jasperCredentialsPath(ctx, field)
			case "method":
				return ec.fieldContext_BootstrapSettings_method(ctx, field)
			case "preconditionScripts":
				return ec.fieldContext_BootstrapSettings_preconditionScripts(ctx, field)
			case "resourceLimits":
				return ec.fieldContext_BootstrapSettings_resourceLimits(ctx, field)
			case "rootDir":
				return ec.fieldContext_BootstrapSettings_rootDir(ctx, field)
			case "serviceUser":
				return ec.fieldContext_BootstrapSettings_serviceUser(ctx, field)
			case "shellPath":
				return ec.fieldContext_BootstrapSettings_shellPath(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BootstrapSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_containerPool(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_containerPool,
		func(ctx context.Context) (any, error) {
			return obj.ContainerPool, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_containerPool(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_disabled(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_disabled,
		func(ctx context.Context) (any, error) {
			return obj.Disabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_disabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_disableShallowClone(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_disableShallowClone,
		func(ctx context.Context) (any, error) {
			return obj.DisableShallowClone, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_disableShallowClone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_dispatcherSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_dispatcherSettings,
		func(ctx context.Context) (any, error) {
			return obj.DispatcherSettings, nil
		},
		nil,
		ec.marshalNDispatcherSettings2githubcomevergreencievergreenrestmodelAPIDispatcherSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_dispatcherSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_DispatcherSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DispatcherSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_execUser(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_execUser,
		func(ctx context.Context) (any, error) {
			return obj.ExecUser, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_execUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_expansions(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_expansions,
		func(ctx context.Context) (any, error) {
			return obj.Expansions, nil
		},
		nil,
		ec.marshalNExpansion2githubcomevergreencievergreenrestmodelAPIExpansion,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_expansions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Expansion_key(ctx, field)
			case "value":
				return ec.fieldContext_Expansion_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Expansion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_finderSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_finderSettings,
		func(ctx context.Context) (any, error) {
			return obj.FinderSettings, nil
		},
		nil,
		ec.marshalNFinderSettings2githubcomevergreencievergreenrestmodelAPIFinderSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_finderSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_FinderSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FinderSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_homeVolumeSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_homeVolumeSettings,
		func(ctx context.Context) (any, error) {
			return obj.HomeVolumeSettings, nil
		},
		nil,
		ec.marshalNHomeVolumeSettings2githubcomevergreencievergreenrestmodelAPIHomeVolumeSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_homeVolumeSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "formatCommand":
				return ec.fieldContext_HomeVolumeSettings_formatCommand(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HomeVolumeSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_hostAllocatorSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_hostAllocatorSettings,
		func(ctx context.Context) (any, error) {
			return obj.HostAllocatorSettings, nil
		},
		nil,
		ec.marshalNHostAllocatorSettings2githubcomevergreencievergreenrestmodelAPIHostAllocatorSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_hostAllocatorSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acceptableHostIdleTime":
				return ec.fieldContext_HostAllocatorSettings_acceptableHostIdleTime(ctx, field)
			case "autoTuneMaximumHosts":
				return ec.fieldContext_HostAllocatorSettings_autoTuneMaximumHosts(ctx, field)
			case "feedbackRule":
				return ec.fieldContext_HostAllocatorSettings_feedbackRule(ctx, field)
			case "futureHostFraction":
				return ec.fieldContext_HostAllocatorSettings_futureHostFraction(ctx, field)
			case "hostsOverallocatedRule":
				return ec.fieldContext_HostAllocatorSettings_hostsOverallocatedRule(ctx, field)
			case "maximumHosts":
				return ec.fieldContext_HostAllocatorSettings_maximumHosts(ctx, field)
			case "minimumHosts":
				return ec.fieldContext_HostAllocatorSettings_minimumHosts(ctx, field)
			case "roundingRule":
				return ec.fieldContext_HostAllocatorSettings_roundingRule(ctx, field)
			case "version":
				return ec.fieldContext_HostAllocatorSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostAllocatorSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_iceCreamSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_iceCreamSettings,
		func(ctx context.Context) (any, error) {
			return obj.IcecreamSettings, nil
		},
		nil,
		ec.marshalNIceCreamSettings2githubcomevergreencievergreenrestmodelAPIIceCreamSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_iceCreamSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "configPath":
				return ec.fieldContext_IceCreamSettings_configPath(ctx, field)
			case "schedulerHost":
				return ec.fieldContext_IceCreamSettings_schedulerHost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IceCreamSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_imageId(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_imageId,
		func(ctx context.Context) (any, error) {
			return obj.ImageID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_imageId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_isCluster(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_isCluster,
		func(ctx context.Context) (any, error) {
			return obj.IsCluster, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_isCluster(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_isVirtualWorkStation(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_isVirtualWorkStation,
		func(ctx context.Context) (any, error) {
			return obj.IsVirtualWorkstation, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_isVirtualWorkStation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_mountpoints(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_mountpoints,
		func(ctx context.Context) (any, error) {
			return obj.Mountpoints, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_mountpoints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_name(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_note(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_note,
		func(ctx context.Context) (any, error) {
			return obj.Note, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_note(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_plannerSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_plannerSettings,
		func(ctx context.Context) (any, error) {
			return obj.PlannerSettings, nil
		},
		nil,
		ec.marshalNPlannerSettings2githubcomevergreencievergreenrestmodelAPIPlannerSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_plannerSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commitQueueFactor":
				return ec.fieldContext_PlannerSettings_commitQueueFactor(ctx, field)
			case "expectedRuntimeFactor":
				return ec.fieldContext_PlannerSettings_expectedRuntimeFactor(ctx, field)
			case "generateTaskFactor":
				return ec.fieldContext_PlannerSettings_generateTaskFactor(ctx, field)
			case "numDependentsFactor":
				return ec.fieldContext_PlannerSettings_numDependentsFactor(ctx, field)
			case "groupVersions":
				return ec.fieldContext_PlannerSettings_groupVersions(ctx, field)
			case "mainlineTimeInQueueFactor":
				return ec.fieldContext_PlannerSettings_mainlineTimeInQueueFactor(ctx, field)
			case "patchFactor":
				return ec.fieldContext_PlannerSettings_patchFactor(ctx, field)
			case "patchTimeInQueueFactor":
				return ec.fieldContext_PlannerSettings_patchTimeInQueueFactor(ctx, field)
			case "targetTime":
				return ec.fieldContext_PlannerSettings_targetTime(ctx, field)
			case "version":
				return ec.fieldContext_PlannerSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannerSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_provider(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_provider,
		func(ctx context.Context) (any, error) {
			return obj.Provider, nil
		},
		nil,
		ec.marshalNProvider2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Provider does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_providerAccount(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_providerAccount,
		func(ctx context.Context) (any, error) {
			return obj.ProviderAccount, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_providerAccount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_providerSettingsList(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_providerSettingsList,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Distro().ProviderSettingsList(ctx, obj)
		},
		nil,
		ec.marshalNMap2map,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_providerSettingsList(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_setup(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_setup,
		func(ctx context.Context) (any, error) {
			return obj.Setup, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_setup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_setupAsSudo(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_setupAsSudo,
		func(ctx context.Context) (any, error) {
			return obj.SetupAsSudo, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_setupAsSudo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_singleTaskDistro(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_singleTaskDistro,
		func(ctx context.Context) (any, error) {
			return obj.SingleTaskDistro, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_singleTaskDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_sshOptions(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_sshOptions,
		func(ctx context.Context) (any, error) {
			return obj.SSHOptions, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_sshOptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_user(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_userSpawnAllowed(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_userSpawnAllowed,
		func(ctx context.Context) (any, error) {
			return obj.UserSpawnAllowed, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_userSpawnAllowed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_validProjects(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_validProjects,
		func(ctx context.Context) (any, error) {
			return obj.ValidProjects, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_validProjects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_warningNote(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_warningNote,
		func(ctx context.Context) (any, error) {
			return obj.WarningNote, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_warningNote(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_workDir(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_workDir,
		func(ctx context.Context) (any, error) {
			return obj.WorkDir, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Distro_workDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_costData(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Distro_costData,
		func(ctx context.Context) (any, error) {
			return obj.CostData, nil
		},
		nil,
		ec.marshalOCostData2githubcomevergreencievergreenrestmodelAPICostData,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Distro_costData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "onDemandRate":
				return ec.fieldContext_CostData_onDemandRate(ctx, field)
			case "savingsPlanRate":
				return ec.fieldContext_CostData_savingsPlanRate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CostData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_after(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroEvent_after,
		func(ctx context.Context) (any, error) {
			return obj.After, nil
		},
		nil,
		ec.marshalOMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DistroEvent_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_before(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroEvent_before,
		func(ctx context.Context) (any, error) {
			return obj.Before, nil
		},
		nil,
		ec.marshalOMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DistroEvent_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_data(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroEvent_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalOMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DistroEvent_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroEvent_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DistroEvent_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_user(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroEvent_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DistroEvent_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEventsPayload_count(ctx context.Context, field graphql.CollectedField, obj *DistroEventsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroEventsPayload_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DistroEventsPayload_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEventsPayload_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *DistroEventsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroEventsPayload_eventLogEntries,
		func(ctx context.Context) (any, error) {
			return obj.EventLogEntries, nil
		},
		nil,
		ec.marshalNDistroEvent2githubcomevergreencievergreengraphqlDistroEvent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DistroEventsPayload_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "after":
				return ec.fieldContext_DistroEvent_after(ctx, field)
			case "before":
				return ec.fieldContext_DistroEvent_before(ctx, field)
			case "data":
				return ec.fieldContext_DistroEvent_data(ctx, field)
			case "timestamp":
				return ec.fieldContext_DistroEvent_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_DistroEvent_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroInfo_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DistroInfo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_bootstrapMethod(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroInfo_bootstrapMethod,
		func(ctx context.Context) (any, error) {
			return obj.BootstrapMethod, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DistroInfo_bootstrapMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_isVirtualWorkStation(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroInfo_isVirtualWorkStation,
		func(ctx context.Context) (any, error) {
			return obj.IsVirtualWorkstation, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DistroInfo_isVirtualWorkStation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_isWindows(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroInfo_isWindows,
		func(ctx context.Context) (any, error) {
			return obj.IsWindows, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DistroInfo_isWindows(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_user(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroInfo_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DistroInfo_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_workDir(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroInfo_workDir,
		func(ctx context.Context) (any, error) {
			return obj.WorkDir, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DistroInfo_workDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_admin(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroPermissions_admin,
		func(ctx context.Context) (any, error) {
			return obj.Admin, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DistroPermissions_admin(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_edit(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroPermissions_edit,
		func(ctx context.Context) (any, error) {
			return obj.Edit, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DistroPermissions_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_view(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DistroPermissions_view,
		func(ctx context.Context) (any, error) {
			return obj.View, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DistroPermissions_view(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DockerConfig_apiVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIDockerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DockerConfig_apiVersion,
		func(ctx context.Context) (any, error) {
			return obj.APIVersion, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_DockerConfig_apiVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DockerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EC2Key_name(ctx context.Context, field graphql.CollectedField, obj *model.APIEC2Key) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_EC2Key_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_EC2Key_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EC2Key",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EC2Key_key(ctx context.Context, field graphql.CollectedField, obj *model.APIEC2Key) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_EC2Key_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_EC2Key_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EC2Key",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EC2Key_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIEC2Key) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_EC2Key_secret,
		func(ctx context.Context) (any, error) {
			return obj.Secret, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_EC2Key_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EC2Key",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSCapacityProvider_name(ctx context.Context, field graphql.CollectedField, obj *model.APIECSCapacityProvider) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSCapacityProvider_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSCapacityProvider_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSCapacityProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSCapacityProvider_os(ctx context.Context, field graphql.CollectedField, obj *model.APIECSCapacityProvider) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSCapacityProvider_os,
		func(ctx context.Context) (any, error) {
			return obj.OS, nil
		},
		nil,
		ec.marshalOECSOperatingSystem2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSCapacityProvider_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSCapacityProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ECSOperatingSystem does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSCapacityProvider_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIECSCapacityProvider) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSCapacityProvider_arch,
		func(ctx context.Context) (any, error) {
			return obj.Arch, nil
		},
		nil,
		ec.marshalOECSArchitecture2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSCapacityProvider_arch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSCapacityProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ECSArchitecture does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSCapacityProvider_windowsVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIECSCapacityProvider) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSCapacityProvider_windowsVersion,
		func(ctx context.Context) (any, error) {
			return obj.WindowsVersion, nil
		},
		nil,
		ec.marshalOECSWindowsVersion2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSCapacityProvider_windowsVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSCapacityProvider",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ECSWindowsVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSClusterConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.APIECSClusterConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSClusterConfig_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSClusterConfig_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSClusterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSClusterConfig_os(ctx context.Context, field graphql.CollectedField, obj *model.APIECSClusterConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSClusterConfig_os,
		func(ctx context.Context) (any, error) {
			return obj.OS, nil
		},
		nil,
		ec.marshalOECSOperatingSystem2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSClusterConfig_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSClusterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ECSOperatingSystem does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_maxCPU(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_maxCPU,
		func(ctx context.Context) (any, error) {
			return obj.MaxCPU, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_maxCPU(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_maxMemoryMb(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_maxMemoryMb,
		func(ctx context.Context) (any, error) {
			return obj.MaxMemoryMB, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_maxMemoryMb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_taskDefinitionPrefix(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_taskDefinitionPrefix,
		func(ctx context.Context) (any, error) {
			return obj.TaskDefinitionPrefix, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_taskDefinitionPrefix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_taskRole(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_taskRole,
		func(ctx context.Context) (any, error) {
			return obj.TaskRole, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_taskRole(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_executionRole(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_executionRole,
		func(ctx context.Context) (any, error) {
			return obj.ExecutionRole, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_executionRole(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_logRegion(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_logRegion,
		func(ctx context.Context) (any, error) {
			return obj.LogRegion, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_logRegion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_logGroup(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_logGroup,
		func(ctx context.Context) (any, error) {
			return obj.LogGroup, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_logGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_logStreamPrefix(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_logStreamPrefix,
		func(ctx context.Context) (any, error) {
			return obj.LogStreamPrefix, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_logStreamPrefix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_awsVPC(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_awsVPC,
		func(ctx context.Context) (any, error) {
			return obj.AWSVPC, nil
		},
		nil,
		ec.marshalOAWSVPCConfig2githubcomevergreencievergreenrestmodelAPIAWSVPCConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_awsVPC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "subnets":
				return ec.fieldContext_AWSVPCConfig_subnets(ctx, field)
			case "securityGroups":
				return ec.fieldContext_AWSVPCConfig_securityGroups(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AWSVPCConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_clusters(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_clusters,
		func(ctx context.Context) (any, error) {
			return obj.Clusters, nil
		},
		nil,
		ec.marshalNECSClusterConfig2githubcomevergreencievergreenrestmodelAPIECSClusterConfig,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_clusters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ECSClusterConfig_name(ctx, field)
			case "os":
				return ec.fieldContext_ECSClusterConfig_os(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ECSClusterConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_capacityProviders(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_capacityProviders,
		func(ctx context.Context) (any, error) {
			return obj.CapacityProviders, nil
		},
		nil,
		ec.marshalNECSCapacityProvider2githubcomevergreencievergreenrestmodelAPIECSCapacityProvider,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_capacityProviders(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ECSCapacityProvider_name(ctx, field)
			case "os":
				return ec.fieldContext_ECSCapacityProvider_os(ctx, field)
			case "arch":
				return ec.fieldContext_ECSCapacityProvider_arch(ctx, field)
			case "windowsVersion":
				return ec.fieldContext_ECSCapacityProvider_windowsVersion(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ECSCapacityProvider", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_allowedImages(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ECSConfig_allowedImages,
		func(ctx context.Context) (any, error) {
			return obj.AllowedImages, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ECSConfig_allowedImages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvVar_key(ctx context.Context, field graphql.CollectedField, obj *model.APIEnvVar) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_EnvVar_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_EnvVar_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvVar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvVar_value(ctx context.Context, field graphql.CollectedField, obj *model.APIEnvVar) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_EnvVar_value,
		func(ctx context.Context) (any, error) {
			return obj.Value, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_EnvVar_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvVar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Expansion_key(ctx context.Context, field graphql.CollectedField, obj *model.APIExpansion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Expansion_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Expansion_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Expansion_value(ctx context.Context, field graphql.CollectedField, obj *model.APIExpansion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Expansion_value,
		func(ctx context.Context) (any, error) {
			return obj.Value, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Expansion_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExternalLink_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExternalLink_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_requesters(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExternalLink_requesters,
		func(ctx context.Context) (any, error) {
			return obj.Requesters, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExternalLink_requesters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_urlTemplate(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExternalLink_urlTemplate,
		func(ctx context.Context) (any, error) {
			return obj.URLTemplate, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExternalLink_urlTemplate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLinkForMetadata_url(ctx context.Context, field graphql.CollectedField, obj *ExternalLinkForMetadata) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExternalLinkForMetadata_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExternalLinkForMetadata_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLinkForMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLinkForMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *ExternalLinkForMetadata) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ExternalLinkForMetadata_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ExternalLinkForMetadata_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLinkForMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FWSConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APIFWSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FWSConfig_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FWSConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailingCommand_fullDisplayName(ctx context.Context, field graphql.CollectedField, obj *model.APIFailingCommand) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailingCommand_fullDisplayName,
		func(ctx context.Context) (any, error) {
			return obj.FullDisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailingCommand_fullDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailingCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailingCommand_failureMetadataTags(ctx context.Context, field graphql.CollectedField, obj *model.APIFailingCommand) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailingCommand_failureMetadataTags,
		func(ctx context.Context) (any, error) {
			return obj.FailureMetadataTags, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailingCommand_failureMetadataTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailingCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_link(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_link,
		func(ctx context.Context) (any, error) {
			return obj.Link, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_link(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_name(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_urlParsley(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_urlParsley,
		func(ctx context.Context) (any, error) {
			return obj.URLParsley, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_File_urlParsley(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_visibility(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_visibility,
		func(ctx context.Context) (any, error) {
			return obj.Visibility, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_visibility(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_additions(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileDiff_additions,
		func(ctx context.Context) (any, error) {
			return obj.Additions, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileDiff_additions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_deletions(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileDiff_deletions,
		func(ctx context.Context) (any, error) {
			return obj.Deletions, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileDiff_deletions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_description(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileDiff_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileDiff_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_diffLink(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileDiff_diffLink,
		func(ctx context.Context) (any, error) {
			return obj.DiffLink, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileDiff_diffLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_fileName(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FileDiff_fileName,
		func(ctx context.Context) (any, error) {
			return obj.FileName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FileDiff_fileName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinderSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIFinderSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FinderSettings_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNFinderVersion2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FinderSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinderSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FinderVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_id(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneralSubscription_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GeneralSubscription_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_ownerType(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneralSubscription_ownerType,
		func(ctx context.Context) (any, error) {
			return obj.OwnerType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GeneralSubscription_ownerType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_regexSelectors(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneralSubscription_regexSelectors,
		func(ctx context.Context) (any, error) {
			return obj.RegexSelectors, nil
		},
		nil,
		ec.marshalNSelector2githubcomevergreencievergreenrestmodelAPISelector,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GeneralSubscription_regexSelectors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_Selector_data(ctx, field)
			case "type":
				return ec.fieldContext_Selector_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Selector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneralSubscription_resourceType,
		func(ctx context.Context) (any, error) {
			return obj.ResourceType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GeneralSubscription_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_selectors(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneralSubscription_selectors,
		func(ctx context.Context) (any, error) {
			return obj.Selectors, nil
		},
		nil,
		ec.marshalNSelector2githubcomevergreencievergreenrestmodelAPISelector,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GeneralSubscription_selectors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_Selector_data(ctx, field)
			case "type":
				return ec.fieldContext_Selector_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Selector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_subscriber(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneralSubscription_subscriber,
		func(ctx context.Context) (any, error) {
			return obj.Subscriber, nil
		},
		nil,
		ec.marshalOSubscriberWrapper2githubcomevergreencievergreenrestmodelAPISubscriber,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GeneralSubscription_subscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "subscriber":
				return ec.fieldContext_SubscriberWrapper_subscriber(ctx, field)
			case "type":
				return ec.fieldContext_SubscriberWrapper_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubscriberWrapper", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_trigger(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneralSubscription_trigger,
		func(ctx context.Context) (any, error) {
			return obj.Trigger, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GeneralSubscription_trigger(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_triggerData(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneralSubscription_triggerData,
		func(ctx context.Context) (any, error) {
			return obj.TriggerData, nil
		},
		nil,
		ec.marshalOStringMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GeneralSubscription_triggerData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_buildVariantName(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneratedTaskCountResults_buildVariantName,
		func(ctx context.Context) (any, error) {
			return obj.BuildVariantName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_buildVariantName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_taskName(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneratedTaskCountResults_taskName,
		func(ctx context.Context) (any, error) {
			return obj.TaskName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_taskName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_taskId(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneratedTaskCountResults_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_estimatedTasks(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GeneratedTaskCountResults_estimatedTasks,
		func(ctx context.Context) (any, error) {
			return obj.EstimatedTasks, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_estimatedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_appId(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitHubAuthConfig_appId,
		func(ctx context.Context) (any, error) {
			return obj.AppId, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal int64
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOInt2int64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_appId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_clientId(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitHubAuthConfig_clientId,
		func(ctx context.Context) (any, error) {
			return obj.ClientId, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_clientId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_clientSecret(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitHubAuthConfig_clientSecret,
		func(ctx context.Context) (any, error) {
			return obj.ClientSecret, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_clientSecret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_defaultOwner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitHubAuthConfig_defaultOwner,
		func(ctx context.Context) (any, error) {
			return obj.DefaultOwner, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_defaultOwner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_defaultRepo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitHubAuthConfig_defaultRepo,
		func(ctx context.Context) (any, error) {
			return obj.DefaultRepo, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_defaultRepo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_organization(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitHubAuthConfig_organization,
		func(ctx context.Context) (any, error) {
			return obj.Organization, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_organization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_users(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitHubAuthConfig_users,
		func(ctx context.Context) (any, error) {
			return obj.Users, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubCheckRunConfig_checkRunLimit(ctx context.Context, field graphql.CollectedField, obj *model.APIGitHubCheckRunConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitHubCheckRunConfig_checkRunLimit,
		func(ctx context.Context) (any, error) {
			return obj.CheckRunLimit, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GitHubCheckRunConfig_checkRunLimit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubCheckRunConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubDynamicTokenPermissionGroup_name(ctx context.Context, field graphql.CollectedField, obj *model.APIGitHubDynamicTokenPermissionGroup) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitHubDynamicTokenPermissionGroup_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GitHubDynamicTokenPermissionGroup_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubDynamicTokenPermissionGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubDynamicTokenPermissionGroup_permissions(ctx context.Context, field graphql.CollectedField, obj *model.APIGitHubDynamicTokenPermissionGroup) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitHubDynamicTokenPermissionGroup_permissions,
		func(ctx context.Context) (any, error) {
			return obj.Permissions, nil
		},
		nil,
		ec.marshalNStringMap2map,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GitHubDynamicTokenPermissionGroup_permissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubDynamicTokenPermissionGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitTag_tag(ctx context.Context, field graphql.CollectedField, obj *model.APIGitTag) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitTag_tag,
		func(ctx context.Context) (any, error) {
			return obj.Tag, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GitTag_tag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitTag_pusher(ctx context.Context, field graphql.CollectedField, obj *model.APIGitTag) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GitTag_pusher,
		func(ctx context.Context) (any, error) {
			return obj.Pusher, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GitTag_pusher(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAppAuth_appId(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAppAuth) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubAppAuth_appId,
		func(ctx context.Context) (any, error) {
			return obj.AppID, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubAppAuth_appId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAppAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAppAuth_privateKey(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAppAuth) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubAppAuth_privateKey,
		func(ctx context.Context) (any, error) {
			return obj.PrivateKey, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubAppAuth_privateKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAppAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubCheckSubscriber_owner,
		func(ctx context.Context) (any, error) {
			return obj.Owner, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_ref(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubCheckSubscriber_ref,
		func(ctx context.Context) (any, error) {
			return obj.Ref, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_ref(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubCheckSubscriber_repo,
		func(ctx context.Context) (any, error) {
			return obj.Repo, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPRSubscriber_owner,
		func(ctx context.Context) (any, error) {
			return obj.Owner, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_prNumber(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPRSubscriber_prNumber,
		func(ctx context.Context) (any, error) {
			return obj.PRNumber, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_prNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_ref(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPRSubscriber_ref,
		func(ctx context.Context) (any, error) {
			return obj.Ref, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_ref(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPRSubscriber_repo,
		func(ctx context.Context) (any, error) {
			return obj.Repo, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_author(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPatch_author,
		func(ctx context.Context) (any, error) {
			return obj.Author, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubPatch_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_baseOwner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPatch_baseOwner,
		func(ctx context.Context) (any, error) {
			return obj.BaseOwner, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubPatch_baseOwner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_baseRepo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPatch_baseRepo,
		func(ctx context.Context) (any, error) {
			return obj.BaseRepo, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubPatch_baseRepo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_headBranch(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPatch_headBranch,
		func(ctx context.Context) (any, error) {
			return obj.HeadBranch, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubPatch_headBranch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_headHash(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPatch_headHash,
		func(ctx context.Context) (any, error) {
			return obj.HeadHash, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubPatch_headHash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_headOwner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPatch_headOwner,
		func(ctx context.Context) (any, error) {
			return obj.HeadOwner, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubPatch_headOwner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_headRepo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPatch_headRepo,
		func(ctx context.Context) (any, error) {
			return obj.HeadRepo, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubPatch_headRepo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_prNumber(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubPatch_prNumber,
		func(ctx context.Context) (any, error) {
			return obj.PRNumber, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubPatch_prNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_commitCheckIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubProjectConflicts_commitCheckIdentifiers,
		func(ctx context.Context) (any, error) {
			return obj.CommitCheckIdentifiers, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_commitCheckIdentifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_commitQueueIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubProjectConflicts_commitQueueIdentifiers,
		func(ctx context.Context) (any, error) {
			return obj.CommitQueueIdentifiers, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_commitQueueIdentifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_prTestingIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubProjectConflicts_prTestingIdentifiers,
		func(ctx context.Context) (any, error) {
			return obj.PRTestingIdentifiers, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_prTestingIdentifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_lastKnownAs(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubUser_lastKnownAs,
		func(ctx context.Context) (any, error) {
			return obj.LastKnownAs, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubUser_lastKnownAs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_uid(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GithubUser_uid,
		func(ctx context.Context) (any, error) {
			return obj.UID, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GithubUser_uid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GraphiteConfig_ciOptimizationToken(ctx context.Context, field graphql.CollectedField, obj *model.APIGraphiteConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GraphiteConfig_ciOptimizationToken,
		func(ctx context.Context) (any, error) {
			return obj.CIOptimizationToken, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GraphiteConfig_ciOptimizationToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GraphiteConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GraphiteConfig_serverUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIGraphiteConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GraphiteConfig_serverUrl,
		func(ctx context.Context) (any, error) {
			return obj.ServerURL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GraphiteConfig_serverUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GraphiteConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedBuildVariant_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_tasks(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedBuildVariant_tasks,
		func(ctx context.Context) (any, error) {
			return obj.Tasks, nil
		},
		nil,
		ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_variant(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedBuildVariant_variant,
		func(ctx context.Context) (any, error) {
			return obj.Variant, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_variant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_files(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedFiles_files,
		func(ctx context.Context) (any, error) {
			return obj.Files, nil
		},
		nil,
		ec.marshalOFile2githubcomevergreencievergreenrestmodelAPIFile,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GroupedFiles_files(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "link":
				return ec.fieldContext_File_link(ctx, field)
			case "name":
				return ec.fieldContext_File_name(ctx, field)
			case "urlParsley":
				return ec.fieldContext_File_urlParsley(ctx, field)
			case "visibility":
				return ec.fieldContext_File_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_taskName(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedFiles_taskName,
		func(ctx context.Context) (any, error) {
			return obj.TaskName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GroupedFiles_taskName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_taskId(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedFiles_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupedFiles_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_execution(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedFiles_execution,
		func(ctx context.Context) (any, error) {
			return obj.Execution, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupedFiles_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_groupDisplayName(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedProjects_groupDisplayName,
		func(ctx context.Context) (any, error) {
			return obj.GroupDisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupedProjects_groupDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_projects(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedProjects_projects,
		func(ctx context.Context) (any, error) {
			return obj.Projects, nil
		},
		nil,
		ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupedProjects_projects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_repo(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedProjects_repo,
		func(ctx context.Context) (any, error) {
			return obj.Repo, nil
		},
		nil,
		ec.marshalORepoRef2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GroupedProjects_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoRef_id(ctx, field)
			case "admins":
				return ec.fieldContext_RepoRef_admins(ctx, field)
			case "batchTime":
				return ec.fieldContext_RepoRef_batchTime(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_RepoRef_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_RepoRef_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_RepoRef_enabled(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_RepoRef_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_RepoRef_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_RepoRef_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_RepoRef_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_RepoRef_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_RepoRef_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_RepoRef_parsleyFilters(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_RepoRef_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_RepoRef_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_RepoRef_repo(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_RepoRef_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_RepoRef_debugSpawnHostsDisabled(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_RepoRef_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_RepoRef_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_RepoRef_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_RepoRef_workstationConfig(ctx, field)
			case "externalLinks":
				return ec.fieldContext_RepoRef_externalLinks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_displayName(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedTaskStatusCount_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_statusCounts(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedTaskStatusCount_statusCounts,
		func(ctx context.Context) (any, error) {
			return obj.StatusCounts, nil
		},
		nil,
		ec.marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_statusCounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_StatusCount_count(ctx, field)
			case "status":
				return ec.fieldContext_StatusCount_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_variant(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupedTaskStatusCount_variant,
		func(ctx context.Context) (any, error) {
			return obj.Variant, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_variant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HomeVolumeSettings_formatCommand(ctx context.Context, field graphql.CollectedField, obj *model.APIHomeVolumeSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HomeVolumeSettings_formatCommand,
		func(ctx context.Context) (any, error) {
			return obj.FormatCommand, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HomeVolumeSettings_formatCommand(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HomeVolumeSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_id(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_availabilityZone(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_availabilityZone,
		func(ctx context.Context) (any, error) {
			return obj.AvailabilityZone, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_availabilityZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_ami(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_ami,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Host().Ami(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_ami(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_distro(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_distro,
		func(ctx context.Context) (any, error) {
			return obj.Distro, nil
		},
		nil,
		ec.marshalODistroInfo2githubcomevergreencievergreenrestmodelDistroInfo,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_distro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DistroInfo_id(ctx, field)
			case "bootstrapMethod":
				return ec.fieldContext_DistroInfo_bootstrapMethod(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_DistroInfo_isVirtualWorkStation(ctx, field)
			case "isWindows":
				return ec.fieldContext_DistroInfo_isWindows(ctx, field)
			case "user":
				return ec.fieldContext_DistroInfo_user(ctx, field)
			case "workDir":
				return ec.fieldContext_DistroInfo_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_distroId(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_distroId,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Host().DistroID(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_distroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_elapsed(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_elapsed,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Host().Elapsed(ctx, obj)
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_elapsed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_events(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_events,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Host().Events(ctx, obj, fc.Args["opts"].(HostEventsInput))
		},
		nil,
		ec.marshalNHostEvents2githubcomevergreencievergreengraphqlHostEvents,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_HostEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_HostEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Host_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Host_eventTypes(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_eventTypes,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Host().EventTypes(ctx, obj)
		},
		nil,
		ec.marshalNHostEventType2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_eventTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_expiration(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_expiration,
		func(ctx context.Context) (any, error) {
			return obj.Expiration, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_expiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_hostUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_hostUrl,
		func(ctx context.Context) (any, error) {
			return obj.HostURL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_hostUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_homeVolume(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_homeVolume,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Host().HomeVolume(ctx, obj)
		},
		nil,
		ec.marshalOVolume2githubcomevergreencievergreenrestmodelAPIVolume,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_homeVolume(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_homeVolumeID(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_homeVolumeID,
		func(ctx context.Context) (any, error) {
			return obj.HomeVolumeID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_homeVolumeID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_instanceType(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_instanceType,
		func(ctx context.Context) (any, error) {
			return obj.InstanceType, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_instanceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_instanceTags(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_instanceTags,
		func(ctx context.Context) (any, error) {
			return obj.InstanceTags, nil
		},
		nil,
		ec.marshalNInstanceTag2githubcomevergreencievergreenmodelhostTag,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_instanceTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canBeModified":
				return ec.fieldContext_InstanceTag_canBeModified(ctx, field)
			case "key":
				return ec.fieldContext_InstanceTag_key(ctx, field)
			case "value":
				return ec.fieldContext_InstanceTag_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InstanceTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_lastCommunicationTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_lastCommunicationTime,
		func(ctx context.Context) (any, error) {
			return obj.LastCommunicationTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_lastCommunicationTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_noExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_noExpiration,
		func(ctx context.Context) (any, error) {
			return obj.NoExpiration, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_noExpiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_persistentDnsName(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_persistentDnsName,
		func(ctx context.Context) (any, error) {
			return obj.PersistentDNSName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_persistentDnsName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_provider(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_provider,
		func(ctx context.Context) (any, error) {
			return obj.Provider, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_runningTask(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_runningTask,
		func(ctx context.Context) (any, error) {
			return obj.RunningTask, nil
		},
		nil,
		ec.marshalOTaskInfo2githubcomevergreencievergreenrestmodelTaskInfo,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_runningTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_TaskInfo_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_sleepSchedule(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_sleepSchedule,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Host().SleepSchedule(ctx, obj)
		},
		nil,
		ec.marshalOSleepSchedule2githubcomevergreencievergreenmodelhostSleepScheduleInfo,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_sleepSchedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dailyStartTime":
				return ec.fieldContext_SleepSchedule_dailyStartTime(ctx, field)
			case "dailyStopTime":
				return ec.fieldContext_SleepSchedule_dailyStopTime(ctx, field)
			case "nextStartTime":
				return ec.fieldContext_SleepSchedule_nextStartTime(ctx, field)
			case "nextStopTime":
				return ec.fieldContext_SleepSchedule_nextStopTime(ctx, field)
			case "permanentlyExempt":
				return ec.fieldContext_SleepSchedule_permanentlyExempt(ctx, field)
			case "shouldKeepOff":
				return ec.fieldContext_SleepSchedule_shouldKeepOff(ctx, field)
			case "timeZone":
				return ec.fieldContext_SleepSchedule_timeZone(ctx, field)
			case "temporarilyExemptUntil":
				return ec.fieldContext_SleepSchedule_temporarilyExemptUntil(ctx, field)
			case "wholeWeekdaysOff":
				return ec.fieldContext_SleepSchedule_wholeWeekdaysOff(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SleepSchedule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_startedBy(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_startedBy,
		func(ctx context.Context) (any, error) {
			return obj.StartedBy, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_startedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_status(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_tag(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_tag,
		func(ctx context.Context) (any, error) {
			return obj.Tag, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_tag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_totalIdleTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_totalIdleTime,
		func(ctx context.Context) (any, error) {
			return obj.TotalIdleTime, nil
		},
		nil,
		ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_totalIdleTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_uptime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_uptime,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Host().Uptime(ctx, obj)
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_uptime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_user(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Host_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_volumes(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Host_volumes,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Host().Volumes(ctx, obj)
		},
		nil,
		ec.marshalNVolume2githubcomevergreencievergreenrestmodelAPIVolume,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Host_volumes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_acceptableHostIdleTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostAllocatorSettings_acceptableHostIdleTime,
		func(ctx context.Context) (any, error) {
			return obj.AcceptableHostIdleTime, nil
		},
		nil,
		ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_acceptableHostIdleTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_autoTuneMaximumHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostAllocatorSettings_autoTuneMaximumHosts,
		func(ctx context.Context) (any, error) {
			return obj.AutoTuneMaximumHosts, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_autoTuneMaximumHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_feedbackRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostAllocatorSettings_feedbackRule,
		func(ctx context.Context) (any, error) {
			return obj.FeedbackRule, nil
		},
		nil,
		ec.marshalNFeedbackRule2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_feedbackRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FeedbackRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_futureHostFraction(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostAllocatorSettings_futureHostFraction,
		func(ctx context.Context) (any, error) {
			return obj.FutureHostFraction, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_futureHostFraction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_hostsOverallocatedRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostAllocatorSettings_hostsOverallocatedRule,
		func(ctx context.Context) (any, error) {
			return obj.HostsOverallocatedRule, nil
		},
		nil,
		ec.marshalNOverallocatedRule2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_hostsOverallocatedRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OverallocatedRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_maximumHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostAllocatorSettings_maximumHosts,
		func(ctx context.Context) (any, error) {
			return obj.MaximumHosts, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_maximumHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_minimumHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostAllocatorSettings_minimumHosts,
		func(ctx context.Context) (any, error) {
			return obj.MinimumHosts, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_minimumHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_roundingRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostAllocatorSettings_roundingRule,
		func(ctx context.Context) (any, error) {
			return obj.RoundingRule, nil
		},
		nil,
		ec.marshalNRoundingRule2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_roundingRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RoundingRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostAllocatorSettings_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNHostAllocatorVersion2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostAllocatorVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_agentBuild(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_agentBuild,
		func(ctx context.Context) (any, error) {
			return obj.AgentBuild, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_agentBuild(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_agentRevision(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_agentRevision,
		func(ctx context.Context) (any, error) {
			return obj.AgentRevision, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_agentRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_duration(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_duration,
		func(ctx context.Context) (any, error) {
			return obj.Duration, nil
		},
		nil,
		ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_execution(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_execution,
		func(ctx context.Context) (any, error) {
			return obj.Execution, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_hostname(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_hostname,
		func(ctx context.Context) (any, error) {
			return obj.Hostname, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_hostname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_jasperRevision(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_jasperRevision,
		func(ctx context.Context) (any, error) {
			return obj.JasperRevision, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_jasperRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_logs(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_logs,
		func(ctx context.Context) (any, error) {
			return obj.Logs, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_monitorOp(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_monitorOp,
		func(ctx context.Context) (any, error) {
			return obj.MonitorOp, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_monitorOp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_newStatus,
		func(ctx context.Context) (any, error) {
			return obj.NewStatus, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_newStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_oldStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_oldStatus,
		func(ctx context.Context) (any, error) {
			return obj.OldStatus, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_oldStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_provisioningMethod(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_provisioningMethod,
		func(ctx context.Context) (any, error) {
			return obj.ProvisioningMethod, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_provisioningMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_successful(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_successful,
		func(ctx context.Context) (any, error) {
			return obj.Successful, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_successful(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskId(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskPid(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_taskPid,
		func(ctx context.Context) (any, error) {
			return obj.TaskPid, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskPid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_taskStatus,
		func(ctx context.Context) (any, error) {
			return obj.TaskStatus, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_user(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogData_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogData_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogEntry_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogEntry_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNHostEventLogData2githubcomevergreencievergreenrestmodelHostAPIEventData,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentBuild":
				return ec.fieldContext_HostEventLogData_agentBuild(ctx, field)
			case "agentRevision":
				return ec.fieldContext_HostEventLogData_agentRevision(ctx, field)
			case "duration":
				return ec.fieldContext_HostEventLogData_duration(ctx, field)
			case "execution":
				return ec.fieldContext_HostEventLogData_execution(ctx, field)
			case "hostname":
				return ec.fieldContext_HostEventLogData_hostname(ctx, field)
			case "jasperRevision":
				return ec.fieldContext_HostEventLogData_jasperRevision(ctx, field)
			case "logs":
				return ec.fieldContext_HostEventLogData_logs(ctx, field)
			case "monitorOp":
				return ec.fieldContext_HostEventLogData_monitorOp(ctx, field)
			case "newStatus":
				return ec.fieldContext_HostEventLogData_newStatus(ctx, field)
			case "oldStatus":
				return ec.fieldContext_HostEventLogData_oldStatus(ctx, field)
			case "provisioningMethod":
				return ec.fieldContext_HostEventLogData_provisioningMethod(ctx, field)
			case "successful":
				return ec.fieldContext_HostEventLogData_successful(ctx, field)
			case "taskId":
				return ec.fieldContext_HostEventLogData_taskId(ctx, field)
			case "taskPid":
				return ec.fieldContext_HostEventLogData_taskPid(ctx, field)
			case "taskStatus":
				return ec.fieldContext_HostEventLogData_taskStatus(ctx, field)
			case "user":
				return ec.fieldContext_HostEventLogData_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogEntry_eventType,
		func(ctx context.Context) (any, error) {
			return obj.EventType, nil
		},
		nil,
		ec.marshalOHostEventType2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_eventType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogEntry_processedAt,
		func(ctx context.Context) (any, error) {
			return obj.ProcessedAt, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_processedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogEntry_resourceId,
		func(ctx context.Context) (any, error) {
			return obj.ResourceId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_resourceId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogEntry_resourceType,
		func(ctx context.Context) (any, error) {
			return obj.ResourceType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEventLogEntry_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEvents_count(ctx context.Context, field graphql.CollectedField, obj *HostEvents) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEvents_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEvents_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *HostEvents) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostEvents_eventLogEntries,
		func(ctx context.Context) (any, error) {
			return obj.EventLogEntries, nil
		},
		nil,
		ec.marshalNHostEventLogEntry2githubcomevergreencievergreenrestmodelHostAPIEventLogEntry,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostEvents_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_HostEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_HostEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_HostEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_HostEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_HostEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_HostEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostInitConfig_hostThrottle(ctx context.Context, field graphql.CollectedField, obj *model.APIHostInitConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostInitConfig_hostThrottle,
		func(ctx context.Context) (any, error) {
			return obj.HostThrottle, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostInitConfig_hostThrottle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostInitConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostInitConfig_provisioningThrottle(ctx context.Context, field graphql.CollectedField, obj *model.APIHostInitConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostInitConfig_provisioningThrottle,
		func(ctx context.Context) (any, error) {
			return obj.ProvisioningThrottle, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostInitConfig_provisioningThrottle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostInitConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostInitConfig_cloudStatusBatchSize(ctx context.Context, field graphql.CollectedField, obj *model.APIHostInitConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostInitConfig_cloudStatusBatchSize,
		func(ctx context.Context) (any, error) {
			return obj.CloudStatusBatchSize, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostInitConfig_cloudStatusBatchSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostInitConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostInitConfig_maxTotalDynamicHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostInitConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostInitConfig_maxTotalDynamicHosts,
		func(ctx context.Context) (any, error) {
			return obj.MaxTotalDynamicHosts, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostInitConfig_maxTotalDynamicHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostInitConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostJasperConfig_binaryName(ctx context.Context, field graphql.CollectedField, obj *model.APIHostJasperConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostJasperConfig_binaryName,
		func(ctx context.Context) (any, error) {
			return obj.BinaryName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostJasperConfig_binaryName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostJasperConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostJasperConfig_downloadFileName(ctx context.Context, field graphql.CollectedField, obj *model.APIHostJasperConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostJasperConfig_downloadFileName,
		func(ctx context.Context) (any, error) {
			return obj.DownloadFileName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostJasperConfig_downloadFileName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostJasperConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostJasperConfig_port(ctx context.Context, field graphql.CollectedField, obj *model.APIHostJasperConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostJasperConfig_port,
		func(ctx context.Context) (any, error) {
			return obj.Port, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostJasperConfig_port(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostJasperConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostJasperConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APIHostJasperConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostJasperConfig_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostJasperConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostJasperConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostJasperConfig_version(ctx context.Context, field graphql.CollectedField, obj *model.APIHostJasperConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostJasperConfig_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostJasperConfig_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostJasperConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_filteredHostsCount(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostsResponse_filteredHostsCount,
		func(ctx context.Context) (any, error) {
			return obj.FilteredHostsCount, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_HostsResponse_filteredHostsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_hosts(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostsResponse_hosts,
		func(ctx context.Context) (any, error) {
			return obj.Hosts, nil
		},
		nil,
		ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostsResponse_hosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_totalHostsCount(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_HostsResponse_totalHostsCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalHostsCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_HostsResponse_totalHostsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IceCreamSettings_configPath(ctx context.Context, field graphql.CollectedField, obj *model.APIIceCreamSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IceCreamSettings_configPath,
		func(ctx context.Context) (any, error) {
			return obj.ConfigPath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IceCreamSettings_configPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IceCreamSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IceCreamSettings_schedulerHost(ctx context.Context, field graphql.CollectedField, obj *model.APIIceCreamSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IceCreamSettings_schedulerHost,
		func(ctx context.Context) (any, error) {
			return obj.SchedulerHost, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IceCreamSettings_schedulerHost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IceCreamSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_id(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Image_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Image_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_ami(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Image_ami,
		func(ctx context.Context) (any, error) {
			return obj.AMI, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Image_ami(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_distros(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Image_distros,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Image().Distros(ctx, obj)
		},
		nil,
		ec.marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Image_distros(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "availableRegions":
				return ec.fieldContext_Distro_availableRegions(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerAccount":
				return ec.fieldContext_Distro_providerAccount(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			case "costData":
				return ec.fieldContext_Distro_costData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_events(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Image_events,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Image().Events(ctx, obj, fc.Args["limit"].(int), fc.Args["page"].(int))
		},
		nil,
		ec.marshalNImageEventsPayload2githubcomevergreencievergreengraphqlImageEventsPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Image_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ImageEventsPayload_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ImageEventsPayload_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageEventsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Image_files(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Image_files,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Image().Files(ctx, obj, fc.Args["opts"].(thirdparty.FileFilterOptions))
		},
		nil,
		ec.marshalNImageFilesPayload2githubcomevergreencievergreengraphqlImageFilesPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Image_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ImageFilesPayload_data(ctx, field)
			case "filteredCount":
				return ec.fieldContext_ImageFilesPayload_filteredCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ImageFilesPayload_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageFilesPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_files_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Image_lastDeployed(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Image_lastDeployed,
		func(ctx context.Context) (any, error) {
			return obj.LastDeployed, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Image_lastDeployed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_latestTask(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Image_latestTask,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Image().LatestTask(ctx, obj)
		},
		nil,
		ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Image_latestTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_operatingSystem(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Image_operatingSystem,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Image().OperatingSystem(ctx, obj, fc.Args["opts"].(thirdparty.OSInfoFilterOptions))
		},
		nil,
		ec.marshalNImageOperatingSystemPayload2githubcomevergreencievergreengraphqlImageOperatingSystemPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Image_operatingSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ImageOperatingSystemPayload_data(ctx, field)
			case "filteredCount":
				return ec.fieldContext_ImageOperatingSystemPayload_filteredCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ImageOperatingSystemPayload_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageOperatingSystemPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_operatingSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Image_packages(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Image_packages,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Image().Packages(ctx, obj, fc.Args["opts"].(thirdparty.PackageFilterOptions))
		},
		nil,
		ec.marshalNImagePackagesPayload2githubcomevergreencievergreengraphqlImagePackagesPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Image_packages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ImagePackagesPayload_data(ctx, field)
			case "filteredCount":
				return ec.fieldContext_ImagePackagesPayload_filteredCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ImagePackagesPayload_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImagePackagesPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_packages_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Image_toolchains(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Image_toolchains,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Image().Toolchains(ctx, obj, fc.Args["opts"].(thirdparty.ToolchainFilterOptions))
		},
		nil,
		ec.marshalNImageToolchainsPayload2githubcomevergreencievergreengraphqlImageToolchainsPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Image_toolchains(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ImageToolchainsPayload_data(ctx, field)
			case "filteredCount":
				return ec.fieldContext_ImageToolchainsPayload_filteredCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ImageToolchainsPayload_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageToolchainsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_toolchains_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_entries(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEvent_entries,
		func(ctx context.Context) (any, error) {
			return obj.Entries, nil
		},
		nil,
		ec.marshalNImageEventEntry2githubcomevergreencievergreenrestmodelAPIImageEventEntry,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageEvent_entries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ImageEventEntry_name(ctx, field)
			case "after":
				return ec.fieldContext_ImageEventEntry_after(ctx, field)
			case "before":
				return ec.fieldContext_ImageEventEntry_before(ctx, field)
			case "type":
				return ec.fieldContext_ImageEventEntry_type(ctx, field)
			case "action":
				return ec.fieldContext_ImageEventEntry_action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageEventEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEvent_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageEvent_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_amiBefore(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEvent_amiBefore,
		func(ctx context.Context) (any, error) {
			return obj.AMIBefore, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ImageEvent_amiBefore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_amiAfter(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEvent_amiAfter,
		func(ctx context.Context) (any, error) {
			return obj.AMIAfter, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageEvent_amiAfter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_name(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEventEntry_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageEventEntry_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_after(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEventEntry_after,
		func(ctx context.Context) (any, error) {
			return obj.After, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageEventEntry_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_before(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEventEntry_before,
		func(ctx context.Context) (any, error) {
			return obj.Before, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageEventEntry_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_type(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEventEntry_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNImageEventType2githubcomevergreencievergreenthirdpartyImageEventType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageEventEntry_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_action(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEventEntry_action,
		func(ctx context.Context) (any, error) {
			return obj.Action, nil
		},
		nil,
		ec.marshalNImageEventEntryAction2githubcomevergreencievergreenthirdpartyImageEventEntryAction,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageEventEntry_action(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageEventEntryAction does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventsPayload_count(ctx context.Context, field graphql.CollectedField, obj *ImageEventsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEventsPayload_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageEventsPayload_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventsPayload_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *ImageEventsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageEventsPayload_eventLogEntries,
		func(ctx context.Context) (any, error) {
			return obj.EventLogEntries, nil
		},
		nil,
		ec.marshalNImageEvent2githubcomevergreencievergreenrestmodelAPIImageEvent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageEventsPayload_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "entries":
				return ec.fieldContext_ImageEvent_entries(ctx, field)
			case "timestamp":
				return ec.fieldContext_ImageEvent_timestamp(ctx, field)
			case "amiBefore":
				return ec.fieldContext_ImageEvent_amiBefore(ctx, field)
			case "amiAfter":
				return ec.fieldContext_ImageEvent_amiAfter(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageFile_name(ctx context.Context, field graphql.CollectedField, obj *model.APIImageFile) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageFile_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageFile_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageFile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageFile_path(ctx context.Context, field graphql.CollectedField, obj *model.APIImageFile) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageFile_path,
		func(ctx context.Context) (any, error) {
			return obj.Path, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageFile_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageFile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageFile_version(ctx context.Context, field graphql.CollectedField, obj *model.APIImageFile) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageFile_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageFile_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageFile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageFilesPayload_data(ctx context.Context, field graphql.CollectedField, obj *ImageFilesPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageFilesPayload_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNImageFile2githubcomevergreencievergreenrestmodelAPIImageFile,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageFilesPayload_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageFilesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ImageFile_name(ctx, field)
			case "path":
				return ec.fieldContext_ImageFile_path(ctx, field)
			case "version":
				return ec.fieldContext_ImageFile_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageFile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageFilesPayload_filteredCount(ctx context.Context, field graphql.CollectedField, obj *ImageFilesPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageFilesPayload_filteredCount,
		func(ctx context.Context) (any, error) {
			return obj.FilteredCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageFilesPayload_filteredCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageFilesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageFilesPayload_totalCount(ctx context.Context, field graphql.CollectedField, obj *ImageFilesPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageFilesPayload_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageFilesPayload_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageFilesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageOperatingSystemPayload_data(ctx context.Context, field graphql.CollectedField, obj *ImageOperatingSystemPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageOperatingSystemPayload_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNOSInfo2githubcomevergreencievergreenrestmodelAPIOSInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageOperatingSystemPayload_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageOperatingSystemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_OSInfo_name(ctx, field)
			case "version":
				return ec.fieldContext_OSInfo_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OSInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageOperatingSystemPayload_filteredCount(ctx context.Context, field graphql.CollectedField, obj *ImageOperatingSystemPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageOperatingSystemPayload_filteredCount,
		func(ctx context.Context) (any, error) {
			return obj.FilteredCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageOperatingSystemPayload_filteredCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageOperatingSystemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageOperatingSystemPayload_totalCount(ctx context.Context, field graphql.CollectedField, obj *ImageOperatingSystemPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageOperatingSystemPayload_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageOperatingSystemPayload_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageOperatingSystemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImagePackagesPayload_data(ctx context.Context, field graphql.CollectedField, obj *ImagePackagesPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImagePackagesPayload_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNPackage2githubcomevergreencievergreenrestmodelAPIPackage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImagePackagesPayload_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImagePackagesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Package_name(ctx, field)
			case "manager":
				return ec.fieldContext_Package_manager(ctx, field)
			case "version":
				return ec.fieldContext_Package_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Package", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImagePackagesPayload_filteredCount(ctx context.Context, field graphql.CollectedField, obj *ImagePackagesPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImagePackagesPayload_filteredCount,
		func(ctx context.Context) (any, error) {
			return obj.FilteredCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImagePackagesPayload_filteredCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImagePackagesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImagePackagesPayload_totalCount(ctx context.Context, field graphql.CollectedField, obj *ImagePackagesPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImagePackagesPayload_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImagePackagesPayload_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImagePackagesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageToolchainsPayload_data(ctx context.Context, field graphql.CollectedField, obj *ImageToolchainsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageToolchainsPayload_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNToolchain2githubcomevergreencievergreenrestmodelAPIToolchain,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageToolchainsPayload_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageToolchainsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Toolchain_name(ctx, field)
			case "path":
				return ec.fieldContext_Toolchain_path(ctx, field)
			case "version":
				return ec.fieldContext_Toolchain_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Toolchain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageToolchainsPayload_filteredCount(ctx context.Context, field graphql.CollectedField, obj *ImageToolchainsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageToolchainsPayload_filteredCount,
		func(ctx context.Context) (any, error) {
			return obj.FilteredCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageToolchainsPayload_filteredCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageToolchainsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageToolchainsPayload_totalCount(ctx context.Context, field graphql.CollectedField, obj *ImageToolchainsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageToolchainsPayload_totalCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageToolchainsPayload_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageToolchainsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedLocalModule_module(ctx context.Context, field graphql.CollectedField, obj *model.APILocalModuleInclude) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IncludedLocalModule_module,
		func(ctx context.Context) (any, error) {
			return obj.Module, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IncludedLocalModule_module(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedLocalModule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedLocalModule_fileName(ctx context.Context, field graphql.CollectedField, obj *model.APILocalModuleInclude) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IncludedLocalModule_fileName,
		func(ctx context.Context) (any, error) {
			return obj.FileName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_IncludedLocalModule_fileName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedLocalModule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_canBeModified(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceTag_canBeModified,
		func(ctx context.Context) (any, error) {
			return obj.CanBeModified, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceTag_canBeModified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_key(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceTag_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceTag_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_value(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_InstanceTag_value,
		func(ctx context.Context) (any, error) {
			return obj.Value, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_InstanceTag_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_confidenceScore(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IssueLink_confidenceScore,
		func(ctx context.Context) (any, error) {
			return obj.ConfidenceScore, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_IssueLink_confidenceScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_issueKey(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IssueLink_issueKey,
		func(ctx context.Context) (any, error) {
			return obj.IssueKey, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_IssueLink_issueKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_jiraTicket(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IssueLink_jiraTicket,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.IssueLink().JiraTicket(ctx, obj)
		},
		nil,
		ec.marshalOJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_IssueLink_jiraTicket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_source(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IssueLink_source,
		func(ctx context.Context) (any, error) {
			return obj.Source, nil
		},
		nil,
		ec.marshalOSource2githubcomevergreencievergreenrestmodelAPISource,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_IssueLink_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_url(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_IssueLink_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_IssueLink_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraConfig_email(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraConfig_email,
		func(ctx context.Context) (any, error) {
			return obj.Email, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_JiraConfig_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraConfig_host(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraConfig_host,
		func(ctx context.Context) (any, error) {
			return obj.Host, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_JiraConfig_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraConfig_personalAccessToken(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraConfig_personalAccessToken,
		func(ctx context.Context) (any, error) {
			return obj.PersonalAccessToken, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_JiraConfig_personalAccessToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraIssueSubscriber_issueType(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRAIssueSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraIssueSubscriber_issueType,
		func(ctx context.Context) (any, error) {
			return obj.IssueType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraIssueSubscriber_issueType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraIssueSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraIssueSubscriber_project(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRAIssueSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraIssueSubscriber_project,
		func(ctx context.Context) (any, error) {
			return obj.Project, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraIssueSubscriber_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraIssueSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraNotificationsConfig_customFields(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRANotificationsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraNotificationsConfig_customFields,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.JiraNotificationsConfig().CustomFields(ctx, obj)
		},
		nil,
		ec.marshalNJiraNotificationsProjectEntry2githubcomevergreencievergreengraphqlJiraNotificationsProjectEntry,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraNotificationsConfig_customFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraNotificationsConfig",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "project":
				return ec.fieldContext_JiraNotificationsProjectEntry_project(ctx, field)
			case "fields":
				return ec.fieldContext_JiraNotificationsProjectEntry_fields(ctx, field)
			case "components":
				return ec.fieldContext_JiraNotificationsProjectEntry_components(ctx, field)
			case "labels":
				return ec.fieldContext_JiraNotificationsProjectEntry_labels(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraNotificationsProjectEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraNotificationsProject_fields(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRANotificationsProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraNotificationsProject_fields,
		func(ctx context.Context) (any, error) {
			return obj.Fields, nil
		},
		nil,
		ec.marshalOStringMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_JiraNotificationsProject_fields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraNotificationsProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraNotificationsProject_components(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRANotificationsProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraNotificationsProject_components,
		func(ctx context.Context) (any, error) {
			return obj.Components, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraNotificationsProject_components(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraNotificationsProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraNotificationsProject_labels(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRANotificationsProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraNotificationsProject_labels,
		func(ctx context.Context) (any, error) {
			return obj.Labels, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraNotificationsProject_labels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraNotificationsProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraNotificationsProjectEntry_project(ctx context.Context, field graphql.CollectedField, obj *JiraNotificationsProjectEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraNotificationsProjectEntry_project,
		func(ctx context.Context) (any, error) {
			return obj.Project, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraNotificationsProjectEntry_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraNotificationsProjectEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraNotificationsProjectEntry_fields(ctx context.Context, field graphql.CollectedField, obj *JiraNotificationsProjectEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraNotificationsProjectEntry_fields,
		func(ctx context.Context) (any, error) {
			return obj.Fields, nil
		},
		nil,
		ec.marshalOStringMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_JiraNotificationsProjectEntry_fields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraNotificationsProjectEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraNotificationsProjectEntry_components(ctx context.Context, field graphql.CollectedField, obj *JiraNotificationsProjectEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraNotificationsProjectEntry_components,
		func(ctx context.Context) (any, error) {
			return obj.Components, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraNotificationsProjectEntry_components(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraNotificationsProjectEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraNotificationsProjectEntry_labels(ctx context.Context, field graphql.CollectedField, obj *JiraNotificationsProjectEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraNotificationsProjectEntry_labels,
		func(ctx context.Context) (any, error) {
			return obj.Labels, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraNotificationsProjectEntry_labels(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraNotificationsProjectEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraStatus_id(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraStatus_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraStatus_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraStatus_name(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraStatus) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraStatus_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraStatus_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraTicket_fields(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraTicket) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraTicket_fields,
		func(ctx context.Context) (any, error) {
			return obj.Fields, nil
		},
		nil,
		ec.marshalNTicketFields2githubcomevergreencievergreenthirdpartyTicketFields,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraTicket_fields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignedTeam":
				return ec.fieldContext_TicketFields_assignedTeam(ctx, field)
			case "assigneeDisplayName":
				return ec.fieldContext_TicketFields_assigneeDisplayName(ctx, field)
			case "created":
				return ec.fieldContext_TicketFields_created(ctx, field)
			case "resolutionName":
				return ec.fieldContext_TicketFields_resolutionName(ctx, field)
			case "status":
				return ec.fieldContext_TicketFields_status(ctx, field)
			case "summary":
				return ec.fieldContext_TicketFields_summary(ctx, field)
			case "updated":
				return ec.fieldContext_TicketFields_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TicketFields", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraTicket_key(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraTicket) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_JiraTicket_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_JiraTicket_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KanopyAuthConfig_headerName(ctx context.Context, field graphql.CollectedField, obj *model.APIKanopyAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_KanopyAuthConfig_headerName,
		func(ctx context.Context) (any, error) {
			return obj.HeaderName, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_KanopyAuthConfig_headerName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KanopyAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KanopyAuthConfig_issuer(ctx context.Context, field graphql.CollectedField, obj *model.APIKanopyAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_KanopyAuthConfig_issuer,
		func(ctx context.Context) (any, error) {
			return obj.Issuer, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_KanopyAuthConfig_issuer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KanopyAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KanopyAuthConfig_keysetURL(ctx context.Context, field graphql.CollectedField, obj *model.APIKanopyAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_KanopyAuthConfig_keysetURL,
		func(ctx context.Context) (any, error) {
			return obj.KeysetURL, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_KanopyAuthConfig_keysetURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KanopyAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogBuffering_useAsync(ctx context.Context, field graphql.CollectedField, obj *model.APILogBuffering) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogBuffering_useAsync,
		func(ctx context.Context) (any, error) {
			return obj.UseAsync, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogBuffering_useAsync(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogBuffering",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogBuffering_durationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APILogBuffering) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogBuffering_durationSeconds,
		func(ctx context.Context) (any, error) {
			return obj.DurationSeconds, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LogBuffering_durationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogBuffering",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogBuffering_count(ctx context.Context, field graphql.CollectedField, obj *model.APILogBuffering) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogBuffering_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LogBuffering_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogBuffering",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogBuffering_incomingBufferFactor(ctx context.Context, field graphql.CollectedField, obj *model.APILogBuffering) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogBuffering_incomingBufferFactor,
		func(ctx context.Context) (any, error) {
			return obj.IncomingBufferFactor, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LogBuffering_incomingBufferFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogBuffering",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_message(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogMessage_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LogMessage_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_severity(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogMessage_severity,
		func(ctx context.Context) (any, error) {
			return obj.Severity, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LogMessage_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_timestamp(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogMessage_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LogMessage_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_type(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogMessage_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LogMessage_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_version(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogMessage_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LogMessage_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoggerConfig_buffer(ctx context.Context, field graphql.CollectedField, obj *model.APILoggerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LoggerConfig_buffer,
		func(ctx context.Context) (any, error) {
			return obj.Buffer, nil
		},
		nil,
		ec.marshalOLogBuffering2githubcomevergreencievergreenrestmodelAPILogBuffering,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LoggerConfig_buffer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "useAsync":
				return ec.fieldContext_LogBuffering_useAsync(ctx, field)
			case "durationSeconds":
				return ec.fieldContext_LogBuffering_durationSeconds(ctx, field)
			case "count":
				return ec.fieldContext_LogBuffering_count(ctx, field)
			case "incomingBufferFactor":
				return ec.fieldContext_LogBuffering_incomingBufferFactor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogBuffering", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoggerConfig_defaultLevel(ctx context.Context, field graphql.CollectedField, obj *model.APILoggerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LoggerConfig_defaultLevel,
		func(ctx context.Context) (any, error) {
			return obj.DefaultLevel, nil
		},
		nil,
		ec.marshalOPriorityLevel2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LoggerConfig_defaultLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PriorityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoggerConfig_thresholdLevel(ctx context.Context, field graphql.CollectedField, obj *model.APILoggerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LoggerConfig_thresholdLevel,
		func(ctx context.Context) (any, error) {
			return obj.ThresholdLevel, nil
		},
		nil,
		ec.marshalOPriorityLevel2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LoggerConfig_thresholdLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PriorityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoggerConfig_logkeeperURL(ctx context.Context, field graphql.CollectedField, obj *model.APILoggerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LoggerConfig_logkeeperURL,
		func(ctx context.Context) (any, error) {
			return obj.LogkeeperURL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LoggerConfig_logkeeperURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoggerConfig_redactKeys(ctx context.Context, field graphql.CollectedField, obj *model.APILoggerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LoggerConfig_redactKeys,
		func(ctx context.Context) (any, error) {
			return obj.RedactKeys, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LoggerConfig_redactKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_id(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperBuild_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_builder(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperBuild_builder,
		func(ctx context.Context) (any, error) {
			return obj.Builder, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_builder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_buildNum(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperBuild_buildNum,
		func(ctx context.Context) (any, error) {
			return obj.BuildNum, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_buildNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_taskId(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperBuild_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_taskExecution(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperBuild_taskExecution,
		func(ctx context.Context) (any, error) {
			return obj.TaskExecution, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_tests(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperBuild_tests,
		func(ctx context.Context) (any, error) {
			return obj.Tests, nil
		},
		nil,
		ec.marshalNLogkeeperTest2githubcomevergreenciplankTest,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_tests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LogkeeperTest_id(ctx, field)
			case "name":
				return ec.fieldContext_LogkeeperTest_name(ctx, field)
			case "buildId":
				return ec.fieldContext_LogkeeperTest_buildId(ctx, field)
			case "taskId":
				return ec.fieldContext_LogkeeperTest_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_LogkeeperTest_taskExecution(ctx, field)
			case "phase":
				return ec.fieldContext_LogkeeperTest_phase(ctx, field)
			case "command":
				return ec.fieldContext_LogkeeperTest_command(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogkeeperTest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_task(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperBuild_task,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.LogkeeperBuild().Task(ctx, obj)
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_id(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperTest_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperTest_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_name(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperTest_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperTest_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_buildId(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperTest_buildId,
		func(ctx context.Context) (any, error) {
			return obj.BuildID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperTest_buildId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_taskId(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperTest_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperTest_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_taskExecution(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperTest_taskExecution,
		func(ctx context.Context) (any, error) {
			return obj.TaskExecution, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperTest_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_phase(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperTest_phase,
		func(ctx context.Context) (any, error) {
			return obj.Phase, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperTest_phase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_command(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LogkeeperTest_command,
		func(ctx context.Context) (any, error) {
			return obj.Command, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LogkeeperTest_command(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommitVersion_rolledUpVersions(ctx context.Context, field graphql.CollectedField, obj *MainlineCommitVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MainlineCommitVersion_rolledUpVersions,
		func(ctx context.Context) (any, error) {
			return obj.RolledUpVersions, nil
		},
		nil,
		ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_MainlineCommitVersion_rolledUpVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommitVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommitVersion_version(ctx context.Context, field graphql.CollectedField, obj *MainlineCommitVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MainlineCommitVersion_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_MainlineCommitVersion_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommitVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_nextPageOrderNumber(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MainlineCommits_nextPageOrderNumber,
		func(ctx context.Context) (any, error) {
			return obj.NextPageOrderNumber, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_MainlineCommits_nextPageOrderNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_prevPageOrderNumber(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MainlineCommits_prevPageOrderNumber,
		func(ctx context.Context) (any, error) {
			return obj.PrevPageOrderNumber, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_MainlineCommits_prevPageOrderNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_versions(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MainlineCommits_versions,
		func(ctx context.Context) (any, error) {
			return obj.Versions, nil
		},
		nil,
		ec.marshalNMainlineCommitVersion2githubcomevergreencievergreengraphqlMainlineCommitVersion,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_MainlineCommits_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rolledUpVersions":
				return ec.fieldContext_MainlineCommitVersion_rolledUpVersions(ctx, field)
			case "version":
				return ec.fieldContext_MainlineCommitVersion_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MainlineCommitVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_id(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Manifest_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Manifest_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_branch(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Manifest_branch,
		func(ctx context.Context) (any, error) {
			return obj.Branch, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Manifest_branch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_isBase(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Manifest_isBase,
		func(ctx context.Context) (any, error) {
			return obj.IsBase, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Manifest_isBase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_moduleOverrides(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Manifest_moduleOverrides,
		func(ctx context.Context) (any, error) {
			return obj.ModuleOverrides, nil
		},
		nil,
		ec.marshalOStringMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Manifest_moduleOverrides(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_modules(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Manifest_modules,
		func(ctx context.Context) (any, error) {
			return obj.Modules, nil
		},
		nil,
		ec.marshalOMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Manifest_modules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_project(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Manifest_project,
		func(ctx context.Context) (any, error) {
			return obj.Project, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Manifest_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_revision(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Manifest_revision,
		func(ctx context.Context) (any, error) {
			return obj.Revision, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Manifest_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_url(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MetadataLink_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_MetadataLink_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_text(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MetadataLink_text,
		func(ctx context.Context) (any, error) {
			return obj.Text, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_MetadataLink_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_source(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MetadataLink_source,
		func(ctx context.Context) (any, error) {
			return obj.Source, nil
		},
		nil,
		ec.marshalOSource2githubcomevergreencievergreenrestmodelAPISource,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_MetadataLink_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_branchName(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ModuleCodeChange_branchName,
		func(ctx context.Context) (any, error) {
			return obj.BranchName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_branchName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_fileDiffs(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ModuleCodeChange_fileDiffs,
		func(ctx context.Context) (any, error) {
			return obj.FileDiffs, nil
		},
		nil,
		ec.marshalNFileDiff2githubcomevergreencievergreenrestmodelFileDiff,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_fileDiffs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "additions":
				return ec.fieldContext_FileDiff_additions(ctx, field)
			case "deletions":
				return ec.fieldContext_FileDiff_deletions(ctx, field)
			case "description":
				return ec.fieldContext_FileDiff_description(ctx, field)
			case "diffLink":
				return ec.fieldContext_FileDiff_diffLink(ctx, field)
			case "fileName":
				return ec.fieldContext_FileDiff_fileName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDiff", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_htmlLink(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ModuleCodeChange_htmlLink,
		func(ctx context.Context) (any, error) {
			return obj.HTMLLink, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_htmlLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_rawLink(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ModuleCodeChange_rawLink,
		func(ctx context.Context) (any, error) {
			return obj.RawLink, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_rawLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MultiAuthConfig_readWrite(ctx context.Context, field graphql.CollectedField, obj *model.APIMultiAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MultiAuthConfig_readWrite,
		func(ctx context.Context) (any, error) {
			return obj.ReadWrite, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_MultiAuthConfig_readWrite(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MultiAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MultiAuthConfig_readOnly(ctx context.Context, field graphql.CollectedField, obj *model.APIMultiAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MultiAuthConfig_readOnly,
		func(ctx context.Context) (any, error) {
			return obj.ReadOnly, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_MultiAuthConfig_readOnly(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MultiAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bbCreateTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_bbCreateTicket,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().BbCreateTicket(ctx, fc.Args["taskId"].(string), fc.Args["execution"].(*int))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_bbCreateTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bbCreateTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_addAnnotationIssue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().AddAnnotationIssue(ctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_addAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editAnnotationNote(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_editAnnotationNote,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().EditAnnotationNote(ctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["originalMessage"].(string), fc.Args["newMessage"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_editAnnotationNote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editAnnotationNote_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_moveAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_moveAnnotationIssue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().MoveAnnotationIssue(ctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_moveAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_moveAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_removeAnnotationIssue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RemoveAnnotationIssue(ctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_removeAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setAnnotationMetadataLinks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_setAnnotationMetadataLinks,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SetAnnotationMetadataLinks(ctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["metadataLinks"].([]*model.APIMetadataLink))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_setAnnotationMetadataLinks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setAnnotationMetadataLinks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveAdminSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_saveAdminSettings,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SaveAdminSettings(ctx, fc.Args["adminSettings"].(model.APIAdminSettings))
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *model.APIAdminSettings
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, nil, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNAdminSettings2githubcomevergreencievergreenrestmodelAPIAdminSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_saveAdminSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "amboy":
				return ec.fieldContext_AdminSettings_amboy(ctx, field)
			case "amboyDB":
				return ec.fieldContext_AdminSettings_amboyDB(ctx, field)
			case "api":
				return ec.fieldContext_AdminSettings_api(ctx, field)
			case "authConfig":
				return ec.fieldContext_AdminSettings_authConfig(ctx, field)
			case "banner":
				return ec.fieldContext_AdminSettings_banner(ctx, field)
			case "bannerTheme":
				return ec.fieldContext_AdminSettings_bannerTheme(ctx, field)
			case "buckets":
				return ec.fieldContext_AdminSettings_buckets(ctx, field)
			case "cedar":
				return ec.fieldContext_AdminSettings_cedar(ctx, field)
			case "configDir":
				return ec.fieldContext_AdminSettings_configDir(ctx, field)
			case "containerPools":
				return ec.fieldContext_AdminSettings_containerPools(ctx, field)
			case "cost":
				return ec.fieldContext_AdminSettings_cost(ctx, field)
			case "disabledGQLQueries":
				return ec.fieldContext_AdminSettings_disabledGQLQueries(ctx, field)
			case "domainName":
				return ec.fieldContext_AdminSettings_domainName(ctx, field)
			case "expansions":
				return ec.fieldContext_AdminSettings_expansions(ctx, field)
			case "fws":
				return ec.fieldContext_AdminSettings_fws(ctx, field)
			case "graphite":
				return ec.fieldContext_AdminSettings_graphite(ctx, field)
			case "githubCheckRun":
				return ec.fieldContext_AdminSettings_githubCheckRun(ctx, field)
			case "githubOrgs":
				return ec.fieldContext_AdminSettings_githubOrgs(ctx, field)
			case "githubPRCreatorOrg":
				return ec.fieldContext_AdminSettings_githubPRCreatorOrg(ctx, field)
			case "githubWebhookSecret":
				return ec.fieldContext_AdminSettings_githubWebhookSecret(ctx, field)
			case "hostInit":
				return ec.fieldContext_AdminSettings_hostInit(ctx, field)
			case "hostJasper":
				return ec.fieldContext_AdminSettings_hostJasper(ctx, field)
			case "jira":
				return ec.fieldContext_AdminSettings_jira(ctx, field)
			case "jiraNotifications":
				return ec.fieldContext_AdminSettings_jiraNotifications(ctx, field)
			case "kanopySSHKeyPath":
				return ec.fieldContext_AdminSettings_kanopySSHKeyPath(ctx, field)
			case "logPath":
				return ec.fieldContext_AdminSettings_logPath(ctx, field)
			case "loggerConfig":
				return ec.fieldContext_AdminSettings_loggerConfig(ctx, field)
			case "notify":
				return ec.fieldContext_AdminSettings_notify(ctx, field)
			case "oldestAllowedCLIVersion":
				return ec.fieldContext_AdminSettings_oldestAllowedCLIVersion(ctx, field)
			case "parameterStore":
				return ec.fieldContext_AdminSettings_parameterStore(ctx, field)
			case "perfMonitoringKanopyURL":
				return ec.fieldContext_AdminSettings_perfMonitoringKanopyURL(ctx, field)
			case "perfMonitoringURL":
				return ec.fieldContext_AdminSettings_perfMonitoringURL(ctx, field)
			case "podLifecycle":
				return ec.fieldContext_AdminSettings_podLifecycle(ctx, field)
			case "pprofPort":
				return ec.fieldContext_AdminSettings_pprofPort(ctx, field)
			case "projectCreation":
				return ec.fieldContext_AdminSettings_projectCreation(ctx, field)
			case "providers":
				return ec.fieldContext_AdminSettings_providers(ctx, field)
			case "releaseMode":
				return ec.fieldContext_AdminSettings_releaseMode(ctx, field)
			case "repotracker":
				return ec.fieldContext_AdminSettings_repotracker(ctx, field)
			case "runtimeEnvironments":
				return ec.fieldContext_AdminSettings_runtimeEnvironments(ctx, field)
			case "scheduler":
				return ec.fieldContext_AdminSettings_scheduler(ctx, field)
			case "serviceFlags":
				return ec.fieldContext_AdminSettings_serviceFlags(ctx, field)
			case "shutdownWaitSeconds":
				return ec.fieldContext_AdminSettings_shutdownWaitSeconds(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_AdminSettings_singleTaskDistro(ctx, field)
			case "slack":
				return ec.fieldContext_AdminSettings_slack(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_AdminSettings_sleepSchedule(ctx, field)
			case "spawnhost":
				return ec.fieldContext_AdminSettings_spawnhost(ctx, field)
			case "splunk":
				return ec.fieldContext_AdminSettings_splunk(ctx, field)
			case "ssh":
				return ec.fieldContext_AdminSettings_ssh(ctx, field)
			case "taskLimits":
				return ec.fieldContext_AdminSettings_taskLimits(ctx, field)
			case "testSelection":
				return ec.fieldContext_AdminSettings_testSelection(ctx, field)
			case "tracer":
				return ec.fieldContext_AdminSettings_tracer(ctx, field)
			case "triggers":
				return ec.fieldContext_AdminSettings_triggers(ctx, field)
			case "ui":
				return ec.fieldContext_AdminSettings_ui(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveAdminSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartAdminTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_restartAdminTasks,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RestartAdminTasks(ctx, fc.Args["opts"].(model1.RestartOptions))
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *RestartAdminTasksPayload
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, nil, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNRestartAdminTasksPayload2githubcomevergreencievergreengraphqlRestartAdminTasksPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_restartAdminTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "numRestartedTasks":
				return ec.fieldContext_RestartAdminTasksPayload_numRestartedTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RestartAdminTasksPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartAdminTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteDistro,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteDistro(ctx, fc.Args["opts"].(DeleteDistroInput))
		},
		nil,
		ec.marshalNDeleteDistroPayload2githubcomevergreencievergreengraphqlDeleteDistroPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedDistroId":
				return ec.fieldContext_DeleteDistroPayload_deletedDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_copyDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_copyDistro,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CopyDistro(ctx, fc.Args["opts"].(model.CopyDistroOpts))
		},
		nil,
		ec.marshalNNewDistroPayload2githubcomevergreencievergreengraphqlNewDistroPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_copyDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "newDistroId":
				return ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_copyDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createDistro,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateDistro(ctx, fc.Args["opts"].(CreateDistroInput))
		},
		nil,
		ec.marshalNNewDistroPayload2githubcomevergreencievergreengraphqlNewDistroPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "newDistroId":
				return ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_saveDistro,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SaveDistro(ctx, fc.Args["opts"].(SaveDistroInput))
		},
		nil,
		ec.marshalNSaveDistroPayload2githubcomevergreencievergreengraphqlSaveDistroPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_saveDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distro":
				return ec.fieldContext_SaveDistroPayload_distro(ctx, field)
			case "hostCount":
				return ec.fieldContext_SaveDistroPayload_hostCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SaveDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reprovisionToNew(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_reprovisionToNew,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ReprovisionToNew(ctx, fc.Args["hostIds"].([]string))
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_reprovisionToNew(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reprovisionToNew_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartJasper(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_restartJasper,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RestartJasper(ctx, fc.Args["hostIds"].([]string))
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_restartJasper(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartJasper_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateHostStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateHostStatus,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateHostStatus(ctx, fc.Args["hostIds"].([]string), fc.Args["status"].(string), fc.Args["notes"].(*string))
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateHostStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateHostStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setPatchVisibility(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_setPatchVisibility,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SetPatchVisibility(ctx, fc.Args["patchIds"].([]string), fc.Args["hidden"].(bool))
		},
		nil,
		ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_setPatchVisibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "includedLocalModules":
				return ec.fieldContext_Patch_includedLocalModules(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "user":
				return ec.fieldContext_Patch_user(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setPatchVisibility_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_schedulePatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_schedulePatch,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SchedulePatch(ctx, fc.Args["patchId"].(string), fc.Args["configure"].(PatchConfigure))
		},
		nil,
		ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_schedulePatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "includedLocalModules":
				return ec.fieldContext_Patch_includedLocalModules(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "user":
				return ec.fieldContext_Patch_user(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_schedulePatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachProjectToNewRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_attachProjectToNewRepo,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().AttachProjectToNewRepo(ctx, fc.Args["project"].(MoveProjectInput))
		},
		nil,
		ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_attachProjectToNewRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachProjectToNewRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachProjectToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_attachProjectToRepo,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().AttachProjectToRepo(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_attachProjectToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachProjectToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createProject,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreateProject(ctx, fc.Args["project"].(model.APIProjectRef), fc.Args["requestS3Creds"].(*bool))
		},
		nil,
		ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_copyProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_copyProject,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CopyProject(ctx, fc.Args["project"].(model.CopyProjectOpts), fc.Args["requestS3Creds"].(*bool))
		},
		nil,
		ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_copyProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_copyProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deactivateStepbackTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deactivateStepbackTask,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeactivateStepbackTask(ctx, fc.Args["opts"].(DeactivateStepbackTaskInput))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deactivateStepbackTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deactivateStepbackTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_defaultSectionToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_defaultSectionToRepo,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DefaultSectionToRepo(ctx, fc.Args["opts"].(DefaultSectionToRepoInput))
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Mutation_defaultSectionToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_defaultSectionToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGithubAppCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteGithubAppCredentials,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteGithubAppCredentials(ctx, fc.Args["opts"].(DeleteGithubAppCredentialsInput))
		},
		nil,
		ec.marshalODeleteGithubAppCredentialsPayload2githubcomevergreencievergreengraphqlDeleteGithubAppCredentialsPayload,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteGithubAppCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "oldAppId":
				return ec.fieldContext_DeleteGithubAppCredentialsPayload_oldAppId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteGithubAppCredentialsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGithubAppCredentials_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteProject,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteProject(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_detachProjectFromRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_detachProjectFromRepo,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DetachProjectFromRepo(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_detachProjectFromRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_detachProjectFromRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_forceRepotrackerRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_forceRepotrackerRun,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ForceRepotrackerRun(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_forceRepotrackerRun(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_forceRepotrackerRun_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_promoteVarsToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_promoteVarsToRepo,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().PromoteVarsToRepo(ctx, fc.Args["opts"].(PromoteVarsToRepoInput))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_promoteVarsToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_promoteVarsToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveProjectSettingsForSection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_saveProjectSettingsForSection,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SaveProjectSettingsForSection(ctx, fc.Args["projectSettings"].(*model.APIProjectSettings), fc.Args["section"].(ProjectSettingsSection))
		},
		nil,
		ec.marshalNProjectSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_saveProjectSettingsForSection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveProjectSettingsForSection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveRepoSettingsForSection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_saveRepoSettingsForSection,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SaveRepoSettingsForSection(ctx, fc.Args["repoSettings"].(*model.APIProjectSettings), fc.Args["section"].(ProjectSettingsSection))
		},
		nil,
		ec.marshalNRepoSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_saveRepoSettingsForSection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_RepoSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_RepoSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_RepoSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_RepoSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_RepoSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveRepoSettingsForSection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setLastRevision(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_setLastRevision,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SetLastRevision(ctx, fc.Args["opts"].(SetLastRevisionInput))
		},
		nil,
		ec.marshalNSetLastRevisionPayload2githubcomevergreencievergreengraphqlSetLastRevisionPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_setLastRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mergeBaseRevision":
				return ec.fieldContext_SetLastRevisionPayload_mergeBaseRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetLastRevisionPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setLastRevision_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachVolumeToHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_attachVolumeToHost,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().AttachVolumeToHost(ctx, fc.Args["volumeAndHost"].(VolumeHost))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_attachVolumeToHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachVolumeToHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_detachVolumeFromHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_detachVolumeFromHost,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DetachVolumeFromHost(ctx, fc.Args["volumeId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_detachVolumeFromHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_detachVolumeFromHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editSpawnHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_editSpawnHost,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().EditSpawnHost(ctx, fc.Args["spawnHost"].(*EditSpawnHostInput))
		},
		nil,
		ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_editSpawnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editSpawnHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_migrateVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_migrateVolume,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().MigrateVolume(ctx, fc.Args["volumeId"].(string), fc.Args["spawnHostInput"].(*SpawnHostInput))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_migrateVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_migrateVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_spawnHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_spawnHost,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SpawnHost(ctx, fc.Args["spawnHostInput"].(*SpawnHostInput))
		},
		nil,
		ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_spawnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_spawnHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_spawnVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_spawnVolume,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SpawnVolume(ctx, fc.Args["spawnVolumeInput"].(SpawnVolumeInput))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_spawnVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_spawnVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_removeVolume,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RemoveVolume(ctx, fc.Args["volumeId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_removeVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSpawnHostStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateSpawnHostStatus,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateSpawnHostStatus(ctx, fc.Args["updateSpawnHostStatusInput"].(UpdateSpawnHostStatusInput))
		},
		nil,
		ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateSpawnHostStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSpawnHostStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateVolume,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateVolume(ctx, fc.Args["updateVolumeInput"].(UpdateVolumeInput))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_abortTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_abortTask,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().AbortTask(ctx, fc.Args["taskId"].(string))
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_abortTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_abortTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_overrideTaskDependencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_overrideTaskDependencies,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().OverrideTaskDependencies(ctx, fc.Args["taskId"].(string))
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_overrideTaskDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_overrideTaskDependencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_restartTask,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RestartTask(ctx, fc.Args["taskId"].(string), fc.Args["failedOnly"].(bool))
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_restartTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_scheduleTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_scheduleTasks,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ScheduleTasks(ctx, fc.Args["versionId"].(string), fc.Args["taskIds"].([]string))
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_scheduleTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_scheduleTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setTaskPriority(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_setTaskPriority,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SetTaskPriority(ctx, fc.Args["taskId"].(string), fc.Args["priority"].(int))
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_setTaskPriority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setTaskPriority_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setTaskPriorities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_setTaskPriorities,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SetTaskPriorities(ctx, fc.Args["taskPriorities"].([]*TaskPriority))
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_setTaskPriorities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setTaskPriorities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unscheduleTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_unscheduleTask,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UnscheduleTask(ctx, fc.Args["taskId"].(string))
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_unscheduleTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unscheduleTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_quarantineTest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_quarantineTest,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().QuarantineTest(ctx, fc.Args["opts"].(QuarantineTestInput))
		},
		nil,
		ec.marshalNQuarantineTestPayload2githubcomevergreencievergreengraphqlQuarantineTestPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_quarantineTest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_QuarantineTestPayload_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type QuarantineTestPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_quarantineTest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addFavoriteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_addFavoriteProject,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().AddFavoriteProject(ctx, fc.Args["opts"].(AddFavoriteProjectInput))
		},
		nil,
		ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_addFavoriteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addFavoriteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_clearMySubscriptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_clearMySubscriptions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().ClearMySubscriptions(ctx)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_clearMySubscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_createPublicKey,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().CreatePublicKey(ctx, fc.Args["publicKeyInput"].(PublicKeyInput))
		},
		nil,
		ec.marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_createPublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSubscriptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_deleteSubscriptions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().DeleteSubscriptions(ctx, fc.Args["subscriptionIds"].([]string))
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_deleteSubscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSubscriptions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeFavoriteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_removeFavoriteProject,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RemoveFavoriteProject(ctx, fc.Args["opts"].(RemoveFavoriteProjectInput))
		},
		nil,
		ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_removeFavoriteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeFavoriteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removePublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_removePublicKey,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RemovePublicKey(ctx, fc.Args["keyName"].(string))
		},
		nil,
		ec.marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_removePublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removePublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_resetAPIKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_resetAPIKey,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Mutation().ResetAPIKey(ctx)
		},
		nil,
		ec.marshalOUserConfig2githubcomevergreencievergreengraphqlUserConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Mutation_resetAPIKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "api_key":
				return ec.fieldContext_UserConfig_api_key(ctx, field)
			case "api_server_host":
				return ec.fieldContext_UserConfig_api_server_host(ctx, field)
			case "ui_server_host":
				return ec.fieldContext_UserConfig_ui_server_host(ctx, field)
			case "user":
				return ec.fieldContext_UserConfig_user(ctx, field)
			case "oauth_issuer":
				return ec.fieldContext_UserConfig_oauth_issuer(ctx, field)
			case "oauth_client_id":
				return ec.fieldContext_UserConfig_oauth_client_id(ctx, field)
			case "oauth_connector_id":
				return ec.fieldContext_UserConfig_oauth_connector_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveSubscription(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_saveSubscription,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SaveSubscription(ctx, fc.Args["subscription"].(model.APISubscription))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_saveSubscription(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveSubscription_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBetaFeatures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateBetaFeatures,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateBetaFeatures(ctx, fc.Args["opts"].(UpdateBetaFeaturesInput))
		},
		nil,
		ec.marshalOUpdateBetaFeaturesPayload2githubcomevergreencievergreengraphqlUpdateBetaFeaturesPayload,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateBetaFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_UpdateBetaFeaturesPayload_betaFeatures(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateBetaFeaturesPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBetaFeatures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateParsleySettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateParsleySettings,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateParsleySettings(ctx, fc.Args["opts"].(UpdateParsleySettingsInput))
		},
		nil,
		ec.marshalOUpdateParsleySettingsPayload2githubcomevergreencievergreengraphqlUpdateParsleySettingsPayload,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateParsleySettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "parsleySettings":
				return ec.fieldContext_UpdateParsleySettingsPayload_parsleySettings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateParsleySettingsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateParsleySettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updatePublicKey,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdatePublicKey(ctx, fc.Args["targetKeyName"].(string), fc.Args["updateInfo"].(PublicKeyInput))
		},
		nil,
		ec.marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updatePublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_updateUserSettings,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UpdateUserSettings(ctx, fc.Args["userSettings"].(*model.APIUserSettings))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Mutation_updateUserSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_restartVersions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().RestartVersions(ctx, fc.Args["versionId"].(string), fc.Args["abort"].(bool), fc.Args["versionsToRestart"].([]*model1.VersionToRestart))
		},
		nil,
		ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Mutation_restartVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_scheduleUndispatchedBaseTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_scheduleUndispatchedBaseTasks,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().ScheduleUndispatchedBaseTasks(ctx, fc.Args["versionId"].(string))
		},
		nil,
		ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Mutation_scheduleUndispatchedBaseTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_scheduleUndispatchedBaseTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setVersionPriority(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_setVersionPriority,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().SetVersionPriority(ctx, fc.Args["versionId"].(string), fc.Args["priority"].(int))
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Mutation_setVersionPriority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setVersionPriority_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unscheduleVersionTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Mutation_unscheduleVersionTasks,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Mutation().UnscheduleVersionTasks(ctx, fc.Args["versionId"].(string), fc.Args["abort"].(bool))
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Mutation_unscheduleVersionTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unscheduleVersionTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _NaiveAuthConfig_users(ctx context.Context, field graphql.CollectedField, obj *model.APINaiveAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NaiveAuthConfig_users,
		func(ctx context.Context) (any, error) {
			return obj.Users, nil
		},
		nil,
		ec.marshalNAuthUser2githubcomevergreencievergreenrestmodelAPIAuthUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NaiveAuthConfig_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NaiveAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "displayName":
				return ec.fieldContext_AuthUser_displayName(ctx, field)
			case "password":
				return ec.fieldContext_AuthUser_password(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NewDistroPayload_newDistroId(ctx context.Context, field graphql.CollectedField, obj *NewDistroPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NewDistroPayload_newDistroId,
		func(ctx context.Context) (any, error) {
			return obj.NewDistroID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NewDistroPayload_newDistroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NewDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Note_message(ctx context.Context, field graphql.CollectedField, obj *model.APINote) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Note_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Note_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Note",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Note_source(ctx context.Context, field graphql.CollectedField, obj *model.APINote) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Note_source,
		func(ctx context.Context) (any, error) {
			return obj.Source, nil
		},
		nil,
		ec.marshalNSource2githubcomevergreencievergreenrestmodelAPISource,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Note_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Note",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_buildBreak(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Notifications_buildBreak,
		func(ctx context.Context) (any, error) {
			return obj.BuildBreak, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Notifications_buildBreak(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_buildBreakId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Notifications_buildBreakId,
		func(ctx context.Context) (any, error) {
			return obj.BuildBreakID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Notifications_buildBreakId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFinish(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Notifications_patchFinish,
		func(ctx context.Context) (any, error) {
			return obj.PatchFinish, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Notifications_patchFinish(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFinishId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Notifications_patchFinishId,
		func(ctx context.Context) (any, error) {
			return obj.PatchFinishID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Notifications_patchFinishId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFirstFailure(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Notifications_patchFirstFailure,
		func(ctx context.Context) (any, error) {
			return obj.PatchFirstFailure, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Notifications_patchFirstFailure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFirstFailureId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Notifications_patchFirstFailureId,
		func(ctx context.Context) (any, error) {
			return obj.PatchFirstFailureID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Notifications_patchFirstFailureId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Notifications_spawnHostExpiration,
		func(ctx context.Context) (any, error) {
			return obj.SpawnHostExpiration, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostExpiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostExpirationId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Notifications_spawnHostExpirationId,
		func(ctx context.Context) (any, error) {
			return obj.SpawnHostExpirationID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostExpirationId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostOutcome(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Notifications_spawnHostOutcome,
		func(ctx context.Context) (any, error) {
			return obj.SpawnHostOutcome, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostOutcome(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostOutcomeId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Notifications_spawnHostOutcomeId,
		func(ctx context.Context) (any, error) {
			return obj.SpawnHostOutcomeID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostOutcomeId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifyConfig_ses(ctx context.Context, field graphql.CollectedField, obj *model.APINotifyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NotifyConfig_ses,
		func(ctx context.Context) (any, error) {
			return obj.SES, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal model.APISESConfig
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOSESConfig2githubcomevergreencievergreenrestmodelAPISESConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_NotifyConfig_ses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "senderAddress":
				return ec.fieldContext_SESConfig_senderAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SESConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifyConfig_bufferTargetPerInterval(ctx context.Context, field graphql.CollectedField, obj *model.APINotifyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NotifyConfig_bufferTargetPerInterval,
		func(ctx context.Context) (any, error) {
			return obj.BufferTargetPerInterval, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_NotifyConfig_bufferTargetPerInterval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifyConfig_bufferIntervalSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APINotifyConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NotifyConfig_bufferIntervalSeconds,
		func(ctx context.Context) (any, error) {
			return obj.BufferIntervalSeconds, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_NotifyConfig_bufferIntervalSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthConfig_issuer(ctx context.Context, field graphql.CollectedField, obj *model.APIOAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OAuthConfig_issuer,
		func(ctx context.Context) (any, error) {
			return obj.Issuer, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OAuthConfig_issuer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthConfig_clientId(ctx context.Context, field graphql.CollectedField, obj *model.APIOAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OAuthConfig_clientId,
		func(ctx context.Context) (any, error) {
			return obj.ClientID, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OAuthConfig_clientId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuthConfig_connectorId(ctx context.Context, field graphql.CollectedField, obj *model.APIOAuthConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OAuthConfig_connectorId,
		func(ctx context.Context) (any, error) {
			return obj.ConnectorID, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OAuthConfig_connectorId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OSInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.APIOSInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OSInfo_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OSInfo_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OSInfo_version(ctx context.Context, field graphql.CollectedField, obj *model.APIOSInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OSInfo_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OSInfo_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_clientId(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OktaConfig_clientId,
		func(ctx context.Context) (any, error) {
			return obj.ClientID, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OktaConfig_clientId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_clientSecret(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OktaConfig_clientSecret,
		func(ctx context.Context) (any, error) {
			return obj.ClientSecret, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OktaConfig_clientSecret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_issuer(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OktaConfig_issuer,
		func(ctx context.Context) (any, error) {
			return obj.Issuer, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OktaConfig_issuer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_scopes(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OktaConfig_scopes,
		func(ctx context.Context) (any, error) {
			return obj.Scopes, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OktaConfig_scopes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_userGroup(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OktaConfig_userGroup,
		func(ctx context.Context) (any, error) {
			return obj.UserGroup, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OktaConfig_userGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_expireAfterMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OktaConfig_expireAfterMinutes,
		func(ctx context.Context) (any, error) {
			return obj.ExpireAfterMinutes, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OktaConfig_expireAfterMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OomTrackerInfo_detected(ctx context.Context, field graphql.CollectedField, obj *model.APIOomTrackerInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OomTrackerInfo_detected,
		func(ctx context.Context) (any, error) {
			return obj.Detected, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OomTrackerInfo_detected(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OomTrackerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OomTrackerInfo_pids(ctx context.Context, field graphql.CollectedField, obj *model.APIOomTrackerInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OomTrackerInfo_pids,
		func(ctx context.Context) (any, error) {
			return obj.Pids, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OomTrackerInfo_pids(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OomTrackerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OwnerRepo_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIOwnerRepo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OwnerRepo_owner,
		func(ctx context.Context) (any, error) {
			return obj.Owner, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OwnerRepo_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OwnerRepo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OwnerRepo_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIOwnerRepo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OwnerRepo_repo,
		func(ctx context.Context) (any, error) {
			return obj.Repo, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OwnerRepo_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OwnerRepo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Package_name(ctx context.Context, field graphql.CollectedField, obj *model.APIPackage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Package_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Package_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Package_manager(ctx context.Context, field graphql.CollectedField, obj *model.APIPackage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Package_manager,
		func(ctx context.Context) (any, error) {
			return obj.Manager, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Package_manager(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Package_version(ctx context.Context, field graphql.CollectedField, obj *model.APIPackage) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Package_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Package_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Parameter_key(ctx context.Context, field graphql.CollectedField, obj *model.APIParameter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Parameter_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Parameter_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Parameter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Parameter_value(ctx context.Context, field graphql.CollectedField, obj *model.APIParameter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Parameter_value,
		func(ctx context.Context) (any, error) {
			return obj.Value, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Parameter_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Parameter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParameterStoreConfig_prefix(ctx context.Context, field graphql.CollectedField, obj *model.APIParameterStoreConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParameterStoreConfig_prefix,
		func(ctx context.Context) (any, error) {
			return obj.Prefix, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ParameterStoreConfig_prefix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParameterStoreConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParserProjectS3Config_key(ctx context.Context, field graphql.CollectedField, obj *model.APIParserProjectS3Config) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParserProjectS3Config_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ParserProjectS3Config_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParserProjectS3Config",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParserProjectS3Config_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIParserProjectS3Config) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParserProjectS3Config_secret,
		func(ctx context.Context) (any, error) {
			return obj.Secret, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ParserProjectS3Config_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParserProjectS3Config",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParserProjectS3Config_bucket(ctx context.Context, field graphql.CollectedField, obj *model.APIParserProjectS3Config) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParserProjectS3Config_bucket,
		func(ctx context.Context) (any, error) {
			return obj.Bucket, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ParserProjectS3Config_bucket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParserProjectS3Config",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParserProjectS3Config_prefix(ctx context.Context, field graphql.CollectedField, obj *model.APIParserProjectS3Config) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParserProjectS3Config_prefix,
		func(ctx context.Context) (any, error) {
			return obj.Prefix, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ParserProjectS3Config_prefix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParserProjectS3Config",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParserProjectS3Config_generatedJSONPrefix(ctx context.Context, field graphql.CollectedField, obj *model.APIParserProjectS3Config) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParserProjectS3Config_generatedJSONPrefix,
		func(ctx context.Context) (any, error) {
			return obj.GeneratedJSONPrefix, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ParserProjectS3Config_generatedJSONPrefix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParserProjectS3Config",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_caseSensitive(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParsleyFilter_caseSensitive,
		func(ctx context.Context) (any, error) {
			return obj.CaseSensitive, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ParsleyFilter_caseSensitive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_description(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParsleyFilter_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ParsleyFilter_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_exactMatch(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParsleyFilter_exactMatch,
		func(ctx context.Context) (any, error) {
			return obj.ExactMatch, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ParsleyFilter_exactMatch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_expression(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParsleyFilter_expression,
		func(ctx context.Context) (any, error) {
			return obj.Expression, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ParsleyFilter_expression(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleySettings_sectionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleySettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParsleySettings_sectionsEnabled,
		func(ctx context.Context) (any, error) {
			return obj.SectionsEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ParsleySettings_sectionsEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleySettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleySettings_jumpToFailingLineEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleySettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ParsleySettings_jumpToFailingLineEnabled,
		func(ctx context.Context) (any, error) {
			return obj.JumpToFailingLineEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ParsleySettings_jumpToFailingLineEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleySettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_activated(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_activated,
		func(ctx context.Context) (any, error) {
			return obj.Activated, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_alias,
		func(ctx context.Context) (any, error) {
			return obj.Alias, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_author(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_author,
		func(ctx context.Context) (any, error) {
			return obj.Author, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_authorDisplayName(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_authorDisplayName,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().AuthorDisplayName(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_authorDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_baseTaskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_baseTaskStatuses,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().BaseTaskStatuses(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_baseTaskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_builds(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_builds,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().Builds(ctx, obj)
		},
		nil,
		ec.marshalNBuild2githubcomevergreencievergreenrestmodelAPIBuild,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_builds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "actualMakespan":
				return ec.fieldContext_Build_actualMakespan(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Build_buildVariant(ctx, field)
			case "predictedMakespan":
				return ec.fieldContext_Build_predictedMakespan(ctx, field)
			case "status":
				return ec.fieldContext_Build_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_childPatchAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_childPatchAliases,
		func(ctx context.Context) (any, error) {
			return obj.ChildPatchAliases, nil
		},
		nil,
		ec.marshalOChildPatchAlias2githubcomevergreencievergreenrestmodelAPIChildPatchAlias,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_childPatchAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_ChildPatchAlias_alias(ctx, field)
			case "patchId":
				return ec.fieldContext_ChildPatchAlias_patchId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChildPatchAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_childPatches(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_childPatches,
		func(ctx context.Context) (any, error) {
			return obj.ChildPatches, nil
		},
		nil,
		ec.marshalOPatch2githubcomevergreencievergreenrestmodelAPIPatch,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_childPatches(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "includedLocalModules":
				return ec.fieldContext_Patch_includedLocalModules(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "user":
				return ec.fieldContext_Patch_user(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_description(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_duration(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_duration,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().Duration(ctx, obj)
		},
		nil,
		ec.marshalOPatchDuration2githubcomevergreencievergreengraphqlPatchDuration,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "makespan":
				return ec.fieldContext_PatchDuration_makespan(ctx, field)
			case "time":
				return ec.fieldContext_PatchDuration_time(ctx, field)
			case "timeTaken":
				return ec.fieldContext_PatchDuration_timeTaken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchDuration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_generatedTaskCounts(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_generatedTaskCounts,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().GeneratedTaskCounts(ctx, obj)
		},
		nil,
		ec.marshalNGeneratedTaskCountResults2githubcomevergreencievergreengraphqlGeneratedTaskCountResults,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_generatedTaskCounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariantName":
				return ec.fieldContext_GeneratedTaskCountResults_buildVariantName(ctx, field)
			case "taskName":
				return ec.fieldContext_GeneratedTaskCountResults_taskName(ctx, field)
			case "taskId":
				return ec.fieldContext_GeneratedTaskCountResults_taskId(ctx, field)
			case "estimatedTasks":
				return ec.fieldContext_GeneratedTaskCountResults_estimatedTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneratedTaskCountResults", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_githash(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_githash,
		func(ctx context.Context) (any, error) {
			return obj.Githash, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_githash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_githubPatchData(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_githubPatchData,
		func(ctx context.Context) (any, error) {
			return obj.GithubPatchData, nil
		},
		nil,
		ec.marshalOGithubPatch2githubcomevergreencievergreenrestmodelAPIGithubPatch,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_githubPatchData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_GithubPatch_author(ctx, field)
			case "baseOwner":
				return ec.fieldContext_GithubPatch_baseOwner(ctx, field)
			case "baseRepo":
				return ec.fieldContext_GithubPatch_baseRepo(ctx, field)
			case "headBranch":
				return ec.fieldContext_GithubPatch_headBranch(ctx, field)
			case "headHash":
				return ec.fieldContext_GithubPatch_headHash(ctx, field)
			case "headOwner":
				return ec.fieldContext_GithubPatch_headOwner(ctx, field)
			case "headRepo":
				return ec.fieldContext_GithubPatch_headRepo(ctx, field)
			case "prNumber":
				return ec.fieldContext_GithubPatch_prNumber(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubPatch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_hidden(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_hidden,
		func(ctx context.Context) (any, error) {
			return obj.Hidden, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_hidden(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_includedLocalModules(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_includedLocalModules,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().IncludedLocalModules(ctx, obj)
		},
		nil,
		ec.marshalNIncludedLocalModule2githubcomevergreencievergreenrestmodelAPILocalModuleInclude,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_includedLocalModules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "module":
				return ec.fieldContext_IncludedLocalModule_module(ctx, field)
			case "fileName":
				return ec.fieldContext_IncludedLocalModule_fileName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IncludedLocalModule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_moduleCodeChanges(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_moduleCodeChanges,
		func(ctx context.Context) (any, error) {
			return obj.ModuleCodeChanges, nil
		},
		nil,
		ec.marshalNModuleCodeChange2githubcomevergreencievergreenrestmodelAPIModulePatch,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_moduleCodeChanges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "branchName":
				return ec.fieldContext_ModuleCodeChange_branchName(ctx, field)
			case "fileDiffs":
				return ec.fieldContext_ModuleCodeChange_fileDiffs(ctx, field)
			case "htmlLink":
				return ec.fieldContext_ModuleCodeChange_htmlLink(ctx, field)
			case "rawLink":
				return ec.fieldContext_ModuleCodeChange_rawLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModuleCodeChange", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_parameters,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().Parameters(ctx, obj)
		},
		nil,
		ec.marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_parameters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_patchNumber(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_patchNumber,
		func(ctx context.Context) (any, error) {
			return obj.PatchNumber, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_patchNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_patchTriggerAliases,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().PatchTriggerAliases(ctx, obj)
		},
		nil,
		ec.marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_patchTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "downstreamRevision":
				return ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_project(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_project,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().Project(ctx, obj)
		},
		nil,
		ec.marshalOPatchProject2githubcomevergreencievergreengraphqlPatchProject,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "variants":
				return ec.fieldContext_PatchProject_variants(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchProject", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectID(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_projectID,
		func(ctx context.Context) (any, error) {
			return obj.ProjectId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_projectID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_projectIdentifier,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().ProjectIdentifier(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_projectMetadata,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().ProjectMetadata(ctx, obj)
		},
		nil,
		ec.marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_projectMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_taskCount(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_taskCount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().TaskCount(ctx, obj)
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_taskCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_tasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_tasks,
		func(ctx context.Context) (any, error) {
			return obj.Tasks, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_taskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_taskStatuses,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().TaskStatuses(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_taskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_time(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_time,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().Time(ctx, obj)
		},
		nil,
		ec.marshalOPatchTime2githubcomevergreencievergreengraphqlPatchTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "finished":
				return ec.fieldContext_PatchTime_finished(ctx, field)
			case "started":
				return ec.fieldContext_PatchTime_started(ctx, field)
			case "submittedAt":
				return ec.fieldContext_PatchTime_submittedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_user(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_user,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().User(ctx, obj)
		},
		nil,
		ec.marshalNUser2githubcomevergreencievergreenrestmodelAPIDBUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_User_betaFeatures(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "emailAddress":
				return ec.fieldContext_User_emailAddress(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_User_parsleyFilters(ctx, field)
			case "parsleySettings":
				return ec.fieldContext_User_parsleySettings(ctx, field)
			case "patches":
				return ec.fieldContext_User_patches(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "subscriptions":
				return ec.fieldContext_User_subscriptions(ctx, field)
			case "userId":
				return ec.fieldContext_User_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_variants(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_variants,
		func(ctx context.Context) (any, error) {
			return obj.Variants, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_variants(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_variantsTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_variantsTasks,
		func(ctx context.Context) (any, error) {
			return obj.VariantsTasks, nil
		},
		nil,
		ec.marshalNVariantTask2githubcomevergreencievergreenrestmodelVariantTask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patch_variantsTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_VariantTask_name(ctx, field)
			case "tasks":
				return ec.fieldContext_VariantTask_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VariantTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_versionFull(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patch_versionFull,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Patch().VersionFull(ctx, obj)
		},
		nil,
		ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Patch_versionFull(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_makespan(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchDuration_makespan,
		func(ctx context.Context) (any, error) {
			return obj.Makespan, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PatchDuration_makespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_time(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchDuration_time,
		func(ctx context.Context) (any, error) {
			return obj.Time, nil
		},
		nil,
		ec.marshalOPatchTime2githubcomevergreencievergreengraphqlPatchTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PatchDuration_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "finished":
				return ec.fieldContext_PatchTime_finished(ctx, field)
			case "started":
				return ec.fieldContext_PatchTime_started(ctx, field)
			case "submittedAt":
				return ec.fieldContext_PatchTime_submittedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_timeTaken(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchDuration_timeTaken,
		func(ctx context.Context) (any, error) {
			return obj.TimeTaken, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PatchDuration_timeTaken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchProject_variants(ctx context.Context, field graphql.CollectedField, obj *PatchProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchProject_variants,
		func(ctx context.Context) (any, error) {
			return obj.Variants, nil
		},
		nil,
		ec.marshalNProjectBuildVariant2githubcomevergreencievergreengraphqlProjectBuildVariant,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PatchProject_variants(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ProjectBuildVariant_displayName(ctx, field)
			case "name":
				return ec.fieldContext_ProjectBuildVariant_name(ctx, field)
			case "tasks":
				return ec.fieldContext_ProjectBuildVariant_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectBuildVariant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_finished(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTime_finished,
		func(ctx context.Context) (any, error) {
			return obj.Finished, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PatchTime_finished(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_started(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTime_started,
		func(ctx context.Context) (any, error) {
			return obj.Started, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PatchTime_started(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_submittedAt(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTime_submittedAt,
		func(ctx context.Context) (any, error) {
			return obj.SubmittedAt, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PatchTime_submittedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTriggerAlias_alias,
		func(ctx context.Context) (any, error) {
			return obj.Alias, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_childProjectId(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTriggerAlias_childProjectId,
		func(ctx context.Context) (any, error) {
			return obj.ChildProjectId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_childProjectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_childProjectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTriggerAlias_childProjectIdentifier,
		func(ctx context.Context) (any, error) {
			return obj.ChildProjectIdentifier, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_childProjectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_parentAsModule(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTriggerAlias_parentAsModule,
		func(ctx context.Context) (any, error) {
			return obj.ParentAsModule, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_parentAsModule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTriggerAlias_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_downstreamRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTriggerAlias_downstreamRevision,
		func(ctx context.Context) (any, error) {
			return obj.DownstreamRevision, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_downstreamRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_taskSpecifiers(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTriggerAlias_taskSpecifiers,
		func(ctx context.Context) (any, error) {
			return obj.TaskSpecifiers, nil
		},
		nil,
		ec.marshalOTaskSpecifier2githubcomevergreencievergreenrestmodelAPITaskSpecifier,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_taskSpecifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "patchAlias":
				return ec.fieldContext_TaskSpecifier_patchAlias(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TaskSpecifier_taskRegex(ctx, field)
			case "variantRegex":
				return ec.fieldContext_TaskSpecifier_variantRegex(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskSpecifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_variantsTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PatchTriggerAlias_variantsTasks,
		func(ctx context.Context) (any, error) {
			return obj.VariantsTasks, nil
		},
		nil,
		ec.marshalNVariantTask2githubcomevergreencievergreenrestmodelVariantTask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_variantsTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_VariantTask_name(ctx, field)
			case "tasks":
				return ec.fieldContext_VariantTask_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VariantTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patches_filteredPatchCount(ctx context.Context, field graphql.CollectedField, obj *Patches) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patches_filteredPatchCount,
		func(ctx context.Context) (any, error) {
			return obj.FilteredPatchCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patches_filteredPatchCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patches",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patches_patches(ctx context.Context, field graphql.CollectedField, obj *Patches) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Patches_patches,
		func(ctx context.Context) (any, error) {
			return obj.Patches, nil
		},
		nil,
		ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Patches_patches(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patches",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "includedLocalModules":
				return ec.fieldContext_Patch_includedLocalModules(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "user":
				return ec.fieldContext_Patch_user(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PeriodicBuild_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PeriodicBuild_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PeriodicBuild_alias,
		func(ctx context.Context) (any, error) {
			return obj.Alias, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PeriodicBuild_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_configFile(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PeriodicBuild_configFile,
		func(ctx context.Context) (any, error) {
			return obj.ConfigFile, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PeriodicBuild_configFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_intervalHours(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PeriodicBuild_intervalHours,
		func(ctx context.Context) (any, error) {
			return obj.IntervalHours, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PeriodicBuild_intervalHours(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_cron(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PeriodicBuild_cron,
		func(ctx context.Context) (any, error) {
			return obj.Cron, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PeriodicBuild_cron(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_message(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PeriodicBuild_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PeriodicBuild_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_nextRunTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PeriodicBuild_nextRunTime,
		func(ctx context.Context) (any, error) {
			return obj.NextRunTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PeriodicBuild_nextRunTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canCreateDistro(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Permissions_canCreateDistro,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Permissions().CanCreateDistro(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Permissions_canCreateDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canCreateProject(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Permissions_canCreateProject,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Permissions().CanCreateProject(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Permissions_canCreateProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canEditAdminSettings(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Permissions_canEditAdminSettings,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Permissions().CanEditAdminSettings(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Permissions_canEditAdminSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_distroPermissions(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Permissions_distroPermissions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Permissions().DistroPermissions(ctx, obj, fc.Args["options"].(DistroPermissionsOptions))
		},
		nil,
		ec.marshalNDistroPermissions2githubcomevergreencievergreengraphqlDistroPermissions,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Permissions_distroPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "admin":
				return ec.fieldContext_DistroPermissions_admin(ctx, field)
			case "edit":
				return ec.fieldContext_DistroPermissions_edit(ctx, field)
			case "view":
				return ec.fieldContext_DistroPermissions_view(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroPermissions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Permissions_distroPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_projectPermissions(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Permissions_projectPermissions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Permissions().ProjectPermissions(ctx, obj, fc.Args["options"].(ProjectPermissionsOptions))
		},
		nil,
		ec.marshalNProjectPermissions2githubcomevergreencievergreengraphqlProjectPermissions,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Permissions_projectPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edit":
				return ec.fieldContext_ProjectPermissions_edit(ctx, field)
			case "view":
				return ec.fieldContext_ProjectPermissions_view(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectPermissions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Permissions_projectPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_repoPermissions(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Permissions_repoPermissions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Permissions().RepoPermissions(ctx, obj, fc.Args["options"].(RepoPermissionsOptions))
		},
		nil,
		ec.marshalNRepoPermissions2githubcomevergreencievergreengraphqlRepoPermissions,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Permissions_repoPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edit":
				return ec.fieldContext_RepoPermissions_edit(ctx, field)
			case "view":
				return ec.fieldContext_RepoPermissions_view(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoPermissions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Permissions_repoPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_userId(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Permissions_userId,
		func(ctx context.Context) (any, error) {
			return obj.UserID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Permissions_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersistentDNSConfig_hostedZoneID(ctx context.Context, field graphql.CollectedField, obj *model.APIPersistentDNSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PersistentDNSConfig_hostedZoneID,
		func(ctx context.Context) (any, error) {
			return obj.HostedZoneID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PersistentDNSConfig_hostedZoneID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersistentDNSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PersistentDNSConfig_domain(ctx context.Context, field graphql.CollectedField, obj *model.APIPersistentDNSConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PersistentDNSConfig_domain,
		func(ctx context.Context) (any, error) {
			return obj.Domain, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PersistentDNSConfig_domain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PersistentDNSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_commitQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PlannerSettings_commitQueueFactor,
		func(ctx context.Context) (any, error) {
			return obj.CommitQueueFactor, nil
		},
		nil,
		ec.marshalNInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PlannerSettings_commitQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_expectedRuntimeFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PlannerSettings_expectedRuntimeFactor,
		func(ctx context.Context) (any, error) {
			return obj.ExpectedRuntimeFactor, nil
		},
		nil,
		ec.marshalNInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PlannerSettings_expectedRuntimeFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_generateTaskFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PlannerSettings_generateTaskFactor,
		func(ctx context.Context) (any, error) {
			return obj.GenerateTaskFactor, nil
		},
		nil,
		ec.marshalNInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PlannerSettings_generateTaskFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_numDependentsFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PlannerSettings_numDependentsFactor,
		func(ctx context.Context) (any, error) {
			return obj.NumDependentsFactor, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PlannerSettings_numDependentsFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_groupVersions(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PlannerSettings_groupVersions,
		func(ctx context.Context) (any, error) {
			return obj.GroupVersions, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PlannerSettings_groupVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_mainlineTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PlannerSettings_mainlineTimeInQueueFactor,
		func(ctx context.Context) (any, error) {
			return obj.MainlineTimeInQueueFactor, nil
		},
		nil,
		ec.marshalNInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PlannerSettings_mainlineTimeInQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_patchFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PlannerSettings_patchFactor,
		func(ctx context.Context) (any, error) {
			return obj.PatchFactor, nil
		},
		nil,
		ec.marshalNInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PlannerSettings_patchFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_patchTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PlannerSettings_patchTimeInQueueFactor,
		func(ctx context.Context) (any, error) {
			return obj.PatchTimeInQueueFactor, nil
		},
		nil,
		ec.marshalNInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PlannerSettings_patchTimeInQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_targetTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PlannerSettings_targetTime,
		func(ctx context.Context) (any, error) {
			return obj.TargetTime, nil
		},
		nil,
		ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PlannerSettings_targetTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PlannerSettings_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNPlannerVersion2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PlannerSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PlannerVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_events(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Pod_events,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Pod().Events(ctx, obj, fc.Args["limit"].(*int), fc.Args["page"].(*int))
		},
		nil,
		ec.marshalNPodEvents2githubcomevergreencievergreengraphqlPodEvents,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Pod_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_PodEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_PodEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Pod_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Pod_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Pod_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Pod_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Pod_status,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Pod().Status(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Pod_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_task(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Pod_task,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Pod().Task(ctx, obj)
		},
		nil,
		ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Pod_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_taskContainerCreationOpts(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Pod_taskContainerCreationOpts,
		func(ctx context.Context) (any, error) {
			return obj.TaskContainerCreationOpts, nil
		},
		nil,
		ec.marshalNTaskContainerCreationOpts2githubcomevergreencievergreenrestmodelAPIPodTaskContainerCreationOptions,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Pod_taskContainerCreationOpts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "image":
				return ec.fieldContext_TaskContainerCreationOpts_image(ctx, field)
			case "memoryMB":
				return ec.fieldContext_TaskContainerCreationOpts_memoryMB(ctx, field)
			case "cpu":
				return ec.fieldContext_TaskContainerCreationOpts_cpu(ctx, field)
			case "os":
				return ec.fieldContext_TaskContainerCreationOpts_os(ctx, field)
			case "arch":
				return ec.fieldContext_TaskContainerCreationOpts_arch(ctx, field)
			case "workingDir":
				return ec.fieldContext_TaskContainerCreationOpts_workingDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskContainerCreationOpts", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_type(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Pod_type,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Pod().Type(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Pod_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_oldStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogData_oldStatus,
		func(ctx context.Context) (any, error) {
			return obj.OldStatus, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodEventLogData_oldStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogData_newStatus,
		func(ctx context.Context) (any, error) {
			return obj.NewStatus, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodEventLogData_newStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_reason(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogData_reason,
		func(ctx context.Context) (any, error) {
			return obj.Reason, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodEventLogData_reason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskID(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogData_taskID,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskExecution(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogData_taskExecution,
		func(ctx context.Context) (any, error) {
			return obj.TaskExecution, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogData_taskStatus,
		func(ctx context.Context) (any, error) {
			return obj.TaskStatus, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_task(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogData_task,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.PodEventLogData().Task(ctx, obj)
		},
		nil,
		ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodEventLogData_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogEntry_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogEntry_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNPodEventLogData2githubcomevergreencievergreenrestmodelPodAPIEventData,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "oldStatus":
				return ec.fieldContext_PodEventLogData_oldStatus(ctx, field)
			case "newStatus":
				return ec.fieldContext_PodEventLogData_newStatus(ctx, field)
			case "reason":
				return ec.fieldContext_PodEventLogData_reason(ctx, field)
			case "taskID":
				return ec.fieldContext_PodEventLogData_taskID(ctx, field)
			case "taskExecution":
				return ec.fieldContext_PodEventLogData_taskExecution(ctx, field)
			case "taskStatus":
				return ec.fieldContext_PodEventLogData_taskStatus(ctx, field)
			case "task":
				return ec.fieldContext_PodEventLogData_task(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogEntry_eventType,
		func(ctx context.Context) (any, error) {
			return obj.EventType, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_eventType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogEntry_processedAt,
		func(ctx context.Context) (any, error) {
			return obj.ProcessedAt, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_processedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogEntry_resourceId,
		func(ctx context.Context) (any, error) {
			return obj.ResourceId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_resourceId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogEntry_resourceType,
		func(ctx context.Context) (any, error) {
			return obj.ResourceType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEventLogEntry_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEvents_count(ctx context.Context, field graphql.CollectedField, obj *PodEvents) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEvents_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PodEvents_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *PodEvents) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodEvents_eventLogEntries,
		func(ctx context.Context) (any, error) {
			return obj.EventLogEntries, nil
		},
		nil,
		ec.marshalNPodEventLogEntry2githubcomevergreencievergreenrestmodelPodAPIEventLogEntry,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PodEvents_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PodEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_PodEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_PodEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_PodEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_PodEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_PodEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_PodEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodLifecycleConfig_maxParallelPodRequests(ctx context.Context, field graphql.CollectedField, obj *model.APIPodLifecycleConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodLifecycleConfig_maxParallelPodRequests,
		func(ctx context.Context) (any, error) {
			return obj.MaxParallelPodRequests, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodLifecycleConfig_maxParallelPodRequests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodLifecycleConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodLifecycleConfig_maxPodDefinitionCleanupRate(ctx context.Context, field graphql.CollectedField, obj *model.APIPodLifecycleConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodLifecycleConfig_maxPodDefinitionCleanupRate,
		func(ctx context.Context) (any, error) {
			return obj.MaxPodDefinitionCleanupRate, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodLifecycleConfig_maxPodDefinitionCleanupRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodLifecycleConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodLifecycleConfig_maxSecretCleanupRate(ctx context.Context, field graphql.CollectedField, obj *model.APIPodLifecycleConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PodLifecycleConfig_maxSecretCleanupRate,
		func(ctx context.Context) (any, error) {
			return obj.MaxSecretCleanupRate, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PodLifecycleConfig_maxSecretCleanupRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodLifecycleConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreconditionScript_path(ctx context.Context, field graphql.CollectedField, obj *model.APIPreconditionScript) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreconditionScript_path,
		func(ctx context.Context) (any, error) {
			return obj.Path, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreconditionScript_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreconditionScript",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreconditionScript_script(ctx context.Context, field graphql.CollectedField, obj *model.APIPreconditionScript) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreconditionScript_script,
		func(ctx context.Context) (any, error) {
			return obj.Script, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreconditionScript_script(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreconditionScript",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_admins(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_admins,
		func(ctx context.Context) (any, error) {
			return obj.Admins, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_admins(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_banner,
		func(ctx context.Context) (any, error) {
			return obj.Banner, nil
		},
		nil,
		ec.marshalOProjectBanner2githubcomevergreencievergreenrestmodelAPIProjectBanner,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_banner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_ProjectBanner_text(ctx, field)
			case "theme":
				return ec.fieldContext_ProjectBanner_theme(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectBanner", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_batchTime(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_batchTime,
		func(ctx context.Context) (any, error) {
			return obj.BatchTime, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_batchTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_branch(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_branch,
		func(ctx context.Context) (any, error) {
			return obj.Branch, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_branch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_buildBaronSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_buildBaronSettings,
		func(ctx context.Context) (any, error) {
			return obj.BuildBaronSettings, nil
		},
		nil,
		ec.marshalNBuildBaronSettings2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_buildBaronSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bfSuggestionFeaturesURL":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
			case "bfSuggestionPassword":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
			case "bfSuggestionServer":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
			case "bfSuggestionTimeoutSecs":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
			case "bfSuggestionUsername":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
			case "ticketCreateProject":
				return ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
			case "ticketSearchProjects":
				return ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
			case "ticketCreateIssueType":
				return ec.fieldContext_BuildBaronSettings_ticketCreateIssueType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaronSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_commitQueue(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_commitQueue,
		func(ctx context.Context) (any, error) {
			return obj.CommitQueue, nil
		},
		nil,
		ec.marshalNCommitQueueParams2githubcomevergreencievergreenrestmodelAPICommitQueueParams,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_commitQueue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_CommitQueueParams_enabled(ctx, field)
			case "mergeMethod":
				return ec.fieldContext_CommitQueueParams_mergeMethod(ctx, field)
			case "message":
				return ec.fieldContext_CommitQueueParams_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CommitQueueParams", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_containerSizeDefinitions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_containerSizeDefinitions,
		func(ctx context.Context) (any, error) {
			return obj.ContainerSizeDefinitions, nil
		},
		nil,
		ec.marshalOContainerResources2githubcomevergreencievergreenrestmodelAPIContainerResources,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_containerSizeDefinitions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ContainerResources_name(ctx, field)
			case "cpu":
				return ec.fieldContext_ContainerResources_cpu(ctx, field)
			case "memoryMb":
				return ec.fieldContext_ContainerResources_memoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_deactivatePrevious(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_deactivatePrevious,
		func(ctx context.Context) (any, error) {
			return obj.DeactivatePrevious, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_deactivatePrevious(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_debugSpawnHostsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_debugSpawnHostsDisabled,
		func(ctx context.Context) (any, error) {
			return obj.DebugSpawnHostsDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_debugSpawnHostsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_disabledStatsCache(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_disabledStatsCache,
		func(ctx context.Context) (any, error) {
			return obj.DisabledStatsCache, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_disabledStatsCache(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_dispatchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_dispatchingDisabled,
		func(ctx context.Context) (any, error) {
			return obj.DispatchingDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_dispatchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_enabled,
		func(ctx context.Context) (any, error) {
			return obj.Enabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_externalLinks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_externalLinks,
		func(ctx context.Context) (any, error) {
			return obj.ExternalLinks, nil
		},
		nil,
		ec.marshalOExternalLink2githubcomevergreencievergreenrestmodelAPIExternalLink,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_externalLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ExternalLink_displayName(ctx, field)
			case "requesters":
				return ec.fieldContext_ExternalLink_requesters(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubChecksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_githubChecksEnabled,
		func(ctx context.Context) (any, error) {
			return obj.GithubChecksEnabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_githubChecksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubDynamicTokenPermissionGroups(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_githubDynamicTokenPermissionGroups,
		func(ctx context.Context) (any, error) {
			return obj.GitHubDynamicTokenPermissionGroups, nil
		},
		nil,
		ec.marshalNGitHubDynamicTokenPermissionGroup2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_githubDynamicTokenPermissionGroups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_name(ctx, field)
			case "permissions":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_permissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitHubDynamicTokenPermissionGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubPermissionGroupByRequester(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_githubPermissionGroupByRequester,
		func(ctx context.Context) (any, error) {
			return obj.GitHubPermissionGroupByRequester, nil
		},
		nil,
		ec.marshalOStringMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_githubPermissionGroupByRequester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubPRTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_githubPRTriggerAliases,
		func(ctx context.Context) (any, error) {
			return obj.GithubPRTriggerAliases, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_githubPRTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubMQTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_githubMQTriggerAliases,
		func(ctx context.Context) (any, error) {
			return obj.GithubMQTriggerAliases, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_githubMQTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagAuthorizedTeams(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_gitTagAuthorizedTeams,
		func(ctx context.Context) (any, error) {
			return obj.GitTagAuthorizedTeams, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_gitTagAuthorizedTeams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagAuthorizedUsers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_gitTagAuthorizedUsers,
		func(ctx context.Context) (any, error) {
			return obj.GitTagAuthorizedUsers, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_gitTagAuthorizedUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagVersionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_gitTagVersionsEnabled,
		func(ctx context.Context) (any, error) {
			return obj.GitTagVersionsEnabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_gitTagVersionsEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_hidden(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_hidden,
		func(ctx context.Context) (any, error) {
			return obj.Hidden, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_hidden(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_identifier(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_identifier,
		func(ctx context.Context) (any, error) {
			return obj.Identifier, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_identifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_isFavorite(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_isFavorite,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Project().IsFavorite(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_isFavorite(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_manualPrTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_manualPrTestingEnabled,
		func(ctx context.Context) (any, error) {
			return obj.ManualPRTestingEnabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_manualPrTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_notifyOnBuildFailure(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_notifyOnBuildFailure,
		func(ctx context.Context) (any, error) {
			return obj.NotifyOnBuildFailure, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_notifyOnBuildFailure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_oldestAllowedMergeBase(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_oldestAllowedMergeBase,
		func(ctx context.Context) (any, error) {
			return obj.OldestAllowedMergeBase, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_oldestAllowedMergeBase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_owner,
		func(ctx context.Context) (any, error) {
			return obj.Owner, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_parsleyFilters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_parsleyFilters,
		func(ctx context.Context) (any, error) {
			return obj.ParsleyFilters, nil
		},
		nil,
		ec.marshalOParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_parsleyFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "caseSensitive":
				return ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
			case "description":
				return ec.fieldContext_ParsleyFilter_description(ctx, field)
			case "exactMatch":
				return ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
			case "expression":
				return ec.fieldContext_ParsleyFilter_expression(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleyFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_patches(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_patches,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Project().Patches(ctx, obj, fc.Args["patchesInput"].(PatchesInput))
		},
		nil,
		ec.marshalNPatches2githubcomevergreencievergreengraphqlPatches,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_patches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredPatchCount":
				return ec.fieldContext_Patches_filteredPatchCount(ctx, field)
			case "patches":
				return ec.fieldContext_Patches_patches(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patches", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Project_patches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Project_patchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_patchingDisabled,
		func(ctx context.Context) (any, error) {
			return obj.PatchingDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_patchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_patchTriggerAliases,
		func(ctx context.Context) (any, error) {
			return obj.PatchTriggerAliases, nil
		},
		nil,
		ec.marshalOPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_patchTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "downstreamRevision":
				return ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_perfEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_perfEnabled,
		func(ctx context.Context) (any, error) {
			return obj.PerfEnabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_perfEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_periodicBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_periodicBuilds,
		func(ctx context.Context) (any, error) {
			return obj.PeriodicBuilds, nil
		},
		nil,
		ec.marshalOPeriodicBuild2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_periodicBuilds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PeriodicBuild_id(ctx, field)
			case "alias":
				return ec.fieldContext_PeriodicBuild_alias(ctx, field)
			case "configFile":
				return ec.fieldContext_PeriodicBuild_configFile(ctx, field)
			case "intervalHours":
				return ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
			case "cron":
				return ec.fieldContext_PeriodicBuild_cron(ctx, field)
			case "message":
				return ec.fieldContext_PeriodicBuild_message(ctx, field)
			case "nextRunTime":
				return ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PeriodicBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_projectHealthView(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_projectHealthView,
		func(ctx context.Context) (any, error) {
			return obj.ProjectHealthView, nil
		},
		nil,
		ec.marshalNProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_projectHealthView(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectHealthView does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_prTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_prTestingEnabled,
		func(ctx context.Context) (any, error) {
			return obj.PRTestingEnabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_prTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_remotePath,
		func(ctx context.Context) (any, error) {
			return obj.RemotePath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_remotePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_repo,
		func(ctx context.Context) (any, error) {
			return obj.Repo, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repoRefId(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_repoRefId,
		func(ctx context.Context) (any, error) {
			return obj.RepoRefId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_repoRefId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repotrackerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_repotrackerDisabled,
		func(ctx context.Context) (any, error) {
			return obj.RepotrackerDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_repotrackerDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repotrackerError(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_repotrackerError,
		func(ctx context.Context) (any, error) {
			return obj.RepotrackerError, nil
		},
		nil,
		ec.marshalORepotrackerError2githubcomevergreencievergreenrestmodelAPIRepositoryErrorDetails,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_repotrackerError(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_RepotrackerError_exists(ctx, field)
			case "invalidRevision":
				return ec.fieldContext_RepotrackerError_invalidRevision(ctx, field)
			case "mergeBaseRevision":
				return ec.fieldContext_RepotrackerError_mergeBaseRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepotrackerError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_restricted(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_restricted,
		func(ctx context.Context) (any, error) {
			return obj.Restricted, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_restricted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_spawnHostScriptPath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_spawnHostScriptPath,
		func(ctx context.Context) (any, error) {
			return obj.SpawnHostScriptPath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_spawnHostScriptPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_stepbackDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_stepbackDisabled,
		func(ctx context.Context) (any, error) {
			return obj.StepbackDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_stepbackDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_stepbackBisect(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_stepbackBisect,
		func(ctx context.Context) (any, error) {
			return obj.StepbackBisect, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_stepbackBisect(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_taskAnnotationSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_taskAnnotationSettings,
		func(ctx context.Context) (any, error) {
			return obj.TaskAnnotationSettings, nil
		},
		nil,
		ec.marshalNTaskAnnotationSettings2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_taskAnnotationSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileTicketWebhook":
				return ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskAnnotationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_testSelection(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_testSelection,
		func(ctx context.Context) (any, error) {
			return obj.TestSelection, nil
		},
		nil,
		ec.marshalOTestSelectionSettings2githubcomevergreencievergreenrestmodelAPITestSelectionSettings,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_testSelection(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowed":
				return ec.fieldContext_TestSelectionSettings_allowed(ctx, field)
			case "defaultEnabled":
				return ec.fieldContext_TestSelectionSettings_defaultEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestSelectionSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_tracksPushEvents(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_tracksPushEvents,
		func(ctx context.Context) (any, error) {
			return obj.TracksPushEvents, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_tracksPushEvents(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_triggers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_triggers,
		func(ctx context.Context) (any, error) {
			return obj.Triggers, nil
		},
		nil,
		ec.marshalOTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_triggers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_TriggerAlias_alias(ctx, field)
			case "buildVariantRegex":
				return ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
			case "configFile":
				return ec.fieldContext_TriggerAlias_configFile(ctx, field)
			case "dateCutoff":
				return ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
			case "level":
				return ec.fieldContext_TriggerAlias_level(ctx, field)
			case "project":
				return ec.fieldContext_TriggerAlias_project(ctx, field)
			case "status":
				return ec.fieldContext_TriggerAlias_status(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
			case "unscheduleDownstreamVersions":
				return ec.fieldContext_TriggerAlias_unscheduleDownstreamVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_versionControlEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_versionControlEnabled,
		func(ctx context.Context) (any, error) {
			return obj.VersionControlEnabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Project_versionControlEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_workstationConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Project_workstationConfig,
		func(ctx context.Context) (any, error) {
			return obj.WorkstationConfig, nil
		},
		nil,
		ec.marshalNWorkstationConfig2githubcomevergreencievergreenrestmodelAPIWorkstationConfig,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Project_workstationConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gitClone":
				return ec.fieldContext_WorkstationConfig_gitClone(ctx, field)
			case "setupCommands":
				return ec.fieldContext_WorkstationConfig_setupCommands(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectAlias_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectAlias_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectAlias_alias,
		func(ctx context.Context) (any, error) {
			return obj.Alias, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_description(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectAlias_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectAlias_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_gitTag(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectAlias_gitTag,
		func(ctx context.Context) (any, error) {
			return obj.GitTag, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectAlias_gitTag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectAlias_remotePath,
		func(ctx context.Context) (any, error) {
			return obj.RemotePath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectAlias_remotePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_task(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectAlias_task,
		func(ctx context.Context) (any, error) {
			return obj.Task, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectAlias_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_taskTags(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectAlias_taskTags,
		func(ctx context.Context) (any, error) {
			return obj.TaskTags, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectAlias_taskTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_variant(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectAlias_variant,
		func(ctx context.Context) (any, error) {
			return obj.Variant, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectAlias_variant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_variantTags(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectAlias_variantTags,
		func(ctx context.Context) (any, error) {
			return obj.VariantTags, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectAlias_variantTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectAlias_parameters,
		func(ctx context.Context) (any, error) {
			return obj.Parameters, nil
		},
		nil,
		ec.marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectAlias_parameters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBanner_text(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectBanner) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectBanner_text,
		func(ctx context.Context) (any, error) {
			return obj.Text, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectBanner_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBanner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBanner_theme(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectBanner) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectBanner_theme,
		func(ctx context.Context) (any, error) {
			return obj.Theme, nil
		},
		nil,
		ec.marshalNBannerTheme2githubcomevergreencievergreenBannerTheme,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectBanner_theme(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBanner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BannerTheme does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectBuildVariant_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_name(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectBuildVariant_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_tasks(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectBuildVariant_tasks,
		func(ctx context.Context) (any, error) {
			return obj.Tasks, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectCreationConfig_totalProjectLimit(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectCreationConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectCreationConfig_totalProjectLimit,
		func(ctx context.Context) (any, error) {
			return obj.TotalProjectLimit, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectCreationConfig_totalProjectLimit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectCreationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectCreationConfig_repoProjectLimit(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectCreationConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectCreationConfig_repoProjectLimit,
		func(ctx context.Context) (any, error) {
			return obj.RepoProjectLimit, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectCreationConfig_repoProjectLimit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectCreationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectCreationConfig_repoExceptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectCreationConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectCreationConfig_repoExceptions,
		func(ctx context.Context) (any, error) {
			return obj.RepoExceptions, nil
		},
		nil,
		ec.marshalNOwnerRepo2githubcomevergreencievergreenrestmodelAPIOwnerRepo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectCreationConfig_repoExceptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectCreationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_OwnerRepo_owner(ctx, field)
			case "repo":
				return ec.fieldContext_OwnerRepo_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OwnerRepo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectCreationConfig_jiraProject(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectCreationConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectCreationConfig_jiraProject,
		func(ctx context.Context) (any, error) {
			return obj.JiraProject, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectCreationConfig_jiraProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectCreationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_after(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEventLogEntry_after,
		func(ctx context.Context) (any, error) {
			return obj.After, nil
		},
		nil,
		ec.marshalOProjectEventSettings2githubcomevergreencievergreenrestmodelAPIProjectEventSettings,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectEventSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectEventSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_before(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEventLogEntry_before,
		func(ctx context.Context) (any, error) {
			return obj.Before, nil
		},
		nil,
		ec.marshalOProjectEventSettings2githubcomevergreencievergreenrestmodelAPIProjectEventSettings,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectEventSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectEventSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEventLogEntry_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_user(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEventLogEntry_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEventSettings_aliases,
		func(ctx context.Context) (any, error) {
			return obj.Aliases, nil
		},
		nil,
		ec.marshalOProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_githubAppAuth(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEventSettings_githubAppAuth,
		func(ctx context.Context) (any, error) {
			return obj.GithubAppAuth, nil
		},
		nil,
		ec.marshalOGithubAppAuth2githubcomevergreencievergreenrestmodelAPIGithubAppAuth,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_githubAppAuth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GithubAppAuth_appId(ctx, field)
			case "privateKey":
				return ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAppAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled,
		func(ctx context.Context) (any, error) {
			return obj.GithubWebhooksEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_githubWebhooksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEventSettings_projectRef,
		func(ctx context.Context) (any, error) {
			return obj.ProjectRef, nil
		},
		nil,
		ec.marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_projectRef(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEventSettings_subscriptions,
		func(ctx context.Context) (any, error) {
			return obj.Subscriptions, nil
		},
		nil,
		ec.marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEventSettings_vars,
		func(ctx context.Context) (any, error) {
			return obj.Vars, nil
		},
		nil,
		ec.marshalOProjectVars2githubcomevergreencievergreenrestmodelAPIProjectVars,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEvents_count(ctx context.Context, field graphql.CollectedField, obj *ProjectEvents) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEvents_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectEvents_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *ProjectEvents) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectEvents_eventLogEntries,
		func(ctx context.Context) (any, error) {
			return obj.EventLogEntries, nil
		},
		nil,
		ec.marshalNProjectEventLogEntry2githubcomevergreencievergreenrestmodelAPIProjectEvent,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectEvents_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "after":
				return ec.fieldContext_ProjectEventLogEntry_after(ctx, field)
			case "before":
				return ec.fieldContext_ProjectEventLogEntry_before(ctx, field)
			case "timestamp":
				return ec.fieldContext_ProjectEventLogEntry_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_ProjectEventLogEntry_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectPermissions_edit(ctx context.Context, field graphql.CollectedField, obj *ProjectPermissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectPermissions_edit,
		func(ctx context.Context) (any, error) {
			return obj.Edit, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectPermissions_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectPermissions_view(ctx context.Context, field graphql.CollectedField, obj *ProjectPermissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectPermissions_view,
		func(ctx context.Context) (any, error) {
			return obj.View, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectPermissions_view(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectSettings_aliases,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectSettings().Aliases(ctx, obj)
		},
		nil,
		ec.marshalOProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectSettings_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_githubAppAuth(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectSettings_githubAppAuth,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectSettings().GithubAppAuth(ctx, obj)
		},
		nil,
		ec.marshalOGithubAppAuth2githubcomevergreencievergreenrestmodelAPIGithubAppAuth,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectSettings_githubAppAuth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GithubAppAuth_appId(ctx, field)
			case "privateKey":
				return ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAppAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectSettings_githubWebhooksEnabled,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectSettings().GithubWebhooksEnabled(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectSettings_githubWebhooksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectSettings_projectRef,
		func(ctx context.Context) (any, error) {
			return obj.ProjectRef, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireProjectSettingsAccess == nil {
					var zeroVal model.APIProjectRef
					return zeroVal, errors.New("directive requireProjectSettingsAccess is not implemented")
				}
				return ec.directives.RequireProjectSettingsAccess(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectSettings_projectRef(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectSettings_subscriptions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectSettings().Subscriptions(ctx, obj)
		},
		nil,
		ec.marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectSettings_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectSettings_vars,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectSettings().Vars(ctx, obj)
		},
		nil,
		ec.marshalOProjectVars2githubcomevergreencievergreenrestmodelAPIProjectVars,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectSettings_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTasksPair_projectId(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectTasksPair) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectTasksPair_projectId,
		func(ctx context.Context) (any, error) {
			return obj.ProjectID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectTasksPair_projectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTasksPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTasksPair_allowedTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectTasksPair) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectTasksPair_allowedTasks,
		func(ctx context.Context) (any, error) {
			return obj.AllowedTasks, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectTasksPair_allowedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTasksPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTasksPair_allowedBVs(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectTasksPair) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectTasksPair_allowedBVs,
		func(ctx context.Context) (any, error) {
			return obj.AllowedBVs, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectTasksPair_allowedBVs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTasksPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_adminOnlyVars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectVars_adminOnlyVars,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectVars().AdminOnlyVars(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectVars_adminOnlyVars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_privateVars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectVars_privateVars,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ProjectVars().PrivateVars(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProjectVars_privateVars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProjectVars_vars,
		func(ctx context.Context) (any, error) {
			return obj.Vars, nil
		},
		nil,
		ec.marshalOStringMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProjectVars_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicKey_key(ctx context.Context, field graphql.CollectedField, obj *model.APIPubKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PublicKey_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PublicKey_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicKey_name(ctx context.Context, field graphql.CollectedField, obj *model.APIPubKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PublicKey_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PublicKey_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _QuarantineTestPayload_success(ctx context.Context, field graphql.CollectedField, obj *QuarantineTestPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_QuarantineTestPayload_success,
		func(ctx context.Context) (any, error) {
			return obj.Success, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_QuarantineTestPayload_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "QuarantineTestPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_bbGetCreatedTickets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_bbGetCreatedTickets,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().BbGetCreatedTickets(ctx, fc.Args["taskId"].(string))
		},
		nil,
		ec.marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_bbGetCreatedTickets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bbGetCreatedTickets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_buildBaron(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_buildBaron,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().BuildBaron(ctx, fc.Args["taskId"].(string), fc.Args["execution"].(int))
		},
		nil,
		ec.marshalNBuildBaron2githubcomevergreencievergreengraphqlBuildBaron,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_buildBaron(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bbTicketCreationDefined":
				return ec.fieldContext_BuildBaron_bbTicketCreationDefined(ctx, field)
			case "buildBaronConfigured":
				return ec.fieldContext_BuildBaron_buildBaronConfigured(ctx, field)
			case "searchReturnInfo":
				return ec.fieldContext_BuildBaron_searchReturnInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaron", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_buildBaron_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_adminEvents,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().AdminEvents(ctx, fc.Args["opts"].(AdminEventsInput))
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *AdminEventsPayload
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, nil, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNAdminEventsPayload2githubcomevergreencievergreengraphqlAdminEventsPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_adminEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_AdminEventsPayload_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_AdminEventsPayload_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminEventsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_adminEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_adminSettings,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().AdminSettings(ctx)
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *model.APIAdminSettings
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, nil, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOAdminSettings2githubcomevergreencievergreenrestmodelAPIAdminSettings,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_adminSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "amboy":
				return ec.fieldContext_AdminSettings_amboy(ctx, field)
			case "amboyDB":
				return ec.fieldContext_AdminSettings_amboyDB(ctx, field)
			case "api":
				return ec.fieldContext_AdminSettings_api(ctx, field)
			case "authConfig":
				return ec.fieldContext_AdminSettings_authConfig(ctx, field)
			case "banner":
				return ec.fieldContext_AdminSettings_banner(ctx, field)
			case "bannerTheme":
				return ec.fieldContext_AdminSettings_bannerTheme(ctx, field)
			case "buckets":
				return ec.fieldContext_AdminSettings_buckets(ctx, field)
			case "cedar":
				return ec.fieldContext_AdminSettings_cedar(ctx, field)
			case "configDir":
				return ec.fieldContext_AdminSettings_configDir(ctx, field)
			case "containerPools":
				return ec.fieldContext_AdminSettings_containerPools(ctx, field)
			case "cost":
				return ec.fieldContext_AdminSettings_cost(ctx, field)
			case "disabledGQLQueries":
				return ec.fieldContext_AdminSettings_disabledGQLQueries(ctx, field)
			case "domainName":
				return ec.fieldContext_AdminSettings_domainName(ctx, field)
			case "expansions":
				return ec.fieldContext_AdminSettings_expansions(ctx, field)
			case "fws":
				return ec.fieldContext_AdminSettings_fws(ctx, field)
			case "graphite":
				return ec.fieldContext_AdminSettings_graphite(ctx, field)
			case "githubCheckRun":
				return ec.fieldContext_AdminSettings_githubCheckRun(ctx, field)
			case "githubOrgs":
				return ec.fieldContext_AdminSettings_githubOrgs(ctx, field)
			case "githubPRCreatorOrg":
				return ec.fieldContext_AdminSettings_githubPRCreatorOrg(ctx, field)
			case "githubWebhookSecret":
				return ec.fieldContext_AdminSettings_githubWebhookSecret(ctx, field)
			case "hostInit":
				return ec.fieldContext_AdminSettings_hostInit(ctx, field)
			case "hostJasper":
				return ec.fieldContext_AdminSettings_hostJasper(ctx, field)
			case "jira":
				return ec.fieldContext_AdminSettings_jira(ctx, field)
			case "jiraNotifications":
				return ec.fieldContext_AdminSettings_jiraNotifications(ctx, field)
			case "kanopySSHKeyPath":
				return ec.fieldContext_AdminSettings_kanopySSHKeyPath(ctx, field)
			case "logPath":
				return ec.fieldContext_AdminSettings_logPath(ctx, field)
			case "loggerConfig":
				return ec.fieldContext_AdminSettings_loggerConfig(ctx, field)
			case "notify":
				return ec.fieldContext_AdminSettings_notify(ctx, field)
			case "oldestAllowedCLIVersion":
				return ec.fieldContext_AdminSettings_oldestAllowedCLIVersion(ctx, field)
			case "parameterStore":
				return ec.fieldContext_AdminSettings_parameterStore(ctx, field)
			case "perfMonitoringKanopyURL":
				return ec.fieldContext_AdminSettings_perfMonitoringKanopyURL(ctx, field)
			case "perfMonitoringURL":
				return ec.fieldContext_AdminSettings_perfMonitoringURL(ctx, field)
			case "podLifecycle":
				return ec.fieldContext_AdminSettings_podLifecycle(ctx, field)
			case "pprofPort":
				return ec.fieldContext_AdminSettings_pprofPort(ctx, field)
			case "projectCreation":
				return ec.fieldContext_AdminSettings_projectCreation(ctx, field)
			case "providers":
				return ec.fieldContext_AdminSettings_providers(ctx, field)
			case "releaseMode":
				return ec.fieldContext_AdminSettings_releaseMode(ctx, field)
			case "repotracker":
				return ec.fieldContext_AdminSettings_repotracker(ctx, field)
			case "runtimeEnvironments":
				return ec.fieldContext_AdminSettings_runtimeEnvironments(ctx, field)
			case "scheduler":
				return ec.fieldContext_AdminSettings_scheduler(ctx, field)
			case "serviceFlags":
				return ec.fieldContext_AdminSettings_serviceFlags(ctx, field)
			case "shutdownWaitSeconds":
				return ec.fieldContext_AdminSettings_shutdownWaitSeconds(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_AdminSettings_singleTaskDistro(ctx, field)
			case "slack":
				return ec.fieldContext_AdminSettings_slack(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_AdminSettings_sleepSchedule(ctx, field)
			case "spawnhost":
				return ec.fieldContext_AdminSettings_spawnhost(ctx, field)
			case "splunk":
				return ec.fieldContext_AdminSettings_splunk(ctx, field)
			case "ssh":
				return ec.fieldContext_AdminSettings_ssh(ctx, field)
			case "taskLimits":
				return ec.fieldContext_AdminSettings_taskLimits(ctx, field)
			case "testSelection":
				return ec.fieldContext_AdminSettings_testSelection(ctx, field)
			case "tracer":
				return ec.fieldContext_AdminSettings_tracer(ctx, field)
			case "triggers":
				return ec.fieldContext_AdminSettings_triggers(ctx, field)
			case "ui":
				return ec.fieldContext_AdminSettings_ui(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminTasksToRestart(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_adminTasksToRestart,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().AdminTasksToRestart(ctx, fc.Args["opts"].(model1.RestartOptions))
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *AdminTasksToRestartPayload
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, nil, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNAdminTasksToRestartPayload2githubcomevergreencievergreengraphqlAdminTasksToRestartPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_adminTasksToRestart(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tasksToRestart":
				return ec.fieldContext_AdminTasksToRestartPayload_tasksToRestart(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminTasksToRestartPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_adminTasksToRestart_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_awsRegions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_awsRegions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().AWSRegions(ctx)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_awsRegions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_clientConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_clientConfig,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().ClientConfig(ctx)
		},
		nil,
		ec.marshalOClientConfig2githubcomevergreencievergreenrestmodelAPIClientConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_clientConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientBinaries":
				return ec.fieldContext_ClientConfig_clientBinaries(ctx, field)
			case "latestRevision":
				return ec.fieldContext_ClientConfig_latestRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_instanceTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_instanceTypes,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().InstanceTypes(ctx)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_instanceTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_spruceConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_spruceConfig,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().SpruceConfig(ctx)
		},
		nil,
		ec.marshalOSpruceConfig2githubcomevergreencievergreenrestmodelAPIAdminSettings,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_spruceConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "banner":
				return ec.fieldContext_SpruceConfig_banner(ctx, field)
			case "bannerTheme":
				return ec.fieldContext_SpruceConfig_bannerTheme(ctx, field)
			case "containerPools":
				return ec.fieldContext_SpruceConfig_containerPools(ctx, field)
			case "githubOrgs":
				return ec.fieldContext_SpruceConfig_githubOrgs(ctx, field)
			case "jira":
				return ec.fieldContext_SpruceConfig_jira(ctx, field)
			case "providers":
				return ec.fieldContext_SpruceConfig_providers(ctx, field)
			case "secretFields":
				return ec.fieldContext_SpruceConfig_secretFields(ctx, field)
			case "serviceFlags":
				return ec.fieldContext_SpruceConfig_serviceFlags(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_SpruceConfig_singleTaskDistro(ctx, field)
			case "slack":
				return ec.fieldContext_SpruceConfig_slack(ctx, field)
			case "spawnHost":
				return ec.fieldContext_SpruceConfig_spawnHost(ctx, field)
			case "ui":
				return ec.fieldContext_SpruceConfig_ui(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpruceConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_subnetAvailabilityZones(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_subnetAvailabilityZones,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().SubnetAvailabilityZones(ctx)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_subnetAvailabilityZones(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_distro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_distro,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Distro(ctx, fc.Args["distroId"].(string))
		},
		nil,
		ec.marshalODistro2githubcomevergreencievergreenrestmodelAPIDistro,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_distro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "availableRegions":
				return ec.fieldContext_Distro_availableRegions(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerAccount":
				return ec.fieldContext_Distro_providerAccount(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			case "costData":
				return ec.fieldContext_Distro_costData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_distroEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_distroEvents,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().DistroEvents(ctx, fc.Args["opts"].(DistroEventsInput))
		},
		nil,
		ec.marshalNDistroEventsPayload2githubcomevergreencievergreengraphqlDistroEventsPayload,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_distroEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_DistroEventsPayload_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_DistroEventsPayload_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroEventsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distroEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_distros(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_distros,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Distros(ctx, fc.Args["onlySpawnable"].(bool))
		},
		nil,
		ec.marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_distros(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "availableRegions":
				return ec.fieldContext_Distro_availableRegions(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerAccount":
				return ec.fieldContext_Distro_providerAccount(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			case "costData":
				return ec.fieldContext_Distro_costData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distros_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_distroTaskQueue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_distroTaskQueue,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().DistroTaskQueue(ctx, fc.Args["distroId"].(string))
		},
		nil,
		ec.marshalNTaskQueueItem2githubcomevergreencievergreenrestmodelAPITaskQueueItem,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_distroTaskQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskQueueItem_id(ctx, field)
			case "buildVariant":
				return ec.fieldContext_TaskQueueItem_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_TaskQueueItem_displayName(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_TaskQueueItem_expectedDuration(ctx, field)
			case "priority":
				return ec.fieldContext_TaskQueueItem_priority(ctx, field)
			case "project":
				return ec.fieldContext_TaskQueueItem_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_TaskQueueItem_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_TaskQueueItem_requester(ctx, field)
			case "activatedBy":
				return ec.fieldContext_TaskQueueItem_activatedBy(ctx, field)
			case "revision":
				return ec.fieldContext_TaskQueueItem_revision(ctx, field)
			case "version":
				return ec.fieldContext_TaskQueueItem_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskQueueItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distroTaskQueue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_host(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_host,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Host(ctx, fc.Args["hostId"].(string))
		},
		nil,
		ec.marshalOHost2githubcomevergreencievergreenrestmodelAPIHost,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_host_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hostEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_hostEvents,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().HostEvents(ctx, fc.Args["hostId"].(string), fc.Args["hostTag"].(*string), fc.Args["limit"].(*int), fc.Args["page"].(*int))
		},
		nil,
		ec.marshalNHostEvents2githubcomevergreencievergreengraphqlHostEvents,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_hostEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_HostEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_HostEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hostEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hosts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_hosts,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Hosts(ctx, fc.Args["hostId"].(*string), fc.Args["distroId"].(*string), fc.Args["currentTaskId"].(*string), fc.Args["statuses"].([]string), fc.Args["startedBy"].(*string), fc.Args["sortBy"].(*HostSortBy), fc.Args["sortDir"].(*SortDirection), fc.Args["page"].(*int), fc.Args["limit"].(*int))
		},
		nil,
		ec.marshalNHostsResponse2githubcomevergreencievergreengraphqlHostsResponse,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_hosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredHostsCount":
				return ec.fieldContext_HostsResponse_filteredHostsCount(ctx, field)
			case "hosts":
				return ec.fieldContext_HostsResponse_hosts(ctx, field)
			case "totalHostsCount":
				return ec.fieldContext_HostsResponse_totalHostsCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hosts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskQueueDistros(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_taskQueueDistros,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().TaskQueueDistros(ctx)
		},
		nil,
		ec.marshalNTaskQueueDistro2githubcomevergreencievergreengraphqlTaskQueueDistro,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_taskQueueDistros(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskQueueDistro_id(ctx, field)
			case "hostCount":
				return ec.fieldContext_TaskQueueDistro_hostCount(ctx, field)
			case "taskCount":
				return ec.fieldContext_TaskQueueDistro_taskCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskQueueDistro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_pod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_pod,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Pod(ctx, fc.Args["podId"].(string))
		},
		nil,
		ec.marshalNPod2githubcomevergreencievergreenrestmodelAPIPod,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_pod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "events":
				return ec.fieldContext_Pod_events(ctx, field)
			case "id":
				return ec.fieldContext_Pod_id(ctx, field)
			case "status":
				return ec.fieldContext_Pod_status(ctx, field)
			case "task":
				return ec.fieldContext_Pod_task(ctx, field)
			case "taskContainerCreationOpts":
				return ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
			case "type":
				return ec.fieldContext_Pod_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_pod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_patch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_patch,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Patch(ctx, fc.Args["patchId"].(string))
		},
		nil,
		ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_patch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "includedLocalModules":
				return ec.fieldContext_Patch_includedLocalModules(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "user":
				return ec.fieldContext_Patch_user(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_patch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubProjectConflicts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_githubProjectConflicts,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GithubProjectConflicts(ctx, fc.Args["projectId"].(string))
		},
		nil,
		ec.marshalNGithubProjectConflicts2githubcomevergreencievergreenmodelGithubProjectConflicts,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_githubProjectConflicts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commitCheckIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_commitCheckIdentifiers(ctx, field)
			case "commitQueueIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_commitQueueIdentifiers(ctx, field)
			case "prTestingIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_prTestingIdentifiers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubProjectConflicts", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubProjectConflicts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_project(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_project,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Project(ctx, fc.Args["projectIdentifier"].(string))
		},
		nil,
		ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_project_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_projects(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_projects,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Projects(ctx)
		},
		nil,
		ec.marshalNGroupedProjects2githubcomevergreencievergreengraphqlGroupedProjects,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_projects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupDisplayName":
				return ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
			case "projects":
				return ec.fieldContext_GroupedProjects_projects(ctx, field)
			case "repo":
				return ec.fieldContext_GroupedProjects_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedProjects", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_projectEvents,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().ProjectEvents(ctx, fc.Args["projectIdentifier"].(string), fc.Args["limit"].(*int), fc.Args["before"].(*time.Time))
		},
		nil,
		ec.marshalNProjectEvents2githubcomevergreencievergreengraphqlProjectEvents,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_projectEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ProjectEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_projectSettings,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().ProjectSettings(ctx, fc.Args["projectIdentifier"].(string))
		},
		nil,
		ec.marshalNProjectSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_projectSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_repoEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_repoEvents,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().RepoEvents(ctx, fc.Args["repoId"].(string), fc.Args["limit"].(*int), fc.Args["before"].(*time.Time))
		},
		nil,
		ec.marshalNProjectEvents2githubcomevergreencievergreengraphqlProjectEvents,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_repoEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ProjectEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_repoEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_repoSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_repoSettings,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().RepoSettings(ctx, fc.Args["repoId"].(string))
		},
		nil,
		ec.marshalNRepoSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_repoSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_RepoSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_RepoSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_RepoSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_RepoSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_RepoSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_repoSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewableProjectRefs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_viewableProjectRefs,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().ViewableProjectRefs(ctx)
		},
		nil,
		ec.marshalNGroupedProjects2githubcomevergreencievergreengraphqlGroupedProjects,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_viewableProjectRefs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupDisplayName":
				return ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
			case "projects":
				return ec.fieldContext_GroupedProjects_projects(ctx, field)
			case "repo":
				return ec.fieldContext_GroupedProjects_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedProjects", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_isRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_isRepo,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().IsRepo(ctx, fc.Args["projectOrRepoId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_isRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_isRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_myHosts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_myHosts,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().MyHosts(ctx)
		},
		nil,
		ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_myHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_myVolumes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_myVolumes,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().MyVolumes(ctx)
		},
		nil,
		ec.marshalNVolume2githubcomevergreencievergreenrestmodelAPIVolume,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_myVolumes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_logkeeperBuildMetadata(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_logkeeperBuildMetadata,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().LogkeeperBuildMetadata(ctx, fc.Args["buildId"].(string))
		},
		nil,
		ec.marshalNLogkeeperBuild2githubcomevergreenciplankBuild,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_logkeeperBuildMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LogkeeperBuild_id(ctx, field)
			case "builder":
				return ec.fieldContext_LogkeeperBuild_builder(ctx, field)
			case "buildNum":
				return ec.fieldContext_LogkeeperBuild_buildNum(ctx, field)
			case "taskId":
				return ec.fieldContext_LogkeeperBuild_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_LogkeeperBuild_taskExecution(ctx, field)
			case "tests":
				return ec.fieldContext_LogkeeperBuild_tests(ctx, field)
			case "task":
				return ec.fieldContext_LogkeeperBuild_task(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogkeeperBuild", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_logkeeperBuildMetadata_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_task(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_task,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Task(ctx, fc.Args["taskId"].(string), fc.Args["execution"].(*int))
		},
		nil,
		ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_task_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskAllExecutions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_taskAllExecutions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().TaskAllExecutions(ctx, fc.Args["taskId"].(string))
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_taskAllExecutions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskAllExecutions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskTestSample(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_taskTestSample,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().TaskTestSample(ctx, fc.Args["versionId"].(string), fc.Args["taskIds"].([]string), fc.Args["filters"].([]*TestFilter))
		},
		nil,
		ec.marshalOTaskTestResultSample2githubcomevergreencievergreengraphqlTaskTestResultSample,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_taskTestSample(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "execution":
				return ec.fieldContext_TaskTestResultSample_execution(ctx, field)
			case "matchingFailedTestNames":
				return ec.fieldContext_TaskTestResultSample_matchingFailedTestNames(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskTestResultSample_taskId(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_TaskTestResultSample_totalTestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskTestResultSample", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskTestSample_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_myPublicKeys(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_myPublicKeys,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().MyPublicKeys(ctx)
		},
		nil,
		ec.marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_myPublicKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_user,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().User(ctx, fc.Args["userId"].(*string))
		},
		nil,
		ec.marshalNUser2githubcomevergreencievergreenrestmodelAPIDBUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_User_betaFeatures(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "emailAddress":
				return ec.fieldContext_User_emailAddress(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_User_parsleyFilters(ctx, field)
			case "parsleySettings":
				return ec.fieldContext_User_parsleySettings(ctx, field)
			case "patches":
				return ec.fieldContext_User_patches(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "subscriptions":
				return ec.fieldContext_User_subscriptions(ctx, field)
			case "userId":
				return ec.fieldContext_User_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_userConfig,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().UserConfig(ctx)
		},
		nil,
		ec.marshalOUserConfig2githubcomevergreencievergreengraphqlUserConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_userConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "api_key":
				return ec.fieldContext_UserConfig_api_key(ctx, field)
			case "api_server_host":
				return ec.fieldContext_UserConfig_api_server_host(ctx, field)
			case "ui_server_host":
				return ec.fieldContext_UserConfig_ui_server_host(ctx, field)
			case "user":
				return ec.fieldContext_UserConfig_user(ctx, field)
			case "oauth_issuer":
				return ec.fieldContext_UserConfig_oauth_issuer(ctx, field)
			case "oauth_client_id":
				return ec.fieldContext_UserConfig_oauth_client_id(ctx, field)
			case "oauth_connector_id":
				return ec.fieldContext_UserConfig_oauth_connector_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_buildVariantsForTaskName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_buildVariantsForTaskName,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().BuildVariantsForTaskName(ctx, fc.Args["projectIdentifier"].(string), fc.Args["taskName"].(string))
		},
		nil,
		ec.marshalOBuildVariantTuple2githubcomevergreencievergreenmodeltaskBuildVariantTuple,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_buildVariantsForTaskName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariant":
				return ec.fieldContext_BuildVariantTuple_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_BuildVariantTuple_displayName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildVariantTuple", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_buildVariantsForTaskName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_mainlineCommits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_mainlineCommits,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().MainlineCommits(ctx, fc.Args["options"].(MainlineCommitsOptions), fc.Args["buildVariantOptions"].(*BuildVariantOptions))
		},
		nil,
		ec.marshalOMainlineCommits2githubcomevergreencievergreengraphqlMainlineCommits,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_mainlineCommits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nextPageOrderNumber":
				return ec.fieldContext_MainlineCommits_nextPageOrderNumber(ctx, field)
			case "prevPageOrderNumber":
				return ec.fieldContext_MainlineCommits_prevPageOrderNumber(ctx, field)
			case "versions":
				return ec.fieldContext_MainlineCommits_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MainlineCommits", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_mainlineCommits_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskNamesForBuildVariant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_taskNamesForBuildVariant,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().TaskNamesForBuildVariant(ctx, fc.Args["projectIdentifier"].(string), fc.Args["buildVariant"].(string))
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_taskNamesForBuildVariant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskNamesForBuildVariant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_waterfall(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_waterfall,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Waterfall(ctx, fc.Args["options"].(WaterfallOptions))
		},
		nil,
		ec.marshalNWaterfall2githubcomevergreencievergreengraphqlWaterfall,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_waterfall(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "flattenedVersions":
				return ec.fieldContext_Waterfall_flattenedVersions(ctx, field)
			case "pagination":
				return ec.fieldContext_Waterfall_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waterfall", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_waterfall_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskHistory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_taskHistory,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().TaskHistory(ctx, fc.Args["options"].(TaskHistoryOpts))
		},
		nil,
		ec.marshalNTaskHistory2githubcomevergreencievergreengraphqlTaskHistory,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_taskHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tasks":
				return ec.fieldContext_TaskHistory_tasks(ctx, field)
			case "pagination":
				return ec.fieldContext_TaskHistory_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hasVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_hasVersion,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().HasVersion(ctx, fc.Args["patchId"].(string))
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_hasVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hasVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_version,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Version(ctx, fc.Args["versionId"].(string))
		},
		nil,
		ec.marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_version_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_image(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_image,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Image(ctx, fc.Args["imageId"].(string))
		},
		nil,
		ec.marshalOImage2githubcomevergreencievergreenrestmodelAPIImage,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_image(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "ami":
				return ec.fieldContext_Image_ami(ctx, field)
			case "distros":
				return ec.fieldContext_Image_distros(ctx, field)
			case "events":
				return ec.fieldContext_Image_events(ctx, field)
			case "files":
				return ec.fieldContext_Image_files(ctx, field)
			case "lastDeployed":
				return ec.fieldContext_Image_lastDeployed(ctx, field)
			case "latestTask":
				return ec.fieldContext_Image_latestTask(ctx, field)
			case "operatingSystem":
				return ec.fieldContext_Image_operatingSystem(ctx, field)
			case "packages":
				return ec.fieldContext_Image_packages(ctx, field)
			case "toolchains":
				return ec.fieldContext_Image_toolchains(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_image_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_images(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_images,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().Images(ctx)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReleaseModeConfig_distroMaxHostsFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIReleaseModeConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReleaseModeConfig_distroMaxHostsFactor,
		func(ctx context.Context) (any, error) {
			return obj.DistroMaxHostsFactor, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReleaseModeConfig_distroMaxHostsFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReleaseModeConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReleaseModeConfig_targetTimeSecondsOverride(ctx context.Context, field graphql.CollectedField, obj *model.APIReleaseModeConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReleaseModeConfig_targetTimeSecondsOverride,
		func(ctx context.Context) (any, error) {
			return obj.TargetTimeSecondsOverride, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReleaseModeConfig_targetTimeSecondsOverride(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReleaseModeConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReleaseModeConfig_idleTimeSecondsOverride(ctx context.Context, field graphql.CollectedField, obj *model.APIReleaseModeConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ReleaseModeConfig_idleTimeSecondsOverride,
		func(ctx context.Context) (any, error) {
			return obj.IdleTimeSecondsOverride, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ReleaseModeConfig_idleTimeSecondsOverride(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReleaseModeConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoCommitQueueParams_enabled,
		func(ctx context.Context) (any, error) {
			return obj.Enabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_mergeMethod(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoCommitQueueParams_mergeMethod,
		func(ctx context.Context) (any, error) {
			return obj.MergeMethod, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_mergeMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_message(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoCommitQueueParams_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoPermissions_edit(ctx context.Context, field graphql.CollectedField, obj *RepoPermissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoPermissions_edit,
		func(ctx context.Context) (any, error) {
			return obj.Edit, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoPermissions_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoPermissions_view(ctx context.Context, field graphql.CollectedField, obj *RepoPermissions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoPermissions_view,
		func(ctx context.Context) (any, error) {
			return obj.View, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoPermissions_view(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_admins(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_admins,
		func(ctx context.Context) (any, error) {
			return obj.Admins, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_admins(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_batchTime(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_batchTime,
		func(ctx context.Context) (any, error) {
			return obj.BatchTime, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_batchTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_buildBaronSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_buildBaronSettings,
		func(ctx context.Context) (any, error) {
			return obj.BuildBaronSettings, nil
		},
		nil,
		ec.marshalNBuildBaronSettings2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_buildBaronSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bfSuggestionFeaturesURL":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
			case "bfSuggestionPassword":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
			case "bfSuggestionServer":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
			case "bfSuggestionTimeoutSecs":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
			case "bfSuggestionUsername":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
			case "ticketCreateProject":
				return ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
			case "ticketSearchProjects":
				return ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
			case "ticketCreateIssueType":
				return ec.fieldContext_BuildBaronSettings_ticketCreateIssueType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaronSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_commitQueue(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_commitQueue,
		func(ctx context.Context) (any, error) {
			return obj.CommitQueue, nil
		},
		nil,
		ec.marshalNRepoCommitQueueParams2githubcomevergreencievergreenrestmodelAPICommitQueueParams,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_commitQueue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_RepoCommitQueueParams_enabled(ctx, field)
			case "mergeMethod":
				return ec.fieldContext_RepoCommitQueueParams_mergeMethod(ctx, field)
			case "message":
				return ec.fieldContext_RepoCommitQueueParams_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoCommitQueueParams", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_containerSizeDefinitions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_containerSizeDefinitions,
		func(ctx context.Context) (any, error) {
			return obj.ContainerSizeDefinitions, nil
		},
		nil,
		ec.marshalOContainerResources2githubcomevergreencievergreenrestmodelAPIContainerResources,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_containerSizeDefinitions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ContainerResources_name(ctx, field)
			case "cpu":
				return ec.fieldContext_ContainerResources_cpu(ctx, field)
			case "memoryMb":
				return ec.fieldContext_ContainerResources_memoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_deactivatePrevious(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_deactivatePrevious,
		func(ctx context.Context) (any, error) {
			return obj.DeactivatePrevious, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_deactivatePrevious(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_disabledStatsCache(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_disabledStatsCache,
		func(ctx context.Context) (any, error) {
			return obj.DisabledStatsCache, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_disabledStatsCache(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_dispatchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_dispatchingDisabled,
		func(ctx context.Context) (any, error) {
			return obj.DispatchingDisabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_dispatchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_enabled,
		func(ctx context.Context) (any, error) {
			return obj.Enabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubChecksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_githubChecksEnabled,
		func(ctx context.Context) (any, error) {
			return obj.GithubChecksEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_githubChecksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubDynamicTokenPermissionGroups(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_githubDynamicTokenPermissionGroups,
		func(ctx context.Context) (any, error) {
			return obj.GitHubDynamicTokenPermissionGroups, nil
		},
		nil,
		ec.marshalNGitHubDynamicTokenPermissionGroup2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_githubDynamicTokenPermissionGroups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_name(ctx, field)
			case "permissions":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_permissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitHubDynamicTokenPermissionGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubPermissionGroupByRequester(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_githubPermissionGroupByRequester,
		func(ctx context.Context) (any, error) {
			return obj.GitHubPermissionGroupByRequester, nil
		},
		nil,
		ec.marshalOStringMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_githubPermissionGroupByRequester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubPRTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_githubPRTriggerAliases,
		func(ctx context.Context) (any, error) {
			return obj.GithubPRTriggerAliases, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_githubPRTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubMQTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_githubMQTriggerAliases,
		func(ctx context.Context) (any, error) {
			return obj.GithubMQTriggerAliases, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_githubMQTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagAuthorizedTeams(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_gitTagAuthorizedTeams,
		func(ctx context.Context) (any, error) {
			return obj.GitTagAuthorizedTeams, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagAuthorizedTeams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagAuthorizedUsers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_gitTagAuthorizedUsers,
		func(ctx context.Context) (any, error) {
			return obj.GitTagAuthorizedUsers, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagAuthorizedUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagVersionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_gitTagVersionsEnabled,
		func(ctx context.Context) (any, error) {
			return obj.GitTagVersionsEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagVersionsEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_manualPrTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_manualPrTestingEnabled,
		func(ctx context.Context) (any, error) {
			return obj.ManualPRTestingEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_manualPrTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_notifyOnBuildFailure(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_notifyOnBuildFailure,
		func(ctx context.Context) (any, error) {
			return obj.NotifyOnBuildFailure, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_notifyOnBuildFailure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_oldestAllowedMergeBase(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_oldestAllowedMergeBase,
		func(ctx context.Context) (any, error) {
			return obj.OldestAllowedMergeBase, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_oldestAllowedMergeBase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_owner,
		func(ctx context.Context) (any, error) {
			return obj.Owner, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_parsleyFilters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_parsleyFilters,
		func(ctx context.Context) (any, error) {
			return obj.ParsleyFilters, nil
		},
		nil,
		ec.marshalOParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_parsleyFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "caseSensitive":
				return ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
			case "description":
				return ec.fieldContext_ParsleyFilter_description(ctx, field)
			case "exactMatch":
				return ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
			case "expression":
				return ec.fieldContext_ParsleyFilter_expression(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleyFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_patchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_patchingDisabled,
		func(ctx context.Context) (any, error) {
			return obj.PatchingDisabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_patchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_patchTriggerAliases,
		func(ctx context.Context) (any, error) {
			return obj.PatchTriggerAliases, nil
		},
		nil,
		ec.marshalOPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_patchTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "downstreamRevision":
				return ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_perfEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_perfEnabled,
		func(ctx context.Context) (any, error) {
			return obj.PerfEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_perfEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_periodicBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_periodicBuilds,
		func(ctx context.Context) (any, error) {
			return obj.PeriodicBuilds, nil
		},
		nil,
		ec.marshalOPeriodicBuild2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_periodicBuilds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PeriodicBuild_id(ctx, field)
			case "alias":
				return ec.fieldContext_PeriodicBuild_alias(ctx, field)
			case "configFile":
				return ec.fieldContext_PeriodicBuild_configFile(ctx, field)
			case "intervalHours":
				return ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
			case "cron":
				return ec.fieldContext_PeriodicBuild_cron(ctx, field)
			case "message":
				return ec.fieldContext_PeriodicBuild_message(ctx, field)
			case "nextRunTime":
				return ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PeriodicBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_prTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_prTestingEnabled,
		func(ctx context.Context) (any, error) {
			return obj.PRTestingEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_prTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_remotePath,
		func(ctx context.Context) (any, error) {
			return obj.RemotePath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_remotePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_repo,
		func(ctx context.Context) (any, error) {
			return obj.Repo, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_repotrackerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_repotrackerDisabled,
		func(ctx context.Context) (any, error) {
			return obj.RepotrackerDisabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_repotrackerDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_restricted(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_restricted,
		func(ctx context.Context) (any, error) {
			return obj.Restricted, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_restricted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_spawnHostScriptPath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_spawnHostScriptPath,
		func(ctx context.Context) (any, error) {
			return obj.SpawnHostScriptPath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_spawnHostScriptPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_debugSpawnHostsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_debugSpawnHostsDisabled,
		func(ctx context.Context) (any, error) {
			return obj.DebugSpawnHostsDisabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_debugSpawnHostsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_stepbackDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_stepbackDisabled,
		func(ctx context.Context) (any, error) {
			return obj.StepbackDisabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_stepbackDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_stepbackBisect(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_stepbackBisect,
		func(ctx context.Context) (any, error) {
			return obj.StepbackBisect, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_stepbackBisect(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_taskAnnotationSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_taskAnnotationSettings,
		func(ctx context.Context) (any, error) {
			return obj.TaskAnnotationSettings, nil
		},
		nil,
		ec.marshalNTaskAnnotationSettings2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_taskAnnotationSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileTicketWebhook":
				return ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskAnnotationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_testSelection(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_testSelection,
		func(ctx context.Context) (any, error) {
			return obj.TestSelection, nil
		},
		nil,
		ec.marshalORepoTestSelectionSettings2githubcomevergreencievergreenrestmodelAPITestSelectionSettings,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_testSelection(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowed":
				return ec.fieldContext_RepoTestSelectionSettings_allowed(ctx, field)
			case "defaultEnabled":
				return ec.fieldContext_RepoTestSelectionSettings_defaultEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoTestSelectionSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_tracksPushEvents(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_tracksPushEvents,
		func(ctx context.Context) (any, error) {
			return obj.TracksPushEvents, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_tracksPushEvents(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_triggers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_triggers,
		func(ctx context.Context) (any, error) {
			return obj.Triggers, nil
		},
		nil,
		ec.marshalNTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_triggers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_TriggerAlias_alias(ctx, field)
			case "buildVariantRegex":
				return ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
			case "configFile":
				return ec.fieldContext_TriggerAlias_configFile(ctx, field)
			case "dateCutoff":
				return ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
			case "level":
				return ec.fieldContext_TriggerAlias_level(ctx, field)
			case "project":
				return ec.fieldContext_TriggerAlias_project(ctx, field)
			case "status":
				return ec.fieldContext_TriggerAlias_status(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
			case "unscheduleDownstreamVersions":
				return ec.fieldContext_TriggerAlias_unscheduleDownstreamVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_versionControlEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_versionControlEnabled,
		func(ctx context.Context) (any, error) {
			return obj.VersionControlEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_versionControlEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_workstationConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_workstationConfig,
		func(ctx context.Context) (any, error) {
			return obj.WorkstationConfig, nil
		},
		nil,
		ec.marshalNRepoWorkstationConfig2githubcomevergreencievergreenrestmodelAPIWorkstationConfig,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoRef_workstationConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gitClone":
				return ec.fieldContext_RepoWorkstationConfig_gitClone(ctx, field)
			case "setupCommands":
				return ec.fieldContext_RepoWorkstationConfig_setupCommands(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoWorkstationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_externalLinks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoRef_externalLinks,
		func(ctx context.Context) (any, error) {
			return obj.ExternalLinks, nil
		},
		nil,
		ec.marshalOExternalLink2githubcomevergreencievergreenrestmodelAPIExternalLink,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoRef_externalLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ExternalLink_displayName(ctx, field)
			case "requesters":
				return ec.fieldContext_ExternalLink_requesters(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoSettings_aliases,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.RepoSettings().Aliases(ctx, obj)
		},
		nil,
		ec.marshalOProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoSettings_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_githubAppAuth(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoSettings_githubAppAuth,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.RepoSettings().GithubAppAuth(ctx, obj)
		},
		nil,
		ec.marshalOGithubAppAuth2githubcomevergreencievergreenrestmodelAPIGithubAppAuth,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoSettings_githubAppAuth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GithubAppAuth_appId(ctx, field)
			case "privateKey":
				return ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAppAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoSettings_githubWebhooksEnabled,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.RepoSettings().GithubWebhooksEnabled(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoSettings_githubWebhooksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoSettings_projectRef,
		func(ctx context.Context) (any, error) {
			return obj.ProjectRef, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireProjectSettingsAccess == nil {
					var zeroVal model.APIProjectRef
					return zeroVal, errors.New("directive requireProjectSettingsAccess is not implemented")
				}
				return ec.directives.RequireProjectSettingsAccess(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalORepoRef2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoSettings_projectRef(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoRef_id(ctx, field)
			case "admins":
				return ec.fieldContext_RepoRef_admins(ctx, field)
			case "batchTime":
				return ec.fieldContext_RepoRef_batchTime(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_RepoRef_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_RepoRef_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_RepoRef_enabled(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_RepoRef_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_RepoRef_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_RepoRef_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_RepoRef_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_RepoRef_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_RepoRef_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_RepoRef_parsleyFilters(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_RepoRef_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_RepoRef_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_RepoRef_repo(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_RepoRef_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_RepoRef_debugSpawnHostsDisabled(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_RepoRef_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_RepoRef_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_RepoRef_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_RepoRef_workstationConfig(ctx, field)
			case "externalLinks":
				return ec.fieldContext_RepoRef_externalLinks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoSettings_subscriptions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.RepoSettings().Subscriptions(ctx, obj)
		},
		nil,
		ec.marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoSettings_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoSettings_vars,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.RepoSettings().Vars(ctx, obj)
		},
		nil,
		ec.marshalOProjectVars2githubcomevergreencievergreenrestmodelAPIProjectVars,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoSettings_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoTestSelectionSettings_allowed(ctx context.Context, field graphql.CollectedField, obj *model.APITestSelectionSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoTestSelectionSettings_allowed,
		func(ctx context.Context) (any, error) {
			return obj.Allowed, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoTestSelectionSettings_allowed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoTestSelectionSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoTestSelectionSettings_defaultEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITestSelectionSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoTestSelectionSettings_defaultEnabled,
		func(ctx context.Context) (any, error) {
			return obj.DefaultEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoTestSelectionSettings_defaultEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoTestSelectionSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoWorkstationConfig_gitClone(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoWorkstationConfig_gitClone,
		func(ctx context.Context) (any, error) {
			return obj.GitClone, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepoWorkstationConfig_gitClone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoWorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoWorkstationConfig_setupCommands(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepoWorkstationConfig_setupCommands,
		func(ctx context.Context) (any, error) {
			return obj.SetupCommands, nil
		},
		nil,
		ec.marshalOWorkstationSetupCommand2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepoWorkstationConfig_setupCommands(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoWorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "command":
				return ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
			case "directory":
				return ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationSetupCommand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerConfig_numNewRepoRevisionsToFetch(ctx context.Context, field graphql.CollectedField, obj *model.APIRepoTrackerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepotrackerConfig_numNewRepoRevisionsToFetch,
		func(ctx context.Context) (any, error) {
			return obj.NumNewRepoRevisionsToFetch, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepotrackerConfig_numNewRepoRevisionsToFetch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerConfig_maxRepoRevisionsToSearch(ctx context.Context, field graphql.CollectedField, obj *model.APIRepoTrackerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepotrackerConfig_maxRepoRevisionsToSearch,
		func(ctx context.Context) (any, error) {
			return obj.MaxRepoRevisionsToSearch, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepotrackerConfig_maxRepoRevisionsToSearch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerConfig_maxConcurrentRequests(ctx context.Context, field graphql.CollectedField, obj *model.APIRepoTrackerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepotrackerConfig_maxConcurrentRequests,
		func(ctx context.Context) (any, error) {
			return obj.MaxConcurrentRequests, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RepotrackerConfig_maxConcurrentRequests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerError_exists(ctx context.Context, field graphql.CollectedField, obj *model.APIRepositoryErrorDetails) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepotrackerError_exists,
		func(ctx context.Context) (any, error) {
			return obj.Exists, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepotrackerError_exists(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerError_invalidRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIRepositoryErrorDetails) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepotrackerError_invalidRevision,
		func(ctx context.Context) (any, error) {
			return obj.InvalidRevision, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepotrackerError_invalidRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerError_mergeBaseRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIRepositoryErrorDetails) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RepotrackerError_mergeBaseRevision,
		func(ctx context.Context) (any, error) {
			return obj.MergeBaseRevision, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RepotrackerError_mergeBaseRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_lockedMemoryKb(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ResourceLimits_lockedMemoryKb,
		func(ctx context.Context) (any, error) {
			return obj.LockedMemoryKB, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ResourceLimits_lockedMemoryKb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numFiles(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ResourceLimits_numFiles,
		func(ctx context.Context) (any, error) {
			return obj.NumFiles, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ResourceLimits_numFiles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numProcesses(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ResourceLimits_numProcesses,
		func(ctx context.Context) (any, error) {
			return obj.NumProcesses, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ResourceLimits_numProcesses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ResourceLimits_numTasks,
		func(ctx context.Context) (any, error) {
			return obj.NumTasks, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ResourceLimits_numTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_virtualMemoryKb(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ResourceLimits_virtualMemoryKb,
		func(ctx context.Context) (any, error) {
			return obj.VirtualMemoryKB, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ResourceLimits_virtualMemoryKb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RestartAdminTasksPayload_numRestartedTasks(ctx context.Context, field graphql.CollectedField, obj *RestartAdminTasksPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RestartAdminTasksPayload_numRestartedTasks,
		func(ctx context.Context) (any, error) {
			return obj.NumRestartedTasks, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RestartAdminTasksPayload_numRestartedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RestartAdminTasksPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeEnvironmentConfig_baseUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIRuntimeEnvironmentsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RuntimeEnvironmentConfig_baseUrl,
		func(ctx context.Context) (any, error) {
			return obj.BaseURL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RuntimeEnvironmentConfig_baseUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeEnvironmentConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeEnvironmentConfig_apiKey(ctx context.Context, field graphql.CollectedField, obj *model.APIRuntimeEnvironmentsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RuntimeEnvironmentConfig_apiKey,
		func(ctx context.Context) (any, error) {
			return obj.APIKey, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_RuntimeEnvironmentConfig_apiKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeEnvironmentConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _S3Credentials_key(ctx context.Context, field graphql.CollectedField, obj *model.APIS3Credentials) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_S3Credentials_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_S3Credentials_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "S3Credentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _S3Credentials_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIS3Credentials) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_S3Credentials_secret,
		func(ctx context.Context) (any, error) {
			return obj.Secret, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_S3Credentials_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "S3Credentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _S3Credentials_bucket(ctx context.Context, field graphql.CollectedField, obj *model.APIS3Credentials) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_S3Credentials_bucket,
		func(ctx context.Context) (any, error) {
			return obj.Bucket, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_S3Credentials_bucket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "S3Credentials",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SESConfig_senderAddress(ctx context.Context, field graphql.CollectedField, obj *model.APISESConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SESConfig_senderAddress,
		func(ctx context.Context) (any, error) {
			return obj.SenderAddress, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SESConfig_senderAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SESConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SSHConfig_taskHostKey(ctx context.Context, field graphql.CollectedField, obj *model.APISSHConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SSHConfig_taskHostKey,
		func(ctx context.Context) (any, error) {
			return obj.TaskHostKey, nil
		},
		nil,
		ec.marshalOSSHKeyPair2githubcomevergreencievergreenrestmodelAPISSHKeyPair,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SSHConfig_taskHostKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SSHConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SSHKeyPair_name(ctx, field)
			case "secretARN":
				return ec.fieldContext_SSHKeyPair_secretARN(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SSHKeyPair", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SSHConfig_spawnHostKey(ctx context.Context, field graphql.CollectedField, obj *model.APISSHConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SSHConfig_spawnHostKey,
		func(ctx context.Context) (any, error) {
			return obj.SpawnHostKey, nil
		},
		nil,
		ec.marshalOSSHKeyPair2githubcomevergreencievergreenrestmodelAPISSHKeyPair,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SSHConfig_spawnHostKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SSHConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SSHKeyPair_name(ctx, field)
			case "secretARN":
				return ec.fieldContext_SSHKeyPair_secretARN(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SSHKeyPair", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SSHKeyPair_name(ctx context.Context, field graphql.CollectedField, obj *model.APISSHKeyPair) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SSHKeyPair_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SSHKeyPair_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SSHKeyPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SSHKeyPair_secretARN(ctx context.Context, field graphql.CollectedField, obj *model.APISSHKeyPair) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SSHKeyPair_secretARN,
		func(ctx context.Context) (any, error) {
			return obj.SecretARN, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SSHKeyPair_secretARN(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SSHKeyPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SaveDistroPayload_distro(ctx context.Context, field graphql.CollectedField, obj *SaveDistroPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SaveDistroPayload_distro,
		func(ctx context.Context) (any, error) {
			return obj.Distro, nil
		},
		nil,
		ec.marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SaveDistroPayload_distro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SaveDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "availableRegions":
				return ec.fieldContext_Distro_availableRegions(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerAccount":
				return ec.fieldContext_Distro_providerAccount(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			case "costData":
				return ec.fieldContext_Distro_costData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SaveDistroPayload_hostCount(ctx context.Context, field graphql.CollectedField, obj *SaveDistroPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SaveDistroPayload_hostCount,
		func(ctx context.Context) (any, error) {
			return obj.HostCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SaveDistroPayload_hostCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SaveDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_taskFinder(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_taskFinder,
		func(ctx context.Context) (any, error) {
			return obj.TaskFinder, nil
		},
		nil,
		ec.marshalOFinderVersion2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_taskFinder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FinderVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_hostAllocator(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_hostAllocator,
		func(ctx context.Context) (any, error) {
			return obj.HostAllocator, nil
		},
		nil,
		ec.marshalOHostAllocatorVersion2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_hostAllocator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostAllocatorVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_hostAllocatorRoundingRule(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_hostAllocatorRoundingRule,
		func(ctx context.Context) (any, error) {
			return obj.HostAllocatorRoundingRule, nil
		},
		nil,
		ec.marshalORoundingRule2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_hostAllocatorRoundingRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RoundingRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_hostAllocatorFeedbackRule(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_hostAllocatorFeedbackRule,
		func(ctx context.Context) (any, error) {
			return obj.HostAllocatorFeedbackRule, nil
		},
		nil,
		ec.marshalOFeedbackRule2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_hostAllocatorFeedbackRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FeedbackRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_hostsOverallocatedRule(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_hostsOverallocatedRule,
		func(ctx context.Context) (any, error) {
			return obj.HostsOverallocatedRule, nil
		},
		nil,
		ec.marshalOOverallocatedRule2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_hostsOverallocatedRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OverallocatedRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_futureHostFraction(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_futureHostFraction,
		func(ctx context.Context) (any, error) {
			return obj.FutureHostFraction, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_futureHostFraction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_cacheDurationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_cacheDurationSeconds,
		func(ctx context.Context) (any, error) {
			return obj.CacheDurationSeconds, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_cacheDurationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_targetTimeSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_targetTimeSeconds,
		func(ctx context.Context) (any, error) {
			return obj.TargetTimeSeconds, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_targetTimeSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_acceptableHostIdleTimeSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_acceptableHostIdleTimeSeconds,
		func(ctx context.Context) (any, error) {
			return obj.AcceptableHostIdleTimeSeconds, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_acceptableHostIdleTimeSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_groupVersions(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_groupVersions,
		func(ctx context.Context) (any, error) {
			return obj.GroupVersions, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_groupVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_patchFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_patchFactor,
		func(ctx context.Context) (any, error) {
			return obj.PatchFactor, nil
		},
		nil,
		ec.marshalOInt2int64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_patchFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_patchTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_patchTimeInQueueFactor,
		func(ctx context.Context) (any, error) {
			return obj.PatchTimeInQueueFactor, nil
		},
		nil,
		ec.marshalOInt2int64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_patchTimeInQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_commitQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_commitQueueFactor,
		func(ctx context.Context) (any, error) {
			return obj.CommitQueueFactor, nil
		},
		nil,
		ec.marshalOInt2int64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_commitQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_mainlineTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_mainlineTimeInQueueFactor,
		func(ctx context.Context) (any, error) {
			return obj.MainlineTimeInQueueFactor, nil
		},
		nil,
		ec.marshalOInt2int64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_mainlineTimeInQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_expectedRuntimeFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_expectedRuntimeFactor,
		func(ctx context.Context) (any, error) {
			return obj.ExpectedRuntimeFactor, nil
		},
		nil,
		ec.marshalOInt2int64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_expectedRuntimeFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_generateTaskFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_generateTaskFactor,
		func(ctx context.Context) (any, error) {
			return obj.GenerateTaskFactor, nil
		},
		nil,
		ec.marshalOInt2int64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_generateTaskFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_numDependentsFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_numDependentsFactor,
		func(ctx context.Context) (any, error) {
			return obj.NumDependentsFactor, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_numDependentsFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_stepbackTaskFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SchedulerConfig_stepbackTaskFactor,
		func(ctx context.Context) (any, error) {
			return obj.StepbackTaskFactor, nil
		},
		nil,
		ec.marshalOInt2int64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SchedulerConfig_stepbackTaskFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_featuresURL(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchReturnInfo_featuresURL,
		func(ctx context.Context) (any, error) {
			return obj.FeaturesURL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_featuresURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_issues(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchReturnInfo_issues,
		func(ctx context.Context) (any, error) {
			return obj.Issues, nil
		},
		nil,
		ec.marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_issues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_search(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchReturnInfo_search,
		func(ctx context.Context) (any, error) {
			return obj.Search, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_search(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_source(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SearchReturnInfo_source,
		func(ctx context.Context) (any, error) {
			return obj.Source, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SecretsManagerConfig_secretPrefix(ctx context.Context, field graphql.CollectedField, obj *model.APISecretsManagerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SecretsManagerConfig_secretPrefix,
		func(ctx context.Context) (any, error) {
			return obj.SecretPrefix, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SecretsManagerConfig_secretPrefix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SecretsManagerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Selector_data(ctx context.Context, field graphql.CollectedField, obj *model.APISelector) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Selector_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Selector_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Selector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Selector_type(ctx context.Context, field graphql.CollectedField, obj *model.APISelector) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Selector_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Selector_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Selector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_taskDispatchDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_taskDispatchDisabled,
		func(ctx context.Context) (any, error) {
			return obj.TaskDispatchDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_taskDispatchDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_hostInitDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_hostInitDisabled,
		func(ctx context.Context) (any, error) {
			return obj.HostInitDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_hostInitDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_podInitDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_podInitDisabled,
		func(ctx context.Context) (any, error) {
			return obj.PodInitDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_podInitDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_largeParserProjectsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_largeParserProjectsDisabled,
		func(ctx context.Context) (any, error) {
			return obj.LargeParserProjectsDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_largeParserProjectsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_monitorDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_monitorDisabled,
		func(ctx context.Context) (any, error) {
			return obj.MonitorDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_monitorDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_alertsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_alertsDisabled,
		func(ctx context.Context) (any, error) {
			return obj.AlertsDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_alertsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_agentStartDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_agentStartDisabled,
		func(ctx context.Context) (any, error) {
			return obj.AgentStartDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_agentStartDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_repotrackerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_repotrackerDisabled,
		func(ctx context.Context) (any, error) {
			return obj.RepotrackerDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_repotrackerDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_schedulerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_schedulerDisabled,
		func(ctx context.Context) (any, error) {
			return obj.SchedulerDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_schedulerDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_checkBlockedTasksDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_checkBlockedTasksDisabled,
		func(ctx context.Context) (any, error) {
			return obj.CheckBlockedTasksDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_checkBlockedTasksDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_githubPRTestingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_githubPRTestingDisabled,
		func(ctx context.Context) (any, error) {
			return obj.GithubPRTestingDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_githubPRTestingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_cliUpdatesDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_cliUpdatesDisabled,
		func(ctx context.Context) (any, error) {
			return obj.CLIUpdatesDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_cliUpdatesDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_backgroundStatsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_backgroundStatsDisabled,
		func(ctx context.Context) (any, error) {
			return obj.BackgroundStatsDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_backgroundStatsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_taskLoggingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_taskLoggingDisabled,
		func(ctx context.Context) (any, error) {
			return obj.TaskLoggingDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_taskLoggingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_cacheStatsJobDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_cacheStatsJobDisabled,
		func(ctx context.Context) (any, error) {
			return obj.CacheStatsJobDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_cacheStatsJobDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_cacheStatsEndpointDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_cacheStatsEndpointDisabled,
		func(ctx context.Context) (any, error) {
			return obj.CacheStatsEndpointDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_cacheStatsEndpointDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_taskReliabilityDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_taskReliabilityDisabled,
		func(ctx context.Context) (any, error) {
			return obj.TaskReliabilityDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_taskReliabilityDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_hostAllocatorDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_hostAllocatorDisabled,
		func(ctx context.Context) (any, error) {
			return obj.HostAllocatorDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_hostAllocatorDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_podAllocatorDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_podAllocatorDisabled,
		func(ctx context.Context) (any, error) {
			return obj.PodAllocatorDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_podAllocatorDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_unrecognizedPodCleanupDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_unrecognizedPodCleanupDisabled,
		func(ctx context.Context) (any, error) {
			return obj.UnrecognizedPodCleanupDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_unrecognizedPodCleanupDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_backgroundReauthDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_backgroundReauthDisabled,
		func(ctx context.Context) (any, error) {
			return obj.BackgroundReauthDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_backgroundReauthDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_cloudCleanupDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_cloudCleanupDisabled,
		func(ctx context.Context) (any, error) {
			return obj.CloudCleanupDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_cloudCleanupDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_debugSpawnHostDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_debugSpawnHostDisabled,
		func(ctx context.Context) (any, error) {
			return obj.DebugSpawnHostDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_debugSpawnHostDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_sleepScheduleDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_sleepScheduleDisabled,
		func(ctx context.Context) (any, error) {
			return obj.SleepScheduleDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_sleepScheduleDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_staticAPIKeysDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_staticAPIKeysDisabled,
		func(ctx context.Context) (any, error) {
			return obj.StaticAPIKeysDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_staticAPIKeysDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_jwtTokenForCLIDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_jwtTokenForCLIDisabled,
		func(ctx context.Context) (any, error) {
			return obj.JWTTokenForCLIDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_jwtTokenForCLIDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_systemFailedTaskRestartDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_systemFailedTaskRestartDisabled,
		func(ctx context.Context) (any, error) {
			return obj.SystemFailedTaskRestartDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_systemFailedTaskRestartDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_degradedModeDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_degradedModeDisabled,
		func(ctx context.Context) (any, error) {
			return obj.DegradedModeDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_degradedModeDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_elasticIPsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_elasticIPsDisabled,
		func(ctx context.Context) (any, error) {
			return obj.ElasticIPsDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_elasticIPsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_useGitForGitHubFilesDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_useGitForGitHubFilesDisabled,
		func(ctx context.Context) (any, error) {
			return obj.UseGitForGitHubFilesDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_useGitForGitHubFilesDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_releaseModeDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_releaseModeDisabled,
		func(ctx context.Context) (any, error) {
			return obj.ReleaseModeDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_releaseModeDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_eventProcessingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_eventProcessingDisabled,
		func(ctx context.Context) (any, error) {
			return obj.EventProcessingDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_eventProcessingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_jiraNotificationsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_jiraNotificationsDisabled,
		func(ctx context.Context) (any, error) {
			return obj.JIRANotificationsDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_jiraNotificationsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_slackNotificationsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_slackNotificationsDisabled,
		func(ctx context.Context) (any, error) {
			return obj.SlackNotificationsDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_slackNotificationsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_emailNotificationsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_emailNotificationsDisabled,
		func(ctx context.Context) (any, error) {
			return obj.EmailNotificationsDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_emailNotificationsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_webhookNotificationsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_webhookNotificationsDisabled,
		func(ctx context.Context) (any, error) {
			return obj.WebhookNotificationsDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_webhookNotificationsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_githubStatusAPIDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_githubStatusAPIDisabled,
		func(ctx context.Context) (any, error) {
			return obj.GithubStatusAPIDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_githubStatusAPIDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_s3LifecycleSyncDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ServiceFlags_s3LifecycleSyncDisabled,
		func(ctx context.Context) (any, error) {
			return obj.S3LifecycleSyncDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ServiceFlags_s3LifecycleSyncDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetLastRevisionPayload_mergeBaseRevision(ctx context.Context, field graphql.CollectedField, obj *SetLastRevisionPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SetLastRevisionPayload_mergeBaseRevision,
		func(ctx context.Context) (any, error) {
			return obj.MergeBaseRevision, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SetLastRevisionPayload_mergeBaseRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetLastRevisionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SingleTaskDistroConfig_projectTasksPairs(ctx context.Context, field graphql.CollectedField, obj *model.APISingleTaskDistroConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SingleTaskDistroConfig_projectTasksPairs,
		func(ctx context.Context) (any, error) {
			return obj.ProjectTasksPairs, nil
		},
		nil,
		ec.marshalNProjectTasksPair2githubcomevergreencievergreenrestmodelAPIProjectTasksPair,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SingleTaskDistroConfig_projectTasksPairs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SingleTaskDistroConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectId":
				return ec.fieldContext_ProjectTasksPair_projectId(ctx, field)
			case "allowedTasks":
				return ec.fieldContext_ProjectTasksPair_allowedTasks(ctx, field)
			case "allowedBVs":
				return ec.fieldContext_ProjectTasksPair_allowedBVs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTasksPair", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackConfig_options(ctx context.Context, field graphql.CollectedField, obj *model.APISlackConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackConfig_options,
		func(ctx context.Context) (any, error) {
			return obj.Options, nil
		},
		nil,
		ec.marshalOSlackOptions2githubcomevergreencievergreenrestmodelAPISlackOptions,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackConfig_options(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "channel":
				return ec.fieldContext_SlackOptions_channel(ctx, field)
			case "hostname":
				return ec.fieldContext_SlackOptions_hostname(ctx, field)
			case "name":
				return ec.fieldContext_SlackOptions_name(ctx, field)
			case "username":
				return ec.fieldContext_SlackOptions_username(ctx, field)
			case "basicMetadata":
				return ec.fieldContext_SlackOptions_basicMetadata(ctx, field)
			case "fields":
				return ec.fieldContext_SlackOptions_fields(ctx, field)
			case "allFields":
				return ec.fieldContext_SlackOptions_allFields(ctx, field)
			case "fieldsSet":
				return ec.fieldContext_SlackOptions_fieldsSet(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlackOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackConfig_token(ctx context.Context, field graphql.CollectedField, obj *model.APISlackConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackConfig_token,
		func(ctx context.Context) (any, error) {
			return obj.Token, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackConfig_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackConfig_level(ctx context.Context, field graphql.CollectedField, obj *model.APISlackConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackConfig_level,
		func(ctx context.Context) (any, error) {
			return obj.Level, nil
		},
		nil,
		ec.marshalOPriorityLevel2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackConfig_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PriorityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.APISlackConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackConfig_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackConfig_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_channel(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackOptions_channel,
		func(ctx context.Context) (any, error) {
			return obj.Channel, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackOptions_channel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_hostname(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackOptions_hostname,
		func(ctx context.Context) (any, error) {
			return obj.Hostname, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackOptions_hostname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_name(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackOptions_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackOptions_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_username(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackOptions_username,
		func(ctx context.Context) (any, error) {
			return obj.Username, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackOptions_username(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_basicMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackOptions_basicMetadata,
		func(ctx context.Context) (any, error) {
			return obj.BasicMetadata, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackOptions_basicMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_fields(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackOptions_fields,
		func(ctx context.Context) (any, error) {
			return obj.Fields, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackOptions_fields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_allFields(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackOptions_allFields,
		func(ctx context.Context) (any, error) {
			return obj.AllFields, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackOptions_allFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_fieldsSet(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SlackOptions_fieldsSet,
		func(ctx context.Context) (any, error) {
			return obj.FieldsSet, nil
		},
		nil,
		ec.marshalOBooleanMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SlackOptions_fieldsSet(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BooleanMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_dailyStartTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SleepSchedule_dailyStartTime,
		func(ctx context.Context) (any, error) {
			return obj.DailyStartTime, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SleepSchedule_dailyStartTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_dailyStopTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SleepSchedule_dailyStopTime,
		func(ctx context.Context) (any, error) {
			return obj.DailyStopTime, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SleepSchedule_dailyStopTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_nextStartTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SleepSchedule_nextStartTime,
		func(ctx context.Context) (any, error) {
			return obj.NextStartTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SleepSchedule_nextStartTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_nextStopTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SleepSchedule_nextStopTime,
		func(ctx context.Context) (any, error) {
			return obj.NextStopTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SleepSchedule_nextStopTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_permanentlyExempt(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SleepSchedule_permanentlyExempt,
		func(ctx context.Context) (any, error) {
			return obj.PermanentlyExempt, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SleepSchedule_permanentlyExempt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_shouldKeepOff(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SleepSchedule_shouldKeepOff,
		func(ctx context.Context) (any, error) {
			return obj.ShouldKeepOff, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SleepSchedule_shouldKeepOff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_timeZone(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SleepSchedule_timeZone,
		func(ctx context.Context) (any, error) {
			return obj.TimeZone, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SleepSchedule_timeZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_temporarilyExemptUntil(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SleepSchedule_temporarilyExemptUntil,
		func(ctx context.Context) (any, error) {
			return obj.TemporarilyExemptUntil, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SleepSchedule_temporarilyExemptUntil(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_wholeWeekdaysOff(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SleepSchedule_wholeWeekdaysOff,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SleepSchedule().WholeWeekdaysOff(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SleepSchedule_wholeWeekdaysOff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepScheduleConfig_permanentlyExemptHosts(ctx context.Context, field graphql.CollectedField, obj *model.APISleepScheduleConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SleepScheduleConfig_permanentlyExemptHosts,
		func(ctx context.Context) (any, error) {
			return obj.PermanentlyExemptHosts, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SleepScheduleConfig_permanentlyExemptHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepScheduleConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_author(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Source_author,
		func(ctx context.Context) (any, error) {
			return obj.Author, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Source_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_requester(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Source_requester,
		func(ctx context.Context) (any, error) {
			return obj.Requester, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Source_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_time(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Source_time,
		func(ctx context.Context) (any, error) {
			return obj.Time, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Source_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_unexpirableHostsPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpawnHostConfig_unexpirableHostsPerUser,
		func(ctx context.Context) (any, error) {
			return obj.UnexpirableHostsPerUser, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_unexpirableHostsPerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_unexpirableVolumesPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpawnHostConfig_unexpirableVolumesPerUser,
		func(ctx context.Context) (any, error) {
			return obj.UnexpirableVolumesPerUser, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_spawnHostsPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpawnHostConfig_spawnHostsPerUser,
		func(ctx context.Context) (any, error) {
			return obj.SpawnHostsPerUser, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_spawnHostsPerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplunkConfig_splunkConnectionInfo(ctx context.Context, field graphql.CollectedField, obj *model.APISplunkConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SplunkConfig_splunkConnectionInfo,
		func(ctx context.Context) (any, error) {
			return obj.SplunkConnectionInfo, nil
		},
		nil,
		ec.marshalNSplunkConnectionInfo2githubcomevergreencievergreenrestmodelAPISplunkConnectionInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SplunkConfig_splunkConnectionInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplunkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "serverUrl":
				return ec.fieldContext_SplunkConnectionInfo_serverUrl(ctx, field)
			case "token":
				return ec.fieldContext_SplunkConnectionInfo_token(ctx, field)
			case "channel":
				return ec.fieldContext_SplunkConnectionInfo_channel(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplunkConnectionInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplunkConnectionInfo_serverUrl(ctx context.Context, field graphql.CollectedField, obj *model.APISplunkConnectionInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SplunkConnectionInfo_serverUrl,
		func(ctx context.Context) (any, error) {
			return obj.ServerURL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SplunkConnectionInfo_serverUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplunkConnectionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplunkConnectionInfo_token(ctx context.Context, field graphql.CollectedField, obj *model.APISplunkConnectionInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SplunkConnectionInfo_token,
		func(ctx context.Context) (any, error) {
			return obj.Token, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SplunkConnectionInfo_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplunkConnectionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplunkConnectionInfo_channel(ctx context.Context, field graphql.CollectedField, obj *model.APISplunkConnectionInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SplunkConnectionInfo_channel,
		func(ctx context.Context) (any, error) {
			return obj.Channel, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SplunkConnectionInfo_channel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplunkConnectionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_banner,
		func(ctx context.Context) (any, error) {
			return obj.Banner, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_banner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_bannerTheme(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_bannerTheme,
		func(ctx context.Context) (any, error) {
			return obj.BannerTheme, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_bannerTheme(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_containerPools(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_containerPools,
		func(ctx context.Context) (any, error) {
			return obj.ContainerPools, nil
		},
		nil,
		ec.marshalOContainerPoolsConfig2githubcomevergreencievergreenrestmodelAPIContainerPoolsConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_containerPools(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pools":
				return ec.fieldContext_ContainerPoolsConfig_pools(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerPoolsConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_githubOrgs(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_githubOrgs,
		func(ctx context.Context) (any, error) {
			return obj.GithubOrgs, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_githubOrgs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_jira(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_jira,
		func(ctx context.Context) (any, error) {
			return obj.Jira, nil
		},
		nil,
		ec.marshalOJiraConfig2githubcomevergreencievergreenrestmodelAPIJiraConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_jira(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "email":
				return ec.fieldContext_JiraConfig_email(ctx, field)
			case "host":
				return ec.fieldContext_JiraConfig_host(ctx, field)
			case "personalAccessToken":
				return ec.fieldContext_JiraConfig_personalAccessToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_providers(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_providers,
		func(ctx context.Context) (any, error) {
			return obj.Providers, nil
		},
		nil,
		ec.marshalOCloudProviderConfig2githubcomevergreencievergreenrestmodelAPICloudProviders,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_providers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aws":
				return ec.fieldContext_CloudProviderConfig_aws(ctx, field)
			case "docker":
				return ec.fieldContext_CloudProviderConfig_docker(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CloudProviderConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_secretFields(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_secretFields,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SpruceConfig().SecretFields(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_secretFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_serviceFlags(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_serviceFlags,
		func(ctx context.Context) (any, error) {
			return obj.ServiceFlags, nil
		},
		nil,
		ec.marshalNUserServiceFlags2githubcomevergreencievergreenrestmodelAPIServiceFlags,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_serviceFlags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jwtTokenForCLIDisabled":
				return ec.fieldContext_UserServiceFlags_jwtTokenForCLIDisabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserServiceFlags", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_singleTaskDistro(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_singleTaskDistro,
		func(ctx context.Context) (any, error) {
			return obj.SingleTaskDistro, nil
		},
		nil,
		ec.marshalOSingleTaskDistroConfig2githubcomevergreencievergreenrestmodelAPISingleTaskDistroConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_singleTaskDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectTasksPairs":
				return ec.fieldContext_SingleTaskDistroConfig_projectTasksPairs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SingleTaskDistroConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_slack(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_slack,
		func(ctx context.Context) (any, error) {
			return obj.Slack, nil
		},
		nil,
		ec.marshalOSlackConfig2githubcomevergreencievergreenrestmodelAPISlackConfig,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_slack(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "options":
				return ec.fieldContext_SlackConfig_options(ctx, field)
			case "token":
				return ec.fieldContext_SlackConfig_token(ctx, field)
			case "level":
				return ec.fieldContext_SlackConfig_level(ctx, field)
			case "name":
				return ec.fieldContext_SlackConfig_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlackConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_spawnHost(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_spawnHost,
		func(ctx context.Context) (any, error) {
			return obj.Spawnhost, nil
		},
		nil,
		ec.marshalNSpawnHostConfig2githubcomevergreencievergreenrestmodelAPISpawnHostConfig,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_spawnHost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "unexpirableHostsPerUser":
				return ec.fieldContext_SpawnHostConfig_unexpirableHostsPerUser(ctx, field)
			case "unexpirableVolumesPerUser":
				return ec.fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(ctx, field)
			case "spawnHostsPerUser":
				return ec.fieldContext_SpawnHostConfig_spawnHostsPerUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpawnHostConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_ui(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SpruceConfig_ui,
		func(ctx context.Context) (any, error) {
			return obj.Ui, nil
		},
		nil,
		ec.marshalNUIConfig2githubcomevergreencievergreenrestmodelAPIUIConfig,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SpruceConfig_ui(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_UIConfig_betaFeatures(ctx, field)
			case "url":
				return ec.fieldContext_UIConfig_url(ctx, field)
			case "helpUrl":
				return ec.fieldContext_UIConfig_helpUrl(ctx, field)
			case "uiv2Url":
				return ec.fieldContext_UIConfig_uiv2Url(ctx, field)
			case "parsleyUrl":
				return ec.fieldContext_UIConfig_parsleyUrl(ctx, field)
			case "httpListenAddr":
				return ec.fieldContext_UIConfig_httpListenAddr(ctx, field)
			case "secret":
				return ec.fieldContext_UIConfig_secret(ctx, field)
			case "defaultProject":
				return ec.fieldContext_UIConfig_defaultProject(ctx, field)
			case "corsOrigins":
				return ec.fieldContext_UIConfig_corsOrigins(ctx, field)
			case "fileStreamingContentTypes":
				return ec.fieldContext_UIConfig_fileStreamingContentTypes(ctx, field)
			case "loginDomain":
				return ec.fieldContext_UIConfig_loginDomain(ctx, field)
			case "userVoice":
				return ec.fieldContext_UIConfig_userVoice(ctx, field)
			case "csrfKey":
				return ec.fieldContext_UIConfig_csrfKey(ctx, field)
			case "cacheTemplates":
				return ec.fieldContext_UIConfig_cacheTemplates(ctx, field)
			case "stagingEnvironment":
				return ec.fieldContext_UIConfig_stagingEnvironment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UIConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusCount_count(ctx context.Context, field graphql.CollectedField, obj *task.StatusCount) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StatusCount_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StatusCount_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusCount_status(ctx context.Context, field graphql.CollectedField, obj *task.StatusCount) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StatusCount_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_StatusCount_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_lastFailingStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepbackInfo_lastFailingStepbackTaskId,
		func(ctx context.Context) (any, error) {
			return obj.LastFailingStepbackTaskId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_StepbackInfo_lastFailingStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_lastPassingStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepbackInfo_lastPassingStepbackTaskId,
		func(ctx context.Context) (any, error) {
			return obj.LastPassingStepbackTaskId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_StepbackInfo_lastPassingStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_nextStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepbackInfo_nextStepbackTaskId,
		func(ctx context.Context) (any, error) {
			return obj.NextStepbackTaskId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_StepbackInfo_nextStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_previousStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_StepbackInfo_previousStepbackTaskId,
		func(ctx context.Context) (any, error) {
			return obj.PreviousStepbackTaskId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_StepbackInfo_previousStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subnet_az(ctx context.Context, field graphql.CollectedField, obj *model.APISubnet) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subnet_az,
		func(ctx context.Context) (any, error) {
			return obj.AZ, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subnet_az(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subnet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subnet_subnetId(ctx context.Context, field graphql.CollectedField, obj *model.APISubnet) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subnet_subnetId,
		func(ctx context.Context) (any, error) {
			return obj.SubnetID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Subnet_subnetId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subnet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_emailSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscriber_emailSubscriber,
		func(ctx context.Context) (any, error) {
			return obj.EmailSubscriber, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Subscriber_emailSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_githubCheckSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscriber_githubCheckSubscriber,
		func(ctx context.Context) (any, error) {
			return obj.GithubCheckSubscriber, nil
		},
		nil,
		ec.marshalOGithubCheckSubscriber2githubcomevergreencievergreenrestmodelAPIGithubCheckSubscriber,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Subscriber_githubCheckSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_GithubCheckSubscriber_owner(ctx, field)
			case "ref":
				return ec.fieldContext_GithubCheckSubscriber_ref(ctx, field)
			case "repo":
				return ec.fieldContext_GithubCheckSubscriber_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubCheckSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_githubPRSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscriber_githubPRSubscriber,
		func(ctx context.Context) (any, error) {
			return obj.GithubPRSubscriber, nil
		},
		nil,
		ec.marshalOGithubPRSubscriber2githubcomevergreencievergreenrestmodelAPIGithubPRSubscriber,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Subscriber_githubPRSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_GithubPRSubscriber_owner(ctx, field)
			case "prNumber":
				return ec.fieldContext_GithubPRSubscriber_prNumber(ctx, field)
			case "ref":
				return ec.fieldContext_GithubPRSubscriber_ref(ctx, field)
			case "repo":
				return ec.fieldContext_GithubPRSubscriber_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubPRSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_jiraCommentSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscriber_jiraCommentSubscriber,
		func(ctx context.Context) (any, error) {
			return obj.JiraCommentSubscriber, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Subscriber_jiraCommentSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_jiraIssueSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscriber_jiraIssueSubscriber,
		func(ctx context.Context) (any, error) {
			return obj.JiraIssueSubscriber, nil
		},
		nil,
		ec.marshalOJiraIssueSubscriber2githubcomevergreencievergreenrestmodelAPIJIRAIssueSubscriber,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Subscriber_jiraIssueSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "issueType":
				return ec.fieldContext_JiraIssueSubscriber_issueType(ctx, field)
			case "project":
				return ec.fieldContext_JiraIssueSubscriber_project(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraIssueSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_slackSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscriber_slackSubscriber,
		func(ctx context.Context) (any, error) {
			return obj.SlackSubscriber, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Subscriber_slackSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_webhookSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Subscriber_webhookSubscriber,
		func(ctx context.Context) (any, error) {
			return obj.WebhookSubscriber, nil
		},
		nil,
		ec.marshalOWebhookSubscriber2githubcomevergreencievergreenrestmodelAPIWebhookSubscriber,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Subscriber_webhookSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "headers":
				return ec.fieldContext_WebhookSubscriber_headers(ctx, field)
			case "secret":
				return ec.fieldContext_WebhookSubscriber_secret(ctx, field)
			case "url":
				return ec.fieldContext_WebhookSubscriber_url(ctx, field)
			case "retries":
				return ec.fieldContext_WebhookSubscriber_retries(ctx, field)
			case "minDelayMs":
				return ec.fieldContext_WebhookSubscriber_minDelayMs(ctx, field)
			case "timeoutMs":
				return ec.fieldContext_WebhookSubscriber_timeoutMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubscriberWrapper_subscriber(ctx context.Context, field graphql.CollectedField, obj *model.APISubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SubscriberWrapper_subscriber,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.SubscriberWrapper().Subscriber(ctx, obj)
		},
		nil,
		ec.marshalNSubscriber2githubcomevergreencievergreengraphqlSubscriber,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SubscriberWrapper_subscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubscriberWrapper",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "emailSubscriber":
				return ec.fieldContext_Subscriber_emailSubscriber(ctx, field)
			case "githubCheckSubscriber":
				return ec.fieldContext_Subscriber_githubCheckSubscriber(ctx, field)
			case "githubPRSubscriber":
				return ec.fieldContext_Subscriber_githubPRSubscriber(ctx, field)
			case "jiraCommentSubscriber":
				return ec.fieldContext_Subscriber_jiraCommentSubscriber(ctx, field)
			case "jiraIssueSubscriber":
				return ec.fieldContext_Subscriber_jiraIssueSubscriber(ctx, field)
			case "slackSubscriber":
				return ec.fieldContext_Subscriber_slackSubscriber(ctx, field)
			case "webhookSubscriber":
				return ec.fieldContext_Subscriber_webhookSubscriber(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Subscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubscriberWrapper_type(ctx context.Context, field graphql.CollectedField, obj *model.APISubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_SubscriberWrapper_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_SubscriberWrapper_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubscriberWrapper",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_aborted(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_aborted,
		func(ctx context.Context) (any, error) {
			return obj.Aborted, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_aborted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_abortInfo(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_abortInfo,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().AbortInfo(ctx, obj)
		},
		nil,
		ec.marshalOAbortInfo2githubcomevergreencievergreengraphqlAbortInfo,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_abortInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariantDisplayName":
				return ec.fieldContext_AbortInfo_buildVariantDisplayName(ctx, field)
			case "newVersion":
				return ec.fieldContext_AbortInfo_newVersion(ctx, field)
			case "prClosed":
				return ec.fieldContext_AbortInfo_prClosed(ctx, field)
			case "taskDisplayName":
				return ec.fieldContext_AbortInfo_taskDisplayName(ctx, field)
			case "taskID":
				return ec.fieldContext_AbortInfo_taskID(ctx, field)
			case "user":
				return ec.fieldContext_AbortInfo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbortInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activated(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_activated,
		func(ctx context.Context) (any, error) {
			return obj.Activated, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_activatedBy,
		func(ctx context.Context) (any, error) {
			return obj.ActivatedBy, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_activatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activatedTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_activatedTime,
		func(ctx context.Context) (any, error) {
			return obj.ActivatedTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_activatedTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_ami(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_ami,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().Ami(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_ami(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_annotation(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_annotation,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().Annotation(ctx, obj)
		},
		nil,
		ec.marshalOAnnotation2githubcomevergreencievergreenrestmodelAPITaskAnnotation,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_annotation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Annotation_id(ctx, field)
			case "createdIssues":
				return ec.fieldContext_Annotation_createdIssues(ctx, field)
			case "issues":
				return ec.fieldContext_Annotation_issues(ctx, field)
			case "note":
				return ec.fieldContext_Annotation_note(ctx, field)
			case "suspectedIssues":
				return ec.fieldContext_Annotation_suspectedIssues(ctx, field)
			case "metadataLinks":
				return ec.fieldContext_Annotation_metadataLinks(ctx, field)
			case "taskId":
				return ec.fieldContext_Annotation_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_Annotation_taskExecution(ctx, field)
			case "webhookConfigured":
				return ec.fieldContext_Annotation_webhookConfigured(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Annotation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_id(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_baseStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_baseStatus,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().BaseStatus(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_baseStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_baseTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_baseTask,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().BaseTask(ctx, obj)
		},
		nil,
		ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_baseTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_blocked(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_blocked,
		func(ctx context.Context) (any, error) {
			return obj.Blocked, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_blocked(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_buildId,
		func(ctx context.Context) (any, error) {
			return obj.BuildId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_buildId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_buildVariant,
		func(ctx context.Context) (any, error) {
			return obj.BuildVariant, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildVariantDisplayName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_buildVariantDisplayName,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().BuildVariantDisplayName(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_buildVariantDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canAbort(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_canAbort,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().CanAbort(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_canAbort(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canDisable(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_canDisable,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().CanDisable(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_canDisable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canModifyAnnotation(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_canModifyAnnotation,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().CanModifyAnnotation(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_canModifyAnnotation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canOverrideDependencies(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_canOverrideDependencies,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().CanOverrideDependencies(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_canOverrideDependencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canRestart(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_canRestart,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().CanRestart(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_canRestart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canSchedule(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_canSchedule,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().CanSchedule(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_canSchedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canSetPriority(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_canSetPriority,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().CanSetPriority(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_canSetPriority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canUnschedule(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_canUnschedule,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().CanUnschedule(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_canUnschedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_containerAllocatedTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_containerAllocatedTime,
		func(ctx context.Context) (any, error) {
			return obj.ContainerAllocatedTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_containerAllocatedTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_dependsOn(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_dependsOn,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().DependsOn(ctx, obj)
		},
		nil,
		ec.marshalODependency2githubcomevergreencievergreengraphqlDependency,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_dependsOn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariant":
				return ec.fieldContext_Dependency_buildVariant(ctx, field)
			case "metStatus":
				return ec.fieldContext_Dependency_metStatus(ctx, field)
			case "name":
				return ec.fieldContext_Dependency_name(ctx, field)
			case "requiredStatus":
				return ec.fieldContext_Dependency_requiredStatus(ctx, field)
			case "taskId":
				return ec.fieldContext_Dependency_taskId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_details(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_details,
		func(ctx context.Context) (any, error) {
			return obj.Details, nil
		},
		nil,
		ec.marshalOTaskEndDetail2githubcomevergreencievergreenrestmodelApiTaskEndDetail,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext_TaskEndDetail_description(ctx, field)
			case "diskDevices":
				return ec.fieldContext_TaskEndDetail_diskDevices(ctx, field)
			case "failingCommand":
				return ec.fieldContext_TaskEndDetail_failingCommand(ctx, field)
			case "failureMetadataTags":
				return ec.fieldContext_TaskEndDetail_failureMetadataTags(ctx, field)
			case "oomTracker":
				return ec.fieldContext_TaskEndDetail_oomTracker(ctx, field)
			case "otherFailingCommands":
				return ec.fieldContext_TaskEndDetail_otherFailingCommands(ctx, field)
			case "status":
				return ec.fieldContext_TaskEndDetail_status(ctx, field)
			case "timedOut":
				return ec.fieldContext_TaskEndDetail_timedOut(ctx, field)
			case "timeoutType":
				return ec.fieldContext_TaskEndDetail_timeoutType(ctx, field)
			case "traceID":
				return ec.fieldContext_TaskEndDetail_traceID(ctx, field)
			case "type":
				return ec.fieldContext_TaskEndDetail_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEndDetail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_dispatchTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_dispatchTime,
		func(ctx context.Context) (any, error) {
			return obj.DispatchTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_dispatchTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayOnly(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_displayOnly,
		func(ctx context.Context) (any, error) {
			return obj.DisplayOnly, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_displayOnly(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_displayStatus,
		func(ctx context.Context) (any, error) {
			return obj.DisplayStatus, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_displayStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_displayTask,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().DisplayTask(ctx, obj)
		},
		nil,
		ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_displayTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_distroId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_distroId,
		func(ctx context.Context) (any, error) {
			return obj.DistroId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_distroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_estimatedStart(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_estimatedStart,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().EstimatedStart(ctx, obj)
		},
		nil,
		ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_estimatedStart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_execution(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_execution,
		func(ctx context.Context) (any, error) {
			return obj.Execution, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_executionTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_executionTasks,
		func(ctx context.Context) (any, error) {
			return obj.ExecutionTasks, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_executionTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_executionTasksFull(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_executionTasksFull,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().ExecutionTasksFull(ctx, obj)
		},
		nil,
		ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_executionTasksFull(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_expectedDuration(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_expectedDuration,
		func(ctx context.Context) (any, error) {
			return obj.ExpectedDuration, nil
		},
		nil,
		ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_expectedDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_failedTestCount(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_failedTestCount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().FailedTestCount(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_failedTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_files(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_files,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().Files(ctx, obj)
		},
		nil,
		ec.marshalNTaskFiles2githubcomevergreencievergreengraphqlTaskFiles,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_files(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileCount":
				return ec.fieldContext_TaskFiles_fileCount(ctx, field)
			case "groupedFiles":
				return ec.fieldContext_TaskFiles_groupedFiles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskFiles", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_finishTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_finishTime,
		func(ctx context.Context) (any, error) {
			return obj.FinishTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_finishTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_generatedBy,
		func(ctx context.Context) (any, error) {
			return obj.GeneratedBy, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_generatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generatedByName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_generatedByName,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().GeneratedByName(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_generatedByName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generateTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_generateTask,
		func(ctx context.Context) (any, error) {
			return obj.GenerateTask, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_generateTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_hasTestResults(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_hasTestResults,
		func(ctx context.Context) (any, error) {
			return obj.HasTestResults, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_hasTestResults(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_hostId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_hostId,
		func(ctx context.Context) (any, error) {
			return obj.HostId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_hostId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_imageId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_imageId,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().ImageID(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_imageId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_ingestTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_ingestTime,
		func(ctx context.Context) (any, error) {
			return obj.IngestTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_ingestTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_isPerfPluginEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_isPerfPluginEnabled,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().IsPerfPluginEnabled(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_isPerfPluginEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_latestExecution(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_latestExecution,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().LatestExecution(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_latestExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_logs(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_logs,
		func(ctx context.Context) (any, error) {
			return obj.Logs, nil
		},
		nil,
		ec.marshalNTaskLogLinks2githubcomevergreencievergreenrestmodelLogLinks,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentLogLink":
				return ec.fieldContext_TaskLogLinks_agentLogLink(ctx, field)
			case "allLogLink":
				return ec.fieldContext_TaskLogLinks_allLogLink(ctx, field)
			case "systemLogLink":
				return ec.fieldContext_TaskLogLinks_systemLogLink(ctx, field)
			case "taskLogLink":
				return ec.fieldContext_TaskLogLinks_taskLogLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskLogLinks", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_minQueuePosition(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_minQueuePosition,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().MinQueuePosition(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_minQueuePosition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_order(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_order,
		func(ctx context.Context) (any, error) {
			return obj.Order, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_patch(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_patch,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().Patch(ctx, obj)
		},
		nil,
		ec.marshalOPatch2githubcomevergreencievergreenrestmodelAPIPatch,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_patch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "includedLocalModules":
				return ec.fieldContext_Patch_includedLocalModules(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "user":
				return ec.fieldContext_Patch_user(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_patchNumber(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_patchNumber,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().PatchNumber(ctx, obj)
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_patchNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_pod(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_pod,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().Pod(ctx, obj)
		},
		nil,
		ec.marshalOPod2githubcomevergreencievergreenrestmodelAPIPod,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_pod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "events":
				return ec.fieldContext_Pod_events(ctx, field)
			case "id":
				return ec.fieldContext_Pod_id(ctx, field)
			case "status":
				return ec.fieldContext_Pod_status(ctx, field)
			case "task":
				return ec.fieldContext_Pod_task(ctx, field)
			case "taskContainerCreationOpts":
				return ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
			case "type":
				return ec.fieldContext_Pod_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_priority(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_priority,
		func(ctx context.Context) (any, error) {
			return obj.Priority, nil
		},
		nil,
		ec.marshalOInt2int64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_priority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_project(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_project,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().Project(ctx, obj)
		},
		nil,
		ec.marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_projectId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_projectId,
		func(ctx context.Context) (any, error) {
			return obj.ProjectId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_projectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_projectIdentifier,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().ProjectIdentifier(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_requester(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_requester,
		func(ctx context.Context) (any, error) {
			return obj.Requester, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_resetWhenFinished(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_resetWhenFinished,
		func(ctx context.Context) (any, error) {
			return obj.ResetWhenFinished, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_resetWhenFinished(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_revision(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_revision,
		func(ctx context.Context) (any, error) {
			return obj.Revision, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_scheduledTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_scheduledTime,
		func(ctx context.Context) (any, error) {
			return obj.ScheduledTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_scheduledTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_spawnHostLink(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_spawnHostLink,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().SpawnHostLink(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_spawnHostLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_startTime,
		func(ctx context.Context) (any, error) {
			return obj.StartTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_status(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_tags(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_tags,
		func(ctx context.Context) (any, error) {
			return obj.Tags, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskGroup(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_taskGroup,
		func(ctx context.Context) (any, error) {
			return obj.TaskGroup, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_taskGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskGroupMaxHosts(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_taskGroupMaxHosts,
		func(ctx context.Context) (any, error) {
			return obj.TaskGroupMaxHosts, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_taskGroupMaxHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_stepbackInfo(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_stepbackInfo,
		func(ctx context.Context) (any, error) {
			return obj.StepbackInfo, nil
		},
		nil,
		ec.marshalOStepbackInfo2githubcomevergreencievergreenrestmodelAPIStepbackInfo,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_stepbackInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastFailingStepbackTaskId":
				return ec.fieldContext_StepbackInfo_lastFailingStepbackTaskId(ctx, field)
			case "lastPassingStepbackTaskId":
				return ec.fieldContext_StepbackInfo_lastPassingStepbackTaskId(ctx, field)
			case "nextStepbackTaskId":
				return ec.fieldContext_StepbackInfo_nextStepbackTaskId(ctx, field)
			case "previousStepbackTaskId":
				return ec.fieldContext_StepbackInfo_previousStepbackTaskId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StepbackInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskLogs(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_taskLogs,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().TaskLogs(ctx, obj)
		},
		nil,
		ec.marshalNTaskLogs2githubcomevergreencievergreengraphqlTaskLogs,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_taskLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentLogs":
				return ec.fieldContext_TaskLogs_agentLogs(ctx, field)
			case "allLogs":
				return ec.fieldContext_TaskLogs_allLogs(ctx, field)
			case "eventLogs":
				return ec.fieldContext_TaskLogs_eventLogs(ctx, field)
			case "execution":
				return ec.fieldContext_TaskLogs_execution(ctx, field)
			case "systemLogs":
				return ec.fieldContext_TaskLogs_systemLogs(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskLogs_taskId(ctx, field)
			case "taskLogs":
				return ec.fieldContext_TaskLogs_taskLogs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskLogs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskCost(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_taskCost,
		func(ctx context.Context) (any, error) {
			return obj.TaskCost, nil
		},
		nil,
		ec.marshalOCost2githubcomevergreencievergreenmodelcostCost,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_taskCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "onDemandEC2Cost":
				return ec.fieldContext_Cost_onDemandEC2Cost(ctx, field)
			case "adjustedEC2Cost":
				return ec.fieldContext_Cost_adjustedEC2Cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_predictedTaskCost(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_predictedTaskCost,
		func(ctx context.Context) (any, error) {
			return obj.PredictedTaskCost, nil
		},
		nil,
		ec.marshalOCost2githubcomevergreencievergreenmodelcostCost,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_predictedTaskCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "onDemandEC2Cost":
				return ec.fieldContext_Cost_onDemandEC2Cost(ctx, field)
			case "adjustedEC2Cost":
				return ec.fieldContext_Cost_adjustedEC2Cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskOwnerTeam(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_taskOwnerTeam,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().TaskOwnerTeam(ctx, obj)
		},
		nil,
		ec.marshalOTaskOwnerTeam2githubcomevergreencievergreengraphqlTaskOwnerTeam,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_taskOwnerTeam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignmentType":
				return ec.fieldContext_TaskOwnerTeam_assignmentType(ctx, field)
			case "messages":
				return ec.fieldContext_TaskOwnerTeam_messages(ctx, field)
			case "teamName":
				return ec.fieldContext_TaskOwnerTeam_teamName(ctx, field)
			case "jiraProject":
				return ec.fieldContext_TaskOwnerTeam_jiraProject(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskOwnerTeam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_tests(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_tests,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Task().Tests(ctx, obj, fc.Args["opts"].(*TestFilterOptions))
		},
		nil,
		ec.marshalNTaskTestResult2githubcomevergreencievergreengraphqlTaskTestResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_tests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "testResults":
				return ec.fieldContext_TaskTestResult_testResults(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_TaskTestResult_totalTestCount(ctx, field)
			case "filteredTestCount":
				return ec.fieldContext_TaskTestResult_filteredTestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskTestResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Task_tests_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Task_testSelectionEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_testSelectionEnabled,
		func(ctx context.Context) (any, error) {
			return obj.TestSelectionEnabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_testSelectionEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_timeTaken(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_timeTaken,
		func(ctx context.Context) (any, error) {
			return obj.TimeTaken, nil
		},
		nil,
		ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Task_timeTaken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_totalTestCount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().TotalTestCount(ctx, obj)
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_totalTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_versionMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Task_versionMetadata,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Task().VersionMetadata(ctx, obj)
		},
		nil,
		ec.marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Task_versionMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskAnnotationSettings_fileTicketWebhook(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotationSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook,
		func(ctx context.Context) (any, error) {
			return obj.FileTicketWebhook, nil
		},
		nil,
		ec.marshalNWebhook2githubcomevergreencievergreenrestmodelAPIWebHook,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskAnnotationSettings_fileTicketWebhook(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskAnnotationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endpoint":
				return ec.fieldContext_Webhook_endpoint(ctx, field)
			case "secret":
				return ec.fieldContext_Webhook_secret(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_image(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskContainerCreationOpts_image,
		func(ctx context.Context) (any, error) {
			return obj.Image, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_memoryMB(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskContainerCreationOpts_memoryMB,
		func(ctx context.Context) (any, error) {
			return obj.MemoryMB, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_memoryMB(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_cpu(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskContainerCreationOpts_cpu,
		func(ctx context.Context) (any, error) {
			return obj.CPU, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_os(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskContainerCreationOpts_os,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TaskContainerCreationOpts().Os(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskContainerCreationOpts_arch,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TaskContainerCreationOpts().Arch(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_arch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_workingDir(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskContainerCreationOpts_workingDir,
		func(ctx context.Context) (any, error) {
			return obj.WorkingDir, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_workingDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_description(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_diskDevices(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_diskDevices,
		func(ctx context.Context) (any, error) {
			return obj.DiskDevices, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_diskDevices(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_failingCommand(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_failingCommand,
		func(ctx context.Context) (any, error) {
			return obj.FailingCommand, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_failingCommand(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_failureMetadataTags(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_failureMetadataTags,
		func(ctx context.Context) (any, error) {
			return obj.FailureMetadataTags, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_failureMetadataTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_oomTracker(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_oomTracker,
		func(ctx context.Context) (any, error) {
			return obj.OOMTracker, nil
		},
		nil,
		ec.marshalNOomTrackerInfo2githubcomevergreencievergreenrestmodelAPIOomTrackerInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_oomTracker(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "detected":
				return ec.fieldContext_OomTrackerInfo_detected(ctx, field)
			case "pids":
				return ec.fieldContext_OomTrackerInfo_pids(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OomTrackerInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_otherFailingCommands(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_otherFailingCommands,
		func(ctx context.Context) (any, error) {
			return obj.OtherFailingCommands, nil
		},
		nil,
		ec.marshalNFailingCommand2githubcomevergreencievergreenrestmodelAPIFailingCommand,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_otherFailingCommands(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fullDisplayName":
				return ec.fieldContext_FailingCommand_fullDisplayName(ctx, field)
			case "failureMetadataTags":
				return ec.fieldContext_FailingCommand_failureMetadataTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FailingCommand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_status(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_timedOut(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_timedOut,
		func(ctx context.Context) (any, error) {
			return obj.TimedOut, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_timedOut(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_timeoutType(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_timeoutType,
		func(ctx context.Context) (any, error) {
			return obj.TimeoutType, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_timeoutType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_traceID(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_traceID,
		func(ctx context.Context) (any, error) {
			return obj.TraceID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_traceID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_type(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEndDetail_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskEndDetail_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_hostId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogData_hostId,
		func(ctx context.Context) (any, error) {
			return obj.HostId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogData_hostId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_podId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogData_podId,
		func(ctx context.Context) (any, error) {
			return obj.PodId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogData_podId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_jiraIssue(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogData_jiraIssue,
		func(ctx context.Context) (any, error) {
			return obj.JiraIssue, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogData_jiraIssue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_jiraLink(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogData_jiraLink,
		func(ctx context.Context) (any, error) {
			return obj.JiraLink, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogData_jiraLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_priority(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogData_priority,
		func(ctx context.Context) (any, error) {
			return obj.Priority, nil
		},
		nil,
		ec.marshalOInt2int64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogData_priority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_status(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogData_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogData_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogData_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogData_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_userId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogData_userId,
		func(ctx context.Context) (any, error) {
			return obj.UserId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogData_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_blockedOn(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogData_blockedOn,
		func(ctx context.Context) (any, error) {
			return obj.BlockedOn, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogData_blockedOn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogEntry_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogEntry_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNTaskEventLogData2githubcomevergreencievergreenrestmodelTaskEventData,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hostId":
				return ec.fieldContext_TaskEventLogData_hostId(ctx, field)
			case "podId":
				return ec.fieldContext_TaskEventLogData_podId(ctx, field)
			case "jiraIssue":
				return ec.fieldContext_TaskEventLogData_jiraIssue(ctx, field)
			case "jiraLink":
				return ec.fieldContext_TaskEventLogData_jiraLink(ctx, field)
			case "priority":
				return ec.fieldContext_TaskEventLogData_priority(ctx, field)
			case "status":
				return ec.fieldContext_TaskEventLogData_status(ctx, field)
			case "timestamp":
				return ec.fieldContext_TaskEventLogData_timestamp(ctx, field)
			case "userId":
				return ec.fieldContext_TaskEventLogData_userId(ctx, field)
			case "blockedOn":
				return ec.fieldContext_TaskEventLogData_blockedOn(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogEntry_eventType,
		func(ctx context.Context) (any, error) {
			return obj.EventType, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_eventType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogEntry_processedAt,
		func(ctx context.Context) (any, error) {
			return obj.ProcessedAt, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_processedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogEntry_resourceId,
		func(ctx context.Context) (any, error) {
			return obj.ResourceId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_resourceId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogEntry_resourceType,
		func(ctx context.Context) (any, error) {
			return obj.ResourceType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskEventLogEntry_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskFiles_fileCount(ctx context.Context, field graphql.CollectedField, obj *TaskFiles) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskFiles_fileCount,
		func(ctx context.Context) (any, error) {
			return obj.FileCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskFiles_fileCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskFiles_groupedFiles(ctx context.Context, field graphql.CollectedField, obj *TaskFiles) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskFiles_groupedFiles,
		func(ctx context.Context) (any, error) {
			return obj.GroupedFiles, nil
		},
		nil,
		ec.marshalNGroupedFiles2githubcomevergreencievergreengraphqlGroupedFiles,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskFiles_groupedFiles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "files":
				return ec.fieldContext_GroupedFiles_files(ctx, field)
			case "taskName":
				return ec.fieldContext_GroupedFiles_taskName(ctx, field)
			case "taskId":
				return ec.fieldContext_GroupedFiles_taskId(ctx, field)
			case "execution":
				return ec.fieldContext_GroupedFiles_execution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedFiles", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_tasks(ctx context.Context, field graphql.CollectedField, obj *TaskHistory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskHistory_tasks,
		func(ctx context.Context) (any, error) {
			return obj.Tasks, nil
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskHistory_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_pagination(ctx context.Context, field graphql.CollectedField, obj *TaskHistory) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskHistory_pagination,
		func(ctx context.Context) (any, error) {
			return obj.Pagination, nil
		},
		nil,
		ec.marshalNTaskHistoryPagination2githubcomevergreencievergreengraphqlTaskHistoryPagination,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskHistory_pagination(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mostRecentTaskOrder":
				return ec.fieldContext_TaskHistoryPagination_mostRecentTaskOrder(ctx, field)
			case "oldestTaskOrder":
				return ec.fieldContext_TaskHistoryPagination_oldestTaskOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistoryPagination", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistoryPagination_mostRecentTaskOrder(ctx context.Context, field graphql.CollectedField, obj *TaskHistoryPagination) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskHistoryPagination_mostRecentTaskOrder,
		func(ctx context.Context) (any, error) {
			return obj.MostRecentTaskOrder, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskHistoryPagination_mostRecentTaskOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistoryPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistoryPagination_oldestTaskOrder(ctx context.Context, field graphql.CollectedField, obj *TaskHistoryPagination) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskHistoryPagination_oldestTaskOrder,
		func(ctx context.Context) (any, error) {
			return obj.OldestTaskOrder, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskHistoryPagination_oldestTaskOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistoryPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.TaskInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskInfo_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalOID2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskInfo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.TaskInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskInfo_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskInfo_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxTasksPerVersion(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxTasksPerVersion,
		func(ctx context.Context) (any, error) {
			return obj.MaxTasksPerVersion, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxTasksPerVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxIncludesPerVersion(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxIncludesPerVersion,
		func(ctx context.Context) (any, error) {
			return obj.MaxIncludesPerVersion, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxIncludesPerVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxHourlyPatchTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxHourlyPatchTasks,
		func(ctx context.Context) (any, error) {
			return obj.MaxHourlyPatchTasks, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxHourlyPatchTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxPendingGeneratedTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxPendingGeneratedTasks,
		func(ctx context.Context) (any, error) {
			return obj.MaxPendingGeneratedTasks, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxPendingGeneratedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxGenerateTaskJSONSize(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxGenerateTaskJSONSize,
		func(ctx context.Context) (any, error) {
			return obj.MaxGenerateTaskJSONSize, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxGenerateTaskJSONSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxConcurrentLargeParserProjectTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxConcurrentLargeParserProjectTasks,
		func(ctx context.Context) (any, error) {
			return obj.MaxConcurrentLargeParserProjectTasks, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxConcurrentLargeParserProjectTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxDegradedModeConcurrentLargeParserProjectTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxDegradedModeConcurrentLargeParserProjectTasks,
		func(ctx context.Context) (any, error) {
			return obj.MaxDegradedModeConcurrentLargeParserProjectTasks, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxDegradedModeConcurrentLargeParserProjectTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxDegradedModeParserProjectSize(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxDegradedModeParserProjectSize,
		func(ctx context.Context) (any, error) {
			return obj.MaxDegradedModeParserProjectSize, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxDegradedModeParserProjectSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxParserProjectSize(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxParserProjectSize,
		func(ctx context.Context) (any, error) {
			return obj.MaxParserProjectSize, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxParserProjectSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxExecTimeoutSecs(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxExecTimeoutSecs,
		func(ctx context.Context) (any, error) {
			return obj.MaxExecTimeoutSecs, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxExecTimeoutSecs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxTaskExecution(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxTaskExecution,
		func(ctx context.Context) (any, error) {
			return obj.MaxTaskExecution, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxTaskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxDailyAutomaticRestarts(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLimitsConfig_maxDailyAutomaticRestarts,
		func(ctx context.Context) (any, error) {
			return obj.MaxDailyAutomaticRestarts, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxDailyAutomaticRestarts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_agentLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogLinks_agentLogLink,
		func(ctx context.Context) (any, error) {
			return obj.AgentLogLink, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLogLinks_agentLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_allLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogLinks_allLogLink,
		func(ctx context.Context) (any, error) {
			return obj.AllLogLink, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLogLinks_allLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_systemLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogLinks_systemLogLink,
		func(ctx context.Context) (any, error) {
			return obj.SystemLogLink, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLogLinks_systemLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_taskLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogLinks_taskLogLink,
		func(ctx context.Context) (any, error) {
			return obj.TaskLogLink, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskLogLinks_taskLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_agentLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogs_agentLogs,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TaskLogs().AgentLogs(ctx, obj)
		},
		nil,
		ec.marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskLogs_agentLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_allLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogs_allLogs,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TaskLogs().AllLogs(ctx, obj)
		},
		nil,
		ec.marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskLogs_allLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_eventLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogs_eventLogs,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TaskLogs().EventLogs(ctx, obj)
		},
		nil,
		ec.marshalNTaskEventLogEntry2githubcomevergreencievergreenrestmodelTaskAPIEventLogEntry,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskLogs_eventLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_TaskEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_TaskEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_TaskEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_TaskEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_TaskEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_TaskEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_execution(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogs_execution,
		func(ctx context.Context) (any, error) {
			return obj.Execution, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskLogs_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_systemLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogs_systemLogs,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TaskLogs().SystemLogs(ctx, obj)
		},
		nil,
		ec.marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskLogs_systemLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_taskId(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogs_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskLogs_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_taskLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskLogs_taskLogs,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TaskLogs().TaskLogs(ctx, obj)
		},
		nil,
		ec.marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskLogs_taskLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_assignmentType(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskOwnerTeam_assignmentType,
		func(ctx context.Context) (any, error) {
			return obj.AssignmentType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_assignmentType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_messages(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskOwnerTeam_messages,
		func(ctx context.Context) (any, error) {
			return obj.Messages, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_messages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_teamName(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskOwnerTeam_teamName,
		func(ctx context.Context) (any, error) {
			return obj.TeamName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_teamName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_jiraProject(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskOwnerTeam_jiraProject,
		func(ctx context.Context) (any, error) {
			return obj.JiraProject, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_jiraProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_id(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueDistro_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_hostCount(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueDistro_hostCount,
		func(ctx context.Context) (any, error) {
			return obj.HostCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_hostCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_taskCount(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueDistro_taskCount,
		func(ctx context.Context) (any, error) {
			return obj.TaskCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_taskCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_id(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_buildVariant,
		func(ctx context.Context) (any, error) {
			return obj.BuildVariant, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_expectedDuration(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_expectedDuration,
		func(ctx context.Context) (any, error) {
			return obj.ExpectedDuration, nil
		},
		nil,
		ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_expectedDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_priority(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_priority,
		func(ctx context.Context) (any, error) {
			return obj.Priority, nil
		},
		nil,
		ec.marshalNInt2int64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_priority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_project(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_project,
		func(ctx context.Context) (any, error) {
			return obj.Project, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_projectIdentifier,
		func(ctx context.Context) (any, error) {
			return obj.ProjectIdentifier, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_requester(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_requester,
		func(ctx context.Context) (any, error) {
			return obj.Requester, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_activatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_activatedBy,
		func(ctx context.Context) (any, error) {
			return obj.ActivatedBy, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_activatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_revision(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_revision,
		func(ctx context.Context) (any, error) {
			return obj.Revision, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_version(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskQueueItem_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskQueueItem_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_patchAlias(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskSpecifier_patchAlias,
		func(ctx context.Context) (any, error) {
			return obj.PatchAlias, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskSpecifier_patchAlias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_taskRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskSpecifier_taskRegex,
		func(ctx context.Context) (any, error) {
			return obj.TaskRegex, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskSpecifier_taskRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_variantRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskSpecifier_variantRegex,
		func(ctx context.Context) (any, error) {
			return obj.VariantRegex, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskSpecifier_variantRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_counts(ctx context.Context, field graphql.CollectedField, obj *task.TaskStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskStats_counts,
		func(ctx context.Context) (any, error) {
			return obj.Counts, nil
		},
		nil,
		ec.marshalOStatusCount2githubcomevergreencievergreenmodeltaskStatusCount,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskStats_counts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_StatusCount_count(ctx, field)
			case "status":
				return ec.fieldContext_StatusCount_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_eta(ctx context.Context, field graphql.CollectedField, obj *task.TaskStats) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskStats_eta,
		func(ctx context.Context) (any, error) {
			return obj.ETA, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TaskStats_eta(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_testResults(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskTestResult_testResults,
		func(ctx context.Context) (any, error) {
			return obj.TestResults, nil
		},
		nil,
		ec.marshalNTestResult2githubcomevergreencievergreenrestmodelAPITest,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskTestResult_testResults(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TestResult_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_TestResult_baseStatus(ctx, field)
			case "duration":
				return ec.fieldContext_TestResult_duration(ctx, field)
			case "endTime":
				return ec.fieldContext_TestResult_endTime(ctx, field)
			case "execution":
				return ec.fieldContext_TestResult_execution(ctx, field)
			case "exitCode":
				return ec.fieldContext_TestResult_exitCode(ctx, field)
			case "groupID":
				return ec.fieldContext_TestResult_groupID(ctx, field)
			case "logs":
				return ec.fieldContext_TestResult_logs(ctx, field)
			case "startTime":
				return ec.fieldContext_TestResult_startTime(ctx, field)
			case "status":
				return ec.fieldContext_TestResult_status(ctx, field)
			case "taskId":
				return ec.fieldContext_TestResult_taskId(ctx, field)
			case "testFile":
				return ec.fieldContext_TestResult_testFile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskTestResult_totalTestCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalTestCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskTestResult_totalTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_filteredTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskTestResult_filteredTestCount,
		func(ctx context.Context) (any, error) {
			return obj.FilteredTestCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskTestResult_filteredTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_execution(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskTestResultSample_execution,
		func(ctx context.Context) (any, error) {
			return obj.Execution, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_matchingFailedTestNames(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskTestResultSample_matchingFailedTestNames,
		func(ctx context.Context) (any, error) {
			return obj.MatchingFailedTestNames, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_matchingFailedTestNames(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_taskId(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskTestResultSample_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TaskTestResultSample_totalTestCount,
		func(ctx context.Context) (any, error) {
			return obj.TotalTestCount, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_totalTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_lineNum(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestLog_lineNum,
		func(ctx context.Context) (any, error) {
			return obj.LineNum, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestLog_lineNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_url(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestLog_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestLog_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_urlParsley(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestLog_urlParsley,
		func(ctx context.Context) (any, error) {
			return obj.URLParsley, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestLog_urlParsley(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_urlRaw(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestLog_urlRaw,
		func(ctx context.Context) (any, error) {
			return obj.URLRaw, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestLog_urlRaw(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_renderingType(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestLog_renderingType,
		func(ctx context.Context) (any, error) {
			return obj.RenderingType, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestLog_renderingType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_testName(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestLog_testName,
		func(ctx context.Context) (any, error) {
			return obj.TestName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestLog_testName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_version(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestLog_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalOInt2int32,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestLog_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_id(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TestResult_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_baseStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_baseStatus,
		func(ctx context.Context) (any, error) {
			return obj.BaseStatus, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestResult_baseStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_duration(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_duration,
		func(ctx context.Context) (any, error) {
			return obj.Duration, nil
		},
		nil,
		ec.marshalOFloat2float64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestResult_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_endTime(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_endTime,
		func(ctx context.Context) (any, error) {
			return obj.EndTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestResult_endTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_execution(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_execution,
		func(ctx context.Context) (any, error) {
			return obj.Execution, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestResult_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_exitCode(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_exitCode,
		func(ctx context.Context) (any, error) {
			return obj.ExitCode, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestResult_exitCode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_groupID(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_groupID,
		func(ctx context.Context) (any, error) {
			return obj.GroupID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestResult_groupID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_logs(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_logs,
		func(ctx context.Context) (any, error) {
			return obj.Logs, nil
		},
		nil,
		ec.marshalNTestLog2githubcomevergreencievergreenrestmodelTestLogs,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TestResult_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lineNum":
				return ec.fieldContext_TestLog_lineNum(ctx, field)
			case "url":
				return ec.fieldContext_TestLog_url(ctx, field)
			case "urlParsley":
				return ec.fieldContext_TestLog_urlParsley(ctx, field)
			case "urlRaw":
				return ec.fieldContext_TestLog_urlRaw(ctx, field)
			case "renderingType":
				return ec.fieldContext_TestLog_renderingType(ctx, field)
			case "testName":
				return ec.fieldContext_TestLog_testName(ctx, field)
			case "version":
				return ec.fieldContext_TestLog_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestLog", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_startTime,
		func(ctx context.Context) (any, error) {
			return obj.StartTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestResult_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_status(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TestResult_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_taskId(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_taskId,
		func(ctx context.Context) (any, error) {
			return obj.TaskID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestResult_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_testFile(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestResult_testFile,
		func(ctx context.Context) (any, error) {
			return obj.TestFile, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TestResult_testFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestSelectionConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APITestSelectionConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestSelectionConfig_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TestSelectionConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestSelectionConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestSelectionSettings_allowed(ctx context.Context, field graphql.CollectedField, obj *model.APITestSelectionSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestSelectionSettings_allowed,
		func(ctx context.Context) (any, error) {
			return obj.Allowed, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestSelectionSettings_allowed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestSelectionSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestSelectionSettings_defaultEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITestSelectionSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TestSelectionSettings_defaultEnabled,
		func(ctx context.Context) (any, error) {
			return obj.DefaultEnabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TestSelectionSettings_defaultEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestSelectionSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_assignedTeam(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TicketFields_assignedTeam,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TicketFields().AssignedTeam(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TicketFields_assignedTeam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_assigneeDisplayName(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TicketFields_assigneeDisplayName,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TicketFields().AssigneeDisplayName(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TicketFields_assigneeDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_created(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TicketFields_created,
		func(ctx context.Context) (any, error) {
			return obj.Created, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TicketFields_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_resolutionName(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TicketFields_resolutionName,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TicketFields().ResolutionName(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TicketFields_resolutionName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_status(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TicketFields_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNJiraStatus2githubcomevergreencievergreenthirdpartyJiraStatus,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TicketFields_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JiraStatus_id(ctx, field)
			case "name":
				return ec.fieldContext_JiraStatus_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_summary(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TicketFields_summary,
		func(ctx context.Context) (any, error) {
			return obj.Summary, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TicketFields_summary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_updated(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TicketFields_updated,
		func(ctx context.Context) (any, error) {
			return obj.Updated, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TicketFields_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Toolchain_name(ctx context.Context, field graphql.CollectedField, obj *model.APIToolchain) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Toolchain_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Toolchain_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Toolchain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Toolchain_path(ctx context.Context, field graphql.CollectedField, obj *model.APIToolchain) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Toolchain_path,
		func(ctx context.Context) (any, error) {
			return obj.Path, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Toolchain_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Toolchain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Toolchain_version(ctx context.Context, field graphql.CollectedField, obj *model.APIToolchain) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Toolchain_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Toolchain_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Toolchain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerSettings_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APITracerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TracerSettings_enabled,
		func(ctx context.Context) (any, error) {
			return obj.Enabled, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TracerSettings_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerSettings_collectorEndpoint(ctx context.Context, field graphql.CollectedField, obj *model.APITracerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TracerSettings_collectorEndpoint,
		func(ctx context.Context) (any, error) {
			return obj.CollectorEndpoint, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TracerSettings_collectorEndpoint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerSettings_collectorInternalEndpoint(ctx context.Context, field graphql.CollectedField, obj *model.APITracerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TracerSettings_collectorInternalEndpoint,
		func(ctx context.Context) (any, error) {
			return obj.CollectorInternalEndpoint, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TracerSettings_collectorInternalEndpoint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TracerSettings_collectorAPIKey(ctx context.Context, field graphql.CollectedField, obj *model.APITracerSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TracerSettings_collectorAPIKey,
		func(ctx context.Context) (any, error) {
			return obj.CollectorAPIKey, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TracerSettings_collectorAPIKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TracerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TriggerAlias_alias,
		func(ctx context.Context) (any, error) {
			return obj.Alias, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TriggerAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_buildVariantRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TriggerAlias_buildVariantRegex,
		func(ctx context.Context) (any, error) {
			return obj.BuildVariantRegex, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TriggerAlias_buildVariantRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_configFile(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TriggerAlias_configFile,
		func(ctx context.Context) (any, error) {
			return obj.ConfigFile, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TriggerAlias_configFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_dateCutoff(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TriggerAlias_dateCutoff,
		func(ctx context.Context) (any, error) {
			return obj.DateCutoff, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TriggerAlias_dateCutoff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_level(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TriggerAlias_level,
		func(ctx context.Context) (any, error) {
			return obj.Level, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TriggerAlias_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_project(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TriggerAlias_project,
		func(ctx context.Context) (any, error) {
			return obj.Project, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TriggerAlias_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_status(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TriggerAlias_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TriggerAlias_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_taskRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TriggerAlias_taskRegex,
		func(ctx context.Context) (any, error) {
			return obj.TaskRegex, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TriggerAlias_taskRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_unscheduleDownstreamVersions(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TriggerAlias_unscheduleDownstreamVersions,
		func(ctx context.Context) (any, error) {
			return obj.UnscheduleDownstreamVersions, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TriggerAlias_unscheduleDownstreamVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerConfig_generateTaskDistro(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TriggerConfig_generateTaskDistro,
		func(ctx context.Context) (any, error) {
			return obj.GenerateTaskDistro, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TriggerConfig_generateTaskDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_betaFeatures(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_betaFeatures,
		func(ctx context.Context) (any, error) {
			return obj.BetaFeatures, nil
		},
		nil,
		ec.marshalNBetaFeatures2githubcomevergreencievergreenrestmodelAPIBetaFeatures,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UIConfig_betaFeatures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceWaterfallEnabled":
				return ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
			case "parsleyAIEnabled":
				return ec.fieldContext_BetaFeatures_parsleyAIEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BetaFeatures", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_url,
		func(ctx context.Context) (any, error) {
			return obj.Url, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_helpUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_helpUrl,
		func(ctx context.Context) (any, error) {
			return obj.HelpUrl, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_helpUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_uiv2Url(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_uiv2Url,
		func(ctx context.Context) (any, error) {
			return obj.UIv2Url, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_uiv2Url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_parsleyUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_parsleyUrl,
		func(ctx context.Context) (any, error) {
			return obj.ParsleyUrl, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_parsleyUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_httpListenAddr(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_httpListenAddr,
		func(ctx context.Context) (any, error) {
			return obj.HttpListenAddr, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_httpListenAddr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_secret,
		func(ctx context.Context) (any, error) {
			return obj.Secret, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_defaultProject(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_defaultProject,
		func(ctx context.Context) (any, error) {
			return obj.DefaultProject, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UIConfig_defaultProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_corsOrigins(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_corsOrigins,
		func(ctx context.Context) (any, error) {
			return obj.CORSOrigins, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UIConfig_corsOrigins(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_fileStreamingContentTypes(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_fileStreamingContentTypes,
		func(ctx context.Context) (any, error) {
			return obj.FileStreamingContentTypes, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UIConfig_fileStreamingContentTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_loginDomain(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_loginDomain,
		func(ctx context.Context) (any, error) {
			return obj.LoginDomain, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_loginDomain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_userVoice(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_userVoice,
		func(ctx context.Context) (any, error) {
			return obj.UserVoice, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_userVoice(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_csrfKey(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_csrfKey,
		func(ctx context.Context) (any, error) {
			return obj.CsrfKey, nil
		},
		func(ctx context.Context, next graphql.Resolver) graphql.Resolver {
			directive0 := next

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RequireAdmin == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireAdmin is not implemented")
				}
				return ec.directives.RequireAdmin(ctx, obj, directive0)
			}

			next = directive1
			return next
		},
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_csrfKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_cacheTemplates(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_cacheTemplates,
		func(ctx context.Context) (any, error) {
			return obj.CacheTemplates, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_cacheTemplates(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_stagingEnvironment(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UIConfig_stagingEnvironment,
		func(ctx context.Context) (any, error) {
			return obj.StagingEnvironment, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UIConfig_stagingEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateBetaFeaturesPayload_betaFeatures(ctx context.Context, field graphql.CollectedField, obj *UpdateBetaFeaturesPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpdateBetaFeaturesPayload_betaFeatures,
		func(ctx context.Context) (any, error) {
			return obj.BetaFeatures, nil
		},
		nil,
		ec.marshalOBetaFeatures2githubcomevergreencievergreenrestmodelAPIBetaFeatures,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UpdateBetaFeaturesPayload_betaFeatures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateBetaFeaturesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceWaterfallEnabled":
				return ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
			case "parsleyAIEnabled":
				return ec.fieldContext_BetaFeatures_parsleyAIEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BetaFeatures", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateParsleySettingsPayload_parsleySettings(ctx context.Context, field graphql.CollectedField, obj *UpdateParsleySettingsPayload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpdateParsleySettingsPayload_parsleySettings,
		func(ctx context.Context) (any, error) {
			return obj.ParsleySettings, nil
		},
		nil,
		ec.marshalOParsleySettings2githubcomevergreencievergreenrestmodelAPIParsleySettings,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UpdateParsleySettingsPayload_parsleySettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateParsleySettingsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sectionsEnabled":
				return ec.fieldContext_ParsleySettings_sectionsEnabled(ctx, field)
			case "jumpToFailingLineEnabled":
				return ec.fieldContext_ParsleySettings_jumpToFailingLineEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleySettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_owner(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpstreamProject_owner,
		func(ctx context.Context) (any, error) {
			return obj.Owner, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpstreamProject_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_project(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpstreamProject_project,
		func(ctx context.Context) (any, error) {
			return obj.Project, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpstreamProject_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_repo(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpstreamProject_repo,
		func(ctx context.Context) (any, error) {
			return obj.Repo, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpstreamProject_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_resourceID(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpstreamProject_resourceID,
		func(ctx context.Context) (any, error) {
			return obj.ResourceID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpstreamProject_resourceID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_revision(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpstreamProject_revision,
		func(ctx context.Context) (any, error) {
			return obj.Revision, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpstreamProject_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_task(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpstreamProject_task,
		func(ctx context.Context) (any, error) {
			return obj.Task, nil
		},
		nil,
		ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UpstreamProject_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_triggerID(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpstreamProject_triggerID,
		func(ctx context.Context) (any, error) {
			return obj.TriggerID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpstreamProject_triggerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_triggerType(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpstreamProject_triggerType,
		func(ctx context.Context) (any, error) {
			return obj.TriggerType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UpstreamProject_triggerType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_version(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UpstreamProject_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UpstreamProject_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UseSpruceOptions_spruceV1(ctx context.Context, field graphql.CollectedField, obj *model.APIUseSpruceOptions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UseSpruceOptions_spruceV1,
		func(ctx context.Context) (any, error) {
			return obj.SpruceV1, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UseSpruceOptions_spruceV1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UseSpruceOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_betaFeatures(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_betaFeatures,
		func(ctx context.Context) (any, error) {
			return obj.BetaFeatures, nil
		},
		nil,
		ec.marshalNBetaFeatures2githubcomevergreencievergreenrestmodelAPIBetaFeatures,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_betaFeatures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceWaterfallEnabled":
				return ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
			case "parsleyAIEnabled":
				return ec.fieldContext_BetaFeatures_parsleyAIEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BetaFeatures", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_emailAddress(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_emailAddress,
		func(ctx context.Context) (any, error) {
			return obj.EmailAddress, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_emailAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_parsleyFilters(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_parsleyFilters,
		func(ctx context.Context) (any, error) {
			return obj.ParsleyFilters, nil
		},
		nil,
		ec.marshalNParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_parsleyFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "caseSensitive":
				return ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
			case "description":
				return ec.fieldContext_ParsleyFilter_description(ctx, field)
			case "exactMatch":
				return ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
			case "expression":
				return ec.fieldContext_ParsleyFilter_expression(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleyFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_parsleySettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_parsleySettings,
		func(ctx context.Context) (any, error) {
			return obj.ParsleySettings, nil
		},
		nil,
		ec.marshalNParsleySettings2githubcomevergreencievergreenrestmodelAPIParsleySettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_parsleySettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sectionsEnabled":
				return ec.fieldContext_ParsleySettings_sectionsEnabled(ctx, field)
			case "jumpToFailingLineEnabled":
				return ec.fieldContext_ParsleySettings_jumpToFailingLineEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleySettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_patches(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_patches,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.User().Patches(ctx, obj, fc.Args["patchesInput"].(PatchesInput))
		},
		nil,
		ec.marshalNPatches2githubcomevergreencievergreengraphqlPatches,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_patches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredPatchCount":
				return ec.fieldContext_Patches_filteredPatchCount(ctx, field)
			case "patches":
				return ec.fieldContext_Patches_patches(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patches", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_patches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_permissions(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_permissions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().Permissions(ctx, obj)
		},
		nil,
		ec.marshalNPermissions2githubcomevergreencievergreengraphqlPermissions,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_permissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canCreateDistro":
				return ec.fieldContext_Permissions_canCreateDistro(ctx, field)
			case "canCreateProject":
				return ec.fieldContext_Permissions_canCreateProject(ctx, field)
			case "canEditAdminSettings":
				return ec.fieldContext_Permissions_canEditAdminSettings(ctx, field)
			case "distroPermissions":
				return ec.fieldContext_Permissions_distroPermissions(ctx, field)
			case "projectPermissions":
				return ec.fieldContext_Permissions_projectPermissions(ctx, field)
			case "repoPermissions":
				return ec.fieldContext_Permissions_repoPermissions(ctx, field)
			case "userId":
				return ec.fieldContext_Permissions_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Permissions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_settings(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_settings,
		func(ctx context.Context) (any, error) {
			return obj.Settings, nil
		},
		nil,
		ec.marshalNUserSettings2githubcomevergreencievergreenrestmodelAPIUserSettings,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_settings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "githubUser":
				return ec.fieldContext_UserSettings_githubUser(ctx, field)
			case "notifications":
				return ec.fieldContext_UserSettings_notifications(ctx, field)
			case "region":
				return ec.fieldContext_UserSettings_region(ctx, field)
			case "slackUsername":
				return ec.fieldContext_UserSettings_slackUsername(ctx, field)
			case "slackMemberId":
				return ec.fieldContext_UserSettings_slackMemberId(ctx, field)
			case "timezone":
				return ec.fieldContext_UserSettings_timezone(ctx, field)
			case "useSpruceOptions":
				return ec.fieldContext_UserSettings_useSpruceOptions(ctx, field)
			case "dateFormat":
				return ec.fieldContext_UserSettings_dateFormat(ctx, field)
			case "timeFormat":
				return ec.fieldContext_UserSettings_timeFormat(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_subscriptions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.User().Subscriptions(ctx, obj)
		},
		nil,
		ec.marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_User_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userId(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_User_userId,
		func(ctx context.Context) (any, error) {
			return obj.UserID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_User_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_api_key(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserConfig_api_key,
		func(ctx context.Context) (any, error) {
			return obj.APIKey, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserConfig_api_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_api_server_host(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserConfig_api_server_host,
		func(ctx context.Context) (any, error) {
			return obj.APIServerHost, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserConfig_api_server_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_ui_server_host(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserConfig_ui_server_host,
		func(ctx context.Context) (any, error) {
			return obj.UIServerHost, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserConfig_ui_server_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_user(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserConfig_user,
		func(ctx context.Context) (any, error) {
			return obj.User, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserConfig_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_oauth_issuer(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserConfig_oauth_issuer,
		func(ctx context.Context) (any, error) {
			return obj.OauthIssuer, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserConfig_oauth_issuer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_oauth_client_id(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserConfig_oauth_client_id,
		func(ctx context.Context) (any, error) {
			return obj.OauthClientID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserConfig_oauth_client_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_oauth_connector_id(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserConfig_oauth_connector_id,
		func(ctx context.Context) (any, error) {
			return obj.OauthConnectorID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_UserConfig_oauth_connector_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserServiceFlags_jwtTokenForCLIDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserServiceFlags_jwtTokenForCLIDisabled,
		func(ctx context.Context) (any, error) {
			return obj.JWTTokenForCLIDisabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UserServiceFlags_jwtTokenForCLIDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_githubUser(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserSettings_githubUser,
		func(ctx context.Context) (any, error) {
			return obj.GithubUser, nil
		},
		nil,
		ec.marshalOGithubUser2githubcomevergreencievergreenrestmodelAPIGithubUser,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UserSettings_githubUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastKnownAs":
				return ec.fieldContext_GithubUser_lastKnownAs(ctx, field)
			case "uid":
				return ec.fieldContext_GithubUser_uid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_notifications(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserSettings_notifications,
		func(ctx context.Context) (any, error) {
			return obj.Notifications, nil
		},
		nil,
		ec.marshalONotifications2githubcomevergreencievergreenrestmodelAPINotificationPreferences,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UserSettings_notifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildBreak":
				return ec.fieldContext_Notifications_buildBreak(ctx, field)
			case "buildBreakId":
				return ec.fieldContext_Notifications_buildBreakId(ctx, field)
			case "patchFinish":
				return ec.fieldContext_Notifications_patchFinish(ctx, field)
			case "patchFinishId":
				return ec.fieldContext_Notifications_patchFinishId(ctx, field)
			case "patchFirstFailure":
				return ec.fieldContext_Notifications_patchFirstFailure(ctx, field)
			case "patchFirstFailureId":
				return ec.fieldContext_Notifications_patchFirstFailureId(ctx, field)
			case "spawnHostExpiration":
				return ec.fieldContext_Notifications_spawnHostExpiration(ctx, field)
			case "spawnHostExpirationId":
				return ec.fieldContext_Notifications_spawnHostExpirationId(ctx, field)
			case "spawnHostOutcome":
				return ec.fieldContext_Notifications_spawnHostOutcome(ctx, field)
			case "spawnHostOutcomeId":
				return ec.fieldContext_Notifications_spawnHostOutcomeId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notifications", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_region(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserSettings_region,
		func(ctx context.Context) (any, error) {
			return obj.Region, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UserSettings_region(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_slackUsername(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserSettings_slackUsername,
		func(ctx context.Context) (any, error) {
			return obj.SlackUsername, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UserSettings_slackUsername(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_slackMemberId(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserSettings_slackMemberId,
		func(ctx context.Context) (any, error) {
			return obj.SlackMemberId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UserSettings_slackMemberId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_timezone(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserSettings_timezone,
		func(ctx context.Context) (any, error) {
			return obj.Timezone, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UserSettings_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_useSpruceOptions(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserSettings_useSpruceOptions,
		func(ctx context.Context) (any, error) {
			return obj.UseSpruceOptions, nil
		},
		nil,
		ec.marshalOUseSpruceOptions2githubcomevergreencievergreenrestmodelAPIUseSpruceOptions,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UserSettings_useSpruceOptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceV1":
				return ec.fieldContext_UseSpruceOptions_spruceV1(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UseSpruceOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_dateFormat(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserSettings_dateFormat,
		func(ctx context.Context) (any, error) {
			return obj.DateFormat, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UserSettings_dateFormat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_timeFormat(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_UserSettings_timeFormat,
		func(ctx context.Context) (any, error) {
			return obj.TimeFormat, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_UserSettings_timeFormat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VariantTask_name(ctx context.Context, field graphql.CollectedField, obj *model.VariantTask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VariantTask_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VariantTask_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VariantTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VariantTask_tasks(ctx context.Context, field graphql.CollectedField, obj *model.VariantTask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VariantTask_tasks,
		func(ctx context.Context) (any, error) {
			return obj.Tasks, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VariantTask_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VariantTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_id(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_activated(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_activated,
		func(ctx context.Context) (any, error) {
			return obj.Activated, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_author(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_author,
		func(ctx context.Context) (any, error) {
			return obj.Author, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_authorEmail(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_authorEmail,
		func(ctx context.Context) (any, error) {
			return obj.AuthorEmail, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_authorEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_baseTaskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_baseTaskStatuses,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().BaseTaskStatuses(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_baseTaskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_baseVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_baseVersion,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().BaseVersion(ctx, obj)
		},
		nil,
		ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_baseVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_branch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_branch,
		func(ctx context.Context) (any, error) {
			return obj.Branch, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_branch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_buildVariants(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_buildVariants,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Version().BuildVariants(ctx, obj, fc.Args["options"].(BuildVariantOptions))
		},
		nil,
		ec.marshalOGroupedBuildVariant2githubcomevergreencievergreengraphqlGroupedBuildVariant,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_buildVariants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_GroupedBuildVariant_displayName(ctx, field)
			case "tasks":
				return ec.fieldContext_GroupedBuildVariant_tasks(ctx, field)
			case "variant":
				return ec.fieldContext_GroupedBuildVariant_variant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedBuildVariant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_buildVariants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_buildVariantStats(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_buildVariantStats,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Version().BuildVariantStats(ctx, obj, fc.Args["options"].(BuildVariantOptions))
		},
		nil,
		ec.marshalOGroupedTaskStatusCount2githubcomevergreencievergreenmodeltaskGroupedTaskStatusCount,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_buildVariantStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_GroupedTaskStatusCount_displayName(ctx, field)
			case "statusCounts":
				return ec.fieldContext_GroupedTaskStatusCount_statusCounts(ctx, field)
			case "variant":
				return ec.fieldContext_GroupedTaskStatusCount_variant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedTaskStatusCount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_buildVariantStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_childVersions(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_childVersions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().ChildVersions(ctx, obj)
		},
		nil,
		ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_childVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_createTime,
		func(ctx context.Context) (any, error) {
			return obj.CreateTime, nil
		},
		nil,
		ec.marshalNTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_errors(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_errors,
		func(ctx context.Context) (any, error) {
			return obj.Errors, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_errors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_externalLinksForMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_externalLinksForMetadata,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().ExternalLinksForMetadata(ctx, obj)
		},
		nil,
		ec.marshalNExternalLinkForMetadata2githubcomevergreencievergreengraphqlExternalLinkForMetadata,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_externalLinksForMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_ExternalLinkForMetadata_url(ctx, field)
			case "displayName":
				return ec.fieldContext_ExternalLinkForMetadata_displayName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLinkForMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_finishTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_finishTime,
		func(ctx context.Context) (any, error) {
			return obj.FinishTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_finishTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_generatedTaskCounts(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_generatedTaskCounts,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().GeneratedTaskCounts(ctx, obj)
		},
		nil,
		ec.marshalNGeneratedTaskCountResults2githubcomevergreencievergreengraphqlGeneratedTaskCountResults,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_generatedTaskCounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariantName":
				return ec.fieldContext_GeneratedTaskCountResults_buildVariantName(ctx, field)
			case "taskName":
				return ec.fieldContext_GeneratedTaskCountResults_taskName(ctx, field)
			case "taskId":
				return ec.fieldContext_GeneratedTaskCountResults_taskId(ctx, field)
			case "estimatedTasks":
				return ec.fieldContext_GeneratedTaskCountResults_estimatedTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneratedTaskCountResults", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_gitTags(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_gitTags,
		func(ctx context.Context) (any, error) {
			return obj.GitTags, nil
		},
		nil,
		ec.marshalOGitTag2githubcomevergreencievergreenrestmodelAPIGitTag,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_gitTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tag":
				return ec.fieldContext_GitTag_tag(ctx, field)
			case "pusher":
				return ec.fieldContext_GitTag_pusher(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_ignored(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_ignored,
		func(ctx context.Context) (any, error) {
			return obj.Ignored, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_ignored(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_isPatch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_isPatch,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().IsPatch(ctx, obj)
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_isPatch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_manifest(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_manifest,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().Manifest(ctx, obj)
		},
		nil,
		ec.marshalOManifest2githubcomevergreencievergreengraphqlManifest,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_manifest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Manifest_id(ctx, field)
			case "branch":
				return ec.fieldContext_Manifest_branch(ctx, field)
			case "isBase":
				return ec.fieldContext_Manifest_isBase(ctx, field)
			case "moduleOverrides":
				return ec.fieldContext_Manifest_moduleOverrides(ctx, field)
			case "modules":
				return ec.fieldContext_Manifest_modules(ctx, field)
			case "project":
				return ec.fieldContext_Manifest_project(ctx, field)
			case "revision":
				return ec.fieldContext_Manifest_revision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Manifest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_message(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_message,
		func(ctx context.Context) (any, error) {
			return obj.Message, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_order(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_order,
		func(ctx context.Context) (any, error) {
			return obj.Order, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_parameters,
		func(ctx context.Context) (any, error) {
			return obj.Parameters, nil
		},
		nil,
		ec.marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_parameters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_patch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_patch,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().Patch(ctx, obj)
		},
		nil,
		ec.marshalOPatch2githubcomevergreencievergreenrestmodelAPIPatch,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_patch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "includedLocalModules":
				return ec.fieldContext_Patch_includedLocalModules(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "user":
				return ec.fieldContext_Patch_user(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_previousVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_previousVersion,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().PreviousVersion(ctx, obj)
		},
		nil,
		ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_previousVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_project(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_project,
		func(ctx context.Context) (any, error) {
			return obj.Project, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_projectIdentifier,
		func(ctx context.Context) (any, error) {
			return obj.ProjectIdentifier, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_projectMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_projectMetadata,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().ProjectMetadata(ctx, obj)
		},
		nil,
		ec.marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_projectMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "debugSpawnHostsDisabled":
				return ec.fieldContext_Project_debugSpawnHostsDisabled(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "testSelection":
				return ec.fieldContext_Project_testSelection(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_repo,
		func(ctx context.Context) (any, error) {
			return obj.Repo, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_requester(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_requester,
		func(ctx context.Context) (any, error) {
			return obj.Requester, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_revision(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_revision,
		func(ctx context.Context) (any, error) {
			return obj.Revision, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_startTime,
		func(ctx context.Context) (any, error) {
			return obj.StartTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_status(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_status,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().Status(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskCount(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_taskCount,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Version().TaskCount(ctx, obj, fc.Args["options"].(*TaskCountOptions))
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_taskCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_taskCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_tasks(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_tasks,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Version().Tasks(ctx, obj, fc.Args["options"].(TaskFilterOptions))
		},
		nil,
		ec.marshalNVersionTasks2githubcomevergreencievergreengraphqlVersionTasks,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_VersionTasks_count(ctx, field)
			case "data":
				return ec.fieldContext_VersionTasks_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionTasks", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_tasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_taskStatuses,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().TaskStatuses(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_taskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskStatusStats(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_taskStatusStats,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Version().TaskStatusStats(ctx, obj, fc.Args["options"].(BuildVariantOptions))
		},
		nil,
		ec.marshalOTaskStats2githubcomevergreencievergreenmodeltaskTaskStats,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_taskStatusStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "counts":
				return ec.fieldContext_TaskStats_counts(ctx, field)
			case "eta":
				return ec.fieldContext_TaskStats_eta(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_taskStatusStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_upstreamProject(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_upstreamProject,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().UpstreamProject(ctx, obj)
		},
		nil,
		ec.marshalOUpstreamProject2githubcomevergreencievergreengraphqlUpstreamProject,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_upstreamProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_UpstreamProject_owner(ctx, field)
			case "project":
				return ec.fieldContext_UpstreamProject_project(ctx, field)
			case "repo":
				return ec.fieldContext_UpstreamProject_repo(ctx, field)
			case "resourceID":
				return ec.fieldContext_UpstreamProject_resourceID(ctx, field)
			case "revision":
				return ec.fieldContext_UpstreamProject_revision(ctx, field)
			case "task":
				return ec.fieldContext_UpstreamProject_task(ctx, field)
			case "triggerID":
				return ec.fieldContext_UpstreamProject_triggerID(ctx, field)
			case "triggerType":
				return ec.fieldContext_UpstreamProject_triggerType(ctx, field)
			case "version":
				return ec.fieldContext_UpstreamProject_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpstreamProject", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_user(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_user,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().User(ctx, obj)
		},
		nil,
		ec.marshalNUser2githubcomevergreencievergreenrestmodelAPIDBUser,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_User_betaFeatures(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "emailAddress":
				return ec.fieldContext_User_emailAddress(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_User_parsleyFilters(ctx, field)
			case "parsleySettings":
				return ec.fieldContext_User_parsleySettings(ctx, field)
			case "patches":
				return ec.fieldContext_User_patches(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "subscriptions":
				return ec.fieldContext_User_subscriptions(ctx, field)
			case "userId":
				return ec.fieldContext_User_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_versionTiming(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_versionTiming,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().VersionTiming(ctx, obj)
		},
		nil,
		ec.marshalOVersionTiming2githubcomevergreencievergreengraphqlVersionTiming,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_versionTiming(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "makespan":
				return ec.fieldContext_VersionTiming_makespan(ctx, field)
			case "timeTaken":
				return ec.fieldContext_VersionTiming_timeTaken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionTiming", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_warnings(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_warnings,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().Warnings(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Version_warnings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_waterfallBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_waterfallBuilds,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Version().WaterfallBuilds(ctx, obj)
		},
		nil,
		ec.marshalOWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_waterfallBuilds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WaterfallBuild_id(ctx, field)
			case "activated":
				return ec.fieldContext_WaterfallBuild_activated(ctx, field)
			case "buildVariant":
				return ec.fieldContext_WaterfallBuild_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_WaterfallBuild_displayName(ctx, field)
			case "version":
				return ec.fieldContext_WaterfallBuild_version(ctx, field)
			case "tasks":
				return ec.fieldContext_WaterfallBuild_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_predictedCost(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Version_predictedCost,
		func(ctx context.Context) (any, error) {
			return obj.PredictedCost, nil
		},
		nil,
		ec.marshalOCost2githubcomevergreencievergreenmodelcostCost,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Version_predictedCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "onDemandEC2Cost":
				return ec.fieldContext_Cost_onDemandEC2Cost(ctx, field)
			case "adjustedEC2Cost":
				return ec.fieldContext_Cost_adjustedEC2Cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTasks_count(ctx context.Context, field graphql.CollectedField, obj *VersionTasks) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VersionTasks_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VersionTasks_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTasks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTasks_data(ctx context.Context, field graphql.CollectedField, obj *VersionTasks) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VersionTasks_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_VersionTasks_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTasks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskCost":
				return ec.fieldContext_Task_taskCost(ctx, field)
			case "predictedTaskCost":
				return ec.fieldContext_Task_predictedTaskCost(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "testSelectionEnabled":
				return ec.fieldContext_Task_testSelectionEnabled(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTiming_makespan(ctx context.Context, field graphql.CollectedField, obj *VersionTiming) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VersionTiming_makespan,
		func(ctx context.Context) (any, error) {
			return obj.Makespan, nil
		},
		nil,
		ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_VersionTiming_makespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTiming",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTiming_timeTaken(ctx context.Context, field graphql.CollectedField, obj *VersionTiming) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_VersionTiming_timeTaken,
		func(ctx context.Context) (any, error) {
			return obj.TimeTaken, nil
		},
		nil,
		ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_VersionTiming_timeTaken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTiming",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_id(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Volume_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_availabilityZone(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_availabilityZone,
		func(ctx context.Context) (any, error) {
			return obj.AvailabilityZone, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Volume_availabilityZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_createdBy,
		func(ctx context.Context) (any, error) {
			return obj.CreatedBy, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Volume_createdBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_creationTime,
		func(ctx context.Context) (any, error) {
			return obj.CreationTime, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Volume_creationTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_deviceName(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_deviceName,
		func(ctx context.Context) (any, error) {
			return obj.DeviceName, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Volume_deviceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Volume_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_expiration(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_expiration,
		func(ctx context.Context) (any, error) {
			return obj.Expiration, nil
		},
		nil,
		ec.marshalOTime2timeTime,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Volume_expiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_homeVolume(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_homeVolume,
		func(ctx context.Context) (any, error) {
			return obj.HomeVolume, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Volume_homeVolume(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_host(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_host,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Volume().Host(ctx, obj)
		},
		nil,
		ec.marshalOHost2githubcomevergreencievergreenrestmodelAPIHost,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Volume_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_hostID(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_hostID,
		func(ctx context.Context) (any, error) {
			return obj.HostID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Volume_hostID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_migrating(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_migrating,
		func(ctx context.Context) (any, error) {
			return obj.Migrating, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Volume_migrating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_noExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_noExpiration,
		func(ctx context.Context) (any, error) {
			return obj.NoExpiration, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Volume_noExpiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_size(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_size,
		func(ctx context.Context) (any, error) {
			return obj.Size, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Volume_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_type(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Volume_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Volume_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waterfall_flattenedVersions(ctx context.Context, field graphql.CollectedField, obj *Waterfall) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Waterfall_flattenedVersions,
		func(ctx context.Context) (any, error) {
			return obj.FlattenedVersions, nil
		},
		nil,
		ec.marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Waterfall_flattenedVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waterfall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waterfall_pagination(ctx context.Context, field graphql.CollectedField, obj *Waterfall) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Waterfall_pagination,
		func(ctx context.Context) (any, error) {
			return obj.Pagination, nil
		},
		nil,
		ec.marshalNWaterfallPagination2githubcomevergreencievergreengraphqlWaterfallPagination,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Waterfall_pagination(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waterfall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "activeVersionIds":
				return ec.fieldContext_WaterfallPagination_activeVersionIds(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_WaterfallPagination_hasNextPage(ctx, field)
			case "hasPrevPage":
				return ec.fieldContext_WaterfallPagination_hasPrevPage(ctx, field)
			case "mostRecentVersionOrder":
				return ec.fieldContext_WaterfallPagination_mostRecentVersionOrder(ctx, field)
			case "nextPageOrder":
				return ec.fieldContext_WaterfallPagination_nextPageOrder(ctx, field)
			case "prevPageOrder":
				return ec.fieldContext_WaterfallPagination_prevPageOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallPagination", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_id(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallBuild_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallBuild_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_activated(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallBuild_activated,
		func(ctx context.Context) (any, error) {
			return obj.Activated, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallBuild_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallBuild_buildVariant,
		func(ctx context.Context) (any, error) {
			return obj.BuildVariant, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallBuild_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_displayName(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallBuild_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallBuild_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_version(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallBuild_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallBuild_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_tasks(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallBuild_tasks,
		func(ctx context.Context) (any, error) {
			return obj.Tasks, nil
		},
		nil,
		ec.marshalNWaterfallTask2githubcomevergreencievergreenmodelWaterfallTask,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallBuild_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WaterfallTask_id(ctx, field)
			case "displayName":
				return ec.fieldContext_WaterfallTask_displayName(ctx, field)
			case "displayStatusCache":
				return ec.fieldContext_WaterfallTask_displayStatusCache(ctx, field)
			case "execution":
				return ec.fieldContext_WaterfallTask_execution(ctx, field)
			case "status":
				return ec.fieldContext_WaterfallTask_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_id(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallBuildVariant_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_builds(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallBuildVariant_builds,
		func(ctx context.Context) (any, error) {
			return obj.Builds, nil
		},
		nil,
		ec.marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_builds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WaterfallBuild_id(ctx, field)
			case "activated":
				return ec.fieldContext_WaterfallBuild_activated(ctx, field)
			case "buildVariant":
				return ec.fieldContext_WaterfallBuild_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_WaterfallBuild_displayName(ctx, field)
			case "version":
				return ec.fieldContext_WaterfallBuild_version(ctx, field)
			case "tasks":
				return ec.fieldContext_WaterfallBuild_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallBuildVariant_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_version(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallBuildVariant_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_activeVersionIds(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallPagination_activeVersionIds,
		func(ctx context.Context) (any, error) {
			return obj.ActiveVersionIds, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallPagination_activeVersionIds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallPagination_hasNextPage,
		func(ctx context.Context) (any, error) {
			return obj.HasNextPage, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallPagination_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_hasPrevPage(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallPagination_hasPrevPage,
		func(ctx context.Context) (any, error) {
			return obj.HasPrevPage, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallPagination_hasPrevPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_mostRecentVersionOrder(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallPagination_mostRecentVersionOrder,
		func(ctx context.Context) (any, error) {
			return obj.MostRecentVersionOrder, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallPagination_mostRecentVersionOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_nextPageOrder(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallPagination_nextPageOrder,
		func(ctx context.Context) (any, error) {
			return obj.NextPageOrder, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallPagination_nextPageOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_prevPageOrder(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallPagination_prevPageOrder,
		func(ctx context.Context) (any, error) {
			return obj.PrevPageOrder, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallPagination_prevPageOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_id(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallTask_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallTask_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_displayName(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallTask_displayName,
		func(ctx context.Context) (any, error) {
			return obj.DisplayName, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallTask_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_displayStatusCache(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallTask_displayStatusCache,
		func(ctx context.Context) (any, error) {
			return obj.DisplayStatusCache, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallTask_displayStatusCache(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_execution(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallTask_execution,
		func(ctx context.Context) (any, error) {
			return obj.Execution, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallTask_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_status(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallTask_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WaterfallTask_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallVersion_inactiveVersions(ctx context.Context, field graphql.CollectedField, obj *WaterfallVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallVersion_inactiveVersions,
		func(ctx context.Context) (any, error) {
			return obj.InactiveVersions, nil
		},
		nil,
		ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WaterfallVersion_inactiveVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallVersion_version(ctx context.Context, field graphql.CollectedField, obj *WaterfallVersion) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WaterfallVersion_version,
		func(ctx context.Context) (any, error) {
			return obj.Version, nil
		},
		nil,
		ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WaterfallVersion_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "user":
				return ec.fieldContext_Version_user(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			case "predictedCost":
				return ec.fieldContext_Version_predictedCost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_endpoint(ctx context.Context, field graphql.CollectedField, obj *model.APIWebHook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_endpoint,
		func(ctx context.Context) (any, error) {
			return obj.Endpoint, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_endpoint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIWebHook) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Webhook_secret,
		func(ctx context.Context) (any, error) {
			return obj.Secret, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Webhook_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookHeader_key(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookHeader) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookHeader_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookHeader_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookHeader",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookHeader_value(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookHeader) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookHeader_value,
		func(ctx context.Context) (any, error) {
			return obj.Value, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookHeader_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookHeader",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_headers(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookSubscriber_headers,
		func(ctx context.Context) (any, error) {
			return obj.Headers, nil
		},
		nil,
		ec.marshalNWebhookHeader2githubcomevergreencievergreenrestmodelAPIWebhookHeader,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_headers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_WebhookHeader_key(ctx, field)
			case "value":
				return ec.fieldContext_WebhookHeader_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookHeader", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookSubscriber_secret,
		func(ctx context.Context) (any, error) {
			return obj.Secret, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_url(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookSubscriber_url,
		func(ctx context.Context) (any, error) {
			return obj.URL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_retries(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookSubscriber_retries,
		func(ctx context.Context) (any, error) {
			return obj.Retries, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_retries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_minDelayMs(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookSubscriber_minDelayMs,
		func(ctx context.Context) (any, error) {
			return obj.MinDelayMS, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_minDelayMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_timeoutMs(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WebhookSubscriber_timeoutMs,
		func(ctx context.Context) (any, error) {
			return obj.TimeoutMS, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_timeoutMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationConfig_gitClone(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WorkstationConfig_gitClone,
		func(ctx context.Context) (any, error) {
			return obj.GitClone, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WorkstationConfig_gitClone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationConfig_setupCommands(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WorkstationConfig_setupCommands,
		func(ctx context.Context) (any, error) {
			return obj.SetupCommands, nil
		},
		nil,
		ec.marshalOWorkstationSetupCommand2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WorkstationConfig_setupCommands(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "command":
				return ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
			case "directory":
				return ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationSetupCommand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationSetupCommand_command(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationSetupCommand) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WorkstationSetupCommand_command,
		func(ctx context.Context) (any, error) {
			return obj.Command, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WorkstationSetupCommand_command(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationSetupCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationSetupCommand_directory(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationSetupCommand) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WorkstationSetupCommand_directory,
		func(ctx context.Context) (any, error) {
			return obj.Directory, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WorkstationSetupCommand_directory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationSetupCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAPIConfigInput(ctx context.Context, obj any) (model.APIapiConfig, error) {
	var it model.APIapiConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"httpListenAddr", "url", "corpUrl"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "httpListenAddr":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("httpListenAddr"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HttpListenAddr = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "corpUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("corpUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CorpURL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAWSAccountRoleMappingInput(ctx context.Context, obj any) (model.APIAWSAccountRoleMapping, error) {
	var it model.APIAWSAccountRoleMapping
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"account", "role"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "account":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("account"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Account = data
			} else if tmp == nil {
				it.Account = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Role = data
			} else if tmp == nil {
				it.Role = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAWSConfigInput(ctx context.Context, obj any) (model.APIAWSConfig, error) {
	var it model.APIAWSConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ec2Keys", "subnets", "parserProject", "persistentDNS", "defaultSecurityGroup", "allowedInstanceTypes", "alertableInstanceTypes", "allowedRegions", "maxVolumeSizePerUser", "pod", "accountRoles", "ipamPoolID", "elasticIPUsageRate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ec2Keys":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ec2Keys"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNEC2KeyInput2githubcomevergreencievergreenrestmodelAPIEC2Key(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal []model.APIEC2Key
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]model.APIEC2Key); ok {
				it.EC2Keys = data
			} else if tmp == nil {
				it.EC2Keys = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APIEC2Key`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "subnets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subnets"))
			data, err := ec.unmarshalNSubnetInput2githubcomevergreencievergreenrestmodelAPISubnet(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subnets = data
		case "parserProject":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parserProject"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOParserProjectS3ConfigInput2githubcomevergreencievergreenrestmodelAPIParserProjectS3Config(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIParserProjectS3Config
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIParserProjectS3Config); ok {
				it.ParserProject = data
			} else if tmp == nil {
				it.ParserProject = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIParserProjectS3Config`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "persistentDNS":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("persistentDNS"))
			data, err := ec.unmarshalOPersistentDNSConfigInput2githubcomevergreencievergreenrestmodelAPIPersistentDNSConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.PersistentDNS = data
		case "defaultSecurityGroup":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultSecurityGroup"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.DefaultSecurityGroup = data
			} else if tmp == nil {
				it.DefaultSecurityGroup = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "allowedInstanceTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedInstanceTypes"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowedInstanceTypes = data
		case "alertableInstanceTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertableInstanceTypes"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertableInstanceTypes = data
		case "allowedRegions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedRegions"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowedRegions = data
		case "maxVolumeSizePerUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxVolumeSizePerUser"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxVolumeSizePerUser = data
		case "pod":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pod"))
			data, err := ec.unmarshalOAWSPodConfigInput2githubcomevergreencievergreenrestmodelAPIAWSPodConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Pod = data
		case "accountRoles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountRoles"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNAWSAccountRoleMappingInput2githubcomevergreencievergreenrestmodelAPIAWSAccountRoleMapping(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal []model.APIAWSAccountRoleMapping
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]model.APIAWSAccountRoleMapping); ok {
				it.AccountRoles = data
			} else if tmp == nil {
				it.AccountRoles = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APIAWSAccountRoleMapping`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "ipamPoolID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ipamPoolID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IPAMPoolID = data
		case "elasticIPUsageRate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("elasticIPUsageRate"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ElasticIPUsageRate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAWSPodConfigInput(ctx context.Context, obj any) (model.APIAWSPodConfig, error) {
	var it model.APIAWSPodConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"role", "region", "ecs", "secretsManager"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Role = data
			} else if tmp == nil {
				it.Role = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "ecs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ecs"))
			data, err := ec.unmarshalOECSConfigInput2githubcomevergreencievergreenrestmodelAPIECSConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.ECS = data
		case "secretsManager":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretsManager"))
			data, err := ec.unmarshalOSecretsManagerConfigInput2githubcomevergreencievergreenrestmodelAPISecretsManagerConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.SecretsManager = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAWSVPCConfigInput(ctx context.Context, obj any) (model.APIAWSVPCConfig, error) {
	var it model.APIAWSVPCConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subnets", "securityGroups"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subnets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subnets"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subnets = data
		case "securityGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("securityGroups"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal []string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]string); ok {
				it.SecurityGroups = data
			} else if tmp == nil {
				it.SecurityGroups = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddFavoriteProjectInput(ctx context.Context, obj any) (AddFavoriteProjectInput, error) {
	var it AddFavoriteProjectInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAdminEventsInput(ctx context.Context, obj any) (AdminEventsInput, error) {
	var it AdminEventsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 10
	}

	fieldsInOrder := [...]string{"before", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "before":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAdminSettingsInput(ctx context.Context, obj any) (model.APIAdminSettings, error) {
	var it model.APIAdminSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"amboy", "amboyDB", "api", "authConfig", "banner", "bannerTheme", "buckets", "cedar", "configDir", "containerPools", "cost", "disabledGQLQueries", "domainName", "expansions", "fws", "graphite", "githubCheckRun", "githubOrgs", "githubPRCreatorOrg", "githubWebhookSecret", "hostInit", "hostJasper", "jira", "jiraNotifications", "kanopySSHKeyPath", "logPath", "loggerConfig", "notify", "oldestAllowedCLIVersion", "parameterStore", "perfMonitoringKanopyURL", "perfMonitoringURL", "podLifecycle", "pprofPort", "projectCreation", "providers", "releaseMode", "repotracker", "runtimeEnvironments", "scheduler", "serviceFlags", "shutdownWaitSeconds", "singleTaskDistro", "slack", "sleepSchedule", "spawnhost", "splunk", "ssh", "taskLimits", "testSelection", "tracer", "triggers", "ui"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "amboy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amboy"))
			data, err := ec.unmarshalOAmboyConfigInput2githubcomevergreencievergreenrestmodelAPIAmboyConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amboy = data
		case "amboyDB":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amboyDB"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOAmboyDBConfigInput2githubcomevergreencievergreenrestmodelAPIAmboyDBConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIAmboyDBConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIAmboyDBConfig); ok {
				it.AmboyDB = data
			} else if tmp == nil {
				it.AmboyDB = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIAmboyDBConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "api":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("api"))
			data, err := ec.unmarshalOAPIConfigInput2githubcomevergreencievergreenrestmodelAPIapiConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Api = data
		case "authConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authConfig"))
			data, err := ec.unmarshalOAuthConfigInput2githubcomevergreencievergreenrestmodelAPIAuthConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthConfig = data
		case "banner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("banner"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Banner = data
		case "bannerTheme":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bannerTheme"))
			data, err := ec.unmarshalOBannerTheme2githubcomevergreencievergreenBannerTheme(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AdminSettingsInput().BannerTheme(ctx, &it, data); err != nil {
				return it, err
			}
		case "buckets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buckets"))
			data, err := ec.unmarshalOBucketsConfigInput2githubcomevergreencievergreenrestmodelAPIBucketsConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Buckets = data
		case "cedar":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cedar"))
			data, err := ec.unmarshalOCedarConfigInput2githubcomevergreencievergreenrestmodelAPICedarConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cedar = data
		case "configDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configDir"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigDir = data
		case "containerPools":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerPools"))
			data, err := ec.unmarshalOContainerPoolsConfigInput2githubcomevergreencievergreenrestmodelAPIContainerPoolsConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerPools = data
		case "cost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cost"))
			data, err := ec.unmarshalOCostConfigInput2githubcomevergreencievergreenrestmodelAPICostConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cost = data
		case "disabledGQLQueries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabledGQLQueries"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisabledGQLQueries = data
		case "domainName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("domainName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DomainName = data
		case "expansions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expansions"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expansions = data
		case "fws":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fws"))
			data, err := ec.unmarshalOFWSConfigInput2githubcomevergreencievergreenrestmodelAPIFWSConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.FWS = data
		case "graphite":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("graphite"))
			data, err := ec.unmarshalOGraphiteConfigInput2githubcomevergreencievergreenrestmodelAPIGraphiteConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Graphite = data
		case "githubCheckRun":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubCheckRun"))
			data, err := ec.unmarshalOGitHubCheckRunConfigInput2githubcomevergreencievergreenrestmodelAPIGitHubCheckRunConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubCheckRun = data
		case "githubOrgs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubOrgs"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubOrgs = data
		case "githubPRCreatorOrg":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPRCreatorOrg"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubPRCreatorOrg = data
		case "githubWebhookSecret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubWebhookSecret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.GithubWebhookSecret = data
			} else if tmp == nil {
				it.GithubWebhookSecret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "hostInit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostInit"))
			data, err := ec.unmarshalOHostInitConfigInput2githubcomevergreencievergreenrestmodelAPIHostInitConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostInit = data
		case "hostJasper":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostJasper"))
			data, err := ec.unmarshalOHostJasperConfigInput2githubcomevergreencievergreenrestmodelAPIHostJasperConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostJasper = data
		case "jira":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jira"))
			data, err := ec.unmarshalOJiraConfigInput2githubcomevergreencievergreenrestmodelAPIJiraConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Jira = data
		case "jiraNotifications":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jiraNotifications"))
			data, err := ec.unmarshalOJiraNotificationsConfigInput2githubcomevergreencievergreenrestmodelAPIJIRANotificationsConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.JIRANotifications = data
		case "kanopySSHKeyPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kanopySSHKeyPath"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.KanopySSHKeyPath = data
			} else if tmp == nil {
				it.KanopySSHKeyPath = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "logPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logPath"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogPath = data
		case "loggerConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loggerConfig"))
			data, err := ec.unmarshalOLoggerConfigInput2githubcomevergreencievergreenrestmodelAPILoggerConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.LoggerConfig = data
		case "notify":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notify"))
			data, err := ec.unmarshalONotifyConfigInput2githubcomevergreencievergreenrestmodelAPINotifyConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Notify = data
		case "oldestAllowedCLIVersion":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oldestAllowedCLIVersion"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OldestAllowedCLIVersion = data
		case "parameterStore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameterStore"))
			data, err := ec.unmarshalOParameterStoreConfigInput2githubcomevergreencievergreenrestmodelAPIParameterStoreConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParameterStore = data
		case "perfMonitoringKanopyURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perfMonitoringKanopyURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerfMonitoringKanopyURL = data
		case "perfMonitoringURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perfMonitoringURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerfMonitoringURL = data
		case "podLifecycle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("podLifecycle"))
			data, err := ec.unmarshalOPodLifecycleConfigInput2githubcomevergreencievergreenrestmodelAPIPodLifecycleConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.PodLifecycle = data
		case "pprofPort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pprofPort"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PprofPort = data
		case "projectCreation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectCreation"))
			data, err := ec.unmarshalOProjectCreationConfigInput2githubcomevergreencievergreenrestmodelAPIProjectCreationConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectCreation = data
		case "providers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providers"))
			data, err := ec.unmarshalOCloudProviderConfigInput2githubcomevergreencievergreenrestmodelAPICloudProviders(ctx, v)
			if err != nil {
				return it, err
			}
			it.Providers = data
		case "releaseMode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseMode"))
			data, err := ec.unmarshalOReleaseModeConfigInput2githubcomevergreencievergreenrestmodelAPIReleaseModeConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReleaseMode = data
		case "repotracker":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotracker"))
			data, err := ec.unmarshalORepotrackerConfigInput2githubcomevergreencievergreenrestmodelAPIRepoTrackerConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoTracker = data
		case "runtimeEnvironments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeEnvironments"))
			data, err := ec.unmarshalORuntimeEnvironmentConfigInput2githubcomevergreencievergreenrestmodelAPIRuntimeEnvironmentsConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeEnvironments = data
		case "scheduler":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scheduler"))
			data, err := ec.unmarshalOSchedulerConfigInput2githubcomevergreencievergreenrestmodelAPISchedulerConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scheduler = data
		case "serviceFlags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceFlags"))
			data, err := ec.unmarshalOServiceFlagsInput2githubcomevergreencievergreenrestmodelAPIServiceFlags(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceFlags = data
		case "shutdownWaitSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shutdownWaitSeconds"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShutdownWaitSeconds = data
		case "singleTaskDistro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("singleTaskDistro"))
			data, err := ec.unmarshalOSingleTaskDistroConfigInput2githubcomevergreencievergreenrestmodelAPISingleTaskDistroConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.SingleTaskDistro = data
		case "slack":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slack"))
			data, err := ec.unmarshalOSlackConfigInput2githubcomevergreencievergreenrestmodelAPISlackConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slack = data
		case "sleepSchedule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sleepSchedule"))
			data, err := ec.unmarshalOSleepScheduleConfigInput2githubcomevergreencievergreenrestmodelAPISleepScheduleConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.SleepSchedule = data
		case "spawnhost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnhost"))
			data, err := ec.unmarshalOSpawnHostConfigInput2githubcomevergreencievergreenrestmodelAPISpawnHostConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Spawnhost = data
		case "splunk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splunk"))
			data, err := ec.unmarshalOSplunkConfigInput2githubcomevergreencievergreenrestmodelAPISplunkConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Splunk = data
		case "ssh":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ssh"))
			data, err := ec.unmarshalOSSHConfigInput2githubcomevergreencievergreenrestmodelAPISSHConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSH = data
		case "taskLimits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskLimits"))
			data, err := ec.unmarshalOTaskLimitsConfigInput2githubcomevergreencievergreenrestmodelAPITaskLimitsConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskLimits = data
		case "testSelection":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testSelection"))
			data, err := ec.unmarshalOTestSelectionConfigInput2githubcomevergreencievergreenrestmodelAPITestSelectionConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestSelection = data
		case "tracer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracer"))
			data, err := ec.unmarshalOTracerSettingsInput2githubcomevergreencievergreenrestmodelAPITracerSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tracer = data
		case "triggers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			data, err := ec.unmarshalOTriggerConfigInput2githubcomevergreencievergreenrestmodelAPITriggerConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Triggers = data
		case "ui":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ui"))
			data, err := ec.unmarshalOUIConfigInput2githubcomevergreencievergreenrestmodelAPIUIConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ui = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAmboyConfigInput(ctx context.Context, obj any) (model.APIAmboyConfig, error) {
	var it model.APIAmboyConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "singleName", "poolSizeLocal", "poolSizeRemote", "localStorage", "groupDefaultWorkers", "groupBackgroundCreateFrequencyMinutes", "groupPruneFrequencyMinutes", "groupTTLMinutes", "lockTimeoutMinutes", "sampleSize", "retry", "namedQueues"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "singleName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("singleName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SingleName = data
		case "poolSizeLocal":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolSizeLocal"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PoolSizeLocal = data
		case "poolSizeRemote":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolSizeRemote"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PoolSizeRemote = data
		case "localStorage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localStorage"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocalStorage = data
		case "groupDefaultWorkers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupDefaultWorkers"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupDefaultWorkers = data
		case "groupBackgroundCreateFrequencyMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupBackgroundCreateFrequencyMinutes"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupBackgroundCreateFrequencyMinutes = data
		case "groupPruneFrequencyMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupPruneFrequencyMinutes"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupPruneFrequencyMinutes = data
		case "groupTTLMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupTTLMinutes"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupTTLMinutes = data
		case "lockTimeoutMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lockTimeoutMinutes"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LockTimeoutMinutes = data
		case "sampleSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sampleSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SampleSize = data
		case "retry":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retry"))
			data, err := ec.unmarshalNAmboyRetryConfigInput2githubcomevergreencievergreenrestmodelAPIAmboyRetryConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Retry = data
		case "namedQueues":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namedQueues"))
			data, err := ec.unmarshalNAmboyNamedQueueConfigInput2githubcomevergreencievergreenrestmodelAPIAmboyNamedQueueConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamedQueues = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAmboyDBConfigInput(ctx context.Context, obj any) (model.APIAmboyDBConfig, error) {
	var it model.APIAmboyDBConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "database"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "database":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("database"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Database = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAmboyNamedQueueConfigInput(ctx context.Context, obj any) (model.APIAmboyNamedQueueConfig, error) {
	var it model.APIAmboyNamedQueueConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "regexp", "numWorkers", "sampleSize", "lockTimeoutSeconds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "regexp":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regexp"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Regexp = data
		case "numWorkers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numWorkers"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumWorkers = data
		case "sampleSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sampleSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SampleSize = data
		case "lockTimeoutSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lockTimeoutSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LockTimeoutSeconds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAmboyRetryConfigInput(ctx context.Context, obj any) (model.APIAmboyRetryConfig, error) {
	var it model.APIAmboyRetryConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"numWorkers", "maxCapacity", "maxRetryAttempts", "maxRetryTimeSeconds", "retryBackoffSeconds", "staleRetryingMonitorIntervalSeconds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "numWorkers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numWorkers"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumWorkers = data
		case "maxCapacity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxCapacity"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxCapacity = data
		case "maxRetryAttempts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxRetryAttempts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxRetryAttempts = data
		case "maxRetryTimeSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxRetryTimeSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxRetryTimeSeconds = data
		case "retryBackoffSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryBackoffSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RetryBackoffSeconds = data
		case "staleRetryingMonitorIntervalSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("staleRetryingMonitorIntervalSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StaleRetryingMonitorIntervalSeconds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthConfigInput(ctx context.Context, obj any) (model.APIAuthConfig, error) {
	var it model.APIAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"okta", "naive", "github", "multi", "kanopy", "oauth", "preferredType", "backgroundReauthMinutes", "allowServiceUsers"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "okta":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("okta"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOOktaConfigInput2githubcomevergreencievergreenrestmodelAPIOktaConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIOktaConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIOktaConfig); ok {
				it.Okta = data
			} else if tmp == nil {
				it.Okta = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIOktaConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "naive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("naive"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalONaiveAuthConfigInput2githubcomevergreencievergreenrestmodelAPINaiveAuthConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APINaiveAuthConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APINaiveAuthConfig); ok {
				it.Naive = data
			} else if tmp == nil {
				it.Naive = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APINaiveAuthConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "github":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("github"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOGitHubAuthConfigInput2githubcomevergreencievergreenrestmodelAPIGithubAuthConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIGithubAuthConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIGithubAuthConfig); ok {
				it.Github = data
			} else if tmp == nil {
				it.Github = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIGithubAuthConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "multi":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("multi"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMultiAuthConfigInput2githubcomevergreencievergreenrestmodelAPIMultiAuthConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIMultiAuthConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIMultiAuthConfig); ok {
				it.Multi = data
			} else if tmp == nil {
				it.Multi = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIMultiAuthConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "kanopy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kanopy"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOKanopyAuthConfigInput2githubcomevergreencievergreenrestmodelAPIKanopyAuthConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIKanopyAuthConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIKanopyAuthConfig); ok {
				it.Kanopy = data
			} else if tmp == nil {
				it.Kanopy = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIKanopyAuthConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "oauth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauth"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOOAuthConfigInput2githubcomevergreencievergreenrestmodelAPIOAuthConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIOAuthConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIOAuthConfig); ok {
				it.OAuth = data
			} else if tmp == nil {
				it.OAuth = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIOAuthConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "preferredType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredType"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOPreferredAuthType2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.PreferredType = data
			} else if tmp == nil {
				it.PreferredType = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "backgroundReauthMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundReauthMinutes"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundReauthMinutes = data
		case "allowServiceUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowServiceUsers"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowServiceUsers = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthUserInput(ctx context.Context, obj any) (model.APIAuthUser, error) {
	var it model.APIAuthUser
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "displayName", "password", "email"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBetaFeaturesInput(ctx context.Context, obj any) (model.APIBetaFeatures, error) {
	var it model.APIBetaFeatures
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"spruceWaterfallEnabled", "parsleyAIEnabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "spruceWaterfallEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spruceWaterfallEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpruceWaterfallEnabled = data
		case "parsleyAIEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleyAIEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleyAIEnabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBootstrapSettingsInput(ctx context.Context, obj any) (model.APIBootstrapSettings, error) {
	var it model.APIBootstrapSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientDir", "communication", "env", "jasperBinaryDir", "jasperCredentialsPath", "method", "preconditionScripts", "resourceLimits", "rootDir", "serviceUser", "shellPath"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientDir"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientDir = data
		case "communication":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("communication"))
			data, err := ec.unmarshalNCommunicationMethod2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Communication = data
		case "env":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("env"))
			data, err := ec.unmarshalNEnvVarInput2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx, v)
			if err != nil {
				return it, err
			}
			it.Env = data
		case "jasperBinaryDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jasperBinaryDir"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.JasperBinaryDir = data
		case "jasperCredentialsPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jasperCredentialsPath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.JasperCredentialsPath = data
		case "method":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			data, err := ec.unmarshalNBootstrapMethod2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Method = data
		case "preconditionScripts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preconditionScripts"))
			data, err := ec.unmarshalNPreconditionScriptInput2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreconditionScripts = data
		case "resourceLimits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceLimits"))
			data, err := ec.unmarshalNResourceLimitsInput2githubcomevergreencievergreenrestmodelAPIResourceLimits(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceLimits = data
		case "rootDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootDir"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RootDir = data
		case "serviceUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceUser"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceUser = data
		case "shellPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shellPath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShellPath = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBucketConfigInput(ctx context.Context, obj any) (model.APIBucketConfig, error) {
	var it model.APIBucketConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "testResultsPrefix", "roleARN", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "testResultsPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testResultsPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestResultsPrefix = data
		case "roleARN":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roleARN"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.RoleARN = data
			} else if tmp == nil {
				it.RoleARN = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBucketsConfigInput(ctx context.Context, obj any) (model.APIBucketsConfig, error) {
	var it model.APIBucketsConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"logBucket", "logBucketLongRetention", "logBucketFailedTasks", "longRetentionProjects", "testResultsBucket", "internalBuckets", "credentials"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "logBucket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logBucket"))
			data, err := ec.unmarshalOBucketConfigInput2githubcomevergreencievergreenrestmodelAPIBucketConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogBucket = data
		case "logBucketLongRetention":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logBucketLongRetention"))
			data, err := ec.unmarshalOBucketConfigInput2githubcomevergreencievergreenrestmodelAPIBucketConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogBucketLongRetention = data
		case "logBucketFailedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logBucketFailedTasks"))
			data, err := ec.unmarshalOBucketConfigInput2githubcomevergreencievergreenrestmodelAPIBucketConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogBucketFailedTasks = data
		case "longRetentionProjects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("longRetentionProjects"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LongRetentionProjects = data
		case "testResultsBucket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testResultsBucket"))
			data, err := ec.unmarshalOBucketConfigInput2githubcomevergreencievergreenrestmodelAPIBucketConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestResultsBucket = data
		case "internalBuckets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("internalBuckets"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InternalBuckets = data
		case "credentials":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("credentials"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOS3CredentialsInput2githubcomevergreencievergreenrestmodelAPIS3Credentials(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIS3Credentials
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIS3Credentials); ok {
				it.Credentials = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIS3Credentials`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildBaronSettingsInput(ctx context.Context, obj any) (model.APIBuildBaronSettings, error) {
	var it model.APIBuildBaronSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"bfSuggestionFeaturesURL", "bfSuggestionPassword", "bfSuggestionServer", "bfSuggestionTimeoutSecs", "bfSuggestionUsername", "ticketCreateProject", "ticketSearchProjects", "ticketCreateIssueType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "bfSuggestionFeaturesURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionFeaturesURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionFeaturesURL = data
		case "bfSuggestionPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionPassword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionPassword = data
		case "bfSuggestionServer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionServer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionServer = data
		case "bfSuggestionTimeoutSecs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionTimeoutSecs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionTimeoutSecs = data
		case "bfSuggestionUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionUsername"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionUsername = data
		case "ticketCreateProject":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketCreateProject"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketCreateProject = data
		case "ticketSearchProjects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketSearchProjects"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketSearchProjects = data
		case "ticketCreateIssueType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketCreateIssueType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketCreateIssueType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildVariantOptions(ctx context.Context, obj any) (BuildVariantOptions, error) {
	var it BuildVariantOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"includeBaseTasks", "includeNeverActivatedTasks", "statuses", "tasks", "variants"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "includeBaseTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeBaseTasks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeBaseTasks = data
		case "includeNeverActivatedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeNeverActivatedTasks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeNeverActivatedTasks = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "tasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "variants":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variants"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variants = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCedarConfigInput(ctx context.Context, obj any) (model.APICedarConfig, error) {
	var it model.APICedarConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dbUrl", "dbName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dbUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dbUrl"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.DBURL = data
			} else if tmp == nil {
				it.DBURL = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "dbName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dbName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DBName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCloudProviderConfigInput(ctx context.Context, obj any) (model.APICloudProviders, error) {
	var it model.APICloudProviders
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"aws", "docker"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "aws":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aws"))
			data, err := ec.unmarshalOAWSConfigInput2githubcomevergreencievergreenrestmodelAPIAWSConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.AWS = data
		case "docker":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("docker"))
			data, err := ec.unmarshalODockerConfigInput2githubcomevergreencievergreenrestmodelAPIDockerConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Docker = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCommitQueueParamsInput(ctx context.Context, obj any) (model.APICommitQueueParams, error) {
	var it model.APICommitQueueParams
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"enabled", "mergeMethod", "message"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "mergeMethod":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mergeMethod"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MergeMethod = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContainerPoolInput(ctx context.Context, obj any) (model.APIContainerPool, error) {
	var it model.APIContainerPool
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "distro", "maxContainers", "port"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "distro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distro"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Distro = data
		case "maxContainers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxContainers"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxContainers = data
		case "port":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ContainerPoolInput().Port(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContainerPoolsConfigInput(ctx context.Context, obj any) (model.APIContainerPoolsConfig, error) {
	var it model.APIContainerPoolsConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pools"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pools":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pools"))
			data, err := ec.unmarshalNContainerPoolInput2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Pools = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContainerResourcesInput(ctx context.Context, obj any) (model.APIContainerResources, error) {
	var it model.APIContainerResources
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "cpu", "memoryMb"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cpu":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cpu"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CPU = data
		case "memoryMb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memoryMb"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MemoryMB = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCopyDistroInput(ctx context.Context, obj any) (model.CopyDistroOpts, error) {
	var it model.CopyDistroOpts
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newDistroId", "distroIdToCopy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newDistroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newDistroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewDistroId = data
		case "distroIdToCopy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroIdToCopy"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroIdToCopy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCopyProjectInput(ctx context.Context, obj any) (model.CopyProjectOpts, error) {
	var it model.CopyProjectOpts
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newProjectId", "newProjectIdentifier", "projectIdToCopy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newProjectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newProjectId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewProjectId = data
		case "newProjectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newProjectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewProjectIdentifier = data
		case "projectIdToCopy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdToCopy"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdToCopy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCostConfigInput(ctx context.Context, obj any) (model.APICostConfig, error) {
	var it model.APICostConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"financeFormula", "savingsPlanDiscount", "onDemandDiscount"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "financeFormula":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("financeFormula"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinanceFormula = data
		case "savingsPlanDiscount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("savingsPlanDiscount"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SavingsPlanDiscount = data
		case "onDemandDiscount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onDemandDiscount"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnDemandDiscount = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCostDataInput(ctx context.Context, obj any) (model.APICostData, error) {
	var it model.APICostData
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"onDemandRate", "savingsPlanRate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "onDemandRate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onDemandRate"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnDemandRate = data
		case "savingsPlanRate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("savingsPlanRate"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SavingsPlanRate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDistroInput(ctx context.Context, obj any) (CreateDistroInput, error) {
	var it CreateDistroInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newDistroId", "singleTaskDistro"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newDistroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newDistroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewDistroID = data
		case "singleTaskDistro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("singleTaskDistro"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SingleTaskDistro = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateProjectInput(ctx context.Context, obj any) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "identifier", "owner", "repo", "repoRefId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "identifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Identifier = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "repo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repoRefId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoRefId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoRefId = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCursorParams(ctx context.Context, obj any) (CursorParams, error) {
	var it CursorParams
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cursorId", "direction", "includeCursor"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cursorId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CursorID = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNTaskHistoryDirection2githubcomevergreencievergreengraphqlTaskHistoryDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "includeCursor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeCursor"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeCursor = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeactivateStepbackTaskInput(ctx context.Context, obj any) (DeactivateStepbackTaskInput, error) {
	var it DeactivateStepbackTaskInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "buildVariantName", "taskName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "buildVariantName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildVariantName = data
		case "taskName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDefaultSectionToRepoInput(ctx context.Context, obj any) (DefaultSectionToRepoInput, error) {
	var it DefaultSectionToRepoInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "section"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "section":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("section"))
			data, err := ec.unmarshalNProjectSettingsSection2githubcomevergreencievergreengraphqlProjectSettingsSection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Section = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteDistroInput(ctx context.Context, obj any) (DeleteDistroInput, error) {
	var it DeleteDistroInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "ADMIN")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireDistroAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.DistroID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteGithubAppCredentialsInput(ctx context.Context, obj any) (DeleteGithubAppCredentialsInput, error) {
	var it DeleteGithubAppCredentialsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDispatcherSettingsInput(ctx context.Context, obj any) (model.APIDispatcherSettings, error) {
	var it model.APIDispatcherSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNDispatcherVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDisplayTask(ctx context.Context, obj any) (DisplayTask, error) {
	var it DisplayTask
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ExecTasks", "Name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ExecTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ExecTasks"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExecTasks = data
		case "Name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroEventsInput(ctx context.Context, obj any) (DistroEventsInput, error) {
	var it DistroEventsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"before", "distroId", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "before":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireDistroAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.DistroID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroInput(ctx context.Context, obj any) (model.APIDistro, error) {
	var it model.APIDistro
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"adminOnly", "aliases", "arch", "authorizedKeysFile", "bootstrapSettings", "containerPool", "disabled", "disableShallowClone", "dispatcherSettings", "execUser", "expansions", "finderSettings", "homeVolumeSettings", "hostAllocatorSettings", "iceCreamSettings", "costData", "imageId", "isCluster", "isVirtualWorkStation", "mountpoints", "name", "note", "plannerSettings", "provider", "providerAccount", "providerSettingsList", "setup", "setupAsSudo", "singleTaskDistro", "sshOptions", "user", "userSpawnAllowed", "validProjects", "warningNote", "workDir"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "adminOnly":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminOnly"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminOnly = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "arch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arch"))
			data, err := ec.unmarshalNArch2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Arch = data
		case "authorizedKeysFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedKeysFile"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthorizedKeysFile = data
		case "bootstrapSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bootstrapSettings"))
			data, err := ec.unmarshalNBootstrapSettingsInput2githubcomevergreencievergreenrestmodelAPIBootstrapSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BootstrapSettings = data
		case "containerPool":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerPool"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerPool = data
		case "disabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disabled = data
		case "disableShallowClone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disableShallowClone"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisableShallowClone = data
		case "dispatcherSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatcherSettings"))
			data, err := ec.unmarshalNDispatcherSettingsInput2githubcomevergreencievergreenrestmodelAPIDispatcherSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatcherSettings = data
		case "execUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execUser"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExecUser = data
		case "expansions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expansions"))
			data, err := ec.unmarshalNExpansionInput2githubcomevergreencievergreenrestmodelAPIExpansion(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expansions = data
		case "finderSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finderSettings"))
			data, err := ec.unmarshalNFinderSettingsInput2githubcomevergreencievergreenrestmodelAPIFinderSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinderSettings = data
		case "homeVolumeSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeVolumeSettings"))
			data, err := ec.unmarshalNHomeVolumeSettingsInput2githubcomevergreencievergreenrestmodelAPIHomeVolumeSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.HomeVolumeSettings = data
		case "hostAllocatorSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocatorSettings"))
			data, err := ec.unmarshalNHostAllocatorSettingsInput2githubcomevergreencievergreenrestmodelAPIHostAllocatorSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocatorSettings = data
		case "iceCreamSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iceCreamSettings"))
			data, err := ec.unmarshalNIceCreamSettingsInput2githubcomevergreencievergreenrestmodelAPIIceCreamSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.IcecreamSettings = data
		case "costData":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costData"))
			data, err := ec.unmarshalOCostDataInput2githubcomevergreencievergreenrestmodelAPICostData(ctx, v)
			if err != nil {
				return it, err
			}
			it.CostData = data
		case "imageId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageID = data
		case "isCluster":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isCluster"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsCluster = data
		case "isVirtualWorkStation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isVirtualWorkStation"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsVirtualWorkstation = data
		case "mountpoints":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mountpoints"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mountpoints = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "EDIT")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.RequireDistroAccess == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "note":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Note = data
		case "plannerSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("plannerSettings"))
			data, err := ec.unmarshalNPlannerSettingsInput2githubcomevergreencievergreenrestmodelAPIPlannerSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.PlannerSettings = data
		case "provider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalNProvider2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Provider = data
		case "providerAccount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerAccount"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderAccount = data
		case "providerSettingsList":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerSettingsList"))
			data, err := ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.DistroInput().ProviderSettingsList(ctx, &it, data); err != nil {
				return it, err
			}
		case "setup":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setup"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Setup = data
		case "setupAsSudo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setupAsSudo"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetupAsSudo = data
		case "singleTaskDistro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("singleTaskDistro"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SingleTaskDistro = data
		case "sshOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sshOptions"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSHOptions = data
		case "user":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.User = data
		case "userSpawnAllowed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userSpawnAllowed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserSpawnAllowed = data
		case "validProjects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validProjects"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValidProjects = data
		case "warningNote":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("warningNote"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WarningNote = data
		case "workDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workDir"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkDir = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroPermissionsOptions(ctx context.Context, obj any) (DistroPermissionsOptions, error) {
	var it DistroPermissionsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDockerConfigInput(ctx context.Context, obj any) (model.APIDockerConfig, error) {
	var it model.APIDockerConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"apiVersion"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "apiVersion":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiVersion"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.APIVersion = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEC2KeyInput(ctx context.Context, obj any) (model.APIEC2Key, error) {
	var it model.APIEC2Key
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "key", "secret"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputECSCapacityProviderInput(ctx context.Context, obj any) (model.APIECSCapacityProvider, error) {
	var it model.APIECSCapacityProvider
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "os", "arch", "windowsVersion"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "os":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("os"))
			data, err := ec.unmarshalOECSOperatingSystem2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OS = data
		case "arch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arch"))
			data, err := ec.unmarshalOECSArchitecture2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Arch = data
		case "windowsVersion":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("windowsVersion"))
			data, err := ec.unmarshalOECSWindowsVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WindowsVersion = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputECSClusterConfigInput(ctx context.Context, obj any) (model.APIECSClusterConfig, error) {
	var it model.APIECSClusterConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "os"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "os":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("os"))
			data, err := ec.unmarshalOECSOperatingSystem2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OS = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputECSConfigInput(ctx context.Context, obj any) (model.APIECSConfig, error) {
	var it model.APIECSConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"maxCPU", "maxMemoryMb", "taskDefinitionPrefix", "taskRole", "executionRole", "logRegion", "logGroup", "logStreamPrefix", "awsVPC", "clusters", "capacityProviders", "allowedImages"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "maxCPU":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxCPU"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxCPU = data
		case "maxMemoryMb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxMemoryMb"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxMemoryMB = data
		case "taskDefinitionPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskDefinitionPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskDefinitionPrefix = data
		case "taskRole":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskRole"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskRole = data
		case "executionRole":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("executionRole"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExecutionRole = data
		case "logRegion":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logRegion"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogRegion = data
		case "logGroup":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logGroup"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogGroup = data
		case "logStreamPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logStreamPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogStreamPrefix = data
		case "awsVPC":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("awsVPC"))
			data, err := ec.unmarshalOAWSVPCConfigInput2githubcomevergreencievergreenrestmodelAPIAWSVPCConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.AWSVPC = data
		case "clusters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clusters"))
			data, err := ec.unmarshalNECSClusterConfigInput2githubcomevergreencievergreenrestmodelAPIECSClusterConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Clusters = data
		case "capacityProviders":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityProviders"))
			data, err := ec.unmarshalNECSCapacityProviderInput2githubcomevergreencievergreenrestmodelAPIECSCapacityProvider(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityProviders = data
		case "allowedImages":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedImages"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowedImages = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEditSpawnHostInput(ctx context.Context, obj any) (EditSpawnHostInput, error) {
	var it EditSpawnHostInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"addedInstanceTags", "deletedInstanceTags", "displayName", "expiration", "hostId", "instanceType", "noExpiration", "publicKey", "savePublicKey", "servicePassword", "sleepSchedule", "volume"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "addedInstanceTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addedInstanceTags"))
			data, err := ec.unmarshalOInstanceTagInput2githubcomevergreencievergreenmodelhostTag(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddedInstanceTags = data
		case "deletedInstanceTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedInstanceTags"))
			data, err := ec.unmarshalOInstanceTagInput2githubcomevergreencievergreenmodelhostTag(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedInstanceTags = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "hostId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireHostAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireHostAccess is not implemented")
				}
				return ec.directives.RequireHostAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.HostID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "instanceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("instanceType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InstanceType = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "publicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKey"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *PublicKeyInput
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*PublicKeyInput); ok {
				it.PublicKey = data
			} else if tmp == nil {
				it.PublicKey = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/graphql.PublicKeyInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "savePublicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("savePublicKey"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SavePublicKey = data
		case "servicePassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("servicePassword"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ServicePassword = data
			} else if tmp == nil {
				it.ServicePassword = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "sleepSchedule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sleepSchedule"))
			data, err := ec.unmarshalOSleepScheduleInput2githubcomevergreencievergreenmodelhostSleepScheduleInfo(ctx, v)
			if err != nil {
				return it, err
			}
			it.SleepSchedule = data
		case "volume":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volume"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Volume = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnvVarInput(ctx context.Context, obj any) (model.APIEnvVar, error) {
	var it model.APIEnvVar
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExpansionInput(ctx context.Context, obj any) (model.APIExpansion, error) {
	var it model.APIExpansion
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExternalLinkInput(ctx context.Context, obj any) (model.APIExternalLink, error) {
	var it model.APIExternalLink
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"displayName", "requesters", "urlTemplate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "urlTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlTemplate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URLTemplate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFWSConfigInput(ctx context.Context, obj any) (model.APIFWSConfig, error) {
	var it model.APIFWSConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFinderSettingsInput(ctx context.Context, obj any) (model.APIFinderSettings, error) {
	var it model.APIFinderSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNFinderVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGitHubAuthConfigInput(ctx context.Context, obj any) (model.APIGithubAuthConfig, error) {
	var it model.APIGithubAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"appId", "clientId", "clientSecret", "defaultOwner", "defaultRepo", "organization", "users"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "appId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOInt2int64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal int64
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int64); ok {
				it.AppId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ClientId = data
			} else if tmp == nil {
				it.ClientId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientSecret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ClientSecret = data
			} else if tmp == nil {
				it.ClientSecret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "defaultOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultOwner"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.DefaultOwner = data
			} else if tmp == nil {
				it.DefaultOwner = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "defaultRepo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultRepo"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.DefaultRepo = data
			} else if tmp == nil {
				it.DefaultRepo = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "organization":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organization"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Organization = data
			} else if tmp == nil {
				it.Organization = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "users":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Users = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGitHubCheckRunConfigInput(ctx context.Context, obj any) (model.APIGitHubCheckRunConfig, error) {
	var it model.APIGitHubCheckRunConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"checkRunLimit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "checkRunLimit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkRunLimit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CheckRunLimit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGitHubDynamicTokenPermissionGroupInput(ctx context.Context, obj any) (model.APIGitHubDynamicTokenPermissionGroup, error) {
	var it model.APIGitHubDynamicTokenPermissionGroup
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "permissions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "permissions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissions"))
			data, err := ec.unmarshalNStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Permissions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubAppAuthInput(ctx context.Context, obj any) (model.APIGithubAppAuth, error) {
	var it model.APIGithubAppAuth
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"appId", "privateKey"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "appId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appId"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppID = data
		case "privateKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("privateKey"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrivateKey = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubUserInput(ctx context.Context, obj any) (model.APIGithubUser, error) {
	var it model.APIGithubUser
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lastKnownAs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lastKnownAs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastKnownAs"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastKnownAs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGraphiteConfigInput(ctx context.Context, obj any) (model.APIGraphiteConfig, error) {
	var it model.APIGraphiteConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ciOptimizationToken", "serverUrl"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ciOptimizationToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ciOptimizationToken"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.CIOptimizationToken = data
			} else if tmp == nil {
				it.CIOptimizationToken = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "serverUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serverUrl"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServerURL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHomeVolumeSettingsInput(ctx context.Context, obj any) (model.APIHomeVolumeSettings, error) {
	var it model.APIHomeVolumeSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"formatCommand"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "formatCommand":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formatCommand"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FormatCommand = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHostAllocatorSettingsInput(ctx context.Context, obj any) (model.APIHostAllocatorSettings, error) {
	var it model.APIHostAllocatorSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"acceptableHostIdleTime", "autoTuneMaximumHosts", "feedbackRule", "futureHostFraction", "hostsOverallocatedRule", "maximumHosts", "minimumHosts", "roundingRule", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "acceptableHostIdleTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acceptableHostIdleTime"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.HostAllocatorSettingsInput().AcceptableHostIdleTime(ctx, &it, data); err != nil {
				return it, err
			}
		case "autoTuneMaximumHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("autoTuneMaximumHosts"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AutoTuneMaximumHosts = data
		case "feedbackRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedbackRule"))
			data, err := ec.unmarshalNFeedbackRule2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedbackRule = data
		case "futureHostFraction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("futureHostFraction"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FutureHostFraction = data
		case "hostsOverallocatedRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostsOverallocatedRule"))
			data, err := ec.unmarshalNOverallocatedRule2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostsOverallocatedRule = data
		case "maximumHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maximumHosts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaximumHosts = data
		case "minimumHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumHosts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinimumHosts = data
		case "roundingRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roundingRule"))
			data, err := ec.unmarshalNRoundingRule2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoundingRule = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNHostAllocatorVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHostEventsInput(ctx context.Context, obj any) (HostEventsInput, error) {
	var it HostEventsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["sortDir"]; !present {
		asMap["sortDir"] = "DESC"
	}

	fieldsInOrder := [...]string{"limit", "page", "sortDir", "eventTypes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "sortDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDir"))
			data, err := ec.unmarshalOSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortDir = data
		case "eventTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypes"))
			data, err := ec.unmarshalOHostEventType2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventTypes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHostInitConfigInput(ctx context.Context, obj any) (model.APIHostInitConfig, error) {
	var it model.APIHostInitConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"hostThrottle", "provisioningThrottle", "cloudStatusBatchSize", "maxTotalDynamicHosts"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "hostThrottle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostThrottle"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostThrottle = data
		case "provisioningThrottle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provisioningThrottle"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProvisioningThrottle = data
		case "cloudStatusBatchSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cloudStatusBatchSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CloudStatusBatchSize = data
		case "maxTotalDynamicHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTotalDynamicHosts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTotalDynamicHosts = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHostJasperConfigInput(ctx context.Context, obj any) (model.APIHostJasperConfig, error) {
	var it model.APIHostJasperConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"binaryName", "downloadFileName", "port", "url", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "binaryName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("binaryName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BinaryName = data
		case "downloadFileName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downloadFileName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownloadFileName = data
		case "port":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Port = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIceCreamSettingsInput(ctx context.Context, obj any) (model.APIIceCreamSettings, error) {
	var it model.APIIceCreamSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"configPath", "schedulerHost"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "configPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configPath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigPath = data
		case "schedulerHost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schedulerHost"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SchedulerHost = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageFileOpts(ctx context.Context, obj any) (thirdparty.FileFilterOptions, error) {
	var it thirdparty.FileFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInstanceTagInput(ctx context.Context, obj any) (host.Tag, error) {
	var it host.Tag
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIssueLinkInput(ctx context.Context, obj any) (model.APIIssueLink, error) {
	var it model.APIIssueLink
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"confidenceScore", "issueKey", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "confidenceScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confidenceScore"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfidenceScore = data
		case "issueKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueKey"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssueKey = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJiraConfigInput(ctx context.Context, obj any) (model.APIJiraConfig, error) {
	var it model.APIJiraConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email", "host", "personalAccessToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Host = data
		case "personalAccessToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("personalAccessToken"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.PersonalAccessToken = data
			} else if tmp == nil {
				it.PersonalAccessToken = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJiraIssueSubscriberInput(ctx context.Context, obj any) (model.APIJIRAIssueSubscriber, error) {
	var it model.APIJIRAIssueSubscriber
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"issueType", "project"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "issueType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssueType = data
		case "project":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Project = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJiraNotificationsConfigInput(ctx context.Context, obj any) (model.APIJIRANotificationsConfig, error) {
	var it model.APIJIRANotificationsConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"customFields"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "customFields":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("customFields"))
			data, err := ec.unmarshalNJiraNotificationsProjectEntryInput2githubcomevergreencievergreengraphqlJiraNotificationsProjectEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.JiraNotificationsConfigInput().CustomFields(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJiraNotificationsProjectEntryInput(ctx context.Context, obj any) (JiraNotificationsProjectEntryInput, error) {
	var it JiraNotificationsProjectEntryInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"project", "fields", "components", "labels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "project":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Project = data
		case "fields":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fields"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fields = data
		case "components":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("components"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Components = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJiraNotificationsProjectInput(ctx context.Context, obj any) (model.APIJIRANotificationsProject, error) {
	var it model.APIJIRANotificationsProject
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fields", "components", "labels"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fields":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fields"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fields = data
		case "components":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("components"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Components = data
		case "labels":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("labels"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Labels = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKanopyAuthConfigInput(ctx context.Context, obj any) (model.APIKanopyAuthConfig, error) {
	var it model.APIKanopyAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"headerName", "issuer", "keysetURL"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "headerName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headerName"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.HeaderName = data
			} else if tmp == nil {
				it.HeaderName = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "issuer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuer"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Issuer = data
			} else if tmp == nil {
				it.Issuer = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "keysetURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keysetURL"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.KeysetURL = data
			} else if tmp == nil {
				it.KeysetURL = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLogBufferingInput(ctx context.Context, obj any) (model.APILogBuffering, error) {
	var it model.APILogBuffering
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"useAsync", "durationSeconds", "count", "incomingBufferFactor"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "useAsync":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useAsync"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseAsync = data
		case "durationSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationSeconds = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "incomingBufferFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("incomingBufferFactor"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncomingBufferFactor = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoggerConfigInput(ctx context.Context, obj any) (model.APILoggerConfig, error) {
	var it model.APILoggerConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buffer", "defaultLevel", "thresholdLevel", "logkeeperURL", "redactKeys"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buffer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buffer"))
			data, err := ec.unmarshalNLogBufferingInput2githubcomevergreencievergreenrestmodelAPILogBuffering(ctx, v)
			if err != nil {
				return it, err
			}
			it.Buffer = data
		case "defaultLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultLevel"))
			data, err := ec.unmarshalNPriorityLevel2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultLevel = data
		case "thresholdLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("thresholdLevel"))
			data, err := ec.unmarshalNPriorityLevel2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThresholdLevel = data
		case "logkeeperURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logkeeperURL"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogkeeperURL = data
		case "redactKeys":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redactKeys"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedactKeys = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMainlineCommitsOptions(ctx context.Context, obj any) (MainlineCommitsOptions, error) {
	var it MainlineCommitsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 7
	}
	if _, present := asMap["shouldCollapse"]; !present {
		asMap["shouldCollapse"] = false
	}

	fieldsInOrder := [...]string{"limit", "projectIdentifier", "requesters", "revision", "shouldCollapse", "skipOrderNumber"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectIdentifier = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		case "shouldCollapse":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shouldCollapse"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShouldCollapse = data
		case "skipOrderNumber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skipOrderNumber"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SkipOrderNumber = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMetadataLinkInput(ctx context.Context, obj any) (model.APIMetadataLink, error) {
	var it model.APIMetadataLink
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMoveProjectInput(ctx context.Context, obj any) (MoveProjectInput, error) {
	var it MoveProjectInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newOwner", "newRepo", "projectId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newOwner"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewOwner = data
		case "newRepo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newRepo"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewRepo = data
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMultiAuthConfigInput(ctx context.Context, obj any) (model.APIMultiAuthConfig, error) {
	var it model.APIMultiAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"readWrite", "readOnly"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "readWrite":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("readWrite"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReadWrite = data
		case "readOnly":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("readOnly"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReadOnly = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNaiveAuthConfigInput(ctx context.Context, obj any) (model.APINaiveAuthConfig, error) {
	var it model.APINaiveAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"users"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "users":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			data, err := ec.unmarshalOAuthUserInput2githubcomevergreencievergreenrestmodelAPIAuthUser(ctx, v)
			if err != nil {
				return it, err
			}
			it.Users = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationsInput(ctx context.Context, obj any) (model.APINotificationPreferences, error) {
	var it model.APINotificationPreferences
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buildBreak", "patchFinish", "patchFirstFailure", "spawnHostExpiration", "spawnHostOutcome"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buildBreak":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBreak"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBreak = data
		case "patchFinish":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFinish"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFinish = data
		case "patchFirstFailure":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFirstFailure"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFirstFailure = data
		case "spawnHostExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostExpiration"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostExpiration = data
		case "spawnHostOutcome":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostOutcome"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostOutcome = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotifyConfigInput(ctx context.Context, obj any) (model.APINotifyConfig, error) {
	var it model.APINotifyConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ses", "bufferTargetPerInterval", "bufferIntervalSeconds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ses"))
			data, err := ec.unmarshalOSESConfigInput2githubcomevergreencievergreenrestmodelAPISESConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.SES = data
		case "bufferTargetPerInterval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bufferTargetPerInterval"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BufferTargetPerInterval = data
		case "bufferIntervalSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bufferIntervalSeconds"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BufferIntervalSeconds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOAuthConfigInput(ctx context.Context, obj any) (model.APIOAuthConfig, error) {
	var it model.APIOAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"issuer", "clientId", "connectorId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "issuer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuer"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Issuer = data
			} else if tmp == nil {
				it.Issuer = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ClientID = data
			} else if tmp == nil {
				it.ClientID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "connectorId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connectorId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ConnectorID = data
			} else if tmp == nil {
				it.ConnectorID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOktaConfigInput(ctx context.Context, obj any) (model.APIOktaConfig, error) {
	var it model.APIOktaConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientId", "clientSecret", "issuer", "scopes", "userGroup", "expireAfterMinutes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ClientID = data
			} else if tmp == nil {
				it.ClientID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientSecret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ClientSecret = data
			} else if tmp == nil {
				it.ClientSecret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "issuer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuer"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Issuer = data
			} else if tmp == nil {
				it.Issuer = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "scopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scopes = data
		case "userGroup":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userGroup"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserGroup = data
		case "expireAfterMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expireAfterMinutes"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpireAfterMinutes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOperatingSystemOpts(ctx context.Context, obj any) (thirdparty.OSInfoFilterOptions, error) {
	var it thirdparty.OSInfoFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOwnerRepoInput(ctx context.Context, obj any) (model.APIOwnerRepo, error) {
	var it model.APIOwnerRepo
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"owner", "repo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "repo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageOpts(ctx context.Context, obj any) (thirdparty.PackageFilterOptions, error) {
	var it thirdparty.PackageFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "manager", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "manager":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manager"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manager = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParameterInput(ctx context.Context, obj any) (model.APIParameter, error) {
	var it model.APIParameter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParameterStoreConfigInput(ctx context.Context, obj any) (model.APIParameterStoreConfig, error) {
	var it model.APIParameterStoreConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"prefix"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "prefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Prefix = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParserProjectS3ConfigInput(ctx context.Context, obj any) (model.APIParserProjectS3Config, error) {
	var it model.APIParserProjectS3Config
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "secret", "bucket", "prefix", "generatedJSONPrefix"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "bucket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bucket"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bucket = data
		case "prefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Prefix = data
		case "generatedJSONPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("generatedJSONPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GeneratedJSONPrefix = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParsleyFilterInput(ctx context.Context, obj any) (model.APIParsleyFilter, error) {
	var it model.APIParsleyFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"caseSensitive", "description", "exactMatch", "expression"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "caseSensitive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caseSensitive"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CaseSensitive = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "exactMatch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exactMatch"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExactMatch = data
		case "expression":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expression = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParsleySettingsInput(ctx context.Context, obj any) (model.APIParsleySettings, error) {
	var it model.APIParsleySettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sectionsEnabled", "jumpToFailingLineEnabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sectionsEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sectionsEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SectionsEnabled = data
		case "jumpToFailingLineEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jumpToFailingLineEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.JumpToFailingLineEnabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchConfigure(ctx context.Context, obj any) (PatchConfigure, error) {
	var it PatchConfigure
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "parameters", "patchTriggerAliases", "variantsTasks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "parameters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOParameterInput2githubcomevergreencievergreenrestmodelAPIParameter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		case "patchTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "variantsTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantsTasks"))
			data, err := ec.unmarshalNVariantTasks2githubcomevergreencievergreengraphqlVariantTasks(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantsTasks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchTriggerAliasInput(ctx context.Context, obj any) (model.APIPatchTriggerDefinition, error) {
	var it model.APIPatchTriggerDefinition
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"alias", "childProjectIdentifier", "parentAsModule", "status", "downstreamRevision", "taskSpecifiers"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "childProjectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("childProjectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChildProjectIdentifier = data
		case "parentAsModule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentAsModule"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentAsModule = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "downstreamRevision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downstreamRevision"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownstreamRevision = data
		case "taskSpecifiers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskSpecifiers"))
			data, err := ec.unmarshalNTaskSpecifierInput2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskSpecifiers = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchesInput(ctx context.Context, obj any) (PatchesInput, error) {
	var it PatchesInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["includeHidden"]; !present {
		asMap["includeHidden"] = false
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["patchName"]; !present {
		asMap["patchName"] = ""
	}
	if _, present := asMap["statuses"]; !present {
		asMap["statuses"] = []any{}
	}

	fieldsInOrder := [...]string{"limit", "onlyMergeQueue", "includeHidden", "page", "patchName", "statuses", "requesters"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "onlyMergeQueue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onlyMergeQueue"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnlyMergeQueue = data
		case "includeHidden":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeHidden"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeHidden = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "patchName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchName = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPeriodicBuildInput(ctx context.Context, obj any) (model.APIPeriodicBuildDefinition, error) {
	var it model.APIPeriodicBuildDefinition
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "alias", "configFile", "cron", "intervalHours", "message", "nextRunTime"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "configFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configFile"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigFile = data
		case "cron":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cron"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cron = data
		case "intervalHours":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intervalHours"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntervalHours = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "nextRunTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nextRunTime"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.NextRunTime = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPersistentDNSConfigInput(ctx context.Context, obj any) (model.APIPersistentDNSConfig, error) {
	var it model.APIPersistentDNSConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"hostedZoneID", "domain"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "hostedZoneID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostedZoneID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostedZoneID = data
		case "domain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("domain"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Domain = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlannerSettingsInput(ctx context.Context, obj any) (model.APIPlannerSettings, error) {
	var it model.APIPlannerSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"commitQueueFactor", "expectedRuntimeFactor", "generateTaskFactor", "groupVersions", "mainlineTimeInQueueFactor", "numDependentsFactor", "patchFactor", "patchTimeInQueueFactor", "targetTime", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "commitQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueueFactor = data
		case "expectedRuntimeFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expectedRuntimeFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpectedRuntimeFactor = data
		case "generateTaskFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("generateTaskFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GenerateTaskFactor = data
		case "groupVersions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupVersions"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupVersions = data
		case "mainlineTimeInQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainlineTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainlineTimeInQueueFactor = data
		case "numDependentsFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numDependentsFactor"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumDependentsFactor = data
		case "patchFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFactor = data
		case "patchTimeInQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTimeInQueueFactor = data
		case "targetTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetTime"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.PlannerSettingsInput().TargetTime(ctx, &it, data); err != nil {
				return it, err
			}
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNPlannerVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPodLifecycleConfigInput(ctx context.Context, obj any) (model.APIPodLifecycleConfig, error) {
	var it model.APIPodLifecycleConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"maxParallelPodRequests", "maxPodDefinitionCleanupRate", "maxSecretCleanupRate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "maxParallelPodRequests":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxParallelPodRequests"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxParallelPodRequests = data
		case "maxPodDefinitionCleanupRate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPodDefinitionCleanupRate"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxPodDefinitionCleanupRate = data
		case "maxSecretCleanupRate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxSecretCleanupRate"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxSecretCleanupRate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPreconditionScriptInput(ctx context.Context, obj any) (model.APIPreconditionScript, error) {
	var it model.APIPreconditionScript
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"path", "script"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "script":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("script"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Script = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectAliasInput(ctx context.Context, obj any) (model.APIProjectAlias, error) {
	var it model.APIProjectAlias
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "alias", "description", "gitTag", "remotePath", "task", "taskTags", "variant", "variantTags", "parameters"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "gitTag":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTag"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTag = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "task":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("task"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Task = data
		case "taskTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskTags"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskTags = data
		case "variant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		case "variantTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantTags"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantTags = data
		case "parameters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOParameterInput2githubcomevergreencievergreenrestmodelAPIParameter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectBannerInput(ctx context.Context, obj any) (model.APIProjectBanner, error) {
	var it model.APIProjectBanner
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "theme"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "theme":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("theme"))
			data, err := ec.unmarshalNBannerTheme2githubcomevergreencievergreenBannerTheme(ctx, v)
			if err != nil {
				return it, err
			}
			it.Theme = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectCreationConfigInput(ctx context.Context, obj any) (model.APIProjectCreationConfig, error) {
	var it model.APIProjectCreationConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"totalProjectLimit", "repoProjectLimit", "repoExceptions", "jiraProject"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "totalProjectLimit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("totalProjectLimit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalProjectLimit = data
		case "repoProjectLimit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoProjectLimit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoProjectLimit = data
		case "repoExceptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoExceptions"))
			data, err := ec.unmarshalNOwnerRepoInput2githubcomevergreencievergreenrestmodelAPIOwnerRepo(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoExceptions = data
		case "jiraProject":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jiraProject"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.JiraProject = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectInput(ctx context.Context, obj any) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "admins", "banner", "batchTime", "branch", "buildBaronSettings", "commitQueue", "containerSizeDefinitions", "deactivatePrevious", "debugSpawnHostsDisabled", "disabledStatsCache", "dispatchingDisabled", "displayName", "enabled", "externalLinks", "githubChecksEnabled", "githubDynamicTokenPermissionGroups", "githubPermissionGroupByRequester", "githubPRTriggerAliases", "githubMQTriggerAliases", "gitTagAuthorizedTeams", "gitTagAuthorizedUsers", "gitTagVersionsEnabled", "identifier", "manualPrTestingEnabled", "notifyOnBuildFailure", "oldestAllowedMergeBase", "owner", "parsleyFilters", "patchingDisabled", "patchTriggerAliases", "perfEnabled", "periodicBuilds", "projectHealthView", "prTestingEnabled", "remotePath", "repo", "repotrackerDisabled", "restricted", "spawnHostScriptPath", "stepbackDisabled", "stepbackBisect", "taskAnnotationSettings", "testSelection", "tracksPushEvents", "triggers", "versionControlEnabled", "workstationConfig"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "admins":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Admins = data
		case "banner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("banner"))
			data, err := ec.unmarshalOProjectBannerInput2githubcomevergreencievergreenrestmodelAPIProjectBanner(ctx, v)
			if err != nil {
				return it, err
			}
			it.Banner = data
		case "batchTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchTime"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BatchTime = data
		case "branch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("branch"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Branch = data
		case "buildBaronSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBaronSettings"))
			data, err := ec.unmarshalOBuildBaronSettingsInput2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBaronSettings = data
		case "commitQueue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueue"))
			data, err := ec.unmarshalOCommitQueueParamsInput2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueue = data
		case "containerSizeDefinitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerSizeDefinitions"))
			data, err := ec.unmarshalOContainerResourcesInput2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerSizeDefinitions = data
		case "deactivatePrevious":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deactivatePrevious"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeactivatePrevious = data
		case "debugSpawnHostsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("debugSpawnHostsDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DebugSpawnHostsDisabled = data
		case "disabledStatsCache":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabledStatsCache"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisabledStatsCache = data
		case "dispatchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatchingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatchingDisabled = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "externalLinks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalLinks"))
			data, err := ec.unmarshalOExternalLinkInput2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalLinks = data
		case "githubChecksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubChecksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubChecksEnabled = data
		case "githubDynamicTokenPermissionGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubDynamicTokenPermissionGroups"))
			data, err := ec.unmarshalOGitHubDynamicTokenPermissionGroupInput2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubDynamicTokenPermissionGroups = data
		case "githubPermissionGroupByRequester":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPermissionGroupByRequester"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubPermissionGroupByRequester = data
		case "githubPRTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPRTriggerAliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubPRTriggerAliases = data
		case "githubMQTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubMQTriggerAliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubMQTriggerAliases = data
		case "gitTagAuthorizedTeams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedTeams"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedTeams = data
		case "gitTagAuthorizedUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedUsers"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedUsers = data
		case "gitTagVersionsEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagVersionsEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagVersionsEnabled = data
		case "identifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Identifier = data
		case "manualPrTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manualPrTestingEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManualPRTestingEnabled = data
		case "notifyOnBuildFailure":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifyOnBuildFailure"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotifyOnBuildFailure = data
		case "oldestAllowedMergeBase":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oldestAllowedMergeBase"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OldestAllowedMergeBase = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "parsleyFilters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleyFilters"))
			data, err := ec.unmarshalOParsleyFilterInput2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleyFilters = data
		case "patchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchingDisabled = data
		case "patchTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOPatchTriggerAliasInput2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "perfEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perfEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerfEnabled = data
		case "periodicBuilds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("periodicBuilds"))
			data, err := ec.unmarshalOPeriodicBuildInput2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.PeriodicBuilds = data
		case "projectHealthView":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectHealthView"))
			data, err := ec.unmarshalOProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectHealthView = data
		case "prTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prTestingEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PRTestingEnabled = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "repo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repotrackerDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotrackerDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepotrackerDisabled = data
		case "restricted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("restricted"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Restricted = data
		case "spawnHostScriptPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostScriptPath"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostScriptPath = data
		case "stepbackDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackDisabled = data
		case "stepbackBisect":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackBisect"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackBisect = data
		case "taskAnnotationSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskAnnotationSettings"))
			data, err := ec.unmarshalOTaskAnnotationSettingsInput2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskAnnotationSettings = data
		case "testSelection":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testSelection"))
			data, err := ec.unmarshalOTestSelectionSettingsInput2githubcomevergreencievergreenrestmodelAPITestSelectionSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestSelection = data
		case "tracksPushEvents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracksPushEvents"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TracksPushEvents = data
		case "triggers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			data, err := ec.unmarshalOTriggerAliasInput2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.Triggers = data
		case "versionControlEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionControlEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionControlEnabled = data
		case "workstationConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workstationConfig"))
			data, err := ec.unmarshalOWorkstationConfigInput2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkstationConfig = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectPermissionsOptions(ctx context.Context, obj any) (ProjectPermissionsOptions, error) {
	var it ProjectPermissionsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectSettingsInput(ctx context.Context, obj any) (model.APIProjectSettings, error) {
	var it model.APIProjectSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "aliases", "githubAppAuth", "githubWebhooksEnabled", "projectRef", "subscriptions", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				if err = ec.resolvers.ProjectSettingsInput().ProjectID(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOProjectAliasInput2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "githubAppAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubAppAuth"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOGithubAppAuthInput2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIGithubAppAuth
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIGithubAppAuth); ok {
				it.GithubAppAuth = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIGithubAppAuth`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "githubWebhooksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubWebhooksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubWebhooksEnabled = data
		case "projectRef":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectRef"))
			data, err := ec.unmarshalOProjectInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectRef = data
		case "subscriptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptions"))
			data, err := ec.unmarshalOSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriptions = data
		case "vars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOProjectVarsInput2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIProjectVars
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIProjectVars); ok {
				it.Vars = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectVars`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectTasksPairInput(ctx context.Context, obj any) (model.APIProjectTasksPair, error) {
	var it model.APIProjectTasksPair
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectID", "allowedTasks", "allowedBVs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectID"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectID = data
		case "allowedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedTasks"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowedTasks = data
		case "allowedBVs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedBVs"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowedBVs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectVarsInput(ctx context.Context, obj any) (model.APIProjectVars, error) {
	var it model.APIProjectVars
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"adminOnlyVarsList", "privateVarsList", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "adminOnlyVarsList":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminOnlyVarsList"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminOnlyVarsList = data
		case "privateVarsList":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("privateVarsList"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrivateVarsList = data
		case "vars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Vars = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPromoteVarsToRepoInput(ctx context.Context, obj any) (PromoteVarsToRepoInput, error) {
	var it PromoteVarsToRepoInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "varNames"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "varNames":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("varNames"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VarNames = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPublicKeyInput(ctx context.Context, obj any) (PublicKeyInput, error) {
	var it PublicKeyInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputQuarantineTestInput(ctx context.Context, obj any) (QuarantineTestInput, error) {
	var it QuarantineTestInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"taskId", "testName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "taskId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.TaskID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "testName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputReleaseModeConfigInput(ctx context.Context, obj any) (model.APIReleaseModeConfig, error) {
	var it model.APIReleaseModeConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroMaxHostsFactor", "targetTimeSecondsOverride", "idleTimeSecondsOverride"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroMaxHostsFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroMaxHostsFactor"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroMaxHostsFactor = data
		case "targetTimeSecondsOverride":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetTimeSecondsOverride"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetTimeSecondsOverride = data
		case "idleTimeSecondsOverride":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idleTimeSecondsOverride"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IdleTimeSecondsOverride = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveFavoriteProjectInput(ctx context.Context, obj any) (RemoveFavoriteProjectInput, error) {
	var it RemoveFavoriteProjectInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoPermissionsOptions(ctx context.Context, obj any) (RepoPermissionsOptions, error) {
	var it RepoPermissionsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"repoId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "repoId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoRefInput(ctx context.Context, obj any) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "admins", "batchTime", "buildBaronSettings", "commitQueue", "deactivatePrevious", "disabledStatsCache", "dispatchingDisabled", "displayName", "enabled", "externalLinks", "githubChecksEnabled", "githubDynamicTokenPermissionGroups", "githubPermissionGroupByRequester", "githubPRTriggerAliases", "githubMQTriggerAliases", "gitTagAuthorizedTeams", "gitTagAuthorizedUsers", "gitTagVersionsEnabled", "manualPrTestingEnabled", "notifyOnBuildFailure", "oldestAllowedMergeBase", "owner", "parsleyFilters", "patchingDisabled", "patchTriggerAliases", "perfEnabled", "periodicBuilds", "prTestingEnabled", "remotePath", "repo", "repotrackerDisabled", "restricted", "spawnHostScriptPath", "debugSpawnHostsDisabled", "stepbackDisabled", "stepbackBisect", "taskAnnotationSettings", "testSelection", "tracksPushEvents", "triggers", "versionControlEnabled", "workstationConfig", "containerSizeDefinitions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "admins":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Admins = data
		case "batchTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchTime"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BatchTime = data
		case "buildBaronSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBaronSettings"))
			data, err := ec.unmarshalOBuildBaronSettingsInput2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBaronSettings = data
		case "commitQueue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueue"))
			data, err := ec.unmarshalOCommitQueueParamsInput2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueue = data
		case "deactivatePrevious":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deactivatePrevious"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeactivatePrevious = data
		case "disabledStatsCache":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabledStatsCache"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisabledStatsCache = data
		case "dispatchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatchingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatchingDisabled = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "externalLinks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalLinks"))
			data, err := ec.unmarshalOExternalLinkInput2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalLinks = data
		case "githubChecksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubChecksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubChecksEnabled = data
		case "githubDynamicTokenPermissionGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubDynamicTokenPermissionGroups"))
			data, err := ec.unmarshalOGitHubDynamicTokenPermissionGroupInput2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubDynamicTokenPermissionGroups = data
		case "githubPermissionGroupByRequester":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPermissionGroupByRequester"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubPermissionGroupByRequester = data
		case "githubPRTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPRTriggerAliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubPRTriggerAliases = data
		case "githubMQTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubMQTriggerAliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubMQTriggerAliases = data
		case "gitTagAuthorizedTeams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedTeams"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedTeams = data
		case "gitTagAuthorizedUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedUsers"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedUsers = data
		case "gitTagVersionsEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagVersionsEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagVersionsEnabled = data
		case "manualPrTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manualPrTestingEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManualPRTestingEnabled = data
		case "notifyOnBuildFailure":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifyOnBuildFailure"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotifyOnBuildFailure = data
		case "oldestAllowedMergeBase":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oldestAllowedMergeBase"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OldestAllowedMergeBase = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "parsleyFilters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleyFilters"))
			data, err := ec.unmarshalOParsleyFilterInput2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleyFilters = data
		case "patchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchingDisabled = data
		case "patchTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOPatchTriggerAliasInput2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "perfEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perfEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerfEnabled = data
		case "periodicBuilds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("periodicBuilds"))
			data, err := ec.unmarshalOPeriodicBuildInput2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.PeriodicBuilds = data
		case "prTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prTestingEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PRTestingEnabled = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "repo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repotrackerDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotrackerDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepotrackerDisabled = data
		case "restricted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("restricted"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Restricted = data
		case "spawnHostScriptPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostScriptPath"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostScriptPath = data
		case "debugSpawnHostsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("debugSpawnHostsDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DebugSpawnHostsDisabled = data
		case "stepbackDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackDisabled = data
		case "stepbackBisect":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackBisect"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackBisect = data
		case "taskAnnotationSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskAnnotationSettings"))
			data, err := ec.unmarshalOTaskAnnotationSettingsInput2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskAnnotationSettings = data
		case "testSelection":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testSelection"))
			data, err := ec.unmarshalOTestSelectionSettingsInput2githubcomevergreencievergreenrestmodelAPITestSelectionSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestSelection = data
		case "tracksPushEvents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracksPushEvents"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TracksPushEvents = data
		case "triggers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			data, err := ec.unmarshalOTriggerAliasInput2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.Triggers = data
		case "versionControlEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionControlEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionControlEnabled = data
		case "workstationConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workstationConfig"))
			data, err := ec.unmarshalOWorkstationConfigInput2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkstationConfig = data
		case "containerSizeDefinitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerSizeDefinitions"))
			data, err := ec.unmarshalOContainerResourcesInput2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerSizeDefinitions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoSettingsInput(ctx context.Context, obj any) (model.APIProjectSettings, error) {
	var it model.APIProjectSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"repoId", "aliases", "githubAppAuth", "githubWebhooksEnabled", "projectRef", "subscriptions", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "repoId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				if err = ec.resolvers.RepoSettingsInput().RepoID(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOProjectAliasInput2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "githubAppAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubAppAuth"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOGithubAppAuthInput2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIGithubAppAuth
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIGithubAppAuth); ok {
				it.GithubAppAuth = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIGithubAppAuth`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "githubWebhooksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubWebhooksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubWebhooksEnabled = data
		case "projectRef":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectRef"))
			data, err := ec.unmarshalORepoRefInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectRef = data
		case "subscriptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptions"))
			data, err := ec.unmarshalOSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriptions = data
		case "vars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOProjectVarsInput2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIProjectVars
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIProjectVars); ok {
				it.Vars = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectVars`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepotrackerConfigInput(ctx context.Context, obj any) (model.APIRepoTrackerConfig, error) {
	var it model.APIRepoTrackerConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"numNewRepoRevisionsToFetch", "maxRepoRevisionsToSearch", "maxConcurrentRequests"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "numNewRepoRevisionsToFetch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numNewRepoRevisionsToFetch"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumNewRepoRevisionsToFetch = data
		case "maxRepoRevisionsToSearch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxRepoRevisionsToSearch"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxRepoRevisionsToSearch = data
		case "maxConcurrentRequests":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxConcurrentRequests"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxConcurrentRequests = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourceLimitsInput(ctx context.Context, obj any) (model.APIResourceLimits, error) {
	var it model.APIResourceLimits
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lockedMemoryKb", "numFiles", "numProcesses", "numTasks", "virtualMemoryKb"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lockedMemoryKb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lockedMemoryKb"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LockedMemoryKB = data
		case "numFiles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numFiles"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumFiles = data
		case "numProcesses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numProcesses"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumProcesses = data
		case "numTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numTasks"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumTasks = data
		case "virtualMemoryKb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("virtualMemoryKb"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.VirtualMemoryKB = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRestartAdminTasksOptions(ctx context.Context, obj any) (model1.RestartOptions, error) {
	var it model1.RestartOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"startTime", "endTime", "includeTestFailed", "includeSystemFailed", "includeSetupFailed"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "startTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startTime"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartTime = data
		case "endTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endTime"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndTime = data
		case "includeTestFailed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeTestFailed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeTestFailed = data
		case "includeSystemFailed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeSystemFailed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeSysFailed = data
		case "includeSetupFailed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeSetupFailed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeSetupFailed = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuntimeEnvironmentConfigInput(ctx context.Context, obj any) (model.APIRuntimeEnvironmentsConfig, error) {
	var it model.APIRuntimeEnvironmentsConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"baseUrl", "apiKey"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "baseUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseURL = data
		case "apiKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiKey"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.APIKey = data
			} else if tmp == nil {
				it.APIKey = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputS3CredentialsInput(ctx context.Context, obj any) (model.APIS3Credentials, error) {
	var it model.APIS3Credentials
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "secret", "bucket"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "bucket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bucket"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bucket = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSESConfigInput(ctx context.Context, obj any) (model.APISESConfig, error) {
	var it model.APISESConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"senderAddress"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "senderAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("senderAddress"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.SenderAddress = data
			} else if tmp == nil {
				it.SenderAddress = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSSHConfigInput(ctx context.Context, obj any) (model.APISSHConfig, error) {
	var it model.APISSHConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"taskHostKey", "spawnHostKey"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "taskHostKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskHostKey"))
			data, err := ec.unmarshalOSSHKeyPairInput2githubcomevergreencievergreenrestmodelAPISSHKeyPair(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskHostKey = data
		case "spawnHostKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostKey"))
			data, err := ec.unmarshalOSSHKeyPairInput2githubcomevergreencievergreenrestmodelAPISSHKeyPair(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostKey = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSSHKeyPairInput(ctx context.Context, obj any) (model.APISSHKeyPair, error) {
	var it model.APISSHKeyPair
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "secretARN"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "secretARN":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretARN"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.SecretARN = data
			} else if tmp == nil {
				it.SecretARN = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSaveAdminSettingsInput(ctx context.Context, obj any) (SaveAdminSettingsInput, error) {
	var it SaveAdminSettingsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"adminSettings"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "adminSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminSettings"))
			data, err := ec.unmarshalNAdminSettingsInput2githubcomevergreencievergreenrestmodelAPIAdminSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminSettings = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSaveDistroInput(ctx context.Context, obj any) (SaveDistroInput, error) {
	var it SaveDistroInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distro", "onSave"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distro"))
			data, err := ec.unmarshalNDistroInput2githubcomevergreencievergreenrestmodelAPIDistro(ctx, v)
			if err != nil {
				return it, err
			}
			it.Distro = data
		case "onSave":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onSave"))
			data, err := ec.unmarshalNDistroOnSaveOperation2githubcomevergreencievergreengraphqlDistroOnSaveOperation(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnSave = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSchedulerConfigInput(ctx context.Context, obj any) (model.APISchedulerConfig, error) {
	var it model.APISchedulerConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"taskFinder", "hostAllocator", "hostAllocatorRoundingRule", "hostAllocatorFeedbackRule", "hostsOverallocatedRule", "futureHostFraction", "cacheDurationSeconds", "targetTimeSeconds", "acceptableHostIdleTimeSeconds", "groupVersions", "patchFactor", "patchTimeInQueueFactor", "commitQueueFactor", "mainlineTimeInQueueFactor", "expectedRuntimeFactor", "generateTaskFactor", "numDependentsFactor", "stepbackTaskFactor"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "taskFinder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskFinder"))
			data, err := ec.unmarshalNFinderVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskFinder = data
		case "hostAllocator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocator"))
			data, err := ec.unmarshalNHostAllocatorVersion2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocator = data
		case "hostAllocatorRoundingRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocatorRoundingRule"))
			data, err := ec.unmarshalNRoundingRule2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocatorRoundingRule = data
		case "hostAllocatorFeedbackRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocatorFeedbackRule"))
			data, err := ec.unmarshalNFeedbackRule2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocatorFeedbackRule = data
		case "hostsOverallocatedRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostsOverallocatedRule"))
			data, err := ec.unmarshalNOverallocatedRule2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostsOverallocatedRule = data
		case "futureHostFraction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("futureHostFraction"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FutureHostFraction = data
		case "cacheDurationSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cacheDurationSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CacheDurationSeconds = data
		case "targetTimeSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetTimeSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetTimeSeconds = data
		case "acceptableHostIdleTimeSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acceptableHostIdleTimeSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcceptableHostIdleTimeSeconds = data
		case "groupVersions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupVersions"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupVersions = data
		case "patchFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFactor = data
		case "patchTimeInQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTimeInQueueFactor = data
		case "commitQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueueFactor = data
		case "mainlineTimeInQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainlineTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainlineTimeInQueueFactor = data
		case "expectedRuntimeFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expectedRuntimeFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpectedRuntimeFactor = data
		case "generateTaskFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("generateTaskFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GenerateTaskFactor = data
		case "numDependentsFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numDependentsFactor"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumDependentsFactor = data
		case "stepbackTaskFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackTaskFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackTaskFactor = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSecretsManagerConfigInput(ctx context.Context, obj any) (model.APISecretsManagerConfig, error) {
	var it model.APISecretsManagerConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"secretPrefix"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "secretPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secretPrefix"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.SecretPrefix = data
			} else if tmp == nil {
				it.SecretPrefix = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSelectorInput(ctx context.Context, obj any) (model.APISelector, error) {
	var it model.APISelector
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"data", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputServiceFlagsInput(ctx context.Context, obj any) (model.APIServiceFlags, error) {
	var it model.APIServiceFlags
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"taskDispatchDisabled", "hostInitDisabled", "podInitDisabled", "largeParserProjectsDisabled", "monitorDisabled", "alertsDisabled", "agentStartDisabled", "repotrackerDisabled", "schedulerDisabled", "checkBlockedTasksDisabled", "githubPRTestingDisabled", "cliUpdatesDisabled", "backgroundStatsDisabled", "taskLoggingDisabled", "cacheStatsJobDisabled", "cacheStatsEndpointDisabled", "taskReliabilityDisabled", "hostAllocatorDisabled", "podAllocatorDisabled", "unrecognizedPodCleanupDisabled", "backgroundReauthDisabled", "cloudCleanupDisabled", "debugSpawnHostDisabled", "sleepScheduleDisabled", "staticAPIKeysDisabled", "jwtTokenForCLIDisabled", "systemFailedTaskRestartDisabled", "degradedModeDisabled", "elasticIPsDisabled", "useGitForGitHubFilesDisabled", "releaseModeDisabled", "eventProcessingDisabled", "jiraNotificationsDisabled", "slackNotificationsDisabled", "emailNotificationsDisabled", "webhookNotificationsDisabled", "githubStatusAPIDisabled", "s3LifecycleSyncDisabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "taskDispatchDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskDispatchDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskDispatchDisabled = data
		case "hostInitDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostInitDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostInitDisabled = data
		case "podInitDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("podInitDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PodInitDisabled = data
		case "largeParserProjectsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("largeParserProjectsDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LargeParserProjectsDisabled = data
		case "monitorDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("monitorDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.MonitorDisabled = data
		case "alertsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertsDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertsDisabled = data
		case "agentStartDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agentStartDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgentStartDisabled = data
		case "repotrackerDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotrackerDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepotrackerDisabled = data
		case "schedulerDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schedulerDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SchedulerDisabled = data
		case "checkBlockedTasksDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkBlockedTasksDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CheckBlockedTasksDisabled = data
		case "githubPRTestingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPRTestingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubPRTestingDisabled = data
		case "cliUpdatesDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cliUpdatesDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CLIUpdatesDisabled = data
		case "backgroundStatsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundStatsDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundStatsDisabled = data
		case "taskLoggingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskLoggingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskLoggingDisabled = data
		case "cacheStatsJobDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cacheStatsJobDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CacheStatsJobDisabled = data
		case "cacheStatsEndpointDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cacheStatsEndpointDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CacheStatsEndpointDisabled = data
		case "taskReliabilityDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskReliabilityDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskReliabilityDisabled = data
		case "hostAllocatorDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocatorDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocatorDisabled = data
		case "podAllocatorDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("podAllocatorDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PodAllocatorDisabled = data
		case "unrecognizedPodCleanupDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unrecognizedPodCleanupDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnrecognizedPodCleanupDisabled = data
		case "backgroundReauthDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundReauthDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundReauthDisabled = data
		case "cloudCleanupDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cloudCleanupDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CloudCleanupDisabled = data
		case "debugSpawnHostDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("debugSpawnHostDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DebugSpawnHostDisabled = data
		case "sleepScheduleDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sleepScheduleDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SleepScheduleDisabled = data
		case "staticAPIKeysDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("staticAPIKeysDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StaticAPIKeysDisabled = data
		case "jwtTokenForCLIDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwtTokenForCLIDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.JWTTokenForCLIDisabled = data
		case "systemFailedTaskRestartDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("systemFailedTaskRestartDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SystemFailedTaskRestartDisabled = data
		case "degradedModeDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("degradedModeDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DegradedModeDisabled = data
		case "elasticIPsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("elasticIPsDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ElasticIPsDisabled = data
		case "useGitForGitHubFilesDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useGitForGitHubFilesDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseGitForGitHubFilesDisabled = data
		case "releaseModeDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseModeDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReleaseModeDisabled = data
		case "eventProcessingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventProcessingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventProcessingDisabled = data
		case "jiraNotificationsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jiraNotificationsDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.JIRANotificationsDisabled = data
		case "slackNotificationsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackNotificationsDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackNotificationsDisabled = data
		case "emailNotificationsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotificationsDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNotificationsDisabled = data
		case "webhookNotificationsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookNotificationsDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.WebhookNotificationsDisabled = data
		case "githubStatusAPIDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubStatusAPIDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubStatusAPIDisabled = data
		case "s3LifecycleSyncDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("s3LifecycleSyncDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.S3LifecycleSyncDisabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetLastRevisionInput(ctx context.Context, obj any) (SetLastRevisionInput, error) {
	var it SetLastRevisionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier", "revision"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSingleTaskDistroConfigInput(ctx context.Context, obj any) (model.APISingleTaskDistroConfig, error) {
	var it model.APISingleTaskDistroConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectTasksPairs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectTasksPairs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectTasksPairs"))
			data, err := ec.unmarshalNProjectTasksPairInput2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectTasksPairs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSlackConfigInput(ctx context.Context, obj any) (model.APISlackConfig, error) {
	var it model.APISlackConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"options", "token", "level", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "options":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
			data, err := ec.unmarshalOSlackOptionsInput2githubcomevergreencievergreenrestmodelAPISlackOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.Options = data
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Token = data
			} else if tmp == nil {
				it.Token = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOPriorityLevel2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSlackOptionsInput(ctx context.Context, obj any) (model.APISlackOptions, error) {
	var it model.APISlackOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"channel", "hostname", "name", "username", "basicMetadata", "fields", "allFields", "fieldsSet"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "channel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channel"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Channel = data
		case "hostname":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostname"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hostname = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "basicMetadata":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basicMetadata"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BasicMetadata = data
		case "fields":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fields"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fields = data
		case "allFields":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allFields"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllFields = data
		case "fieldsSet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldsSet"))
			data, err := ec.unmarshalOBooleanMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldsSet = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSleepScheduleConfigInput(ctx context.Context, obj any) (model.APISleepScheduleConfig, error) {
	var it model.APISleepScheduleConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"permanentlyExemptHosts"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "permanentlyExemptHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permanentlyExemptHosts"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermanentlyExemptHosts = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSleepScheduleInput(ctx context.Context, obj any) (host.SleepScheduleInfo, error) {
	var it host.SleepScheduleInfo
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dailyStartTime", "dailyStopTime", "permanentlyExempt", "shouldKeepOff", "timeZone", "temporarilyExemptUntil", "wholeWeekdaysOff"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dailyStartTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dailyStartTime"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DailyStartTime = data
		case "dailyStopTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dailyStopTime"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DailyStopTime = data
		case "permanentlyExempt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permanentlyExempt"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermanentlyExempt = data
		case "shouldKeepOff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shouldKeepOff"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShouldKeepOff = data
		case "timeZone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeZone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeZone = data
		case "temporarilyExemptUntil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("temporarilyExemptUntil"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TemporarilyExemptUntil = data
		case "wholeWeekdaysOff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wholeWeekdaysOff"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.SleepScheduleInput().WholeWeekdaysOff(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSortOrder(ctx context.Context, obj any) (SortOrder, error) {
	var it SortOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Direction", "Key"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Direction"))
			data, err := ec.unmarshalNSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "Key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Key"))
			data, err := ec.unmarshalNTaskSortCategory2githubcomevergreencievergreengraphqlTaskSortCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpawnHostConfigInput(ctx context.Context, obj any) (model.APISpawnHostConfig, error) {
	var it model.APISpawnHostConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"unexpirableHostsPerUser", "unexpirableVolumesPerUser", "spawnHostsPerUser"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "unexpirableHostsPerUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unexpirableHostsPerUser"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnexpirableHostsPerUser = data
		case "unexpirableVolumesPerUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unexpirableVolumesPerUser"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnexpirableVolumesPerUser = data
		case "spawnHostsPerUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostsPerUser"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostsPerUser = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpawnHostInput(ctx context.Context, obj any) (SpawnHostInput, error) {
	var it SpawnHostInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId", "expiration", "homeVolumeSize", "isVirtualWorkStation", "noExpiration", "publicKey", "region", "savePublicKey", "setUpScript", "sleepSchedule", "spawnHostsStartedByTask", "taskId", "useProjectSetupScript", "userDataScript", "useTaskConfig", "volumeId", "useOAuth"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroID = data
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "homeVolumeSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeVolumeSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HomeVolumeSize = data
		case "isVirtualWorkStation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isVirtualWorkStation"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsVirtualWorkStation = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "publicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKey"))
			data, err := ec.unmarshalNPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublicKey = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "savePublicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("savePublicKey"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SavePublicKey = data
		case "setUpScript":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setUpScript"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetUpScript = data
		case "sleepSchedule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sleepSchedule"))
			data, err := ec.unmarshalOSleepScheduleInput2githubcomevergreencievergreenmodelhostSleepScheduleInfo(ctx, v)
			if err != nil {
				return it, err
			}
			it.SleepSchedule = data
		case "spawnHostsStartedByTask":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostsStartedByTask"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostsStartedByTask = data
		case "taskId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskID = data
		case "useProjectSetupScript":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useProjectSetupScript"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseProjectSetupScript = data
		case "userDataScript":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userDataScript"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserDataScript = data
		case "useTaskConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useTaskConfig"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseTaskConfig = data
		case "volumeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		case "useOAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useOAuth"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseOAuth = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpawnVolumeInput(ctx context.Context, obj any) (SpawnVolumeInput, error) {
	var it SpawnVolumeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"availabilityZone", "expiration", "host", "noExpiration", "size", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "availabilityZone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("availabilityZone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvailabilityZone = data
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Host = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSplunkConfigInput(ctx context.Context, obj any) (model.APISplunkConfig, error) {
	var it model.APISplunkConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splunkConnectionInfo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splunkConnectionInfo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splunkConnectionInfo"))
			data, err := ec.unmarshalNSplunkConnectionInfoInput2githubcomevergreencievergreenrestmodelAPISplunkConnectionInfo(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplunkConnectionInfo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSplunkConnectionInfoInput(ctx context.Context, obj any) (model.APISplunkConnectionInfo, error) {
	var it model.APISplunkConnectionInfo
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"serverUrl", "token", "channel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "serverUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serverUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServerURL = data
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Token = data
			} else if tmp == nil {
				it.Token = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "channel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channel"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Channel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubnetInput(ctx context.Context, obj any) (model.APISubnet, error) {
	var it model.APISubnet
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"az", "subnetId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "az":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("az"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AZ = data
		case "subnetId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subnetId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SubnetID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubscriberInput(ctx context.Context, obj any) (model.APISubscriber, error) {
	var it model.APISubscriber
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"target", "type", "webhookSubscriber", "jiraIssueSubscriber"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "target":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.SubscriberInput().Target(ctx, &it, data); err != nil {
				return it, err
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "webhookSubscriber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookSubscriber"))
			data, err := ec.unmarshalOWebhookSubscriberInput2githubcomevergreencievergreenrestmodelAPIWebhookSubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.WebhookSubscriber = data
		case "jiraIssueSubscriber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jiraIssueSubscriber"))
			data, err := ec.unmarshalOJiraIssueSubscriberInput2githubcomevergreencievergreenrestmodelAPIJIRAIssueSubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.JiraIssueSubscriber = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubscriptionInput(ctx context.Context, obj any) (model.APISubscription, error) {
	var it model.APISubscription
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "owner_type", "owner", "regex_selectors", "resource_type", "selectors", "subscriber", "trigger_data", "trigger"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "owner_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner_type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerType = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "regex_selectors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regex_selectors"))
			data, err := ec.unmarshalNSelectorInput2githubcomevergreencievergreenrestmodelAPISelector(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegexSelectors = data
		case "resource_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resource_type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		case "selectors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectors"))
			data, err := ec.unmarshalNSelectorInput2githubcomevergreencievergreenrestmodelAPISelector(ctx, v)
			if err != nil {
				return it, err
			}
			it.Selectors = data
		case "subscriber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriber"))
			data, err := ec.unmarshalNSubscriberInput2githubcomevergreencievergreenrestmodelAPISubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriber = data
		case "trigger_data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trigger_data"))
			data, err := ec.unmarshalNStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.TriggerData = data
		case "trigger":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trigger"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Trigger = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskAnnotationSettingsInput(ctx context.Context, obj any) (model.APITaskAnnotationSettings, error) {
	var it model.APITaskAnnotationSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fileTicketWebhook"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fileTicketWebhook":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileTicketWebhook"))
			data, err := ec.unmarshalOWebhookInput2githubcomevergreencievergreenrestmodelAPIWebHook(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileTicketWebhook = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskCountOptions(ctx context.Context, obj any) (TaskCountOptions, error) {
	var it TaskCountOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"includeNeverActivatedTasks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "includeNeverActivatedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeNeverActivatedTasks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeNeverActivatedTasks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskFilterOptions(ctx context.Context, obj any) (TaskFilterOptions, error) {
	var it TaskFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["baseStatuses"]; !present {
		asMap["baseStatuses"] = []any{}
	}
	if _, present := asMap["includeNeverActivatedTasks"]; !present {
		asMap["includeNeverActivatedTasks"] = false
	}
	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["statuses"]; !present {
		asMap["statuses"] = []any{}
	}

	fieldsInOrder := [...]string{"baseStatuses", "includeNeverActivatedTasks", "limit", "page", "sorts", "statuses", "taskName", "variant"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "baseStatuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseStatuses"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseStatuses = data
		case "includeNeverActivatedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeNeverActivatedTasks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeNeverActivatedTasks = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "sorts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sorts"))
			data, err := ec.unmarshalOSortOrder2githubcomevergreencievergreengraphqlSortOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sorts = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "taskName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskName = data
		case "variant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskHistoryOpts(ctx context.Context, obj any) (TaskHistoryOpts, error) {
	var it TaskHistoryOpts
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 50
	}

	fieldsInOrder := [...]string{"projectIdentifier", "taskName", "buildVariant", "cursorParams", "limit", "date"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectIdentifier = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "taskName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskName = data
		case "buildVariant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildVariant = data
		case "cursorParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorParams"))
			data, err := ec.unmarshalNCursorParams2githubcomevergreencievergreengraphqlCursorParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CursorParams = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskLimitsConfigInput(ctx context.Context, obj any) (model.APITaskLimitsConfig, error) {
	var it model.APITaskLimitsConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"maxTasksPerVersion", "maxIncludesPerVersion", "maxHourlyPatchTasks", "maxPendingGeneratedTasks", "maxGenerateTaskJSONSize", "maxConcurrentLargeParserProjectTasks", "maxDegradedModeConcurrentLargeParserProjectTasks", "maxDegradedModeParserProjectSize", "maxParserProjectSize", "maxExecTimeoutSecs", "maxTaskExecution", "maxDailyAutomaticRestarts"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "maxTasksPerVersion":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTasksPerVersion"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTasksPerVersion = data
		case "maxIncludesPerVersion":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxIncludesPerVersion"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxIncludesPerVersion = data
		case "maxHourlyPatchTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxHourlyPatchTasks"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxHourlyPatchTasks = data
		case "maxPendingGeneratedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPendingGeneratedTasks"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxPendingGeneratedTasks = data
		case "maxGenerateTaskJSONSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGenerateTaskJSONSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGenerateTaskJSONSize = data
		case "maxConcurrentLargeParserProjectTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxConcurrentLargeParserProjectTasks"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxConcurrentLargeParserProjectTasks = data
		case "maxDegradedModeConcurrentLargeParserProjectTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDegradedModeConcurrentLargeParserProjectTasks"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDegradedModeConcurrentLargeParserProjectTasks = data
		case "maxDegradedModeParserProjectSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDegradedModeParserProjectSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDegradedModeParserProjectSize = data
		case "maxParserProjectSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxParserProjectSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxParserProjectSize = data
		case "maxExecTimeoutSecs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxExecTimeoutSecs"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxExecTimeoutSecs = data
		case "maxTaskExecution":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTaskExecution"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTaskExecution = data
		case "maxDailyAutomaticRestarts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDailyAutomaticRestarts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDailyAutomaticRestarts = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskPriority(ctx context.Context, obj any) (TaskPriority, error) {
	var it TaskPriority
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"taskId", "priority"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "taskId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.TaskID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "priority":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Priority = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskSpecifierInput(ctx context.Context, obj any) (model.APITaskSpecifier, error) {
	var it model.APITaskSpecifier
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"patchAlias", "taskRegex", "variantRegex"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "patchAlias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchAlias"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchAlias = data
		case "taskRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskRegex"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskRegex = data
		case "variantRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantRegex"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantRegex = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestFilter(ctx context.Context, obj any) (TestFilter, error) {
	var it TestFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"testName", "testStatus"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "testName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestName = data
		case "testStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testStatus"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestStatus = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestFilterOptions(ctx context.Context, obj any) (TestFilterOptions, error) {
	var it TestFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"testName", "excludeDisplayNames", "statuses", "groupID", "sort", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "testName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestName = data
		case "excludeDisplayNames":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeDisplayNames"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExcludeDisplayNames = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "groupID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupID = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOTestSortOptions2githubcomevergreencievergreengraphqlTestSortOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestSelectionConfigInput(ctx context.Context, obj any) (model.APITestSelectionConfig, error) {
	var it model.APITestSelectionConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestSelectionSettingsInput(ctx context.Context, obj any) (model.APITestSelectionSettings, error) {
	var it model.APITestSelectionSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"allowed", "defaultEnabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "allowed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowed"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Allowed = data
		case "defaultEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultEnabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestSortOptions(ctx context.Context, obj any) (TestSortOptions, error) {
	var it TestSortOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sortBy", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sortBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalNTestSortCategory2githubcomevergreencievergreengraphqlTestSortCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputToolchainOpts(ctx context.Context, obj any) (thirdparty.ToolchainFilterOptions, error) {
	var it thirdparty.ToolchainFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTracerSettingsInput(ctx context.Context, obj any) (model.APITracerSettings, error) {
	var it model.APITracerSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"enabled", "collectorEndpoint", "collectorInternalEndpoint", "collectorAPIKey"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "collectorEndpoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectorEndpoint"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectorEndpoint = data
		case "collectorInternalEndpoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectorInternalEndpoint"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CollectorInternalEndpoint = data
		case "collectorAPIKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("collectorAPIKey"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.CollectorAPIKey = data
			} else if tmp == nil {
				it.CollectorAPIKey = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTriggerAliasInput(ctx context.Context, obj any) (model.APITriggerDefinition, error) {
	var it model.APITriggerDefinition
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"alias", "buildVariantRegex", "configFile", "dateCutoff", "level", "project", "status", "taskRegex", "unscheduleDownstreamVersions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "buildVariantRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantRegex"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildVariantRegex = data
		case "configFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configFile"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigFile = data
		case "dateCutoff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateCutoff"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateCutoff = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "project":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Project = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "taskRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskRegex"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskRegex = data
		case "unscheduleDownstreamVersions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unscheduleDownstreamVersions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnscheduleDownstreamVersions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTriggerConfigInput(ctx context.Context, obj any) (model.APITriggerConfig, error) {
	var it model.APITriggerConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"generateTaskDistro"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "generateTaskDistro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("generateTaskDistro"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GenerateTaskDistro = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUIConfigInput(ctx context.Context, obj any) (model.APIUIConfig, error) {
	var it model.APIUIConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "helpUrl", "uiv2Url", "parsleyUrl", "httpListenAddr", "secret", "defaultProject", "corsOrigins", "fileStreamingContentTypes", "loginDomain", "userVoice", "csrfKey", "cacheTemplates", "stagingEnvironment", "betaFeatures"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Url = data
		case "helpUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("helpUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HelpUrl = data
		case "uiv2Url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uiv2Url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UIv2Url = data
		case "parsleyUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleyUrl"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleyUrl = data
		case "httpListenAddr":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("httpListenAddr"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HttpListenAddr = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "defaultProject":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultProject"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultProject = data
		case "corsOrigins":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("corsOrigins"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CORSOrigins = data
		case "fileStreamingContentTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileStreamingContentTypes"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileStreamingContentTypes = data
		case "loginDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginDomain"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LoginDomain = data
		case "userVoice":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userVoice"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserVoice = data
		case "csrfKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("csrfKey"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.CsrfKey = data
			} else if tmp == nil {
				it.CsrfKey = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "cacheTemplates":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cacheTemplates"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CacheTemplates = data
		case "stagingEnvironment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stagingEnvironment"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StagingEnvironment = data
		case "betaFeatures":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("betaFeatures"))
			data, err := ec.unmarshalNBetaFeaturesInput2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx, v)
			if err != nil {
				return it, err
			}
			it.BetaFeatures = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateBetaFeaturesInput(ctx context.Context, obj any) (UpdateBetaFeaturesInput, error) {
	var it UpdateBetaFeaturesInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"betaFeatures"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "betaFeatures":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("betaFeatures"))
			data, err := ec.unmarshalNBetaFeaturesInput2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx, v)
			if err != nil {
				return it, err
			}
			it.BetaFeatures = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateParsleySettingsInput(ctx context.Context, obj any) (UpdateParsleySettingsInput, error) {
	var it UpdateParsleySettingsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"parsleySettings"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "parsleySettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleySettings"))
			data, err := ec.unmarshalNParsleySettingsInput2githubcomevergreencievergreenrestmodelAPIParsleySettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleySettings = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSpawnHostStatusInput(ctx context.Context, obj any) (UpdateSpawnHostStatusInput, error) {
	var it UpdateSpawnHostStatusInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"action", "hostId", "shouldKeepOff"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "action":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("action"))
			data, err := ec.unmarshalNSpawnHostStatusActions2githubcomevergreencievergreengraphqlSpawnHostStatusActions(ctx, v)
			if err != nil {
				return it, err
			}
			it.Action = data
		case "hostId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireHostAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireHostAccess is not implemented")
				}
				return ec.directives.RequireHostAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.HostID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "shouldKeepOff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shouldKeepOff"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShouldKeepOff = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateVolumeInput(ctx context.Context, obj any) (UpdateVolumeInput, error) {
	var it UpdateVolumeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"expiration", "name", "noExpiration", "size", "volumeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "volumeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUseSpruceOptionsInput(ctx context.Context, obj any) (model.APIUseSpruceOptions, error) {
	var it model.APIUseSpruceOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"spruceV1"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "spruceV1":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spruceV1"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpruceV1 = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserSettingsInput(ctx context.Context, obj any) (model.APIUserSettings, error) {
	var it model.APIUserSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"githubUser", "notifications", "region", "slackUsername", "slackMemberId", "timezone", "useSpruceOptions", "dateFormat", "timeFormat"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "githubUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubUser"))
			data, err := ec.unmarshalOGithubUserInput2githubcomevergreencievergreenrestmodelAPIGithubUser(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubUser = data
		case "notifications":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifications"))
			data, err := ec.unmarshalONotificationsInput2githubcomevergreencievergreenrestmodelAPINotificationPreferences(ctx, v)
			if err != nil {
				return it, err
			}
			it.Notifications = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "slackUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackUsername"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackUsername = data
		case "slackMemberId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackMemberId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackMemberId = data
		case "timezone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timezone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timezone = data
		case "useSpruceOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useSpruceOptions"))
			data, err := ec.unmarshalOUseSpruceOptionsInput2githubcomevergreencievergreenrestmodelAPIUseSpruceOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseSpruceOptions = data
		case "dateFormat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateFormat"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateFormat = data
		case "timeFormat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeFormat"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeFormat = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVariantTasks(ctx context.Context, obj any) (VariantTasks, error) {
	var it VariantTasks
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"displayTasks", "tasks", "variant"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "displayTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayTasks"))
			data, err := ec.unmarshalNDisplayTask2githubcomevergreencievergreengraphqlDisplayTask(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayTasks = data
		case "tasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "variant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVersionToRestart(ctx context.Context, obj any) (model1.VersionToRestart, error) {
	var it model1.VersionToRestart
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"versionId", "taskIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "versionId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionId = data
		case "taskIds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVolumeHost(ctx context.Context, obj any) (VolumeHost, error) {
	var it VolumeHost
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"volumeId", "hostId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "volumeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		case "hostId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWaterfallOptions(ctx context.Context, obj any) (WaterfallOptions, error) {
	var it WaterfallOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 5
	}

	fieldsInOrder := [...]string{"date", "limit", "minOrder", "maxOrder", "omitInactiveBuilds", "projectIdentifier", "requesters", "revision", "statuses", "tasks", "taskCaseSensitive", "variants", "variantCaseSensitive"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "minOrder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minOrder"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinOrder = data
		case "maxOrder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxOrder"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxOrder = data
		case "omitInactiveBuilds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("omitInactiveBuilds"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OmitInactiveBuilds = data
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectIdentifier = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "tasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "taskCaseSensitive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskCaseSensitive"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskCaseSensitive = data
		case "variants":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variants"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variants = data
		case "variantCaseSensitive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantCaseSensitive"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantCaseSensitive = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookHeaderInput(ctx context.Context, obj any) (model.APIWebhookHeader, error) {
	var it model.APIWebhookHeader
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookInput(ctx context.Context, obj any) (model.APIWebHook, error) {
	var it model.APIWebHook
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"endpoint", "secret"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "endpoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpoint"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpoint = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookSubscriberInput(ctx context.Context, obj any) (model.APIWebhookSubscriber, error) {
	var it model.APIWebhookSubscriber
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["retries"]; !present {
		asMap["retries"] = 0
	}
	if _, present := asMap["minDelayMs"]; !present {
		asMap["minDelayMs"] = 0
	}
	if _, present := asMap["timeoutMs"]; !present {
		asMap["timeoutMs"] = 0
	}

	fieldsInOrder := [...]string{"headers", "secret", "url", "retries", "minDelayMs", "timeoutMs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "headers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headers"))
			data, err := ec.unmarshalNWebhookHeaderInput2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx, v)
			if err != nil {
				return it, err
			}
			it.Headers = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "retries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retries"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Retries = data
		case "minDelayMs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minDelayMs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinDelayMS = data
		case "timeoutMs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeoutMs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeoutMS = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkstationConfigInput(ctx context.Context, obj any) (model.APIWorkstationConfig, error) {
	var it model.APIWorkstationConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"gitClone", "setupCommands"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "gitClone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitClone"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitClone = data
		case "setupCommands":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setupCommands"))
			data, err := ec.unmarshalOWorkstationSetupCommandInput2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetupCommands = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkstationSetupCommandInput(ctx context.Context, obj any) (model.APIWorkstationSetupCommand, error) {
	var it model.APIWorkstationSetupCommand
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"command", "directory"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "command":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("command"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Command = data
		case "directory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("directory"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Directory = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var aPIConfigImplementors = []string{"APIConfig"}

func (ec *executionContext) _APIConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIapiConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aPIConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIConfig")
		case "httpListenAddr":
			out.Values[i] = ec._APIConfig_httpListenAddr(ctx, field, obj)
		case "url":
			out.Values[i] = ec._APIConfig_url(ctx, field, obj)
		case "corpUrl":
			out.Values[i] = ec._APIConfig_corpUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aWSAccountRoleMappingImplementors = []string{"AWSAccountRoleMapping"}

func (ec *executionContext) _AWSAccountRoleMapping(ctx context.Context, sel ast.SelectionSet, obj *model.APIAWSAccountRoleMapping) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aWSAccountRoleMappingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AWSAccountRoleMapping")
		case "account":
			out.Values[i] = ec._AWSAccountRoleMapping_account(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "role":
			out.Values[i] = ec._AWSAccountRoleMapping_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aWSConfigImplementors = []string{"AWSConfig"}

func (ec *executionContext) _AWSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAWSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aWSConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AWSConfig")
		case "ec2Keys":
			out.Values[i] = ec._AWSConfig_ec2Keys(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subnets":
			out.Values[i] = ec._AWSConfig_subnets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parserProject":
			out.Values[i] = ec._AWSConfig_parserProject(ctx, field, obj)
		case "persistentDNS":
			out.Values[i] = ec._AWSConfig_persistentDNS(ctx, field, obj)
		case "defaultSecurityGroup":
			out.Values[i] = ec._AWSConfig_defaultSecurityGroup(ctx, field, obj)
		case "allowedInstanceTypes":
			out.Values[i] = ec._AWSConfig_allowedInstanceTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alertableInstanceTypes":
			out.Values[i] = ec._AWSConfig_alertableInstanceTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowedRegions":
			out.Values[i] = ec._AWSConfig_allowedRegions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxVolumeSizePerUser":
			out.Values[i] = ec._AWSConfig_maxVolumeSizePerUser(ctx, field, obj)
		case "pod":
			out.Values[i] = ec._AWSConfig_pod(ctx, field, obj)
		case "accountRoles":
			out.Values[i] = ec._AWSConfig_accountRoles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ipamPoolID":
			out.Values[i] = ec._AWSConfig_ipamPoolID(ctx, field, obj)
		case "elasticIPUsageRate":
			out.Values[i] = ec._AWSConfig_elasticIPUsageRate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aWSPodConfigImplementors = []string{"AWSPodConfig"}

func (ec *executionContext) _AWSPodConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAWSPodConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aWSPodConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AWSPodConfig")
		case "role":
			out.Values[i] = ec._AWSPodConfig_role(ctx, field, obj)
		case "region":
			out.Values[i] = ec._AWSPodConfig_region(ctx, field, obj)
		case "ecs":
			out.Values[i] = ec._AWSPodConfig_ecs(ctx, field, obj)
		case "secretsManager":
			out.Values[i] = ec._AWSPodConfig_secretsManager(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aWSVPCConfigImplementors = []string{"AWSVPCConfig"}

func (ec *executionContext) _AWSVPCConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAWSVPCConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aWSVPCConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AWSVPCConfig")
		case "subnets":
			out.Values[i] = ec._AWSVPCConfig_subnets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "securityGroups":
			out.Values[i] = ec._AWSVPCConfig_securityGroups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var abortInfoImplementors = []string{"AbortInfo"}

func (ec *executionContext) _AbortInfo(ctx context.Context, sel ast.SelectionSet, obj *AbortInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, abortInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AbortInfo")
		case "buildVariantDisplayName":
			out.Values[i] = ec._AbortInfo_buildVariantDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newVersion":
			out.Values[i] = ec._AbortInfo_newVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prClosed":
			out.Values[i] = ec._AbortInfo_prClosed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskDisplayName":
			out.Values[i] = ec._AbortInfo_taskDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskID":
			out.Values[i] = ec._AbortInfo_taskID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._AbortInfo_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminEventImplementors = []string{"AdminEvent"}

func (ec *executionContext) _AdminEvent(ctx context.Context, sel ast.SelectionSet, obj *AdminEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminEvent")
		case "section":
			out.Values[i] = ec._AdminEvent_section(ctx, field, obj)
		case "after":
			out.Values[i] = ec._AdminEvent_after(ctx, field, obj)
		case "before":
			out.Values[i] = ec._AdminEvent_before(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._AdminEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._AdminEvent_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminEventsPayloadImplementors = []string{"AdminEventsPayload"}

func (ec *executionContext) _AdminEventsPayload(ctx context.Context, sel ast.SelectionSet, obj *AdminEventsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminEventsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminEventsPayload")
		case "count":
			out.Values[i] = ec._AdminEventsPayload_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._AdminEventsPayload_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminSettingsImplementors = []string{"AdminSettings"}

func (ec *executionContext) _AdminSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIAdminSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminSettings")
		case "amboy":
			out.Values[i] = ec._AdminSettings_amboy(ctx, field, obj)
		case "amboyDB":
			out.Values[i] = ec._AdminSettings_amboyDB(ctx, field, obj)
		case "api":
			out.Values[i] = ec._AdminSettings_api(ctx, field, obj)
		case "authConfig":
			out.Values[i] = ec._AdminSettings_authConfig(ctx, field, obj)
		case "banner":
			out.Values[i] = ec._AdminSettings_banner(ctx, field, obj)
		case "bannerTheme":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdminSettings_bannerTheme(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buckets":
			out.Values[i] = ec._AdminSettings_buckets(ctx, field, obj)
		case "cedar":
			out.Values[i] = ec._AdminSettings_cedar(ctx, field, obj)
		case "configDir":
			out.Values[i] = ec._AdminSettings_configDir(ctx, field, obj)
		case "containerPools":
			out.Values[i] = ec._AdminSettings_containerPools(ctx, field, obj)
		case "cost":
			out.Values[i] = ec._AdminSettings_cost(ctx, field, obj)
		case "disabledGQLQueries":
			out.Values[i] = ec._AdminSettings_disabledGQLQueries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "domainName":
			out.Values[i] = ec._AdminSettings_domainName(ctx, field, obj)
		case "expansions":
			out.Values[i] = ec._AdminSettings_expansions(ctx, field, obj)
		case "fws":
			out.Values[i] = ec._AdminSettings_fws(ctx, field, obj)
		case "graphite":
			out.Values[i] = ec._AdminSettings_graphite(ctx, field, obj)
		case "githubCheckRun":
			out.Values[i] = ec._AdminSettings_githubCheckRun(ctx, field, obj)
		case "githubOrgs":
			out.Values[i] = ec._AdminSettings_githubOrgs(ctx, field, obj)
		case "githubPRCreatorOrg":
			out.Values[i] = ec._AdminSettings_githubPRCreatorOrg(ctx, field, obj)
		case "githubWebhookSecret":
			out.Values[i] = ec._AdminSettings_githubWebhookSecret(ctx, field, obj)
		case "hostInit":
			out.Values[i] = ec._AdminSettings_hostInit(ctx, field, obj)
		case "hostJasper":
			out.Values[i] = ec._AdminSettings_hostJasper(ctx, field, obj)
		case "jira":
			out.Values[i] = ec._AdminSettings_jira(ctx, field, obj)
		case "jiraNotifications":
			out.Values[i] = ec._AdminSettings_jiraNotifications(ctx, field, obj)
		case "kanopySSHKeyPath":
			out.Values[i] = ec._AdminSettings_kanopySSHKeyPath(ctx, field, obj)
		case "logPath":
			out.Values[i] = ec._AdminSettings_logPath(ctx, field, obj)
		case "loggerConfig":
			out.Values[i] = ec._AdminSettings_loggerConfig(ctx, field, obj)
		case "notify":
			out.Values[i] = ec._AdminSettings_notify(ctx, field, obj)
		case "oldestAllowedCLIVersion":
			out.Values[i] = ec._AdminSettings_oldestAllowedCLIVersion(ctx, field, obj)
		case "parameterStore":
			out.Values[i] = ec._AdminSettings_parameterStore(ctx, field, obj)
		case "perfMonitoringKanopyURL":
			out.Values[i] = ec._AdminSettings_perfMonitoringKanopyURL(ctx, field, obj)
		case "perfMonitoringURL":
			out.Values[i] = ec._AdminSettings_perfMonitoringURL(ctx, field, obj)
		case "podLifecycle":
			out.Values[i] = ec._AdminSettings_podLifecycle(ctx, field, obj)
		case "pprofPort":
			out.Values[i] = ec._AdminSettings_pprofPort(ctx, field, obj)
		case "projectCreation":
			out.Values[i] = ec._AdminSettings_projectCreation(ctx, field, obj)
		case "providers":
			out.Values[i] = ec._AdminSettings_providers(ctx, field, obj)
		case "releaseMode":
			out.Values[i] = ec._AdminSettings_releaseMode(ctx, field, obj)
		case "repotracker":
			out.Values[i] = ec._AdminSettings_repotracker(ctx, field, obj)
		case "runtimeEnvironments":
			out.Values[i] = ec._AdminSettings_runtimeEnvironments(ctx, field, obj)
		case "scheduler":
			out.Values[i] = ec._AdminSettings_scheduler(ctx, field, obj)
		case "serviceFlags":
			out.Values[i] = ec._AdminSettings_serviceFlags(ctx, field, obj)
		case "shutdownWaitSeconds":
			out.Values[i] = ec._AdminSettings_shutdownWaitSeconds(ctx, field, obj)
		case "singleTaskDistro":
			out.Values[i] = ec._AdminSettings_singleTaskDistro(ctx, field, obj)
		case "slack":
			out.Values[i] = ec._AdminSettings_slack(ctx, field, obj)
		case "sleepSchedule":
			out.Values[i] = ec._AdminSettings_sleepSchedule(ctx, field, obj)
		case "spawnhost":
			out.Values[i] = ec._AdminSettings_spawnhost(ctx, field, obj)
		case "splunk":
			out.Values[i] = ec._AdminSettings_splunk(ctx, field, obj)
		case "ssh":
			out.Values[i] = ec._AdminSettings_ssh(ctx, field, obj)
		case "taskLimits":
			out.Values[i] = ec._AdminSettings_taskLimits(ctx, field, obj)
		case "testSelection":
			out.Values[i] = ec._AdminSettings_testSelection(ctx, field, obj)
		case "tracer":
			out.Values[i] = ec._AdminSettings_tracer(ctx, field, obj)
		case "triggers":
			out.Values[i] = ec._AdminSettings_triggers(ctx, field, obj)
		case "ui":
			out.Values[i] = ec._AdminSettings_ui(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminTasksToRestartPayloadImplementors = []string{"AdminTasksToRestartPayload"}

func (ec *executionContext) _AdminTasksToRestartPayload(ctx context.Context, sel ast.SelectionSet, obj *AdminTasksToRestartPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminTasksToRestartPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminTasksToRestartPayload")
		case "tasksToRestart":
			out.Values[i] = ec._AdminTasksToRestartPayload_tasksToRestart(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var amboyConfigImplementors = []string{"AmboyConfig"}

func (ec *executionContext) _AmboyConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAmboyConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, amboyConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AmboyConfig")
		case "name":
			out.Values[i] = ec._AmboyConfig_name(ctx, field, obj)
		case "singleName":
			out.Values[i] = ec._AmboyConfig_singleName(ctx, field, obj)
		case "poolSizeLocal":
			out.Values[i] = ec._AmboyConfig_poolSizeLocal(ctx, field, obj)
		case "poolSizeRemote":
			out.Values[i] = ec._AmboyConfig_poolSizeRemote(ctx, field, obj)
		case "localStorage":
			out.Values[i] = ec._AmboyConfig_localStorage(ctx, field, obj)
		case "groupDefaultWorkers":
			out.Values[i] = ec._AmboyConfig_groupDefaultWorkers(ctx, field, obj)
		case "groupBackgroundCreateFrequencyMinutes":
			out.Values[i] = ec._AmboyConfig_groupBackgroundCreateFrequencyMinutes(ctx, field, obj)
		case "groupPruneFrequencyMinutes":
			out.Values[i] = ec._AmboyConfig_groupPruneFrequencyMinutes(ctx, field, obj)
		case "groupTTLMinutes":
			out.Values[i] = ec._AmboyConfig_groupTTLMinutes(ctx, field, obj)
		case "lockTimeoutMinutes":
			out.Values[i] = ec._AmboyConfig_lockTimeoutMinutes(ctx, field, obj)
		case "sampleSize":
			out.Values[i] = ec._AmboyConfig_sampleSize(ctx, field, obj)
		case "retry":
			out.Values[i] = ec._AmboyConfig_retry(ctx, field, obj)
		case "namedQueues":
			out.Values[i] = ec._AmboyConfig_namedQueues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var amboyDBConfigImplementors = []string{"AmboyDBConfig"}

func (ec *executionContext) _AmboyDBConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAmboyDBConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, amboyDBConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AmboyDBConfig")
		case "url":
			out.Values[i] = ec._AmboyDBConfig_url(ctx, field, obj)
		case "database":
			out.Values[i] = ec._AmboyDBConfig_database(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var amboyNamedQueueConfigImplementors = []string{"AmboyNamedQueueConfig"}

func (ec *executionContext) _AmboyNamedQueueConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAmboyNamedQueueConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, amboyNamedQueueConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AmboyNamedQueueConfig")
		case "name":
			out.Values[i] = ec._AmboyNamedQueueConfig_name(ctx, field, obj)
		case "regexp":
			out.Values[i] = ec._AmboyNamedQueueConfig_regexp(ctx, field, obj)
		case "numWorkers":
			out.Values[i] = ec._AmboyNamedQueueConfig_numWorkers(ctx, field, obj)
		case "sampleSize":
			out.Values[i] = ec._AmboyNamedQueueConfig_sampleSize(ctx, field, obj)
		case "lockTimeoutSeconds":
			out.Values[i] = ec._AmboyNamedQueueConfig_lockTimeoutSeconds(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var amboyRetryConfigImplementors = []string{"AmboyRetryConfig"}

func (ec *executionContext) _AmboyRetryConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAmboyRetryConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, amboyRetryConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AmboyRetryConfig")
		case "numWorkers":
			out.Values[i] = ec._AmboyRetryConfig_numWorkers(ctx, field, obj)
		case "maxCapacity":
			out.Values[i] = ec._AmboyRetryConfig_maxCapacity(ctx, field, obj)
		case "maxRetryAttempts":
			out.Values[i] = ec._AmboyRetryConfig_maxRetryAttempts(ctx, field, obj)
		case "maxRetryTimeSeconds":
			out.Values[i] = ec._AmboyRetryConfig_maxRetryTimeSeconds(ctx, field, obj)
		case "retryBackoffSeconds":
			out.Values[i] = ec._AmboyRetryConfig_retryBackoffSeconds(ctx, field, obj)
		case "staleRetryingMonitorIntervalSeconds":
			out.Values[i] = ec._AmboyRetryConfig_staleRetryingMonitorIntervalSeconds(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var annotationImplementors = []string{"Annotation"}

func (ec *executionContext) _Annotation(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskAnnotation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Annotation")
		case "id":
			out.Values[i] = ec._Annotation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdIssues":
			out.Values[i] = ec._Annotation_createdIssues(ctx, field, obj)
		case "issues":
			out.Values[i] = ec._Annotation_issues(ctx, field, obj)
		case "note":
			out.Values[i] = ec._Annotation_note(ctx, field, obj)
		case "suspectedIssues":
			out.Values[i] = ec._Annotation_suspectedIssues(ctx, field, obj)
		case "metadataLinks":
			out.Values[i] = ec._Annotation_metadataLinks(ctx, field, obj)
		case "taskId":
			out.Values[i] = ec._Annotation_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskExecution":
			out.Values[i] = ec._Annotation_taskExecution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "webhookConfigured":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Annotation_webhookConfigured(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authConfigImplementors = []string{"AuthConfig"}

func (ec *executionContext) _AuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthConfig")
		case "okta":
			out.Values[i] = ec._AuthConfig_okta(ctx, field, obj)
		case "naive":
			out.Values[i] = ec._AuthConfig_naive(ctx, field, obj)
		case "github":
			out.Values[i] = ec._AuthConfig_github(ctx, field, obj)
		case "multi":
			out.Values[i] = ec._AuthConfig_multi(ctx, field, obj)
		case "kanopy":
			out.Values[i] = ec._AuthConfig_kanopy(ctx, field, obj)
		case "oauth":
			out.Values[i] = ec._AuthConfig_oauth(ctx, field, obj)
		case "preferredType":
			out.Values[i] = ec._AuthConfig_preferredType(ctx, field, obj)
		case "backgroundReauthMinutes":
			out.Values[i] = ec._AuthConfig_backgroundReauthMinutes(ctx, field, obj)
		case "allowServiceUsers":
			out.Values[i] = ec._AuthConfig_allowServiceUsers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authUserImplementors = []string{"AuthUser"}

func (ec *executionContext) _AuthUser(ctx context.Context, sel ast.SelectionSet, obj *model.APIAuthUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthUser")
		case "username":
			out.Values[i] = ec._AuthUser_username(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._AuthUser_displayName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._AuthUser_password(ctx, field, obj)
		case "email":
			out.Values[i] = ec._AuthUser_email(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var betaFeaturesImplementors = []string{"BetaFeatures"}

func (ec *executionContext) _BetaFeatures(ctx context.Context, sel ast.SelectionSet, obj *model.APIBetaFeatures) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, betaFeaturesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BetaFeatures")
		case "spruceWaterfallEnabled":
			out.Values[i] = ec._BetaFeatures_spruceWaterfallEnabled(ctx, field, obj)
		case "parsleyAIEnabled":
			out.Values[i] = ec._BetaFeatures_parsleyAIEnabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bootstrapSettingsImplementors = []string{"BootstrapSettings"}

func (ec *executionContext) _BootstrapSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIBootstrapSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bootstrapSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BootstrapSettings")
		case "clientDir":
			out.Values[i] = ec._BootstrapSettings_clientDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "communication":
			out.Values[i] = ec._BootstrapSettings_communication(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "env":
			out.Values[i] = ec._BootstrapSettings_env(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jasperBinaryDir":
			out.Values[i] = ec._BootstrapSettings_jasperBinaryDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jasperCredentialsPath":
			out.Values[i] = ec._BootstrapSettings_jasperCredentialsPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "method":
			out.Values[i] = ec._BootstrapSettings_method(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "preconditionScripts":
			out.Values[i] = ec._BootstrapSettings_preconditionScripts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceLimits":
			out.Values[i] = ec._BootstrapSettings_resourceLimits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rootDir":
			out.Values[i] = ec._BootstrapSettings_rootDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "serviceUser":
			out.Values[i] = ec._BootstrapSettings_serviceUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "shellPath":
			out.Values[i] = ec._BootstrapSettings_shellPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketConfigImplementors = []string{"BucketConfig"}

func (ec *executionContext) _BucketConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIBucketConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BucketConfig")
		case "name":
			out.Values[i] = ec._BucketConfig_name(ctx, field, obj)
		case "testResultsPrefix":
			out.Values[i] = ec._BucketConfig_testResultsPrefix(ctx, field, obj)
		case "roleARN":
			out.Values[i] = ec._BucketConfig_roleARN(ctx, field, obj)
		case "type":
			out.Values[i] = ec._BucketConfig_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bucketsConfigImplementors = []string{"BucketsConfig"}

func (ec *executionContext) _BucketsConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIBucketsConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bucketsConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BucketsConfig")
		case "logBucket":
			out.Values[i] = ec._BucketsConfig_logBucket(ctx, field, obj)
		case "logBucketLongRetention":
			out.Values[i] = ec._BucketsConfig_logBucketLongRetention(ctx, field, obj)
		case "logBucketFailedTasks":
			out.Values[i] = ec._BucketsConfig_logBucketFailedTasks(ctx, field, obj)
		case "longRetentionProjects":
			out.Values[i] = ec._BucketsConfig_longRetentionProjects(ctx, field, obj)
		case "testResultsBucket":
			out.Values[i] = ec._BucketsConfig_testResultsBucket(ctx, field, obj)
		case "internalBuckets":
			out.Values[i] = ec._BucketsConfig_internalBuckets(ctx, field, obj)
		case "credentials":
			out.Values[i] = ec._BucketsConfig_credentials(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildImplementors = []string{"Build"}

func (ec *executionContext) _Build(ctx context.Context, sel ast.SelectionSet, obj *model.APIBuild) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Build")
		case "id":
			out.Values[i] = ec._Build_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actualMakespan":
			out.Values[i] = ec._Build_actualMakespan(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildVariant":
			out.Values[i] = ec._Build_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "predictedMakespan":
			out.Values[i] = ec._Build_predictedMakespan(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Build_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildBaronImplementors = []string{"BuildBaron"}

func (ec *executionContext) _BuildBaron(ctx context.Context, sel ast.SelectionSet, obj *BuildBaron) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildBaronImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildBaron")
		case "bbTicketCreationDefined":
			out.Values[i] = ec._BuildBaron_bbTicketCreationDefined(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildBaronConfigured":
			out.Values[i] = ec._BuildBaron_buildBaronConfigured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "searchReturnInfo":
			out.Values[i] = ec._BuildBaron_searchReturnInfo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildBaronSettingsImplementors = []string{"BuildBaronSettings"}

func (ec *executionContext) _BuildBaronSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIBuildBaronSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildBaronSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildBaronSettings")
		case "bfSuggestionFeaturesURL":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field, obj)
		case "bfSuggestionPassword":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionPassword(ctx, field, obj)
		case "bfSuggestionServer":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionServer(ctx, field, obj)
		case "bfSuggestionTimeoutSecs":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field, obj)
		case "bfSuggestionUsername":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionUsername(ctx, field, obj)
		case "ticketCreateProject":
			out.Values[i] = ec._BuildBaronSettings_ticketCreateProject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ticketSearchProjects":
			out.Values[i] = ec._BuildBaronSettings_ticketSearchProjects(ctx, field, obj)
		case "ticketCreateIssueType":
			out.Values[i] = ec._BuildBaronSettings_ticketCreateIssueType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildVariantTupleImplementors = []string{"BuildVariantTuple"}

func (ec *executionContext) _BuildVariantTuple(ctx context.Context, sel ast.SelectionSet, obj *task.BuildVariantTuple) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildVariantTupleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildVariantTuple")
		case "buildVariant":
			out.Values[i] = ec._BuildVariantTuple_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._BuildVariantTuple_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cedarConfigImplementors = []string{"CedarConfig"}

func (ec *executionContext) _CedarConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APICedarConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cedarConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CedarConfig")
		case "dbUrl":
			out.Values[i] = ec._CedarConfig_dbUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dbName":
			out.Values[i] = ec._CedarConfig_dbName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var childPatchAliasImplementors = []string{"ChildPatchAlias"}

func (ec *executionContext) _ChildPatchAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIChildPatchAlias) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, childPatchAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChildPatchAlias")
		case "alias":
			out.Values[i] = ec._ChildPatchAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchId":
			out.Values[i] = ec._ChildPatchAlias_patchId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var clientBinaryImplementors = []string{"ClientBinary"}

func (ec *executionContext) _ClientBinary(ctx context.Context, sel ast.SelectionSet, obj *model.APIClientBinary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clientBinaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClientBinary")
		case "arch":
			out.Values[i] = ec._ClientBinary_arch(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._ClientBinary_displayName(ctx, field, obj)
		case "os":
			out.Values[i] = ec._ClientBinary_os(ctx, field, obj)
		case "url":
			out.Values[i] = ec._ClientBinary_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var clientConfigImplementors = []string{"ClientConfig"}

func (ec *executionContext) _ClientConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIClientConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clientConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClientConfig")
		case "clientBinaries":
			out.Values[i] = ec._ClientConfig_clientBinaries(ctx, field, obj)
		case "latestRevision":
			out.Values[i] = ec._ClientConfig_latestRevision(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cloudProviderConfigImplementors = []string{"CloudProviderConfig"}

func (ec *executionContext) _CloudProviderConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APICloudProviders) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cloudProviderConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CloudProviderConfig")
		case "aws":
			out.Values[i] = ec._CloudProviderConfig_aws(ctx, field, obj)
		case "docker":
			out.Values[i] = ec._CloudProviderConfig_docker(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var commitQueueParamsImplementors = []string{"CommitQueueParams"}

func (ec *executionContext) _CommitQueueParams(ctx context.Context, sel ast.SelectionSet, obj *model.APICommitQueueParams) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commitQueueParamsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommitQueueParams")
		case "enabled":
			out.Values[i] = ec._CommitQueueParams_enabled(ctx, field, obj)
		case "mergeMethod":
			out.Values[i] = ec._CommitQueueParams_mergeMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._CommitQueueParams_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerPoolImplementors = []string{"ContainerPool"}

func (ec *executionContext) _ContainerPool(ctx context.Context, sel ast.SelectionSet, obj *model.APIContainerPool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerPoolImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerPool")
		case "id":
			out.Values[i] = ec._ContainerPool_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "distro":
			out.Values[i] = ec._ContainerPool_distro(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "maxContainers":
			out.Values[i] = ec._ContainerPool_maxContainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "port":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerPool_port(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerPoolsConfigImplementors = []string{"ContainerPoolsConfig"}

func (ec *executionContext) _ContainerPoolsConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIContainerPoolsConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerPoolsConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerPoolsConfig")
		case "pools":
			out.Values[i] = ec._ContainerPoolsConfig_pools(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerResourcesImplementors = []string{"ContainerResources"}

func (ec *executionContext) _ContainerResources(ctx context.Context, sel ast.SelectionSet, obj *model.APIContainerResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerResourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerResources")
		case "name":
			out.Values[i] = ec._ContainerResources_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cpu":
			out.Values[i] = ec._ContainerResources_cpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "memoryMb":
			out.Values[i] = ec._ContainerResources_memoryMb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var costImplementors = []string{"Cost"}

func (ec *executionContext) _Cost(ctx context.Context, sel ast.SelectionSet, obj *cost.Cost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, costImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Cost")
		case "onDemandEC2Cost":
			out.Values[i] = ec._Cost_onDemandEC2Cost(ctx, field, obj)
		case "adjustedEC2Cost":
			out.Values[i] = ec._Cost_adjustedEC2Cost(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var costConfigImplementors = []string{"CostConfig"}

func (ec *executionContext) _CostConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APICostConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, costConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CostConfig")
		case "financeFormula":
			out.Values[i] = ec._CostConfig_financeFormula(ctx, field, obj)
		case "savingsPlanDiscount":
			out.Values[i] = ec._CostConfig_savingsPlanDiscount(ctx, field, obj)
		case "onDemandDiscount":
			out.Values[i] = ec._CostConfig_onDemandDiscount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var costDataImplementors = []string{"CostData"}

func (ec *executionContext) _CostData(ctx context.Context, sel ast.SelectionSet, obj *model.APICostData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, costDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CostData")
		case "onDemandRate":
			out.Values[i] = ec._CostData_onDemandRate(ctx, field, obj)
		case "savingsPlanRate":
			out.Values[i] = ec._CostData_savingsPlanRate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteDistroPayloadImplementors = []string{"DeleteDistroPayload"}

func (ec *executionContext) _DeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *DeleteDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteDistroPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteDistroPayload")
		case "deletedDistroId":
			out.Values[i] = ec._DeleteDistroPayload_deletedDistroId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteGithubAppCredentialsPayloadImplementors = []string{"DeleteGithubAppCredentialsPayload"}

func (ec *executionContext) _DeleteGithubAppCredentialsPayload(ctx context.Context, sel ast.SelectionSet, obj *DeleteGithubAppCredentialsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteGithubAppCredentialsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteGithubAppCredentialsPayload")
		case "oldAppId":
			out.Values[i] = ec._DeleteGithubAppCredentialsPayload_oldAppId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dependencyImplementors = []string{"Dependency"}

func (ec *executionContext) _Dependency(ctx context.Context, sel ast.SelectionSet, obj *Dependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dependencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dependency")
		case "buildVariant":
			out.Values[i] = ec._Dependency_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "metStatus":
			out.Values[i] = ec._Dependency_metStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Dependency_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requiredStatus":
			out.Values[i] = ec._Dependency_requiredStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._Dependency_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dispatcherSettingsImplementors = []string{"DispatcherSettings"}

func (ec *executionContext) _DispatcherSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIDispatcherSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dispatcherSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DispatcherSettings")
		case "version":
			out.Values[i] = ec._DispatcherSettings_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroImplementors = []string{"Distro"}

func (ec *executionContext) _Distro(ctx context.Context, sel ast.SelectionSet, obj *model.APIDistro) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Distro")
		case "adminOnly":
			out.Values[i] = ec._Distro_adminOnly(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "aliases":
			out.Values[i] = ec._Distro_aliases(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "arch":
			out.Values[i] = ec._Distro_arch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authorizedKeysFile":
			out.Values[i] = ec._Distro_authorizedKeysFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "availableRegions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Distro_availableRegions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bootstrapSettings":
			out.Values[i] = ec._Distro_bootstrapSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "containerPool":
			out.Values[i] = ec._Distro_containerPool(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "disabled":
			out.Values[i] = ec._Distro_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "disableShallowClone":
			out.Values[i] = ec._Distro_disableShallowClone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dispatcherSettings":
			out.Values[i] = ec._Distro_dispatcherSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "execUser":
			out.Values[i] = ec._Distro_execUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expansions":
			out.Values[i] = ec._Distro_expansions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "finderSettings":
			out.Values[i] = ec._Distro_finderSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "homeVolumeSettings":
			out.Values[i] = ec._Distro_homeVolumeSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hostAllocatorSettings":
			out.Values[i] = ec._Distro_hostAllocatorSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "iceCreamSettings":
			out.Values[i] = ec._Distro_iceCreamSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "imageId":
			out.Values[i] = ec._Distro_imageId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isCluster":
			out.Values[i] = ec._Distro_isCluster(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isVirtualWorkStation":
			out.Values[i] = ec._Distro_isVirtualWorkStation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mountpoints":
			out.Values[i] = ec._Distro_mountpoints(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Distro_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "note":
			out.Values[i] = ec._Distro_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "plannerSettings":
			out.Values[i] = ec._Distro_plannerSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "provider":
			out.Values[i] = ec._Distro_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "providerAccount":
			out.Values[i] = ec._Distro_providerAccount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "providerSettingsList":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Distro_providerSettingsList(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "setup":
			out.Values[i] = ec._Distro_setup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "setupAsSudo":
			out.Values[i] = ec._Distro_setupAsSudo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "singleTaskDistro":
			out.Values[i] = ec._Distro_singleTaskDistro(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sshOptions":
			out.Values[i] = ec._Distro_sshOptions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			out.Values[i] = ec._Distro_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userSpawnAllowed":
			out.Values[i] = ec._Distro_userSpawnAllowed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "validProjects":
			out.Values[i] = ec._Distro_validProjects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "warningNote":
			out.Values[i] = ec._Distro_warningNote(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workDir":
			out.Values[i] = ec._Distro_workDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "costData":
			out.Values[i] = ec._Distro_costData(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroEventImplementors = []string{"DistroEvent"}

func (ec *executionContext) _DistroEvent(ctx context.Context, sel ast.SelectionSet, obj *DistroEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroEvent")
		case "after":
			out.Values[i] = ec._DistroEvent_after(ctx, field, obj)
		case "before":
			out.Values[i] = ec._DistroEvent_before(ctx, field, obj)
		case "data":
			out.Values[i] = ec._DistroEvent_data(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._DistroEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._DistroEvent_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroEventsPayloadImplementors = []string{"DistroEventsPayload"}

func (ec *executionContext) _DistroEventsPayload(ctx context.Context, sel ast.SelectionSet, obj *DistroEventsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroEventsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroEventsPayload")
		case "count":
			out.Values[i] = ec._DistroEventsPayload_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._DistroEventsPayload_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroInfoImplementors = []string{"DistroInfo"}

func (ec *executionContext) _DistroInfo(ctx context.Context, sel ast.SelectionSet, obj *model.DistroInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroInfo")
		case "id":
			out.Values[i] = ec._DistroInfo_id(ctx, field, obj)
		case "bootstrapMethod":
			out.Values[i] = ec._DistroInfo_bootstrapMethod(ctx, field, obj)
		case "isVirtualWorkStation":
			out.Values[i] = ec._DistroInfo_isVirtualWorkStation(ctx, field, obj)
		case "isWindows":
			out.Values[i] = ec._DistroInfo_isWindows(ctx, field, obj)
		case "user":
			out.Values[i] = ec._DistroInfo_user(ctx, field, obj)
		case "workDir":
			out.Values[i] = ec._DistroInfo_workDir(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroPermissionsImplementors = []string{"DistroPermissions"}

func (ec *executionContext) _DistroPermissions(ctx context.Context, sel ast.SelectionSet, obj *DistroPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroPermissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroPermissions")
		case "admin":
			out.Values[i] = ec._DistroPermissions_admin(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edit":
			out.Values[i] = ec._DistroPermissions_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "view":
			out.Values[i] = ec._DistroPermissions_view(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dockerConfigImplementors = []string{"DockerConfig"}

func (ec *executionContext) _DockerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIDockerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dockerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DockerConfig")
		case "apiVersion":
			out.Values[i] = ec._DockerConfig_apiVersion(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eC2KeyImplementors = []string{"EC2Key"}

func (ec *executionContext) _EC2Key(ctx context.Context, sel ast.SelectionSet, obj *model.APIEC2Key) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eC2KeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EC2Key")
		case "name":
			out.Values[i] = ec._EC2Key_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "key":
			out.Values[i] = ec._EC2Key_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secret":
			out.Values[i] = ec._EC2Key_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eCSCapacityProviderImplementors = []string{"ECSCapacityProvider"}

func (ec *executionContext) _ECSCapacityProvider(ctx context.Context, sel ast.SelectionSet, obj *model.APIECSCapacityProvider) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eCSCapacityProviderImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ECSCapacityProvider")
		case "name":
			out.Values[i] = ec._ECSCapacityProvider_name(ctx, field, obj)
		case "os":
			out.Values[i] = ec._ECSCapacityProvider_os(ctx, field, obj)
		case "arch":
			out.Values[i] = ec._ECSCapacityProvider_arch(ctx, field, obj)
		case "windowsVersion":
			out.Values[i] = ec._ECSCapacityProvider_windowsVersion(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eCSClusterConfigImplementors = []string{"ECSClusterConfig"}

func (ec *executionContext) _ECSClusterConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIECSClusterConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eCSClusterConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ECSClusterConfig")
		case "name":
			out.Values[i] = ec._ECSClusterConfig_name(ctx, field, obj)
		case "os":
			out.Values[i] = ec._ECSClusterConfig_os(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eCSConfigImplementors = []string{"ECSConfig"}

func (ec *executionContext) _ECSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIECSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eCSConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ECSConfig")
		case "maxCPU":
			out.Values[i] = ec._ECSConfig_maxCPU(ctx, field, obj)
		case "maxMemoryMb":
			out.Values[i] = ec._ECSConfig_maxMemoryMb(ctx, field, obj)
		case "taskDefinitionPrefix":
			out.Values[i] = ec._ECSConfig_taskDefinitionPrefix(ctx, field, obj)
		case "taskRole":
			out.Values[i] = ec._ECSConfig_taskRole(ctx, field, obj)
		case "executionRole":
			out.Values[i] = ec._ECSConfig_executionRole(ctx, field, obj)
		case "logRegion":
			out.Values[i] = ec._ECSConfig_logRegion(ctx, field, obj)
		case "logGroup":
			out.Values[i] = ec._ECSConfig_logGroup(ctx, field, obj)
		case "logStreamPrefix":
			out.Values[i] = ec._ECSConfig_logStreamPrefix(ctx, field, obj)
		case "awsVPC":
			out.Values[i] = ec._ECSConfig_awsVPC(ctx, field, obj)
		case "clusters":
			out.Values[i] = ec._ECSConfig_clusters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "capacityProviders":
			out.Values[i] = ec._ECSConfig_capacityProviders(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowedImages":
			out.Values[i] = ec._ECSConfig_allowedImages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var envVarImplementors = []string{"EnvVar"}

func (ec *executionContext) _EnvVar(ctx context.Context, sel ast.SelectionSet, obj *model.APIEnvVar) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, envVarImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EnvVar")
		case "key":
			out.Values[i] = ec._EnvVar_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._EnvVar_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var expansionImplementors = []string{"Expansion"}

func (ec *executionContext) _Expansion(ctx context.Context, sel ast.SelectionSet, obj *model.APIExpansion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, expansionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Expansion")
		case "key":
			out.Values[i] = ec._Expansion_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._Expansion_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var externalLinkImplementors = []string{"ExternalLink"}

func (ec *executionContext) _ExternalLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIExternalLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalLinkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalLink")
		case "displayName":
			out.Values[i] = ec._ExternalLink_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requesters":
			out.Values[i] = ec._ExternalLink_requesters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "urlTemplate":
			out.Values[i] = ec._ExternalLink_urlTemplate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var externalLinkForMetadataImplementors = []string{"ExternalLinkForMetadata"}

func (ec *executionContext) _ExternalLinkForMetadata(ctx context.Context, sel ast.SelectionSet, obj *ExternalLinkForMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalLinkForMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalLinkForMetadata")
		case "url":
			out.Values[i] = ec._ExternalLinkForMetadata_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._ExternalLinkForMetadata_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fWSConfigImplementors = []string{"FWSConfig"}

func (ec *executionContext) _FWSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIFWSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fWSConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FWSConfig")
		case "url":
			out.Values[i] = ec._FWSConfig_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var failingCommandImplementors = []string{"FailingCommand"}

func (ec *executionContext) _FailingCommand(ctx context.Context, sel ast.SelectionSet, obj *model.APIFailingCommand) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, failingCommandImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FailingCommand")
		case "fullDisplayName":
			out.Values[i] = ec._FailingCommand_fullDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failureMetadataTags":
			out.Values[i] = ec._FailingCommand_failureMetadataTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileImplementors = []string{"File"}

func (ec *executionContext) _File(ctx context.Context, sel ast.SelectionSet, obj *model.APIFile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("File")
		case "link":
			out.Values[i] = ec._File_link(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._File_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "urlParsley":
			out.Values[i] = ec._File_urlParsley(ctx, field, obj)
		case "visibility":
			out.Values[i] = ec._File_visibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileDiffImplementors = []string{"FileDiff"}

func (ec *executionContext) _FileDiff(ctx context.Context, sel ast.SelectionSet, obj *model.FileDiff) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileDiffImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileDiff")
		case "additions":
			out.Values[i] = ec._FileDiff_additions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletions":
			out.Values[i] = ec._FileDiff_deletions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._FileDiff_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "diffLink":
			out.Values[i] = ec._FileDiff_diffLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileName":
			out.Values[i] = ec._FileDiff_fileName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var finderSettingsImplementors = []string{"FinderSettings"}

func (ec *executionContext) _FinderSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIFinderSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, finderSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FinderSettings")
		case "version":
			out.Values[i] = ec._FinderSettings_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var generalSubscriptionImplementors = []string{"GeneralSubscription"}

func (ec *executionContext) _GeneralSubscription(ctx context.Context, sel ast.SelectionSet, obj *model.APISubscription) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, generalSubscriptionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GeneralSubscription")
		case "id":
			out.Values[i] = ec._GeneralSubscription_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ownerType":
			out.Values[i] = ec._GeneralSubscription_ownerType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "regexSelectors":
			out.Values[i] = ec._GeneralSubscription_regexSelectors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._GeneralSubscription_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectors":
			out.Values[i] = ec._GeneralSubscription_selectors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subscriber":
			out.Values[i] = ec._GeneralSubscription_subscriber(ctx, field, obj)
		case "trigger":
			out.Values[i] = ec._GeneralSubscription_trigger(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerData":
			out.Values[i] = ec._GeneralSubscription_triggerData(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var generatedTaskCountResultsImplementors = []string{"GeneratedTaskCountResults"}

func (ec *executionContext) _GeneratedTaskCountResults(ctx context.Context, sel ast.SelectionSet, obj *GeneratedTaskCountResults) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, generatedTaskCountResultsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GeneratedTaskCountResults")
		case "buildVariantName":
			out.Values[i] = ec._GeneratedTaskCountResults_buildVariantName(ctx, field, obj)
		case "taskName":
			out.Values[i] = ec._GeneratedTaskCountResults_taskName(ctx, field, obj)
		case "taskId":
			out.Values[i] = ec._GeneratedTaskCountResults_taskId(ctx, field, obj)
		case "estimatedTasks":
			out.Values[i] = ec._GeneratedTaskCountResults_estimatedTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gitHubAuthConfigImplementors = []string{"GitHubAuthConfig"}

func (ec *executionContext) _GitHubAuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitHubAuthConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitHubAuthConfig")
		case "appId":
			out.Values[i] = ec._GitHubAuthConfig_appId(ctx, field, obj)
		case "clientId":
			out.Values[i] = ec._GitHubAuthConfig_clientId(ctx, field, obj)
		case "clientSecret":
			out.Values[i] = ec._GitHubAuthConfig_clientSecret(ctx, field, obj)
		case "defaultOwner":
			out.Values[i] = ec._GitHubAuthConfig_defaultOwner(ctx, field, obj)
		case "defaultRepo":
			out.Values[i] = ec._GitHubAuthConfig_defaultRepo(ctx, field, obj)
		case "organization":
			out.Values[i] = ec._GitHubAuthConfig_organization(ctx, field, obj)
		case "users":
			out.Values[i] = ec._GitHubAuthConfig_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gitHubCheckRunConfigImplementors = []string{"GitHubCheckRunConfig"}

func (ec *executionContext) _GitHubCheckRunConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIGitHubCheckRunConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitHubCheckRunConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitHubCheckRunConfig")
		case "checkRunLimit":
			out.Values[i] = ec._GitHubCheckRunConfig_checkRunLimit(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gitHubDynamicTokenPermissionGroupImplementors = []string{"GitHubDynamicTokenPermissionGroup"}

func (ec *executionContext) _GitHubDynamicTokenPermissionGroup(ctx context.Context, sel ast.SelectionSet, obj *model.APIGitHubDynamicTokenPermissionGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitHubDynamicTokenPermissionGroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitHubDynamicTokenPermissionGroup")
		case "name":
			out.Values[i] = ec._GitHubDynamicTokenPermissionGroup_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "permissions":
			out.Values[i] = ec._GitHubDynamicTokenPermissionGroup_permissions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gitTagImplementors = []string{"GitTag"}

func (ec *executionContext) _GitTag(ctx context.Context, sel ast.SelectionSet, obj *model.APIGitTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitTag")
		case "tag":
			out.Values[i] = ec._GitTag_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pusher":
			out.Values[i] = ec._GitTag_pusher(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubAppAuthImplementors = []string{"GithubAppAuth"}

func (ec *executionContext) _GithubAppAuth(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubAppAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubAppAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubAppAuth")
		case "appId":
			out.Values[i] = ec._GithubAppAuth_appId(ctx, field, obj)
		case "privateKey":
			out.Values[i] = ec._GithubAppAuth_privateKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubCheckSubscriberImplementors = []string{"GithubCheckSubscriber"}

func (ec *executionContext) _GithubCheckSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubCheckSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubCheckSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubCheckSubscriber")
		case "owner":
			out.Values[i] = ec._GithubCheckSubscriber_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ref":
			out.Values[i] = ec._GithubCheckSubscriber_ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._GithubCheckSubscriber_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubPRSubscriberImplementors = []string{"GithubPRSubscriber"}

func (ec *executionContext) _GithubPRSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubPRSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubPRSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubPRSubscriber")
		case "owner":
			out.Values[i] = ec._GithubPRSubscriber_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prNumber":
			out.Values[i] = ec._GithubPRSubscriber_prNumber(ctx, field, obj)
		case "ref":
			out.Values[i] = ec._GithubPRSubscriber_ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._GithubPRSubscriber_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubPatchImplementors = []string{"GithubPatch"}

func (ec *executionContext) _GithubPatch(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubPatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubPatchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubPatch")
		case "author":
			out.Values[i] = ec._GithubPatch_author(ctx, field, obj)
		case "baseOwner":
			out.Values[i] = ec._GithubPatch_baseOwner(ctx, field, obj)
		case "baseRepo":
			out.Values[i] = ec._GithubPatch_baseRepo(ctx, field, obj)
		case "headBranch":
			out.Values[i] = ec._GithubPatch_headBranch(ctx, field, obj)
		case "headHash":
			out.Values[i] = ec._GithubPatch_headHash(ctx, field, obj)
		case "headOwner":
			out.Values[i] = ec._GithubPatch_headOwner(ctx, field, obj)
		case "headRepo":
			out.Values[i] = ec._GithubPatch_headRepo(ctx, field, obj)
		case "prNumber":
			out.Values[i] = ec._GithubPatch_prNumber(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubProjectConflictsImplementors = []string{"GithubProjectConflicts"}

func (ec *executionContext) _GithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, obj *model1.GithubProjectConflicts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubProjectConflictsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubProjectConflicts")
		case "commitCheckIdentifiers":
			out.Values[i] = ec._GithubProjectConflicts_commitCheckIdentifiers(ctx, field, obj)
		case "commitQueueIdentifiers":
			out.Values[i] = ec._GithubProjectConflicts_commitQueueIdentifiers(ctx, field, obj)
		case "prTestingIdentifiers":
			out.Values[i] = ec._GithubProjectConflicts_prTestingIdentifiers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubUserImplementors = []string{"GithubUser"}

func (ec *executionContext) _GithubUser(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubUser")
		case "lastKnownAs":
			out.Values[i] = ec._GithubUser_lastKnownAs(ctx, field, obj)
		case "uid":
			out.Values[i] = ec._GithubUser_uid(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var graphiteConfigImplementors = []string{"GraphiteConfig"}

func (ec *executionContext) _GraphiteConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIGraphiteConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, graphiteConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GraphiteConfig")
		case "ciOptimizationToken":
			out.Values[i] = ec._GraphiteConfig_ciOptimizationToken(ctx, field, obj)
		case "serverUrl":
			out.Values[i] = ec._GraphiteConfig_serverUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedBuildVariantImplementors = []string{"GroupedBuildVariant"}

func (ec *executionContext) _GroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *GroupedBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedBuildVariantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedBuildVariant")
		case "displayName":
			out.Values[i] = ec._GroupedBuildVariant_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._GroupedBuildVariant_tasks(ctx, field, obj)
		case "variant":
			out.Values[i] = ec._GroupedBuildVariant_variant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedFilesImplementors = []string{"GroupedFiles"}

func (ec *executionContext) _GroupedFiles(ctx context.Context, sel ast.SelectionSet, obj *GroupedFiles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedFilesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedFiles")
		case "files":
			out.Values[i] = ec._GroupedFiles_files(ctx, field, obj)
		case "taskName":
			out.Values[i] = ec._GroupedFiles_taskName(ctx, field, obj)
		case "taskId":
			out.Values[i] = ec._GroupedFiles_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "execution":
			out.Values[i] = ec._GroupedFiles_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedProjectsImplementors = []string{"GroupedProjects"}

func (ec *executionContext) _GroupedProjects(ctx context.Context, sel ast.SelectionSet, obj *GroupedProjects) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedProjectsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedProjects")
		case "groupDisplayName":
			out.Values[i] = ec._GroupedProjects_groupDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "projects":
			out.Values[i] = ec._GroupedProjects_projects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._GroupedProjects_repo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedTaskStatusCountImplementors = []string{"GroupedTaskStatusCount"}

func (ec *executionContext) _GroupedTaskStatusCount(ctx context.Context, sel ast.SelectionSet, obj *task.GroupedTaskStatusCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedTaskStatusCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedTaskStatusCount")
		case "displayName":
			out.Values[i] = ec._GroupedTaskStatusCount_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "statusCounts":
			out.Values[i] = ec._GroupedTaskStatusCount_statusCounts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variant":
			out.Values[i] = ec._GroupedTaskStatusCount_variant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var homeVolumeSettingsImplementors = []string{"HomeVolumeSettings"}

func (ec *executionContext) _HomeVolumeSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIHomeVolumeSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, homeVolumeSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HomeVolumeSettings")
		case "formatCommand":
			out.Values[i] = ec._HomeVolumeSettings_formatCommand(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostImplementors = []string{"Host"}

func (ec *executionContext) _Host(ctx context.Context, sel ast.SelectionSet, obj *model.APIHost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Host")
		case "id":
			out.Values[i] = ec._Host_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "availabilityZone":
			out.Values[i] = ec._Host_availabilityZone(ctx, field, obj)
		case "ami":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_ami(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "displayName":
			out.Values[i] = ec._Host_displayName(ctx, field, obj)
		case "distro":
			out.Values[i] = ec._Host_distro(ctx, field, obj)
		case "distroId":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_distroId(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "elapsed":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_elapsed(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventTypes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_eventTypes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "expiration":
			out.Values[i] = ec._Host_expiration(ctx, field, obj)
		case "hostUrl":
			out.Values[i] = ec._Host_hostUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "homeVolume":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_homeVolume(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "homeVolumeID":
			out.Values[i] = ec._Host_homeVolumeID(ctx, field, obj)
		case "instanceType":
			out.Values[i] = ec._Host_instanceType(ctx, field, obj)
		case "instanceTags":
			out.Values[i] = ec._Host_instanceTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastCommunicationTime":
			out.Values[i] = ec._Host_lastCommunicationTime(ctx, field, obj)
		case "noExpiration":
			out.Values[i] = ec._Host_noExpiration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "persistentDnsName":
			out.Values[i] = ec._Host_persistentDnsName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "provider":
			out.Values[i] = ec._Host_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "runningTask":
			out.Values[i] = ec._Host_runningTask(ctx, field, obj)
		case "sleepSchedule":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_sleepSchedule(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startedBy":
			out.Values[i] = ec._Host_startedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Host_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tag":
			out.Values[i] = ec._Host_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "totalIdleTime":
			out.Values[i] = ec._Host_totalIdleTime(ctx, field, obj)
		case "uptime":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_uptime(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			out.Values[i] = ec._Host_user(ctx, field, obj)
		case "volumes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_volumes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostAllocatorSettingsImplementors = []string{"HostAllocatorSettings"}

func (ec *executionContext) _HostAllocatorSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIHostAllocatorSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostAllocatorSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostAllocatorSettings")
		case "acceptableHostIdleTime":
			out.Values[i] = ec._HostAllocatorSettings_acceptableHostIdleTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "autoTuneMaximumHosts":
			out.Values[i] = ec._HostAllocatorSettings_autoTuneMaximumHosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feedbackRule":
			out.Values[i] = ec._HostAllocatorSettings_feedbackRule(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "futureHostFraction":
			out.Values[i] = ec._HostAllocatorSettings_futureHostFraction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostsOverallocatedRule":
			out.Values[i] = ec._HostAllocatorSettings_hostsOverallocatedRule(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maximumHosts":
			out.Values[i] = ec._HostAllocatorSettings_maximumHosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minimumHosts":
			out.Values[i] = ec._HostAllocatorSettings_minimumHosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roundingRule":
			out.Values[i] = ec._HostAllocatorSettings_roundingRule(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._HostAllocatorSettings_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostEventLogDataImplementors = []string{"HostEventLogData"}

func (ec *executionContext) _HostEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.HostAPIEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventLogDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEventLogData")
		case "agentBuild":
			out.Values[i] = ec._HostEventLogData_agentBuild(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "agentRevision":
			out.Values[i] = ec._HostEventLogData_agentRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "duration":
			out.Values[i] = ec._HostEventLogData_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "execution":
			out.Values[i] = ec._HostEventLogData_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostname":
			out.Values[i] = ec._HostEventLogData_hostname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jasperRevision":
			out.Values[i] = ec._HostEventLogData_jasperRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "logs":
			out.Values[i] = ec._HostEventLogData_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "monitorOp":
			out.Values[i] = ec._HostEventLogData_monitorOp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newStatus":
			out.Values[i] = ec._HostEventLogData_newStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldStatus":
			out.Values[i] = ec._HostEventLogData_oldStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "provisioningMethod":
			out.Values[i] = ec._HostEventLogData_provisioningMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "successful":
			out.Values[i] = ec._HostEventLogData_successful(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._HostEventLogData_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskPid":
			out.Values[i] = ec._HostEventLogData_taskPid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskStatus":
			out.Values[i] = ec._HostEventLogData_taskStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._HostEventLogData_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostEventLogEntryImplementors = []string{"HostEventLogEntry"}

func (ec *executionContext) _HostEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.HostAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEventLogEntry")
		case "id":
			out.Values[i] = ec._HostEventLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._HostEventLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._HostEventLogEntry_eventType(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._HostEventLogEntry_processedAt(ctx, field, obj)
		case "resourceId":
			out.Values[i] = ec._HostEventLogEntry_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._HostEventLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._HostEventLogEntry_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostEventsImplementors = []string{"HostEvents"}

func (ec *executionContext) _HostEvents(ctx context.Context, sel ast.SelectionSet, obj *HostEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEvents")
		case "count":
			out.Values[i] = ec._HostEvents_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._HostEvents_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostInitConfigImplementors = []string{"HostInitConfig"}

func (ec *executionContext) _HostInitConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIHostInitConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostInitConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostInitConfig")
		case "hostThrottle":
			out.Values[i] = ec._HostInitConfig_hostThrottle(ctx, field, obj)
		case "provisioningThrottle":
			out.Values[i] = ec._HostInitConfig_provisioningThrottle(ctx, field, obj)
		case "cloudStatusBatchSize":
			out.Values[i] = ec._HostInitConfig_cloudStatusBatchSize(ctx, field, obj)
		case "maxTotalDynamicHosts":
			out.Values[i] = ec._HostInitConfig_maxTotalDynamicHosts(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostJasperConfigImplementors = []string{"HostJasperConfig"}

func (ec *executionContext) _HostJasperConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIHostJasperConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostJasperConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostJasperConfig")
		case "binaryName":
			out.Values[i] = ec._HostJasperConfig_binaryName(ctx, field, obj)
		case "downloadFileName":
			out.Values[i] = ec._HostJasperConfig_downloadFileName(ctx, field, obj)
		case "port":
			out.Values[i] = ec._HostJasperConfig_port(ctx, field, obj)
		case "url":
			out.Values[i] = ec._HostJasperConfig_url(ctx, field, obj)
		case "version":
			out.Values[i] = ec._HostJasperConfig_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostsResponseImplementors = []string{"HostsResponse"}

func (ec *executionContext) _HostsResponse(ctx context.Context, sel ast.SelectionSet, obj *HostsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostsResponse")
		case "filteredHostsCount":
			out.Values[i] = ec._HostsResponse_filteredHostsCount(ctx, field, obj)
		case "hosts":
			out.Values[i] = ec._HostsResponse_hosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalHostsCount":
			out.Values[i] = ec._HostsResponse_totalHostsCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iceCreamSettingsImplementors = []string{"IceCreamSettings"}

func (ec *executionContext) _IceCreamSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIIceCreamSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iceCreamSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IceCreamSettings")
		case "configPath":
			out.Values[i] = ec._IceCreamSettings_configPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schedulerHost":
			out.Values[i] = ec._IceCreamSettings_schedulerHost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageImplementors = []string{"Image"}

func (ec *executionContext) _Image(ctx context.Context, sel ast.SelectionSet, obj *model.APIImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Image")
		case "id":
			out.Values[i] = ec._Image_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ami":
			out.Values[i] = ec._Image_ami(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "distros":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_distros(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "files":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_files(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lastDeployed":
			out.Values[i] = ec._Image_lastDeployed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "latestTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_latestTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "operatingSystem":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_operatingSystem(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "packages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_packages(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "toolchains":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_toolchains(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageEventImplementors = []string{"ImageEvent"}

func (ec *executionContext) _ImageEvent(ctx context.Context, sel ast.SelectionSet, obj *model.APIImageEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageEvent")
		case "entries":
			out.Values[i] = ec._ImageEvent_entries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ImageEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "amiBefore":
			out.Values[i] = ec._ImageEvent_amiBefore(ctx, field, obj)
		case "amiAfter":
			out.Values[i] = ec._ImageEvent_amiAfter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageEventEntryImplementors = []string{"ImageEventEntry"}

func (ec *executionContext) _ImageEventEntry(ctx context.Context, sel ast.SelectionSet, obj *model.APIImageEventEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageEventEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageEventEntry")
		case "name":
			out.Values[i] = ec._ImageEventEntry_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "after":
			out.Values[i] = ec._ImageEventEntry_after(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "before":
			out.Values[i] = ec._ImageEventEntry_before(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ImageEventEntry_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "action":
			out.Values[i] = ec._ImageEventEntry_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageEventsPayloadImplementors = []string{"ImageEventsPayload"}

func (ec *executionContext) _ImageEventsPayload(ctx context.Context, sel ast.SelectionSet, obj *ImageEventsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageEventsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageEventsPayload")
		case "count":
			out.Values[i] = ec._ImageEventsPayload_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._ImageEventsPayload_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageFileImplementors = []string{"ImageFile"}

func (ec *executionContext) _ImageFile(ctx context.Context, sel ast.SelectionSet, obj *model.APIImageFile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageFileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageFile")
		case "name":
			out.Values[i] = ec._ImageFile_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "path":
			out.Values[i] = ec._ImageFile_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._ImageFile_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageFilesPayloadImplementors = []string{"ImageFilesPayload"}

func (ec *executionContext) _ImageFilesPayload(ctx context.Context, sel ast.SelectionSet, obj *ImageFilesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageFilesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageFilesPayload")
		case "data":
			out.Values[i] = ec._ImageFilesPayload_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredCount":
			out.Values[i] = ec._ImageFilesPayload_filteredCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ImageFilesPayload_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageOperatingSystemPayloadImplementors = []string{"ImageOperatingSystemPayload"}

func (ec *executionContext) _ImageOperatingSystemPayload(ctx context.Context, sel ast.SelectionSet, obj *ImageOperatingSystemPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageOperatingSystemPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageOperatingSystemPayload")
		case "data":
			out.Values[i] = ec._ImageOperatingSystemPayload_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredCount":
			out.Values[i] = ec._ImageOperatingSystemPayload_filteredCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ImageOperatingSystemPayload_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imagePackagesPayloadImplementors = []string{"ImagePackagesPayload"}

func (ec *executionContext) _ImagePackagesPayload(ctx context.Context, sel ast.SelectionSet, obj *ImagePackagesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imagePackagesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImagePackagesPayload")
		case "data":
			out.Values[i] = ec._ImagePackagesPayload_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredCount":
			out.Values[i] = ec._ImagePackagesPayload_filteredCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ImagePackagesPayload_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageToolchainsPayloadImplementors = []string{"ImageToolchainsPayload"}

func (ec *executionContext) _ImageToolchainsPayload(ctx context.Context, sel ast.SelectionSet, obj *ImageToolchainsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageToolchainsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageToolchainsPayload")
		case "data":
			out.Values[i] = ec._ImageToolchainsPayload_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredCount":
			out.Values[i] = ec._ImageToolchainsPayload_filteredCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ImageToolchainsPayload_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var includedLocalModuleImplementors = []string{"IncludedLocalModule"}

func (ec *executionContext) _IncludedLocalModule(ctx context.Context, sel ast.SelectionSet, obj *model.APILocalModuleInclude) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, includedLocalModuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IncludedLocalModule")
		case "module":
			out.Values[i] = ec._IncludedLocalModule_module(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileName":
			out.Values[i] = ec._IncludedLocalModule_fileName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var instanceTagImplementors = []string{"InstanceTag"}

func (ec *executionContext) _InstanceTag(ctx context.Context, sel ast.SelectionSet, obj *host.Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, instanceTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InstanceTag")
		case "canBeModified":
			out.Values[i] = ec._InstanceTag_canBeModified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "key":
			out.Values[i] = ec._InstanceTag_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._InstanceTag_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var issueLinkImplementors = []string{"IssueLink"}

func (ec *executionContext) _IssueLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIIssueLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, issueLinkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IssueLink")
		case "confidenceScore":
			out.Values[i] = ec._IssueLink_confidenceScore(ctx, field, obj)
		case "issueKey":
			out.Values[i] = ec._IssueLink_issueKey(ctx, field, obj)
		case "jiraTicket":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IssueLink_jiraTicket(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "source":
			out.Values[i] = ec._IssueLink_source(ctx, field, obj)
		case "url":
			out.Values[i] = ec._IssueLink_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraConfigImplementors = []string{"JiraConfig"}

func (ec *executionContext) _JiraConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIJiraConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraConfig")
		case "email":
			out.Values[i] = ec._JiraConfig_email(ctx, field, obj)
		case "host":
			out.Values[i] = ec._JiraConfig_host(ctx, field, obj)
		case "personalAccessToken":
			out.Values[i] = ec._JiraConfig_personalAccessToken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraIssueSubscriberImplementors = []string{"JiraIssueSubscriber"}

func (ec *executionContext) _JiraIssueSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIJIRAIssueSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraIssueSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraIssueSubscriber")
		case "issueType":
			out.Values[i] = ec._JiraIssueSubscriber_issueType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec._JiraIssueSubscriber_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraNotificationsConfigImplementors = []string{"JiraNotificationsConfig"}

func (ec *executionContext) _JiraNotificationsConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIJIRANotificationsConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraNotificationsConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraNotificationsConfig")
		case "customFields":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._JiraNotificationsConfig_customFields(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraNotificationsProjectImplementors = []string{"JiraNotificationsProject"}

func (ec *executionContext) _JiraNotificationsProject(ctx context.Context, sel ast.SelectionSet, obj *model.APIJIRANotificationsProject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraNotificationsProjectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraNotificationsProject")
		case "fields":
			out.Values[i] = ec._JiraNotificationsProject_fields(ctx, field, obj)
		case "components":
			out.Values[i] = ec._JiraNotificationsProject_components(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._JiraNotificationsProject_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraNotificationsProjectEntryImplementors = []string{"JiraNotificationsProjectEntry"}

func (ec *executionContext) _JiraNotificationsProjectEntry(ctx context.Context, sel ast.SelectionSet, obj *JiraNotificationsProjectEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraNotificationsProjectEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraNotificationsProjectEntry")
		case "project":
			out.Values[i] = ec._JiraNotificationsProjectEntry_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fields":
			out.Values[i] = ec._JiraNotificationsProjectEntry_fields(ctx, field, obj)
		case "components":
			out.Values[i] = ec._JiraNotificationsProjectEntry_components(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "labels":
			out.Values[i] = ec._JiraNotificationsProjectEntry_labels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraStatusImplementors = []string{"JiraStatus"}

func (ec *executionContext) _JiraStatus(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.JiraStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraStatus")
		case "id":
			out.Values[i] = ec._JiraStatus_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._JiraStatus_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraTicketImplementors = []string{"JiraTicket"}

func (ec *executionContext) _JiraTicket(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.JiraTicket) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraTicketImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraTicket")
		case "fields":
			out.Values[i] = ec._JiraTicket_fields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "key":
			out.Values[i] = ec._JiraTicket_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kanopyAuthConfigImplementors = []string{"KanopyAuthConfig"}

func (ec *executionContext) _KanopyAuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIKanopyAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kanopyAuthConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KanopyAuthConfig")
		case "headerName":
			out.Values[i] = ec._KanopyAuthConfig_headerName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "issuer":
			out.Values[i] = ec._KanopyAuthConfig_issuer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "keysetURL":
			out.Values[i] = ec._KanopyAuthConfig_keysetURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logBufferingImplementors = []string{"LogBuffering"}

func (ec *executionContext) _LogBuffering(ctx context.Context, sel ast.SelectionSet, obj *model.APILogBuffering) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logBufferingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogBuffering")
		case "useAsync":
			out.Values[i] = ec._LogBuffering_useAsync(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "durationSeconds":
			out.Values[i] = ec._LogBuffering_durationSeconds(ctx, field, obj)
		case "count":
			out.Values[i] = ec._LogBuffering_count(ctx, field, obj)
		case "incomingBufferFactor":
			out.Values[i] = ec._LogBuffering_incomingBufferFactor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logMessageImplementors = []string{"LogMessage"}

func (ec *executionContext) _LogMessage(ctx context.Context, sel ast.SelectionSet, obj *apimodels.LogMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logMessageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogMessage")
		case "message":
			out.Values[i] = ec._LogMessage_message(ctx, field, obj)
		case "severity":
			out.Values[i] = ec._LogMessage_severity(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._LogMessage_timestamp(ctx, field, obj)
		case "type":
			out.Values[i] = ec._LogMessage_type(ctx, field, obj)
		case "version":
			out.Values[i] = ec._LogMessage_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var loggerConfigImplementors = []string{"LoggerConfig"}

func (ec *executionContext) _LoggerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APILoggerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loggerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoggerConfig")
		case "buffer":
			out.Values[i] = ec._LoggerConfig_buffer(ctx, field, obj)
		case "defaultLevel":
			out.Values[i] = ec._LoggerConfig_defaultLevel(ctx, field, obj)
		case "thresholdLevel":
			out.Values[i] = ec._LoggerConfig_thresholdLevel(ctx, field, obj)
		case "logkeeperURL":
			out.Values[i] = ec._LoggerConfig_logkeeperURL(ctx, field, obj)
		case "redactKeys":
			out.Values[i] = ec._LoggerConfig_redactKeys(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logkeeperBuildImplementors = []string{"LogkeeperBuild"}

func (ec *executionContext) _LogkeeperBuild(ctx context.Context, sel ast.SelectionSet, obj *plank.Build) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logkeeperBuildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogkeeperBuild")
		case "id":
			out.Values[i] = ec._LogkeeperBuild_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "builder":
			out.Values[i] = ec._LogkeeperBuild_builder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildNum":
			out.Values[i] = ec._LogkeeperBuild_buildNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskId":
			out.Values[i] = ec._LogkeeperBuild_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskExecution":
			out.Values[i] = ec._LogkeeperBuild_taskExecution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tests":
			out.Values[i] = ec._LogkeeperBuild_tests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "task":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LogkeeperBuild_task(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logkeeperTestImplementors = []string{"LogkeeperTest"}

func (ec *executionContext) _LogkeeperTest(ctx context.Context, sel ast.SelectionSet, obj *plank.Test) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logkeeperTestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogkeeperTest")
		case "id":
			out.Values[i] = ec._LogkeeperTest_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._LogkeeperTest_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildId":
			out.Values[i] = ec._LogkeeperTest_buildId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._LogkeeperTest_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskExecution":
			out.Values[i] = ec._LogkeeperTest_taskExecution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phase":
			out.Values[i] = ec._LogkeeperTest_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "command":
			out.Values[i] = ec._LogkeeperTest_command(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mainlineCommitVersionImplementors = []string{"MainlineCommitVersion"}

func (ec *executionContext) _MainlineCommitVersion(ctx context.Context, sel ast.SelectionSet, obj *MainlineCommitVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mainlineCommitVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MainlineCommitVersion")
		case "rolledUpVersions":
			out.Values[i] = ec._MainlineCommitVersion_rolledUpVersions(ctx, field, obj)
		case "version":
			out.Values[i] = ec._MainlineCommitVersion_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mainlineCommitsImplementors = []string{"MainlineCommits"}

func (ec *executionContext) _MainlineCommits(ctx context.Context, sel ast.SelectionSet, obj *MainlineCommits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mainlineCommitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MainlineCommits")
		case "nextPageOrderNumber":
			out.Values[i] = ec._MainlineCommits_nextPageOrderNumber(ctx, field, obj)
		case "prevPageOrderNumber":
			out.Values[i] = ec._MainlineCommits_prevPageOrderNumber(ctx, field, obj)
		case "versions":
			out.Values[i] = ec._MainlineCommits_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var manifestImplementors = []string{"Manifest"}

func (ec *executionContext) _Manifest(ctx context.Context, sel ast.SelectionSet, obj *Manifest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, manifestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Manifest")
		case "id":
			out.Values[i] = ec._Manifest_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "branch":
			out.Values[i] = ec._Manifest_branch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isBase":
			out.Values[i] = ec._Manifest_isBase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "moduleOverrides":
			out.Values[i] = ec._Manifest_moduleOverrides(ctx, field, obj)
		case "modules":
			out.Values[i] = ec._Manifest_modules(ctx, field, obj)
		case "project":
			out.Values[i] = ec._Manifest_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revision":
			out.Values[i] = ec._Manifest_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var metadataLinkImplementors = []string{"MetadataLink"}

func (ec *executionContext) _MetadataLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIMetadataLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metadataLinkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetadataLink")
		case "url":
			out.Values[i] = ec._MetadataLink_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "text":
			out.Values[i] = ec._MetadataLink_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "source":
			out.Values[i] = ec._MetadataLink_source(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var moduleCodeChangeImplementors = []string{"ModuleCodeChange"}

func (ec *executionContext) _ModuleCodeChange(ctx context.Context, sel ast.SelectionSet, obj *model.APIModulePatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, moduleCodeChangeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModuleCodeChange")
		case "branchName":
			out.Values[i] = ec._ModuleCodeChange_branchName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileDiffs":
			out.Values[i] = ec._ModuleCodeChange_fileDiffs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "htmlLink":
			out.Values[i] = ec._ModuleCodeChange_htmlLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rawLink":
			out.Values[i] = ec._ModuleCodeChange_rawLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var multiAuthConfigImplementors = []string{"MultiAuthConfig"}

func (ec *executionContext) _MultiAuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIMultiAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, multiAuthConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MultiAuthConfig")
		case "readWrite":
			out.Values[i] = ec._MultiAuthConfig_readWrite(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "readOnly":
			out.Values[i] = ec._MultiAuthConfig_readOnly(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "bbCreateTicket":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bbCreateTicket(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addAnnotationIssue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addAnnotationIssue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editAnnotationNote":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editAnnotationNote(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "moveAnnotationIssue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_moveAnnotationIssue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeAnnotationIssue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeAnnotationIssue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setAnnotationMetadataLinks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setAnnotationMetadataLinks(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveAdminSettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveAdminSettings(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartAdminTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartAdminTasks(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "copyDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_copyDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reprovisionToNew":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reprovisionToNew(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartJasper":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartJasper(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateHostStatus":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateHostStatus(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setPatchVisibility":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setPatchVisibility(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schedulePatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_schedulePatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachProjectToNewRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachProjectToNewRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachProjectToRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachProjectToRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "copyProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_copyProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deactivateStepbackTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deactivateStepbackTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultSectionToRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_defaultSectionToRepo(ctx, field)
			})
		case "deleteGithubAppCredentials":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGithubAppCredentials(ctx, field)
			})
		case "deleteProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detachProjectFromRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_detachProjectFromRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "forceRepotrackerRun":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_forceRepotrackerRun(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "promoteVarsToRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_promoteVarsToRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveProjectSettingsForSection":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveProjectSettingsForSection(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveRepoSettingsForSection":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveRepoSettingsForSection(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setLastRevision":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setLastRevision(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachVolumeToHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachVolumeToHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detachVolumeFromHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_detachVolumeFromHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editSpawnHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editSpawnHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "migrateVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_migrateVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spawnHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_spawnHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spawnVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_spawnVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSpawnHostStatus":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSpawnHostStatus(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "abortTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_abortTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "overrideTaskDependencies":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_overrideTaskDependencies(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scheduleTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_scheduleTasks(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setTaskPriority":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setTaskPriority(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setTaskPriorities":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setTaskPriorities(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unscheduleTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unscheduleTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "quarantineTest":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_quarantineTest(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addFavoriteProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addFavoriteProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clearMySubscriptions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_clearMySubscriptions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createPublicKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPublicKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSubscriptions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSubscriptions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeFavoriteProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeFavoriteProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removePublicKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removePublicKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resetAPIKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_resetAPIKey(ctx, field)
			})
		case "saveSubscription":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveSubscription(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBetaFeatures":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBetaFeatures(ctx, field)
			})
		case "updateParsleySettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateParsleySettings(ctx, field)
			})
		case "updatePublicKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePublicKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUserSettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserSettings(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartVersions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartVersions(ctx, field)
			})
		case "scheduleUndispatchedBaseTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_scheduleUndispatchedBaseTasks(ctx, field)
			})
		case "setVersionPriority":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setVersionPriority(ctx, field)
			})
		case "unscheduleVersionTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unscheduleVersionTasks(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var naiveAuthConfigImplementors = []string{"NaiveAuthConfig"}

func (ec *executionContext) _NaiveAuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APINaiveAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, naiveAuthConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NaiveAuthConfig")
		case "users":
			out.Values[i] = ec._NaiveAuthConfig_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var newDistroPayloadImplementors = []string{"NewDistroPayload"}

func (ec *executionContext) _NewDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *NewDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, newDistroPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NewDistroPayload")
		case "newDistroId":
			out.Values[i] = ec._NewDistroPayload_newDistroId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var noteImplementors = []string{"Note"}

func (ec *executionContext) _Note(ctx context.Context, sel ast.SelectionSet, obj *model.APINote) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, noteImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Note")
		case "message":
			out.Values[i] = ec._Note_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "source":
			out.Values[i] = ec._Note_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationsImplementors = []string{"Notifications"}

func (ec *executionContext) _Notifications(ctx context.Context, sel ast.SelectionSet, obj *model.APINotificationPreferences) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Notifications")
		case "buildBreak":
			out.Values[i] = ec._Notifications_buildBreak(ctx, field, obj)
		case "buildBreakId":
			out.Values[i] = ec._Notifications_buildBreakId(ctx, field, obj)
		case "patchFinish":
			out.Values[i] = ec._Notifications_patchFinish(ctx, field, obj)
		case "patchFinishId":
			out.Values[i] = ec._Notifications_patchFinishId(ctx, field, obj)
		case "patchFirstFailure":
			out.Values[i] = ec._Notifications_patchFirstFailure(ctx, field, obj)
		case "patchFirstFailureId":
			out.Values[i] = ec._Notifications_patchFirstFailureId(ctx, field, obj)
		case "spawnHostExpiration":
			out.Values[i] = ec._Notifications_spawnHostExpiration(ctx, field, obj)
		case "spawnHostExpirationId":
			out.Values[i] = ec._Notifications_spawnHostExpirationId(ctx, field, obj)
		case "spawnHostOutcome":
			out.Values[i] = ec._Notifications_spawnHostOutcome(ctx, field, obj)
		case "spawnHostOutcomeId":
			out.Values[i] = ec._Notifications_spawnHostOutcomeId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notifyConfigImplementors = []string{"NotifyConfig"}

func (ec *executionContext) _NotifyConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APINotifyConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notifyConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotifyConfig")
		case "ses":
			out.Values[i] = ec._NotifyConfig_ses(ctx, field, obj)
		case "bufferTargetPerInterval":
			out.Values[i] = ec._NotifyConfig_bufferTargetPerInterval(ctx, field, obj)
		case "bufferIntervalSeconds":
			out.Values[i] = ec._NotifyConfig_bufferIntervalSeconds(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oAuthConfigImplementors = []string{"OAuthConfig"}

func (ec *executionContext) _OAuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIOAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuthConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuthConfig")
		case "issuer":
			out.Values[i] = ec._OAuthConfig_issuer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clientId":
			out.Values[i] = ec._OAuthConfig_clientId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectorId":
			out.Values[i] = ec._OAuthConfig_connectorId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oSInfoImplementors = []string{"OSInfo"}

func (ec *executionContext) _OSInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APIOSInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oSInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OSInfo")
		case "name":
			out.Values[i] = ec._OSInfo_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._OSInfo_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oktaConfigImplementors = []string{"OktaConfig"}

func (ec *executionContext) _OktaConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIOktaConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oktaConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OktaConfig")
		case "clientId":
			out.Values[i] = ec._OktaConfig_clientId(ctx, field, obj)
		case "clientSecret":
			out.Values[i] = ec._OktaConfig_clientSecret(ctx, field, obj)
		case "issuer":
			out.Values[i] = ec._OktaConfig_issuer(ctx, field, obj)
		case "scopes":
			out.Values[i] = ec._OktaConfig_scopes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userGroup":
			out.Values[i] = ec._OktaConfig_userGroup(ctx, field, obj)
		case "expireAfterMinutes":
			out.Values[i] = ec._OktaConfig_expireAfterMinutes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oomTrackerInfoImplementors = []string{"OomTrackerInfo"}

func (ec *executionContext) _OomTrackerInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APIOomTrackerInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oomTrackerInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OomTrackerInfo")
		case "detected":
			out.Values[i] = ec._OomTrackerInfo_detected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pids":
			out.Values[i] = ec._OomTrackerInfo_pids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ownerRepoImplementors = []string{"OwnerRepo"}

func (ec *executionContext) _OwnerRepo(ctx context.Context, sel ast.SelectionSet, obj *model.APIOwnerRepo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ownerRepoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OwnerRepo")
		case "owner":
			out.Values[i] = ec._OwnerRepo_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._OwnerRepo_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var packageImplementors = []string{"Package"}

func (ec *executionContext) _Package(ctx context.Context, sel ast.SelectionSet, obj *model.APIPackage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Package")
		case "name":
			out.Values[i] = ec._Package_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "manager":
			out.Values[i] = ec._Package_manager(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Package_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parameterImplementors = []string{"Parameter"}

func (ec *executionContext) _Parameter(ctx context.Context, sel ast.SelectionSet, obj *model.APIParameter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parameterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Parameter")
		case "key":
			out.Values[i] = ec._Parameter_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._Parameter_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parameterStoreConfigImplementors = []string{"ParameterStoreConfig"}

func (ec *executionContext) _ParameterStoreConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIParameterStoreConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parameterStoreConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ParameterStoreConfig")
		case "prefix":
			out.Values[i] = ec._ParameterStoreConfig_prefix(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parserProjectS3ConfigImplementors = []string{"ParserProjectS3Config"}

func (ec *executionContext) _ParserProjectS3Config(ctx context.Context, sel ast.SelectionSet, obj *model.APIParserProjectS3Config) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parserProjectS3ConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ParserProjectS3Config")
		case "key":
			out.Values[i] = ec._ParserProjectS3Config_key(ctx, field, obj)
		case "secret":
			out.Values[i] = ec._ParserProjectS3Config_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "bucket":
			out.Values[i] = ec._ParserProjectS3Config_bucket(ctx, field, obj)
		case "prefix":
			out.Values[i] = ec._ParserProjectS3Config_prefix(ctx, field, obj)
		case "generatedJSONPrefix":
			out.Values[i] = ec._ParserProjectS3Config_generatedJSONPrefix(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parsleyFilterImplementors = []string{"ParsleyFilter"}

func (ec *executionContext) _ParsleyFilter(ctx context.Context, sel ast.SelectionSet, obj *model.APIParsleyFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parsleyFilterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ParsleyFilter")
		case "caseSensitive":
			out.Values[i] = ec._ParsleyFilter_caseSensitive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ParsleyFilter_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exactMatch":
			out.Values[i] = ec._ParsleyFilter_exactMatch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expression":
			out.Values[i] = ec._ParsleyFilter_expression(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parsleySettingsImplementors = []string{"ParsleySettings"}

func (ec *executionContext) _ParsleySettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIParsleySettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parsleySettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ParsleySettings")
		case "sectionsEnabled":
			out.Values[i] = ec._ParsleySettings_sectionsEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jumpToFailingLineEnabled":
			out.Values[i] = ec._ParsleySettings_jumpToFailingLineEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchImplementors = []string{"Patch"}

func (ec *executionContext) _Patch(ctx context.Context, sel ast.SelectionSet, obj *model.APIPatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Patch")
		case "id":
			out.Values[i] = ec._Patch_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activated":
			out.Values[i] = ec._Patch_activated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "alias":
			out.Values[i] = ec._Patch_alias(ctx, field, obj)
		case "author":
			out.Values[i] = ec._Patch_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authorDisplayName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_authorDisplayName(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "baseTaskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_baseTaskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "builds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_builds(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "childPatchAliases":
			out.Values[i] = ec._Patch_childPatchAliases(ctx, field, obj)
		case "childPatches":
			out.Values[i] = ec._Patch_childPatches(ctx, field, obj)
		case "createTime":
			out.Values[i] = ec._Patch_createTime(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Patch_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "duration":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_duration(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "generatedTaskCounts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_generatedTaskCounts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githash":
			out.Values[i] = ec._Patch_githash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "githubPatchData":
			out.Values[i] = ec._Patch_githubPatchData(ctx, field, obj)
		case "hidden":
			out.Values[i] = ec._Patch_hidden(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "includedLocalModules":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_includedLocalModules(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "moduleCodeChanges":
			out.Values[i] = ec._Patch_moduleCodeChanges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parameters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_parameters(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "patchNumber":
			out.Values[i] = ec._Patch_patchNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patchTriggerAliases":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_patchTriggerAliases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "project":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_project(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectID":
			out.Values[i] = ec._Patch_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_projectIdentifier(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectMetadata":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_projectMetadata(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._Patch_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskCount":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_taskCount(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tasks":
			out.Values[i] = ec._Patch_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_taskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "time":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_time(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "variants":
			out.Values[i] = ec._Patch_variants(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "variantsTasks":
			out.Values[i] = ec._Patch_variantsTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "versionFull":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_versionFull(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchDurationImplementors = []string{"PatchDuration"}

func (ec *executionContext) _PatchDuration(ctx context.Context, sel ast.SelectionSet, obj *PatchDuration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchDurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchDuration")
		case "makespan":
			out.Values[i] = ec._PatchDuration_makespan(ctx, field, obj)
		case "time":
			out.Values[i] = ec._PatchDuration_time(ctx, field, obj)
		case "timeTaken":
			out.Values[i] = ec._PatchDuration_timeTaken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchProjectImplementors = []string{"PatchProject"}

func (ec *executionContext) _PatchProject(ctx context.Context, sel ast.SelectionSet, obj *PatchProject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchProjectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchProject")
		case "variants":
			out.Values[i] = ec._PatchProject_variants(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchTimeImplementors = []string{"PatchTime"}

func (ec *executionContext) _PatchTime(ctx context.Context, sel ast.SelectionSet, obj *PatchTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchTimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchTime")
		case "finished":
			out.Values[i] = ec._PatchTime_finished(ctx, field, obj)
		case "started":
			out.Values[i] = ec._PatchTime_started(ctx, field, obj)
		case "submittedAt":
			out.Values[i] = ec._PatchTime_submittedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchTriggerAliasImplementors = []string{"PatchTriggerAlias"}

func (ec *executionContext) _PatchTriggerAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIPatchTriggerDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchTriggerAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchTriggerAlias")
		case "alias":
			out.Values[i] = ec._PatchTriggerAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "childProjectId":
			out.Values[i] = ec._PatchTriggerAlias_childProjectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "childProjectIdentifier":
			out.Values[i] = ec._PatchTriggerAlias_childProjectIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parentAsModule":
			out.Values[i] = ec._PatchTriggerAlias_parentAsModule(ctx, field, obj)
		case "status":
			out.Values[i] = ec._PatchTriggerAlias_status(ctx, field, obj)
		case "downstreamRevision":
			out.Values[i] = ec._PatchTriggerAlias_downstreamRevision(ctx, field, obj)
		case "taskSpecifiers":
			out.Values[i] = ec._PatchTriggerAlias_taskSpecifiers(ctx, field, obj)
		case "variantsTasks":
			out.Values[i] = ec._PatchTriggerAlias_variantsTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchesImplementors = []string{"Patches"}

func (ec *executionContext) _Patches(ctx context.Context, sel ast.SelectionSet, obj *Patches) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Patches")
		case "filteredPatchCount":
			out.Values[i] = ec._Patches_filteredPatchCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patches":
			out.Values[i] = ec._Patches_patches(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var periodicBuildImplementors = []string{"PeriodicBuild"}

func (ec *executionContext) _PeriodicBuild(ctx context.Context, sel ast.SelectionSet, obj *model.APIPeriodicBuildDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, periodicBuildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PeriodicBuild")
		case "id":
			out.Values[i] = ec._PeriodicBuild_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alias":
			out.Values[i] = ec._PeriodicBuild_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configFile":
			out.Values[i] = ec._PeriodicBuild_configFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "intervalHours":
			out.Values[i] = ec._PeriodicBuild_intervalHours(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cron":
			out.Values[i] = ec._PeriodicBuild_cron(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._PeriodicBuild_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextRunTime":
			out.Values[i] = ec._PeriodicBuild_nextRunTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var permissionsImplementors = []string{"Permissions"}

func (ec *executionContext) _Permissions(ctx context.Context, sel ast.SelectionSet, obj *Permissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, permissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Permissions")
		case "canCreateDistro":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canCreateDistro(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canCreateProject":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canCreateProject(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canEditAdminSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canEditAdminSettings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "distroPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_distroPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_projectPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "repoPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_repoPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userId":
			out.Values[i] = ec._Permissions_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var persistentDNSConfigImplementors = []string{"PersistentDNSConfig"}

func (ec *executionContext) _PersistentDNSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIPersistentDNSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, persistentDNSConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PersistentDNSConfig")
		case "hostedZoneID":
			out.Values[i] = ec._PersistentDNSConfig_hostedZoneID(ctx, field, obj)
		case "domain":
			out.Values[i] = ec._PersistentDNSConfig_domain(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var plannerSettingsImplementors = []string{"PlannerSettings"}

func (ec *executionContext) _PlannerSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIPlannerSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plannerSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlannerSettings")
		case "commitQueueFactor":
			out.Values[i] = ec._PlannerSettings_commitQueueFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expectedRuntimeFactor":
			out.Values[i] = ec._PlannerSettings_expectedRuntimeFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "generateTaskFactor":
			out.Values[i] = ec._PlannerSettings_generateTaskFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numDependentsFactor":
			out.Values[i] = ec._PlannerSettings_numDependentsFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "groupVersions":
			out.Values[i] = ec._PlannerSettings_groupVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainlineTimeInQueueFactor":
			out.Values[i] = ec._PlannerSettings_mainlineTimeInQueueFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchFactor":
			out.Values[i] = ec._PlannerSettings_patchFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchTimeInQueueFactor":
			out.Values[i] = ec._PlannerSettings_patchTimeInQueueFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "targetTime":
			out.Values[i] = ec._PlannerSettings_targetTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._PlannerSettings_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podImplementors = []string{"Pod"}

func (ec *executionContext) _Pod(ctx context.Context, sel ast.SelectionSet, obj *model.APIPod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pod")
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "id":
			out.Values[i] = ec._Pod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "task":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_task(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskContainerCreationOpts":
			out.Values[i] = ec._Pod_taskContainerCreationOpts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podEventLogDataImplementors = []string{"PodEventLogData"}

func (ec *executionContext) _PodEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.PodAPIEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventLogDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEventLogData")
		case "oldStatus":
			out.Values[i] = ec._PodEventLogData_oldStatus(ctx, field, obj)
		case "newStatus":
			out.Values[i] = ec._PodEventLogData_newStatus(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._PodEventLogData_reason(ctx, field, obj)
		case "taskID":
			out.Values[i] = ec._PodEventLogData_taskID(ctx, field, obj)
		case "taskExecution":
			out.Values[i] = ec._PodEventLogData_taskExecution(ctx, field, obj)
		case "taskStatus":
			out.Values[i] = ec._PodEventLogData_taskStatus(ctx, field, obj)
		case "task":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PodEventLogData_task(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podEventLogEntryImplementors = []string{"PodEventLogEntry"}

func (ec *executionContext) _PodEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.PodAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEventLogEntry")
		case "id":
			out.Values[i] = ec._PodEventLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._PodEventLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._PodEventLogEntry_eventType(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._PodEventLogEntry_processedAt(ctx, field, obj)
		case "resourceId":
			out.Values[i] = ec._PodEventLogEntry_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._PodEventLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._PodEventLogEntry_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podEventsImplementors = []string{"PodEvents"}

func (ec *executionContext) _PodEvents(ctx context.Context, sel ast.SelectionSet, obj *PodEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEvents")
		case "count":
			out.Values[i] = ec._PodEvents_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._PodEvents_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podLifecycleConfigImplementors = []string{"PodLifecycleConfig"}

func (ec *executionContext) _PodLifecycleConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIPodLifecycleConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podLifecycleConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodLifecycleConfig")
		case "maxParallelPodRequests":
			out.Values[i] = ec._PodLifecycleConfig_maxParallelPodRequests(ctx, field, obj)
		case "maxPodDefinitionCleanupRate":
			out.Values[i] = ec._PodLifecycleConfig_maxPodDefinitionCleanupRate(ctx, field, obj)
		case "maxSecretCleanupRate":
			out.Values[i] = ec._PodLifecycleConfig_maxSecretCleanupRate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var preconditionScriptImplementors = []string{"PreconditionScript"}

func (ec *executionContext) _PreconditionScript(ctx context.Context, sel ast.SelectionSet, obj *model.APIPreconditionScript) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preconditionScriptImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreconditionScript")
		case "path":
			out.Values[i] = ec._PreconditionScript_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "script":
			out.Values[i] = ec._PreconditionScript_script(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectImplementors = []string{"Project"}

func (ec *executionContext) _Project(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectRef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Project")
		case "id":
			out.Values[i] = ec._Project_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "admins":
			out.Values[i] = ec._Project_admins(ctx, field, obj)
		case "banner":
			out.Values[i] = ec._Project_banner(ctx, field, obj)
		case "batchTime":
			out.Values[i] = ec._Project_batchTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "branch":
			out.Values[i] = ec._Project_branch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildBaronSettings":
			out.Values[i] = ec._Project_buildBaronSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "commitQueue":
			out.Values[i] = ec._Project_commitQueue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "containerSizeDefinitions":
			out.Values[i] = ec._Project_containerSizeDefinitions(ctx, field, obj)
		case "deactivatePrevious":
			out.Values[i] = ec._Project_deactivatePrevious(ctx, field, obj)
		case "debugSpawnHostsDisabled":
			out.Values[i] = ec._Project_debugSpawnHostsDisabled(ctx, field, obj)
		case "disabledStatsCache":
			out.Values[i] = ec._Project_disabledStatsCache(ctx, field, obj)
		case "dispatchingDisabled":
			out.Values[i] = ec._Project_dispatchingDisabled(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Project_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "enabled":
			out.Values[i] = ec._Project_enabled(ctx, field, obj)
		case "externalLinks":
			out.Values[i] = ec._Project_externalLinks(ctx, field, obj)
		case "githubChecksEnabled":
			out.Values[i] = ec._Project_githubChecksEnabled(ctx, field, obj)
		case "githubDynamicTokenPermissionGroups":
			out.Values[i] = ec._Project_githubDynamicTokenPermissionGroups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "githubPermissionGroupByRequester":
			out.Values[i] = ec._Project_githubPermissionGroupByRequester(ctx, field, obj)
		case "githubPRTriggerAliases":
			out.Values[i] = ec._Project_githubPRTriggerAliases(ctx, field, obj)
		case "githubMQTriggerAliases":
			out.Values[i] = ec._Project_githubMQTriggerAliases(ctx, field, obj)
		case "gitTagAuthorizedTeams":
			out.Values[i] = ec._Project_gitTagAuthorizedTeams(ctx, field, obj)
		case "gitTagAuthorizedUsers":
			out.Values[i] = ec._Project_gitTagAuthorizedUsers(ctx, field, obj)
		case "gitTagVersionsEnabled":
			out.Values[i] = ec._Project_gitTagVersionsEnabled(ctx, field, obj)
		case "hidden":
			out.Values[i] = ec._Project_hidden(ctx, field, obj)
		case "identifier":
			out.Values[i] = ec._Project_identifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isFavorite":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_isFavorite(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manualPrTestingEnabled":
			out.Values[i] = ec._Project_manualPrTestingEnabled(ctx, field, obj)
		case "notifyOnBuildFailure":
			out.Values[i] = ec._Project_notifyOnBuildFailure(ctx, field, obj)
		case "oldestAllowedMergeBase":
			out.Values[i] = ec._Project_oldestAllowedMergeBase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "owner":
			out.Values[i] = ec._Project_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parsleyFilters":
			out.Values[i] = ec._Project_parsleyFilters(ctx, field, obj)
		case "patches":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_patches(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "patchingDisabled":
			out.Values[i] = ec._Project_patchingDisabled(ctx, field, obj)
		case "patchTriggerAliases":
			out.Values[i] = ec._Project_patchTriggerAliases(ctx, field, obj)
		case "perfEnabled":
			out.Values[i] = ec._Project_perfEnabled(ctx, field, obj)
		case "periodicBuilds":
			out.Values[i] = ec._Project_periodicBuilds(ctx, field, obj)
		case "projectHealthView":
			out.Values[i] = ec._Project_projectHealthView(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "prTestingEnabled":
			out.Values[i] = ec._Project_prTestingEnabled(ctx, field, obj)
		case "remotePath":
			out.Values[i] = ec._Project_remotePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repo":
			out.Values[i] = ec._Project_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repoRefId":
			out.Values[i] = ec._Project_repoRefId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repotrackerDisabled":
			out.Values[i] = ec._Project_repotrackerDisabled(ctx, field, obj)
		case "repotrackerError":
			out.Values[i] = ec._Project_repotrackerError(ctx, field, obj)
		case "restricted":
			out.Values[i] = ec._Project_restricted(ctx, field, obj)
		case "spawnHostScriptPath":
			out.Values[i] = ec._Project_spawnHostScriptPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stepbackDisabled":
			out.Values[i] = ec._Project_stepbackDisabled(ctx, field, obj)
		case "stepbackBisect":
			out.Values[i] = ec._Project_stepbackBisect(ctx, field, obj)
		case "taskAnnotationSettings":
			out.Values[i] = ec._Project_taskAnnotationSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "testSelection":
			out.Values[i] = ec._Project_testSelection(ctx, field, obj)
		case "tracksPushEvents":
			out.Values[i] = ec._Project_tracksPushEvents(ctx, field, obj)
		case "triggers":
			out.Values[i] = ec._Project_triggers(ctx, field, obj)
		case "versionControlEnabled":
			out.Values[i] = ec._Project_versionControlEnabled(ctx, field, obj)
		case "workstationConfig":
			out.Values[i] = ec._Project_workstationConfig(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectAliasImplementors = []string{"ProjectAlias"}

func (ec *executionContext) _ProjectAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectAlias) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectAlias")
		case "id":
			out.Values[i] = ec._ProjectAlias_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alias":
			out.Values[i] = ec._ProjectAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ProjectAlias_description(ctx, field, obj)
		case "gitTag":
			out.Values[i] = ec._ProjectAlias_gitTag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remotePath":
			out.Values[i] = ec._ProjectAlias_remotePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "task":
			out.Values[i] = ec._ProjectAlias_task(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskTags":
			out.Values[i] = ec._ProjectAlias_taskTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variant":
			out.Values[i] = ec._ProjectAlias_variant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variantTags":
			out.Values[i] = ec._ProjectAlias_variantTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parameters":
			out.Values[i] = ec._ProjectAlias_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectBannerImplementors = []string{"ProjectBanner"}

func (ec *executionContext) _ProjectBanner(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectBanner) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectBannerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectBanner")
		case "text":
			out.Values[i] = ec._ProjectBanner_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "theme":
			out.Values[i] = ec._ProjectBanner_theme(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectBuildVariantImplementors = []string{"ProjectBuildVariant"}

func (ec *executionContext) _ProjectBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *ProjectBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectBuildVariantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectBuildVariant")
		case "displayName":
			out.Values[i] = ec._ProjectBuildVariant_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ProjectBuildVariant_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._ProjectBuildVariant_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectCreationConfigImplementors = []string{"ProjectCreationConfig"}

func (ec *executionContext) _ProjectCreationConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectCreationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectCreationConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectCreationConfig")
		case "totalProjectLimit":
			out.Values[i] = ec._ProjectCreationConfig_totalProjectLimit(ctx, field, obj)
		case "repoProjectLimit":
			out.Values[i] = ec._ProjectCreationConfig_repoProjectLimit(ctx, field, obj)
		case "repoExceptions":
			out.Values[i] = ec._ProjectCreationConfig_repoExceptions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jiraProject":
			out.Values[i] = ec._ProjectCreationConfig_jiraProject(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectEventLogEntryImplementors = []string{"ProjectEventLogEntry"}

func (ec *executionContext) _ProjectEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEventLogEntry")
		case "after":
			out.Values[i] = ec._ProjectEventLogEntry_after(ctx, field, obj)
		case "before":
			out.Values[i] = ec._ProjectEventLogEntry_before(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._ProjectEventLogEntry_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._ProjectEventLogEntry_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectEventSettingsImplementors = []string{"ProjectEventSettings"}

func (ec *executionContext) _ProjectEventSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectEventSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEventSettings")
		case "aliases":
			out.Values[i] = ec._ProjectEventSettings_aliases(ctx, field, obj)
		case "githubAppAuth":
			out.Values[i] = ec._ProjectEventSettings_githubAppAuth(ctx, field, obj)
		case "githubWebhooksEnabled":
			out.Values[i] = ec._ProjectEventSettings_githubWebhooksEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "projectRef":
			out.Values[i] = ec._ProjectEventSettings_projectRef(ctx, field, obj)
		case "subscriptions":
			out.Values[i] = ec._ProjectEventSettings_subscriptions(ctx, field, obj)
		case "vars":
			out.Values[i] = ec._ProjectEventSettings_vars(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectEventsImplementors = []string{"ProjectEvents"}

func (ec *executionContext) _ProjectEvents(ctx context.Context, sel ast.SelectionSet, obj *ProjectEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEvents")
		case "count":
			out.Values[i] = ec._ProjectEvents_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._ProjectEvents_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectPermissionsImplementors = []string{"ProjectPermissions"}

func (ec *executionContext) _ProjectPermissions(ctx context.Context, sel ast.SelectionSet, obj *ProjectPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectPermissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectPermissions")
		case "edit":
			out.Values[i] = ec._ProjectPermissions_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "view":
			out.Values[i] = ec._ProjectPermissions_view(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectSettingsImplementors = []string{"ProjectSettings"}

func (ec *executionContext) _ProjectSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectSettings")
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_aliases(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubAppAuth":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_githubAppAuth(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubWebhooksEnabled":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_githubWebhooksEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectRef":
			out.Values[i] = ec._ProjectSettings_projectRef(ctx, field, obj)
		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_subscriptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vars":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_vars(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectTasksPairImplementors = []string{"ProjectTasksPair"}

func (ec *executionContext) _ProjectTasksPair(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectTasksPair) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectTasksPairImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectTasksPair")
		case "projectId":
			out.Values[i] = ec._ProjectTasksPair_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowedTasks":
			out.Values[i] = ec._ProjectTasksPair_allowedTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowedBVs":
			out.Values[i] = ec._ProjectTasksPair_allowedBVs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectVarsImplementors = []string{"ProjectVars"}

func (ec *executionContext) _ProjectVars(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectVars) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectVarsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectVars")
		case "adminOnlyVars":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectVars_adminOnlyVars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "privateVars":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectVars_privateVars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vars":
			out.Values[i] = ec._ProjectVars_vars(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var publicKeyImplementors = []string{"PublicKey"}

func (ec *executionContext) _PublicKey(ctx context.Context, sel ast.SelectionSet, obj *model.APIPubKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, publicKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublicKey")
		case "key":
			out.Values[i] = ec._PublicKey_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._PublicKey_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var quarantineTestPayloadImplementors = []string{"QuarantineTestPayload"}

func (ec *executionContext) _QuarantineTestPayload(ctx context.Context, sel ast.SelectionSet, obj *QuarantineTestPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, quarantineTestPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("QuarantineTestPayload")
		case "success":
			out.Values[i] = ec._QuarantineTestPayload_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "bbGetCreatedTickets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bbGetCreatedTickets(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "buildBaron":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildBaron(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminSettings":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminSettings(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminTasksToRestart":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminTasksToRestart(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "awsRegions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_awsRegions(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "clientConfig":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_clientConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "instanceTypes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_instanceTypes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "spruceConfig":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_spruceConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "subnetAvailabilityZones":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_subnetAvailabilityZones(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distro":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distro(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distroEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distroEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distros":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distros(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distroTaskQueue":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distroTaskQueue(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "host":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_host(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hostEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hostEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hosts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hosts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskQueueDistros":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskQueueDistros(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "pod":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_pod(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "patch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_patch(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "githubProjectConflicts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubProjectConflicts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_project(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "projects":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projects(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "projectEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "projectSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "repoEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "repoSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "viewableProjectRefs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewableProjectRefs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "isRepo":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_isRepo(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myHosts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myHosts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myVolumes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myVolumes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "logkeeperBuildMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_logkeeperBuildMetadata(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "task":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_task(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskAllExecutions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskAllExecutions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskTestSample":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskTestSample(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myPublicKeys":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myPublicKeys(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userConfig":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "buildVariantsForTaskName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildVariantsForTaskName(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "mainlineCommits":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_mainlineCommits(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskNamesForBuildVariant":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskNamesForBuildVariant(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "waterfall":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_waterfall(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskHistory(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hasVersion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hasVersion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_version(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "image":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_image(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "images":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_images(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var releaseModeConfigImplementors = []string{"ReleaseModeConfig"}

func (ec *executionContext) _ReleaseModeConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIReleaseModeConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, releaseModeConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReleaseModeConfig")
		case "distroMaxHostsFactor":
			out.Values[i] = ec._ReleaseModeConfig_distroMaxHostsFactor(ctx, field, obj)
		case "targetTimeSecondsOverride":
			out.Values[i] = ec._ReleaseModeConfig_targetTimeSecondsOverride(ctx, field, obj)
		case "idleTimeSecondsOverride":
			out.Values[i] = ec._ReleaseModeConfig_idleTimeSecondsOverride(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoCommitQueueParamsImplementors = []string{"RepoCommitQueueParams"}

func (ec *executionContext) _RepoCommitQueueParams(ctx context.Context, sel ast.SelectionSet, obj *model.APICommitQueueParams) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoCommitQueueParamsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoCommitQueueParams")
		case "enabled":
			out.Values[i] = ec._RepoCommitQueueParams_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mergeMethod":
			out.Values[i] = ec._RepoCommitQueueParams_mergeMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RepoCommitQueueParams_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoPermissionsImplementors = []string{"RepoPermissions"}

func (ec *executionContext) _RepoPermissions(ctx context.Context, sel ast.SelectionSet, obj *RepoPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoPermissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoPermissions")
		case "edit":
			out.Values[i] = ec._RepoPermissions_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "view":
			out.Values[i] = ec._RepoPermissions_view(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoRefImplementors = []string{"RepoRef"}

func (ec *executionContext) _RepoRef(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectRef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoRefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoRef")
		case "id":
			out.Values[i] = ec._RepoRef_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "admins":
			out.Values[i] = ec._RepoRef_admins(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "batchTime":
			out.Values[i] = ec._RepoRef_batchTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildBaronSettings":
			out.Values[i] = ec._RepoRef_buildBaronSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "commitQueue":
			out.Values[i] = ec._RepoRef_commitQueue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "containerSizeDefinitions":
			out.Values[i] = ec._RepoRef_containerSizeDefinitions(ctx, field, obj)
		case "deactivatePrevious":
			out.Values[i] = ec._RepoRef_deactivatePrevious(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disabledStatsCache":
			out.Values[i] = ec._RepoRef_disabledStatsCache(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dispatchingDisabled":
			out.Values[i] = ec._RepoRef_dispatchingDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._RepoRef_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._RepoRef_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "githubChecksEnabled":
			out.Values[i] = ec._RepoRef_githubChecksEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "githubDynamicTokenPermissionGroups":
			out.Values[i] = ec._RepoRef_githubDynamicTokenPermissionGroups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "githubPermissionGroupByRequester":
			out.Values[i] = ec._RepoRef_githubPermissionGroupByRequester(ctx, field, obj)
		case "githubPRTriggerAliases":
			out.Values[i] = ec._RepoRef_githubPRTriggerAliases(ctx, field, obj)
		case "githubMQTriggerAliases":
			out.Values[i] = ec._RepoRef_githubMQTriggerAliases(ctx, field, obj)
		case "gitTagAuthorizedTeams":
			out.Values[i] = ec._RepoRef_gitTagAuthorizedTeams(ctx, field, obj)
		case "gitTagAuthorizedUsers":
			out.Values[i] = ec._RepoRef_gitTagAuthorizedUsers(ctx, field, obj)
		case "gitTagVersionsEnabled":
			out.Values[i] = ec._RepoRef_gitTagVersionsEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "manualPrTestingEnabled":
			out.Values[i] = ec._RepoRef_manualPrTestingEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "notifyOnBuildFailure":
			out.Values[i] = ec._RepoRef_notifyOnBuildFailure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldestAllowedMergeBase":
			out.Values[i] = ec._RepoRef_oldestAllowedMergeBase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "owner":
			out.Values[i] = ec._RepoRef_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parsleyFilters":
			out.Values[i] = ec._RepoRef_parsleyFilters(ctx, field, obj)
		case "patchingDisabled":
			out.Values[i] = ec._RepoRef_patchingDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchTriggerAliases":
			out.Values[i] = ec._RepoRef_patchTriggerAliases(ctx, field, obj)
		case "perfEnabled":
			out.Values[i] = ec._RepoRef_perfEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "periodicBuilds":
			out.Values[i] = ec._RepoRef_periodicBuilds(ctx, field, obj)
		case "prTestingEnabled":
			out.Values[i] = ec._RepoRef_prTestingEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remotePath":
			out.Values[i] = ec._RepoRef_remotePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._RepoRef_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repotrackerDisabled":
			out.Values[i] = ec._RepoRef_repotrackerDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restricted":
			out.Values[i] = ec._RepoRef_restricted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spawnHostScriptPath":
			out.Values[i] = ec._RepoRef_spawnHostScriptPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "debugSpawnHostsDisabled":
			out.Values[i] = ec._RepoRef_debugSpawnHostsDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stepbackDisabled":
			out.Values[i] = ec._RepoRef_stepbackDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stepbackBisect":
			out.Values[i] = ec._RepoRef_stepbackBisect(ctx, field, obj)
		case "taskAnnotationSettings":
			out.Values[i] = ec._RepoRef_taskAnnotationSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "testSelection":
			out.Values[i] = ec._RepoRef_testSelection(ctx, field, obj)
		case "tracksPushEvents":
			out.Values[i] = ec._RepoRef_tracksPushEvents(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggers":
			out.Values[i] = ec._RepoRef_triggers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionControlEnabled":
			out.Values[i] = ec._RepoRef_versionControlEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workstationConfig":
			out.Values[i] = ec._RepoRef_workstationConfig(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "externalLinks":
			out.Values[i] = ec._RepoRef_externalLinks(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoSettingsImplementors = []string{"RepoSettings"}

func (ec *executionContext) _RepoSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoSettings")
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_aliases(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubAppAuth":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_githubAppAuth(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubWebhooksEnabled":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_githubWebhooksEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectRef":
			out.Values[i] = ec._RepoSettings_projectRef(ctx, field, obj)
		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_subscriptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vars":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_vars(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoTestSelectionSettingsImplementors = []string{"RepoTestSelectionSettings"}

func (ec *executionContext) _RepoTestSelectionSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APITestSelectionSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoTestSelectionSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoTestSelectionSettings")
		case "allowed":
			out.Values[i] = ec._RepoTestSelectionSettings_allowed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultEnabled":
			out.Values[i] = ec._RepoTestSelectionSettings_defaultEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoWorkstationConfigImplementors = []string{"RepoWorkstationConfig"}

func (ec *executionContext) _RepoWorkstationConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoWorkstationConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoWorkstationConfig")
		case "gitClone":
			out.Values[i] = ec._RepoWorkstationConfig_gitClone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setupCommands":
			out.Values[i] = ec._RepoWorkstationConfig_setupCommands(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repotrackerConfigImplementors = []string{"RepotrackerConfig"}

func (ec *executionContext) _RepotrackerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIRepoTrackerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repotrackerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepotrackerConfig")
		case "numNewRepoRevisionsToFetch":
			out.Values[i] = ec._RepotrackerConfig_numNewRepoRevisionsToFetch(ctx, field, obj)
		case "maxRepoRevisionsToSearch":
			out.Values[i] = ec._RepotrackerConfig_maxRepoRevisionsToSearch(ctx, field, obj)
		case "maxConcurrentRequests":
			out.Values[i] = ec._RepotrackerConfig_maxConcurrentRequests(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repotrackerErrorImplementors = []string{"RepotrackerError"}

func (ec *executionContext) _RepotrackerError(ctx context.Context, sel ast.SelectionSet, obj *model.APIRepositoryErrorDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repotrackerErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepotrackerError")
		case "exists":
			out.Values[i] = ec._RepotrackerError_exists(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invalidRevision":
			out.Values[i] = ec._RepotrackerError_invalidRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mergeBaseRevision":
			out.Values[i] = ec._RepotrackerError_mergeBaseRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceLimitsImplementors = []string{"ResourceLimits"}

func (ec *executionContext) _ResourceLimits(ctx context.Context, sel ast.SelectionSet, obj *model.APIResourceLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceLimits")
		case "lockedMemoryKb":
			out.Values[i] = ec._ResourceLimits_lockedMemoryKb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numFiles":
			out.Values[i] = ec._ResourceLimits_numFiles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numProcesses":
			out.Values[i] = ec._ResourceLimits_numProcesses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numTasks":
			out.Values[i] = ec._ResourceLimits_numTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "virtualMemoryKb":
			out.Values[i] = ec._ResourceLimits_virtualMemoryKb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var restartAdminTasksPayloadImplementors = []string{"RestartAdminTasksPayload"}

func (ec *executionContext) _RestartAdminTasksPayload(ctx context.Context, sel ast.SelectionSet, obj *RestartAdminTasksPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, restartAdminTasksPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestartAdminTasksPayload")
		case "numRestartedTasks":
			out.Values[i] = ec._RestartAdminTasksPayload_numRestartedTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeEnvironmentConfigImplementors = []string{"RuntimeEnvironmentConfig"}

func (ec *executionContext) _RuntimeEnvironmentConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIRuntimeEnvironmentsConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeEnvironmentConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeEnvironmentConfig")
		case "baseUrl":
			out.Values[i] = ec._RuntimeEnvironmentConfig_baseUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "apiKey":
			out.Values[i] = ec._RuntimeEnvironmentConfig_apiKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var s3CredentialsImplementors = []string{"S3Credentials"}

func (ec *executionContext) _S3Credentials(ctx context.Context, sel ast.SelectionSet, obj *model.APIS3Credentials) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, s3CredentialsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("S3Credentials")
		case "key":
			out.Values[i] = ec._S3Credentials_key(ctx, field, obj)
		case "secret":
			out.Values[i] = ec._S3Credentials_secret(ctx, field, obj)
		case "bucket":
			out.Values[i] = ec._S3Credentials_bucket(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sESConfigImplementors = []string{"SESConfig"}

func (ec *executionContext) _SESConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISESConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sESConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SESConfig")
		case "senderAddress":
			out.Values[i] = ec._SESConfig_senderAddress(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sSHConfigImplementors = []string{"SSHConfig"}

func (ec *executionContext) _SSHConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISSHConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sSHConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SSHConfig")
		case "taskHostKey":
			out.Values[i] = ec._SSHConfig_taskHostKey(ctx, field, obj)
		case "spawnHostKey":
			out.Values[i] = ec._SSHConfig_spawnHostKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sSHKeyPairImplementors = []string{"SSHKeyPair"}

func (ec *executionContext) _SSHKeyPair(ctx context.Context, sel ast.SelectionSet, obj *model.APISSHKeyPair) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sSHKeyPairImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SSHKeyPair")
		case "name":
			out.Values[i] = ec._SSHKeyPair_name(ctx, field, obj)
		case "secretARN":
			out.Values[i] = ec._SSHKeyPair_secretARN(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var saveDistroPayloadImplementors = []string{"SaveDistroPayload"}

func (ec *executionContext) _SaveDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *SaveDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, saveDistroPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SaveDistroPayload")
		case "distro":
			out.Values[i] = ec._SaveDistroPayload_distro(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostCount":
			out.Values[i] = ec._SaveDistroPayload_hostCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var schedulerConfigImplementors = []string{"SchedulerConfig"}

func (ec *executionContext) _SchedulerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISchedulerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, schedulerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SchedulerConfig")
		case "taskFinder":
			out.Values[i] = ec._SchedulerConfig_taskFinder(ctx, field, obj)
		case "hostAllocator":
			out.Values[i] = ec._SchedulerConfig_hostAllocator(ctx, field, obj)
		case "hostAllocatorRoundingRule":
			out.Values[i] = ec._SchedulerConfig_hostAllocatorRoundingRule(ctx, field, obj)
		case "hostAllocatorFeedbackRule":
			out.Values[i] = ec._SchedulerConfig_hostAllocatorFeedbackRule(ctx, field, obj)
		case "hostsOverallocatedRule":
			out.Values[i] = ec._SchedulerConfig_hostsOverallocatedRule(ctx, field, obj)
		case "futureHostFraction":
			out.Values[i] = ec._SchedulerConfig_futureHostFraction(ctx, field, obj)
		case "cacheDurationSeconds":
			out.Values[i] = ec._SchedulerConfig_cacheDurationSeconds(ctx, field, obj)
		case "targetTimeSeconds":
			out.Values[i] = ec._SchedulerConfig_targetTimeSeconds(ctx, field, obj)
		case "acceptableHostIdleTimeSeconds":
			out.Values[i] = ec._SchedulerConfig_acceptableHostIdleTimeSeconds(ctx, field, obj)
		case "groupVersions":
			out.Values[i] = ec._SchedulerConfig_groupVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchFactor":
			out.Values[i] = ec._SchedulerConfig_patchFactor(ctx, field, obj)
		case "patchTimeInQueueFactor":
			out.Values[i] = ec._SchedulerConfig_patchTimeInQueueFactor(ctx, field, obj)
		case "commitQueueFactor":
			out.Values[i] = ec._SchedulerConfig_commitQueueFactor(ctx, field, obj)
		case "mainlineTimeInQueueFactor":
			out.Values[i] = ec._SchedulerConfig_mainlineTimeInQueueFactor(ctx, field, obj)
		case "expectedRuntimeFactor":
			out.Values[i] = ec._SchedulerConfig_expectedRuntimeFactor(ctx, field, obj)
		case "generateTaskFactor":
			out.Values[i] = ec._SchedulerConfig_generateTaskFactor(ctx, field, obj)
		case "numDependentsFactor":
			out.Values[i] = ec._SchedulerConfig_numDependentsFactor(ctx, field, obj)
		case "stepbackTaskFactor":
			out.Values[i] = ec._SchedulerConfig_stepbackTaskFactor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchReturnInfoImplementors = []string{"SearchReturnInfo"}

func (ec *executionContext) _SearchReturnInfo(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.SearchReturnInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchReturnInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchReturnInfo")
		case "featuresURL":
			out.Values[i] = ec._SearchReturnInfo_featuresURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "issues":
			out.Values[i] = ec._SearchReturnInfo_issues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "search":
			out.Values[i] = ec._SearchReturnInfo_search(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "source":
			out.Values[i] = ec._SearchReturnInfo_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var secretsManagerConfigImplementors = []string{"SecretsManagerConfig"}

func (ec *executionContext) _SecretsManagerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISecretsManagerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, secretsManagerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretsManagerConfig")
		case "secretPrefix":
			out.Values[i] = ec._SecretsManagerConfig_secretPrefix(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var selectorImplementors = []string{"Selector"}

func (ec *executionContext) _Selector(ctx context.Context, sel ast.SelectionSet, obj *model.APISelector) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, selectorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Selector")
		case "data":
			out.Values[i] = ec._Selector_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Selector_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceFlagsImplementors = []string{"ServiceFlags"}

func (ec *executionContext) _ServiceFlags(ctx context.Context, sel ast.SelectionSet, obj *model.APIServiceFlags) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceFlagsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceFlags")
		case "taskDispatchDisabled":
			out.Values[i] = ec._ServiceFlags_taskDispatchDisabled(ctx, field, obj)
		case "hostInitDisabled":
			out.Values[i] = ec._ServiceFlags_hostInitDisabled(ctx, field, obj)
		case "podInitDisabled":
			out.Values[i] = ec._ServiceFlags_podInitDisabled(ctx, field, obj)
		case "largeParserProjectsDisabled":
			out.Values[i] = ec._ServiceFlags_largeParserProjectsDisabled(ctx, field, obj)
		case "monitorDisabled":
			out.Values[i] = ec._ServiceFlags_monitorDisabled(ctx, field, obj)
		case "alertsDisabled":
			out.Values[i] = ec._ServiceFlags_alertsDisabled(ctx, field, obj)
		case "agentStartDisabled":
			out.Values[i] = ec._ServiceFlags_agentStartDisabled(ctx, field, obj)
		case "repotrackerDisabled":
			out.Values[i] = ec._ServiceFlags_repotrackerDisabled(ctx, field, obj)
		case "schedulerDisabled":
			out.Values[i] = ec._ServiceFlags_schedulerDisabled(ctx, field, obj)
		case "checkBlockedTasksDisabled":
			out.Values[i] = ec._ServiceFlags_checkBlockedTasksDisabled(ctx, field, obj)
		case "githubPRTestingDisabled":
			out.Values[i] = ec._ServiceFlags_githubPRTestingDisabled(ctx, field, obj)
		case "cliUpdatesDisabled":
			out.Values[i] = ec._ServiceFlags_cliUpdatesDisabled(ctx, field, obj)
		case "backgroundStatsDisabled":
			out.Values[i] = ec._ServiceFlags_backgroundStatsDisabled(ctx, field, obj)
		case "taskLoggingDisabled":
			out.Values[i] = ec._ServiceFlags_taskLoggingDisabled(ctx, field, obj)
		case "cacheStatsJobDisabled":
			out.Values[i] = ec._ServiceFlags_cacheStatsJobDisabled(ctx, field, obj)
		case "cacheStatsEndpointDisabled":
			out.Values[i] = ec._ServiceFlags_cacheStatsEndpointDisabled(ctx, field, obj)
		case "taskReliabilityDisabled":
			out.Values[i] = ec._ServiceFlags_taskReliabilityDisabled(ctx, field, obj)
		case "hostAllocatorDisabled":
			out.Values[i] = ec._ServiceFlags_hostAllocatorDisabled(ctx, field, obj)
		case "podAllocatorDisabled":
			out.Values[i] = ec._ServiceFlags_podAllocatorDisabled(ctx, field, obj)
		case "unrecognizedPodCleanupDisabled":
			out.Values[i] = ec._ServiceFlags_unrecognizedPodCleanupDisabled(ctx, field, obj)
		case "backgroundReauthDisabled":
			out.Values[i] = ec._ServiceFlags_backgroundReauthDisabled(ctx, field, obj)
		case "cloudCleanupDisabled":
			out.Values[i] = ec._ServiceFlags_cloudCleanupDisabled(ctx, field, obj)
		case "debugSpawnHostDisabled":
			out.Values[i] = ec._ServiceFlags_debugSpawnHostDisabled(ctx, field, obj)
		case "sleepScheduleDisabled":
			out.Values[i] = ec._ServiceFlags_sleepScheduleDisabled(ctx, field, obj)
		case "staticAPIKeysDisabled":
			out.Values[i] = ec._ServiceFlags_staticAPIKeysDisabled(ctx, field, obj)
		case "jwtTokenForCLIDisabled":
			out.Values[i] = ec._ServiceFlags_jwtTokenForCLIDisabled(ctx, field, obj)
		case "systemFailedTaskRestartDisabled":
			out.Values[i] = ec._ServiceFlags_systemFailedTaskRestartDisabled(ctx, field, obj)
		case "degradedModeDisabled":
			out.Values[i] = ec._ServiceFlags_degradedModeDisabled(ctx, field, obj)
		case "elasticIPsDisabled":
			out.Values[i] = ec._ServiceFlags_elasticIPsDisabled(ctx, field, obj)
		case "useGitForGitHubFilesDisabled":
			out.Values[i] = ec._ServiceFlags_useGitForGitHubFilesDisabled(ctx, field, obj)
		case "releaseModeDisabled":
			out.Values[i] = ec._ServiceFlags_releaseModeDisabled(ctx, field, obj)
		case "eventProcessingDisabled":
			out.Values[i] = ec._ServiceFlags_eventProcessingDisabled(ctx, field, obj)
		case "jiraNotificationsDisabled":
			out.Values[i] = ec._ServiceFlags_jiraNotificationsDisabled(ctx, field, obj)
		case "slackNotificationsDisabled":
			out.Values[i] = ec._ServiceFlags_slackNotificationsDisabled(ctx, field, obj)
		case "emailNotificationsDisabled":
			out.Values[i] = ec._ServiceFlags_emailNotificationsDisabled(ctx, field, obj)
		case "webhookNotificationsDisabled":
			out.Values[i] = ec._ServiceFlags_webhookNotificationsDisabled(ctx, field, obj)
		case "githubStatusAPIDisabled":
			out.Values[i] = ec._ServiceFlags_githubStatusAPIDisabled(ctx, field, obj)
		case "s3LifecycleSyncDisabled":
			out.Values[i] = ec._ServiceFlags_s3LifecycleSyncDisabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var setLastRevisionPayloadImplementors = []string{"SetLastRevisionPayload"}

func (ec *executionContext) _SetLastRevisionPayload(ctx context.Context, sel ast.SelectionSet, obj *SetLastRevisionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setLastRevisionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetLastRevisionPayload")
		case "mergeBaseRevision":
			out.Values[i] = ec._SetLastRevisionPayload_mergeBaseRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var singleTaskDistroConfigImplementors = []string{"SingleTaskDistroConfig"}

func (ec *executionContext) _SingleTaskDistroConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISingleTaskDistroConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, singleTaskDistroConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SingleTaskDistroConfig")
		case "projectTasksPairs":
			out.Values[i] = ec._SingleTaskDistroConfig_projectTasksPairs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var slackConfigImplementors = []string{"SlackConfig"}

func (ec *executionContext) _SlackConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISlackConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, slackConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SlackConfig")
		case "options":
			out.Values[i] = ec._SlackConfig_options(ctx, field, obj)
		case "token":
			out.Values[i] = ec._SlackConfig_token(ctx, field, obj)
		case "level":
			out.Values[i] = ec._SlackConfig_level(ctx, field, obj)
		case "name":
			out.Values[i] = ec._SlackConfig_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var slackOptionsImplementors = []string{"SlackOptions"}

func (ec *executionContext) _SlackOptions(ctx context.Context, sel ast.SelectionSet, obj *model.APISlackOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, slackOptionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SlackOptions")
		case "channel":
			out.Values[i] = ec._SlackOptions_channel(ctx, field, obj)
		case "hostname":
			out.Values[i] = ec._SlackOptions_hostname(ctx, field, obj)
		case "name":
			out.Values[i] = ec._SlackOptions_name(ctx, field, obj)
		case "username":
			out.Values[i] = ec._SlackOptions_username(ctx, field, obj)
		case "basicMetadata":
			out.Values[i] = ec._SlackOptions_basicMetadata(ctx, field, obj)
		case "fields":
			out.Values[i] = ec._SlackOptions_fields(ctx, field, obj)
		case "allFields":
			out.Values[i] = ec._SlackOptions_allFields(ctx, field, obj)
		case "fieldsSet":
			out.Values[i] = ec._SlackOptions_fieldsSet(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sleepScheduleImplementors = []string{"SleepSchedule"}

func (ec *executionContext) _SleepSchedule(ctx context.Context, sel ast.SelectionSet, obj *host.SleepScheduleInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sleepScheduleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SleepSchedule")
		case "dailyStartTime":
			out.Values[i] = ec._SleepSchedule_dailyStartTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dailyStopTime":
			out.Values[i] = ec._SleepSchedule_dailyStopTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "nextStartTime":
			out.Values[i] = ec._SleepSchedule_nextStartTime(ctx, field, obj)
		case "nextStopTime":
			out.Values[i] = ec._SleepSchedule_nextStopTime(ctx, field, obj)
		case "permanentlyExempt":
			out.Values[i] = ec._SleepSchedule_permanentlyExempt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "shouldKeepOff":
			out.Values[i] = ec._SleepSchedule_shouldKeepOff(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "timeZone":
			out.Values[i] = ec._SleepSchedule_timeZone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "temporarilyExemptUntil":
			out.Values[i] = ec._SleepSchedule_temporarilyExemptUntil(ctx, field, obj)
		case "wholeWeekdaysOff":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SleepSchedule_wholeWeekdaysOff(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sleepScheduleConfigImplementors = []string{"SleepScheduleConfig"}

func (ec *executionContext) _SleepScheduleConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISleepScheduleConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sleepScheduleConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SleepScheduleConfig")
		case "permanentlyExemptHosts":
			out.Values[i] = ec._SleepScheduleConfig_permanentlyExemptHosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sourceImplementors = []string{"Source"}

func (ec *executionContext) _Source(ctx context.Context, sel ast.SelectionSet, obj *model.APISource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Source")
		case "author":
			out.Values[i] = ec._Source_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requester":
			out.Values[i] = ec._Source_requester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "time":
			out.Values[i] = ec._Source_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var spawnHostConfigImplementors = []string{"SpawnHostConfig"}

func (ec *executionContext) _SpawnHostConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISpawnHostConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spawnHostConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpawnHostConfig")
		case "unexpirableHostsPerUser":
			out.Values[i] = ec._SpawnHostConfig_unexpirableHostsPerUser(ctx, field, obj)
		case "unexpirableVolumesPerUser":
			out.Values[i] = ec._SpawnHostConfig_unexpirableVolumesPerUser(ctx, field, obj)
		case "spawnHostsPerUser":
			out.Values[i] = ec._SpawnHostConfig_spawnHostsPerUser(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var splunkConfigImplementors = []string{"SplunkConfig"}

func (ec *executionContext) _SplunkConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISplunkConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, splunkConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SplunkConfig")
		case "splunkConnectionInfo":
			out.Values[i] = ec._SplunkConfig_splunkConnectionInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var splunkConnectionInfoImplementors = []string{"SplunkConnectionInfo"}

func (ec *executionContext) _SplunkConnectionInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APISplunkConnectionInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, splunkConnectionInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SplunkConnectionInfo")
		case "serverUrl":
			out.Values[i] = ec._SplunkConnectionInfo_serverUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "token":
			out.Values[i] = ec._SplunkConnectionInfo_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channel":
			out.Values[i] = ec._SplunkConnectionInfo_channel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var spruceConfigImplementors = []string{"SpruceConfig"}

func (ec *executionContext) _SpruceConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAdminSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spruceConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpruceConfig")
		case "banner":
			out.Values[i] = ec._SpruceConfig_banner(ctx, field, obj)
		case "bannerTheme":
			out.Values[i] = ec._SpruceConfig_bannerTheme(ctx, field, obj)
		case "containerPools":
			out.Values[i] = ec._SpruceConfig_containerPools(ctx, field, obj)
		case "githubOrgs":
			out.Values[i] = ec._SpruceConfig_githubOrgs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "jira":
			out.Values[i] = ec._SpruceConfig_jira(ctx, field, obj)
		case "providers":
			out.Values[i] = ec._SpruceConfig_providers(ctx, field, obj)
		case "secretFields":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SpruceConfig_secretFields(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "serviceFlags":
			out.Values[i] = ec._SpruceConfig_serviceFlags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "singleTaskDistro":
			out.Values[i] = ec._SpruceConfig_singleTaskDistro(ctx, field, obj)
		case "slack":
			out.Values[i] = ec._SpruceConfig_slack(ctx, field, obj)
		case "spawnHost":
			out.Values[i] = ec._SpruceConfig_spawnHost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ui":
			out.Values[i] = ec._SpruceConfig_ui(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var statusCountImplementors = []string{"StatusCount"}

func (ec *executionContext) _StatusCount(ctx context.Context, sel ast.SelectionSet, obj *task.StatusCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statusCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatusCount")
		case "count":
			out.Values[i] = ec._StatusCount_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._StatusCount_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stepbackInfoImplementors = []string{"StepbackInfo"}

func (ec *executionContext) _StepbackInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APIStepbackInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stepbackInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StepbackInfo")
		case "lastFailingStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_lastFailingStepbackTaskId(ctx, field, obj)
		case "lastPassingStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_lastPassingStepbackTaskId(ctx, field, obj)
		case "nextStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_nextStepbackTaskId(ctx, field, obj)
		case "previousStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_previousStepbackTaskId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subnetImplementors = []string{"Subnet"}

func (ec *executionContext) _Subnet(ctx context.Context, sel ast.SelectionSet, obj *model.APISubnet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subnetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Subnet")
		case "az":
			out.Values[i] = ec._Subnet_az(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subnetId":
			out.Values[i] = ec._Subnet_subnetId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriberImplementors = []string{"Subscriber"}

func (ec *executionContext) _Subscriber(ctx context.Context, sel ast.SelectionSet, obj *Subscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Subscriber")
		case "emailSubscriber":
			out.Values[i] = ec._Subscriber_emailSubscriber(ctx, field, obj)
		case "githubCheckSubscriber":
			out.Values[i] = ec._Subscriber_githubCheckSubscriber(ctx, field, obj)
		case "githubPRSubscriber":
			out.Values[i] = ec._Subscriber_githubPRSubscriber(ctx, field, obj)
		case "jiraCommentSubscriber":
			out.Values[i] = ec._Subscriber_jiraCommentSubscriber(ctx, field, obj)
		case "jiraIssueSubscriber":
			out.Values[i] = ec._Subscriber_jiraIssueSubscriber(ctx, field, obj)
		case "slackSubscriber":
			out.Values[i] = ec._Subscriber_slackSubscriber(ctx, field, obj)
		case "webhookSubscriber":
			out.Values[i] = ec._Subscriber_webhookSubscriber(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriberWrapperImplementors = []string{"SubscriberWrapper"}

func (ec *executionContext) _SubscriberWrapper(ctx context.Context, sel ast.SelectionSet, obj *model.APISubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriberWrapperImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SubscriberWrapper")
		case "subscriber":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SubscriberWrapper_subscriber(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._SubscriberWrapper_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskImplementors = []string{"Task"}

func (ec *executionContext) _Task(ctx context.Context, sel ast.SelectionSet, obj *model.APITask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Task")
		case "aborted":
			out.Values[i] = ec._Task_aborted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "abortInfo":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_abortInfo(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "activated":
			out.Values[i] = ec._Task_activated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activatedBy":
			out.Values[i] = ec._Task_activatedBy(ctx, field, obj)
		case "activatedTime":
			out.Values[i] = ec._Task_activatedTime(ctx, field, obj)
		case "ami":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_ami(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "annotation":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_annotation(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "id":
			out.Values[i] = ec._Task_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "baseStatus":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_baseStatus(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "baseTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_baseTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "blocked":
			out.Values[i] = ec._Task_blocked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildId":
			out.Values[i] = ec._Task_buildId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariant":
			out.Values[i] = ec._Task_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariantDisplayName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_buildVariantDisplayName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canAbort":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canAbort(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canDisable":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canDisable(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canModifyAnnotation":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canModifyAnnotation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canOverrideDependencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canOverrideDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canRestart":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canRestart(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canSchedule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canSchedule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canSetPriority":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canSetPriority(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canUnschedule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canUnschedule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "containerAllocatedTime":
			out.Values[i] = ec._Task_containerAllocatedTime(ctx, field, obj)
		case "createTime":
			out.Values[i] = ec._Task_createTime(ctx, field, obj)
		case "dependsOn":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_dependsOn(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "details":
			out.Values[i] = ec._Task_details(ctx, field, obj)
		case "dispatchTime":
			out.Values[i] = ec._Task_dispatchTime(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Task_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayOnly":
			out.Values[i] = ec._Task_displayOnly(ctx, field, obj)
		case "displayStatus":
			out.Values[i] = ec._Task_displayStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_displayTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "distroId":
			out.Values[i] = ec._Task_distroId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "estimatedStart":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_estimatedStart(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "execution":
			out.Values[i] = ec._Task_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "executionTasks":
			out.Values[i] = ec._Task_executionTasks(ctx, field, obj)
		case "executionTasksFull":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_executionTasksFull(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "expectedDuration":
			out.Values[i] = ec._Task_expectedDuration(ctx, field, obj)
		case "failedTestCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_failedTestCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "files":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_files(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "finishTime":
			out.Values[i] = ec._Task_finishTime(ctx, field, obj)
		case "generatedBy":
			out.Values[i] = ec._Task_generatedBy(ctx, field, obj)
		case "generatedByName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_generatedByName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "generateTask":
			out.Values[i] = ec._Task_generateTask(ctx, field, obj)
		case "hasTestResults":
			out.Values[i] = ec._Task_hasTestResults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hostId":
			out.Values[i] = ec._Task_hostId(ctx, field, obj)
		case "imageId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_imageId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "ingestTime":
			out.Values[i] = ec._Task_ingestTime(ctx, field, obj)
		case "isPerfPluginEnabled":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_isPerfPluginEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "latestExecution":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_latestExecution(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logs":
			out.Values[i] = ec._Task_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "minQueuePosition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_minQueuePosition(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "order":
			out.Values[i] = ec._Task_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_patch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "patchNumber":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_patchNumber(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "pod":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_pod(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "priority":
			out.Values[i] = ec._Task_priority(ctx, field, obj)
		case "project":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_project(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectId":
			out.Values[i] = ec._Task_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_projectIdentifier(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "requester":
			out.Values[i] = ec._Task_requester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resetWhenFinished":
			out.Values[i] = ec._Task_resetWhenFinished(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "revision":
			out.Values[i] = ec._Task_revision(ctx, field, obj)
		case "scheduledTime":
			out.Values[i] = ec._Task_scheduledTime(ctx, field, obj)
		case "spawnHostLink":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_spawnHostLink(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startTime":
			out.Values[i] = ec._Task_startTime(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Task_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			out.Values[i] = ec._Task_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskGroup":
			out.Values[i] = ec._Task_taskGroup(ctx, field, obj)
		case "taskGroupMaxHosts":
			out.Values[i] = ec._Task_taskGroupMaxHosts(ctx, field, obj)
		case "stepbackInfo":
			out.Values[i] = ec._Task_stepbackInfo(ctx, field, obj)
		case "taskLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_taskLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskCost":
			out.Values[i] = ec._Task_taskCost(ctx, field, obj)
		case "predictedTaskCost":
			out.Values[i] = ec._Task_predictedTaskCost(ctx, field, obj)
		case "taskOwnerTeam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_taskOwnerTeam(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tests":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_tests(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "testSelectionEnabled":
			out.Values[i] = ec._Task_testSelectionEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "timeTaken":
			out.Values[i] = ec._Task_timeTaken(ctx, field, obj)
		case "totalTestCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_totalTestCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "versionMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_versionMetadata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskAnnotationSettingsImplementors = []string{"TaskAnnotationSettings"}

func (ec *executionContext) _TaskAnnotationSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskAnnotationSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskAnnotationSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskAnnotationSettings")
		case "fileTicketWebhook":
			out.Values[i] = ec._TaskAnnotationSettings_fileTicketWebhook(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskContainerCreationOptsImplementors = []string{"TaskContainerCreationOpts"}

func (ec *executionContext) _TaskContainerCreationOpts(ctx context.Context, sel ast.SelectionSet, obj *model.APIPodTaskContainerCreationOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskContainerCreationOptsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskContainerCreationOpts")
		case "image":
			out.Values[i] = ec._TaskContainerCreationOpts_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "memoryMB":
			out.Values[i] = ec._TaskContainerCreationOpts_memoryMB(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cpu":
			out.Values[i] = ec._TaskContainerCreationOpts_cpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "os":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskContainerCreationOpts_os(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "arch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskContainerCreationOpts_arch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workingDir":
			out.Values[i] = ec._TaskContainerCreationOpts_workingDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskEndDetailImplementors = []string{"TaskEndDetail"}

func (ec *executionContext) _TaskEndDetail(ctx context.Context, sel ast.SelectionSet, obj *model.ApiTaskEndDetail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEndDetailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEndDetail")
		case "description":
			out.Values[i] = ec._TaskEndDetail_description(ctx, field, obj)
		case "diskDevices":
			out.Values[i] = ec._TaskEndDetail_diskDevices(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failingCommand":
			out.Values[i] = ec._TaskEndDetail_failingCommand(ctx, field, obj)
		case "failureMetadataTags":
			out.Values[i] = ec._TaskEndDetail_failureMetadataTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oomTracker":
			out.Values[i] = ec._TaskEndDetail_oomTracker(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "otherFailingCommands":
			out.Values[i] = ec._TaskEndDetail_otherFailingCommands(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TaskEndDetail_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timedOut":
			out.Values[i] = ec._TaskEndDetail_timedOut(ctx, field, obj)
		case "timeoutType":
			out.Values[i] = ec._TaskEndDetail_timeoutType(ctx, field, obj)
		case "traceID":
			out.Values[i] = ec._TaskEndDetail_traceID(ctx, field, obj)
		case "type":
			out.Values[i] = ec._TaskEndDetail_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskEventLogDataImplementors = []string{"TaskEventLogData"}

func (ec *executionContext) _TaskEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.TaskEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEventLogDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEventLogData")
		case "hostId":
			out.Values[i] = ec._TaskEventLogData_hostId(ctx, field, obj)
		case "podId":
			out.Values[i] = ec._TaskEventLogData_podId(ctx, field, obj)
		case "jiraIssue":
			out.Values[i] = ec._TaskEventLogData_jiraIssue(ctx, field, obj)
		case "jiraLink":
			out.Values[i] = ec._TaskEventLogData_jiraLink(ctx, field, obj)
		case "priority":
			out.Values[i] = ec._TaskEventLogData_priority(ctx, field, obj)
		case "status":
			out.Values[i] = ec._TaskEventLogData_status(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._TaskEventLogData_timestamp(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._TaskEventLogData_userId(ctx, field, obj)
		case "blockedOn":
			out.Values[i] = ec._TaskEventLogData_blockedOn(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskEventLogEntryImplementors = []string{"TaskEventLogEntry"}

func (ec *executionContext) _TaskEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.TaskAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEventLogEntry")
		case "id":
			out.Values[i] = ec._TaskEventLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._TaskEventLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._TaskEventLogEntry_eventType(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._TaskEventLogEntry_processedAt(ctx, field, obj)
		case "resourceId":
			out.Values[i] = ec._TaskEventLogEntry_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TaskEventLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._TaskEventLogEntry_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskFilesImplementors = []string{"TaskFiles"}

func (ec *executionContext) _TaskFiles(ctx context.Context, sel ast.SelectionSet, obj *TaskFiles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskFilesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskFiles")
		case "fileCount":
			out.Values[i] = ec._TaskFiles_fileCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "groupedFiles":
			out.Values[i] = ec._TaskFiles_groupedFiles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskHistoryImplementors = []string{"TaskHistory"}

func (ec *executionContext) _TaskHistory(ctx context.Context, sel ast.SelectionSet, obj *TaskHistory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskHistoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskHistory")
		case "tasks":
			out.Values[i] = ec._TaskHistory_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._TaskHistory_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskHistoryPaginationImplementors = []string{"TaskHistoryPagination"}

func (ec *executionContext) _TaskHistoryPagination(ctx context.Context, sel ast.SelectionSet, obj *TaskHistoryPagination) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskHistoryPaginationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskHistoryPagination")
		case "mostRecentTaskOrder":
			out.Values[i] = ec._TaskHistoryPagination_mostRecentTaskOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldestTaskOrder":
			out.Values[i] = ec._TaskHistoryPagination_oldestTaskOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskInfoImplementors = []string{"TaskInfo"}

func (ec *executionContext) _TaskInfo(ctx context.Context, sel ast.SelectionSet, obj *model.TaskInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskInfo")
		case "id":
			out.Values[i] = ec._TaskInfo_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._TaskInfo_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskLimitsConfigImplementors = []string{"TaskLimitsConfig"}

func (ec *executionContext) _TaskLimitsConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskLimitsConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskLimitsConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskLimitsConfig")
		case "maxTasksPerVersion":
			out.Values[i] = ec._TaskLimitsConfig_maxTasksPerVersion(ctx, field, obj)
		case "maxIncludesPerVersion":
			out.Values[i] = ec._TaskLimitsConfig_maxIncludesPerVersion(ctx, field, obj)
		case "maxHourlyPatchTasks":
			out.Values[i] = ec._TaskLimitsConfig_maxHourlyPatchTasks(ctx, field, obj)
		case "maxPendingGeneratedTasks":
			out.Values[i] = ec._TaskLimitsConfig_maxPendingGeneratedTasks(ctx, field, obj)
		case "maxGenerateTaskJSONSize":
			out.Values[i] = ec._TaskLimitsConfig_maxGenerateTaskJSONSize(ctx, field, obj)
		case "maxConcurrentLargeParserProjectTasks":
			out.Values[i] = ec._TaskLimitsConfig_maxConcurrentLargeParserProjectTasks(ctx, field, obj)
		case "maxDegradedModeConcurrentLargeParserProjectTasks":
			out.Values[i] = ec._TaskLimitsConfig_maxDegradedModeConcurrentLargeParserProjectTasks(ctx, field, obj)
		case "maxDegradedModeParserProjectSize":
			out.Values[i] = ec._TaskLimitsConfig_maxDegradedModeParserProjectSize(ctx, field, obj)
		case "maxParserProjectSize":
			out.Values[i] = ec._TaskLimitsConfig_maxParserProjectSize(ctx, field, obj)
		case "maxExecTimeoutSecs":
			out.Values[i] = ec._TaskLimitsConfig_maxExecTimeoutSecs(ctx, field, obj)
		case "maxTaskExecution":
			out.Values[i] = ec._TaskLimitsConfig_maxTaskExecution(ctx, field, obj)
		case "maxDailyAutomaticRestarts":
			out.Values[i] = ec._TaskLimitsConfig_maxDailyAutomaticRestarts(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskLogLinksImplementors = []string{"TaskLogLinks"}

func (ec *executionContext) _TaskLogLinks(ctx context.Context, sel ast.SelectionSet, obj *model.LogLinks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskLogLinksImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskLogLinks")
		case "agentLogLink":
			out.Values[i] = ec._TaskLogLinks_agentLogLink(ctx, field, obj)
		case "allLogLink":
			out.Values[i] = ec._TaskLogLinks_allLogLink(ctx, field, obj)
		case "systemLogLink":
			out.Values[i] = ec._TaskLogLinks_systemLogLink(ctx, field, obj)
		case "taskLogLink":
			out.Values[i] = ec._TaskLogLinks_taskLogLink(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskLogsImplementors = []string{"TaskLogs"}

func (ec *executionContext) _TaskLogs(ctx context.Context, sel ast.SelectionSet, obj *TaskLogs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskLogsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskLogs")
		case "agentLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_agentLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "allLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_allLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_eventLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "execution":
			out.Values[i] = ec._TaskLogs_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "systemLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_systemLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskId":
			out.Values[i] = ec._TaskLogs_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_taskLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskOwnerTeamImplementors = []string{"TaskOwnerTeam"}

func (ec *executionContext) _TaskOwnerTeam(ctx context.Context, sel ast.SelectionSet, obj *TaskOwnerTeam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskOwnerTeamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskOwnerTeam")
		case "assignmentType":
			out.Values[i] = ec._TaskOwnerTeam_assignmentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "messages":
			out.Values[i] = ec._TaskOwnerTeam_messages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamName":
			out.Values[i] = ec._TaskOwnerTeam_teamName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jiraProject":
			out.Values[i] = ec._TaskOwnerTeam_jiraProject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskQueueDistroImplementors = []string{"TaskQueueDistro"}

func (ec *executionContext) _TaskQueueDistro(ctx context.Context, sel ast.SelectionSet, obj *TaskQueueDistro) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskQueueDistroImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskQueueDistro")
		case "id":
			out.Values[i] = ec._TaskQueueDistro_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostCount":
			out.Values[i] = ec._TaskQueueDistro_hostCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskCount":
			out.Values[i] = ec._TaskQueueDistro_taskCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskQueueItemImplementors = []string{"TaskQueueItem"}

func (ec *executionContext) _TaskQueueItem(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskQueueItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskQueueItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskQueueItem")
		case "id":
			out.Values[i] = ec._TaskQueueItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildVariant":
			out.Values[i] = ec._TaskQueueItem_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._TaskQueueItem_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expectedDuration":
			out.Values[i] = ec._TaskQueueItem_expectedDuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "priority":
			out.Values[i] = ec._TaskQueueItem_priority(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec._TaskQueueItem_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "projectIdentifier":
			out.Values[i] = ec._TaskQueueItem_projectIdentifier(ctx, field, obj)
		case "requester":
			out.Values[i] = ec._TaskQueueItem_requester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activatedBy":
			out.Values[i] = ec._TaskQueueItem_activatedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revision":
			out.Values[i] = ec._TaskQueueItem_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._TaskQueueItem_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskSpecifierImplementors = []string{"TaskSpecifier"}

func (ec *executionContext) _TaskSpecifier(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskSpecifier) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskSpecifierImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskSpecifier")
		case "patchAlias":
			out.Values[i] = ec._TaskSpecifier_patchAlias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskRegex":
			out.Values[i] = ec._TaskSpecifier_taskRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variantRegex":
			out.Values[i] = ec._TaskSpecifier_variantRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskStatsImplementors = []string{"TaskStats"}

func (ec *executionContext) _TaskStats(ctx context.Context, sel ast.SelectionSet, obj *task.TaskStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskStats")
		case "counts":
			out.Values[i] = ec._TaskStats_counts(ctx, field, obj)
		case "eta":
			out.Values[i] = ec._TaskStats_eta(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskTestResultImplementors = []string{"TaskTestResult"}

func (ec *executionContext) _TaskTestResult(ctx context.Context, sel ast.SelectionSet, obj *TaskTestResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskTestResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskTestResult")
		case "testResults":
			out.Values[i] = ec._TaskTestResult_testResults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalTestCount":
			out.Values[i] = ec._TaskTestResult_totalTestCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredTestCount":
			out.Values[i] = ec._TaskTestResult_filteredTestCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskTestResultSampleImplementors = []string{"TaskTestResultSample"}

func (ec *executionContext) _TaskTestResultSample(ctx context.Context, sel ast.SelectionSet, obj *TaskTestResultSample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskTestResultSampleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskTestResultSample")
		case "execution":
			out.Values[i] = ec._TaskTestResultSample_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingFailedTestNames":
			out.Values[i] = ec._TaskTestResultSample_matchingFailedTestNames(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._TaskTestResultSample_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalTestCount":
			out.Values[i] = ec._TaskTestResultSample_totalTestCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testLogImplementors = []string{"TestLog"}

func (ec *executionContext) _TestLog(ctx context.Context, sel ast.SelectionSet, obj *model.TestLogs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testLogImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestLog")
		case "lineNum":
			out.Values[i] = ec._TestLog_lineNum(ctx, field, obj)
		case "url":
			out.Values[i] = ec._TestLog_url(ctx, field, obj)
		case "urlParsley":
			out.Values[i] = ec._TestLog_urlParsley(ctx, field, obj)
		case "urlRaw":
			out.Values[i] = ec._TestLog_urlRaw(ctx, field, obj)
		case "renderingType":
			out.Values[i] = ec._TestLog_renderingType(ctx, field, obj)
		case "testName":
			out.Values[i] = ec._TestLog_testName(ctx, field, obj)
		case "version":
			out.Values[i] = ec._TestLog_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testResultImplementors = []string{"TestResult"}

func (ec *executionContext) _TestResult(ctx context.Context, sel ast.SelectionSet, obj *model.APITest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestResult")
		case "id":
			out.Values[i] = ec._TestResult_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "baseStatus":
			out.Values[i] = ec._TestResult_baseStatus(ctx, field, obj)
		case "duration":
			out.Values[i] = ec._TestResult_duration(ctx, field, obj)
		case "endTime":
			out.Values[i] = ec._TestResult_endTime(ctx, field, obj)
		case "execution":
			out.Values[i] = ec._TestResult_execution(ctx, field, obj)
		case "exitCode":
			out.Values[i] = ec._TestResult_exitCode(ctx, field, obj)
		case "groupID":
			out.Values[i] = ec._TestResult_groupID(ctx, field, obj)
		case "logs":
			out.Values[i] = ec._TestResult_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startTime":
			out.Values[i] = ec._TestResult_startTime(ctx, field, obj)
		case "status":
			out.Values[i] = ec._TestResult_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._TestResult_taskId(ctx, field, obj)
		case "testFile":
			out.Values[i] = ec._TestResult_testFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testSelectionConfigImplementors = []string{"TestSelectionConfig"}

func (ec *executionContext) _TestSelectionConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APITestSelectionConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testSelectionConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestSelectionConfig")
		case "url":
			out.Values[i] = ec._TestSelectionConfig_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testSelectionSettingsImplementors = []string{"TestSelectionSettings"}

func (ec *executionContext) _TestSelectionSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APITestSelectionSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testSelectionSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestSelectionSettings")
		case "allowed":
			out.Values[i] = ec._TestSelectionSettings_allowed(ctx, field, obj)
		case "defaultEnabled":
			out.Values[i] = ec._TestSelectionSettings_defaultEnabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ticketFieldsImplementors = []string{"TicketFields"}

func (ec *executionContext) _TicketFields(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.TicketFields) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ticketFieldsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TicketFields")
		case "assignedTeam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_assignedTeam(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "assigneeDisplayName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_assigneeDisplayName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "created":
			out.Values[i] = ec._TicketFields_created(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resolutionName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_resolutionName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._TicketFields_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "summary":
			out.Values[i] = ec._TicketFields_summary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updated":
			out.Values[i] = ec._TicketFields_updated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var toolchainImplementors = []string{"Toolchain"}

func (ec *executionContext) _Toolchain(ctx context.Context, sel ast.SelectionSet, obj *model.APIToolchain) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, toolchainImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Toolchain")
		case "name":
			out.Values[i] = ec._Toolchain_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "path":
			out.Values[i] = ec._Toolchain_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Toolchain_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tracerSettingsImplementors = []string{"TracerSettings"}

func (ec *executionContext) _TracerSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APITracerSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tracerSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TracerSettings")
		case "enabled":
			out.Values[i] = ec._TracerSettings_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "collectorEndpoint":
			out.Values[i] = ec._TracerSettings_collectorEndpoint(ctx, field, obj)
		case "collectorInternalEndpoint":
			out.Values[i] = ec._TracerSettings_collectorInternalEndpoint(ctx, field, obj)
		case "collectorAPIKey":
			out.Values[i] = ec._TracerSettings_collectorAPIKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var triggerAliasImplementors = []string{"TriggerAlias"}

func (ec *executionContext) _TriggerAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APITriggerDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, triggerAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TriggerAlias")
		case "alias":
			out.Values[i] = ec._TriggerAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildVariantRegex":
			out.Values[i] = ec._TriggerAlias_buildVariantRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configFile":
			out.Values[i] = ec._TriggerAlias_configFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dateCutoff":
			out.Values[i] = ec._TriggerAlias_dateCutoff(ctx, field, obj)
		case "level":
			out.Values[i] = ec._TriggerAlias_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec._TriggerAlias_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TriggerAlias_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskRegex":
			out.Values[i] = ec._TriggerAlias_taskRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unscheduleDownstreamVersions":
			out.Values[i] = ec._TriggerAlias_unscheduleDownstreamVersions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var triggerConfigImplementors = []string{"TriggerConfig"}

func (ec *executionContext) _TriggerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APITriggerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, triggerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TriggerConfig")
		case "generateTaskDistro":
			out.Values[i] = ec._TriggerConfig_generateTaskDistro(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var uIConfigImplementors = []string{"UIConfig"}

func (ec *executionContext) _UIConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIUIConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uIConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UIConfig")
		case "betaFeatures":
			out.Values[i] = ec._UIConfig_betaFeatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._UIConfig_url(ctx, field, obj)
		case "helpUrl":
			out.Values[i] = ec._UIConfig_helpUrl(ctx, field, obj)
		case "uiv2Url":
			out.Values[i] = ec._UIConfig_uiv2Url(ctx, field, obj)
		case "parsleyUrl":
			out.Values[i] = ec._UIConfig_parsleyUrl(ctx, field, obj)
		case "httpListenAddr":
			out.Values[i] = ec._UIConfig_httpListenAddr(ctx, field, obj)
		case "secret":
			out.Values[i] = ec._UIConfig_secret(ctx, field, obj)
		case "defaultProject":
			out.Values[i] = ec._UIConfig_defaultProject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "corsOrigins":
			out.Values[i] = ec._UIConfig_corsOrigins(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileStreamingContentTypes":
			out.Values[i] = ec._UIConfig_fileStreamingContentTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "loginDomain":
			out.Values[i] = ec._UIConfig_loginDomain(ctx, field, obj)
		case "userVoice":
			out.Values[i] = ec._UIConfig_userVoice(ctx, field, obj)
		case "csrfKey":
			out.Values[i] = ec._UIConfig_csrfKey(ctx, field, obj)
		case "cacheTemplates":
			out.Values[i] = ec._UIConfig_cacheTemplates(ctx, field, obj)
		case "stagingEnvironment":
			out.Values[i] = ec._UIConfig_stagingEnvironment(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateBetaFeaturesPayloadImplementors = []string{"UpdateBetaFeaturesPayload"}

func (ec *executionContext) _UpdateBetaFeaturesPayload(ctx context.Context, sel ast.SelectionSet, obj *UpdateBetaFeaturesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateBetaFeaturesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateBetaFeaturesPayload")
		case "betaFeatures":
			out.Values[i] = ec._UpdateBetaFeaturesPayload_betaFeatures(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateParsleySettingsPayloadImplementors = []string{"UpdateParsleySettingsPayload"}

func (ec *executionContext) _UpdateParsleySettingsPayload(ctx context.Context, sel ast.SelectionSet, obj *UpdateParsleySettingsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateParsleySettingsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateParsleySettingsPayload")
		case "parsleySettings":
			out.Values[i] = ec._UpdateParsleySettingsPayload_parsleySettings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var upstreamProjectImplementors = []string{"UpstreamProject"}

func (ec *executionContext) _UpstreamProject(ctx context.Context, sel ast.SelectionSet, obj *UpstreamProject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, upstreamProjectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamProject")
		case "owner":
			out.Values[i] = ec._UpstreamProject_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec._UpstreamProject_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._UpstreamProject_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceID":
			out.Values[i] = ec._UpstreamProject_resourceID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revision":
			out.Values[i] = ec._UpstreamProject_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "task":
			out.Values[i] = ec._UpstreamProject_task(ctx, field, obj)
		case "triggerID":
			out.Values[i] = ec._UpstreamProject_triggerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerType":
			out.Values[i] = ec._UpstreamProject_triggerType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._UpstreamProject_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var useSpruceOptionsImplementors = []string{"UseSpruceOptions"}

func (ec *executionContext) _UseSpruceOptions(ctx context.Context, sel ast.SelectionSet, obj *model.APIUseSpruceOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, useSpruceOptionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UseSpruceOptions")
		case "spruceV1":
			out.Values[i] = ec._UseSpruceOptions_spruceV1(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.APIDBUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "betaFeatures":
			out.Values[i] = ec._User_betaFeatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._User_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "emailAddress":
			out.Values[i] = ec._User_emailAddress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parsleyFilters":
			out.Values[i] = ec._User_parsleyFilters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parsleySettings":
			out.Values[i] = ec._User_parsleySettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patches":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_patches(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "permissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_permissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "settings":
			out.Values[i] = ec._User_settings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_subscriptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userId":
			out.Values[i] = ec._User_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userConfigImplementors = []string{"UserConfig"}

func (ec *executionContext) _UserConfig(ctx context.Context, sel ast.SelectionSet, obj *UserConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConfig")
		case "api_key":
			out.Values[i] = ec._UserConfig_api_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "api_server_host":
			out.Values[i] = ec._UserConfig_api_server_host(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ui_server_host":
			out.Values[i] = ec._UserConfig_ui_server_host(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._UserConfig_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oauth_issuer":
			out.Values[i] = ec._UserConfig_oauth_issuer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oauth_client_id":
			out.Values[i] = ec._UserConfig_oauth_client_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oauth_connector_id":
			out.Values[i] = ec._UserConfig_oauth_connector_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userServiceFlagsImplementors = []string{"UserServiceFlags"}

func (ec *executionContext) _UserServiceFlags(ctx context.Context, sel ast.SelectionSet, obj *model.APIServiceFlags) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userServiceFlagsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserServiceFlags")
		case "jwtTokenForCLIDisabled":
			out.Values[i] = ec._UserServiceFlags_jwtTokenForCLIDisabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSettingsImplementors = []string{"UserSettings"}

func (ec *executionContext) _UserSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIUserSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSettings")
		case "githubUser":
			out.Values[i] = ec._UserSettings_githubUser(ctx, field, obj)
		case "notifications":
			out.Values[i] = ec._UserSettings_notifications(ctx, field, obj)
		case "region":
			out.Values[i] = ec._UserSettings_region(ctx, field, obj)
		case "slackUsername":
			out.Values[i] = ec._UserSettings_slackUsername(ctx, field, obj)
		case "slackMemberId":
			out.Values[i] = ec._UserSettings_slackMemberId(ctx, field, obj)
		case "timezone":
			out.Values[i] = ec._UserSettings_timezone(ctx, field, obj)
		case "useSpruceOptions":
			out.Values[i] = ec._UserSettings_useSpruceOptions(ctx, field, obj)
		case "dateFormat":
			out.Values[i] = ec._UserSettings_dateFormat(ctx, field, obj)
		case "timeFormat":
			out.Values[i] = ec._UserSettings_timeFormat(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var variantTaskImplementors = []string{"VariantTask"}

func (ec *executionContext) _VariantTask(ctx context.Context, sel ast.SelectionSet, obj *model.VariantTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, variantTaskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VariantTask")
		case "name":
			out.Values[i] = ec._VariantTask_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._VariantTask_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *model.APIVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "id":
			out.Values[i] = ec._Version_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activated":
			out.Values[i] = ec._Version_activated(ctx, field, obj)
		case "author":
			out.Values[i] = ec._Version_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authorEmail":
			out.Values[i] = ec._Version_authorEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "baseTaskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_baseTaskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "baseVersion":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_baseVersion(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "branch":
			out.Values[i] = ec._Version_branch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariants":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_buildVariants(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buildVariantStats":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_buildVariantStats(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "childVersions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_childVersions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createTime":
			out.Values[i] = ec._Version_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "errors":
			out.Values[i] = ec._Version_errors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "externalLinksForMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_externalLinksForMetadata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "finishTime":
			out.Values[i] = ec._Version_finishTime(ctx, field, obj)
		case "generatedTaskCounts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_generatedTaskCounts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "gitTags":
			out.Values[i] = ec._Version_gitTags(ctx, field, obj)
		case "ignored":
			out.Values[i] = ec._Version_ignored(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isPatch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_isPatch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manifest":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_manifest(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "message":
			out.Values[i] = ec._Version_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "order":
			out.Values[i] = ec._Version_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parameters":
			out.Values[i] = ec._Version_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_patch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "previousVersion":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_previousVersion(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "project":
			out.Values[i] = ec._Version_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			out.Values[i] = ec._Version_projectIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectMetadata":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_projectMetadata(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "repo":
			out.Values[i] = ec._Version_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "requester":
			out.Values[i] = ec._Version_requester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "revision":
			out.Values[i] = ec._Version_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "startTime":
			out.Values[i] = ec._Version_startTime(ctx, field, obj)
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskCount":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskCount(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_tasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskStatusStats":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskStatusStats(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "upstreamProject":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_upstreamProject(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "versionTiming":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_versionTiming(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "warnings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_warnings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "waterfallBuilds":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_waterfallBuilds(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "predictedCost":
			out.Values[i] = ec._Version_predictedCost(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionTasksImplementors = []string{"VersionTasks"}

func (ec *executionContext) _VersionTasks(ctx context.Context, sel ast.SelectionSet, obj *VersionTasks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionTasksImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionTasks")
		case "count":
			out.Values[i] = ec._VersionTasks_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._VersionTasks_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionTimingImplementors = []string{"VersionTiming"}

func (ec *executionContext) _VersionTiming(ctx context.Context, sel ast.SelectionSet, obj *VersionTiming) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionTimingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionTiming")
		case "makespan":
			out.Values[i] = ec._VersionTiming_makespan(ctx, field, obj)
		case "timeTaken":
			out.Values[i] = ec._VersionTiming_timeTaken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var volumeImplementors = []string{"Volume"}

func (ec *executionContext) _Volume(ctx context.Context, sel ast.SelectionSet, obj *model.APIVolume) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, volumeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Volume")
		case "id":
			out.Values[i] = ec._Volume_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "availabilityZone":
			out.Values[i] = ec._Volume_availabilityZone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._Volume_createdBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "creationTime":
			out.Values[i] = ec._Volume_creationTime(ctx, field, obj)
		case "deviceName":
			out.Values[i] = ec._Volume_deviceName(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Volume_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expiration":
			out.Values[i] = ec._Volume_expiration(ctx, field, obj)
		case "homeVolume":
			out.Values[i] = ec._Volume_homeVolume(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "host":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Volume_host(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hostID":
			out.Values[i] = ec._Volume_hostID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "migrating":
			out.Values[i] = ec._Volume_migrating(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "noExpiration":
			out.Values[i] = ec._Volume_noExpiration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "size":
			out.Values[i] = ec._Volume_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Volume_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallImplementors = []string{"Waterfall"}

func (ec *executionContext) _Waterfall(ctx context.Context, sel ast.SelectionSet, obj *Waterfall) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Waterfall")
		case "flattenedVersions":
			out.Values[i] = ec._Waterfall_flattenedVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._Waterfall_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallBuildImplementors = []string{"WaterfallBuild"}

func (ec *executionContext) _WaterfallBuild(ctx context.Context, sel ast.SelectionSet, obj *model1.WaterfallBuild) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallBuildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallBuild")
		case "id":
			out.Values[i] = ec._WaterfallBuild_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activated":
			out.Values[i] = ec._WaterfallBuild_activated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildVariant":
			out.Values[i] = ec._WaterfallBuild_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._WaterfallBuild_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._WaterfallBuild_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._WaterfallBuild_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallBuildVariantImplementors = []string{"WaterfallBuildVariant"}

func (ec *executionContext) _WaterfallBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *model1.WaterfallBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallBuildVariantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallBuildVariant")
		case "id":
			out.Values[i] = ec._WaterfallBuildVariant_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "builds":
			out.Values[i] = ec._WaterfallBuildVariant_builds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._WaterfallBuildVariant_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._WaterfallBuildVariant_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallPaginationImplementors = []string{"WaterfallPagination"}

func (ec *executionContext) _WaterfallPagination(ctx context.Context, sel ast.SelectionSet, obj *WaterfallPagination) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallPaginationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallPagination")
		case "activeVersionIds":
			out.Values[i] = ec._WaterfallPagination_activeVersionIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasNextPage":
			out.Values[i] = ec._WaterfallPagination_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPrevPage":
			out.Values[i] = ec._WaterfallPagination_hasPrevPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mostRecentVersionOrder":
			out.Values[i] = ec._WaterfallPagination_mostRecentVersionOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextPageOrder":
			out.Values[i] = ec._WaterfallPagination_nextPageOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prevPageOrder":
			out.Values[i] = ec._WaterfallPagination_prevPageOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallTaskImplementors = []string{"WaterfallTask"}

func (ec *executionContext) _WaterfallTask(ctx context.Context, sel ast.SelectionSet, obj *model1.WaterfallTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallTaskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallTask")
		case "id":
			out.Values[i] = ec._WaterfallTask_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._WaterfallTask_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayStatusCache":
			out.Values[i] = ec._WaterfallTask_displayStatusCache(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "execution":
			out.Values[i] = ec._WaterfallTask_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._WaterfallTask_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallVersionImplementors = []string{"WaterfallVersion"}

func (ec *executionContext) _WaterfallVersion(ctx context.Context, sel ast.SelectionSet, obj *WaterfallVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallVersion")
		case "inactiveVersions":
			out.Values[i] = ec._WaterfallVersion_inactiveVersions(ctx, field, obj)
		case "version":
			out.Values[i] = ec._WaterfallVersion_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookImplementors = []string{"Webhook"}

func (ec *executionContext) _Webhook(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebHook) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Webhook")
		case "endpoint":
			out.Values[i] = ec._Webhook_endpoint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secret":
			out.Values[i] = ec._Webhook_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookHeaderImplementors = []string{"WebhookHeader"}

func (ec *executionContext) _WebhookHeader(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebhookHeader) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookHeaderImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookHeader")
		case "key":
			out.Values[i] = ec._WebhookHeader_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._WebhookHeader_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookSubscriberImplementors = []string{"WebhookSubscriber"}

func (ec *executionContext) _WebhookSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebhookSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookSubscriber")
		case "headers":
			out.Values[i] = ec._WebhookSubscriber_headers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secret":
			out.Values[i] = ec._WebhookSubscriber_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._WebhookSubscriber_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "retries":
			out.Values[i] = ec._WebhookSubscriber_retries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minDelayMs":
			out.Values[i] = ec._WebhookSubscriber_minDelayMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timeoutMs":
			out.Values[i] = ec._WebhookSubscriber_timeoutMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workstationConfigImplementors = []string{"WorkstationConfig"}

func (ec *executionContext) _WorkstationConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workstationConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkstationConfig")
		case "gitClone":
			out.Values[i] = ec._WorkstationConfig_gitClone(ctx, field, obj)
		case "setupCommands":
			out.Values[i] = ec._WorkstationConfig_setupCommands(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workstationSetupCommandImplementors = []string{"WorkstationSetupCommand"}

func (ec *executionContext) _WorkstationSetupCommand(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationSetupCommand) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workstationSetupCommandImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkstationSetupCommand")
		case "command":
			out.Values[i] = ec._WorkstationSetupCommand_command(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "directory":
			out.Values[i] = ec._WorkstationSetupCommand_directory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAWSAccountRoleMapping2githubcomevergreencievergreenrestmodelAPIAWSAccountRoleMapping(ctx context.Context, sel ast.SelectionSet, v model.APIAWSAccountRoleMapping) graphql.Marshaler {
	return ec._AWSAccountRoleMapping(ctx, sel, &v)
}

func (ec *executionContext) marshalNAWSAccountRoleMapping2githubcomevergreencievergreenrestmodelAPIAWSAccountRoleMapping(ctx context.Context, sel ast.SelectionSet, v []model.APIAWSAccountRoleMapping) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAWSAccountRoleMapping2githubcomevergreencievergreenrestmodelAPIAWSAccountRoleMapping(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNAWSAccountRoleMappingInput2githubcomevergreencievergreenrestmodelAPIAWSAccountRoleMapping(ctx context.Context, v any) (model.APIAWSAccountRoleMapping, error) {
	res, err := ec.unmarshalInputAWSAccountRoleMappingInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAWSAccountRoleMappingInput2githubcomevergreencievergreenrestmodelAPIAWSAccountRoleMapping(ctx context.Context, v any) ([]model.APIAWSAccountRoleMapping, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIAWSAccountRoleMapping, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAWSAccountRoleMappingInput2githubcomevergreencievergreenrestmodelAPIAWSAccountRoleMapping(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx context.Context, v any) (AccessLevel, error) {
	var res AccessLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx context.Context, sel ast.SelectionSet, v AccessLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAddFavoriteProjectInput2githubcomevergreencievergreengraphqlAddFavoriteProjectInput(ctx context.Context, v any) (AddFavoriteProjectInput, error) {
	res, err := ec.unmarshalInputAddFavoriteProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminEvent2githubcomevergreencievergreengraphqlAdminEvent(ctx context.Context, sel ast.SelectionSet, v []*AdminEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminEvent2githubcomevergreencievergreengraphqlAdminEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAdminEvent2githubcomevergreencievergreengraphqlAdminEvent(ctx context.Context, sel ast.SelectionSet, v *AdminEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAdminEventsInput2githubcomevergreencievergreengraphqlAdminEventsInput(ctx context.Context, v any) (AdminEventsInput, error) {
	res, err := ec.unmarshalInputAdminEventsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminEventsPayload2githubcomevergreencievergreengraphqlAdminEventsPayload(ctx context.Context, sel ast.SelectionSet, v AdminEventsPayload) graphql.Marshaler {
	return ec._AdminEventsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminEventsPayload2githubcomevergreencievergreengraphqlAdminEventsPayload(ctx context.Context, sel ast.SelectionSet, v *AdminEventsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminEventsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAdminSettings2githubcomevergreencievergreenrestmodelAPIAdminSettings(ctx context.Context, sel ast.SelectionSet, v model.APIAdminSettings) graphql.Marshaler {
	return ec._AdminSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminSettings2githubcomevergreencievergreenrestmodelAPIAdminSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIAdminSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAdminSettingsInput2githubcomevergreencievergreenrestmodelAPIAdminSettings(ctx context.Context, v any) (model.APIAdminSettings, error) {
	res, err := ec.unmarshalInputAdminSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAdminSettingsInput2githubcomevergreencievergreenrestmodelAPIAdminSettings(ctx context.Context, v any) (*model.APIAdminSettings, error) {
	res, err := ec.unmarshalInputAdminSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminTasksToRestartPayload2githubcomevergreencievergreengraphqlAdminTasksToRestartPayload(ctx context.Context, sel ast.SelectionSet, v AdminTasksToRestartPayload) graphql.Marshaler {
	return ec._AdminTasksToRestartPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminTasksToRestartPayload2githubcomevergreencievergreengraphqlAdminTasksToRestartPayload(ctx context.Context, sel ast.SelectionSet, v *AdminTasksToRestartPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminTasksToRestartPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAmboyNamedQueueConfig2githubcomevergreencievergreenrestmodelAPIAmboyNamedQueueConfig(ctx context.Context, sel ast.SelectionSet, v model.APIAmboyNamedQueueConfig) graphql.Marshaler {
	return ec._AmboyNamedQueueConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNAmboyNamedQueueConfig2githubcomevergreencievergreenrestmodelAPIAmboyNamedQueueConfig(ctx context.Context, sel ast.SelectionSet, v []model.APIAmboyNamedQueueConfig) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAmboyNamedQueueConfig2githubcomevergreencievergreenrestmodelAPIAmboyNamedQueueConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNAmboyNamedQueueConfigInput2githubcomevergreencievergreenrestmodelAPIAmboyNamedQueueConfig(ctx context.Context, v any) (model.APIAmboyNamedQueueConfig, error) {
	res, err := ec.unmarshalInputAmboyNamedQueueConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAmboyNamedQueueConfigInput2githubcomevergreencievergreenrestmodelAPIAmboyNamedQueueConfig(ctx context.Context, v any) ([]model.APIAmboyNamedQueueConfig, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIAmboyNamedQueueConfig, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAmboyNamedQueueConfigInput2githubcomevergreencievergreenrestmodelAPIAmboyNamedQueueConfig(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNAmboyRetryConfigInput2githubcomevergreencievergreenrestmodelAPIAmboyRetryConfig(ctx context.Context, v any) (model.APIAmboyRetryConfig, error) {
	res, err := ec.unmarshalInputAmboyRetryConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNArch2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNArch2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArch2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNArch2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNArch2string = map[string]string{
		"LINUX_64_BIT":     evergreen.ArchLinuxAmd64,
		"LINUX_ARM_64_BIT": evergreen.ArchLinuxArm64,
		"LINUX_PPC_64_BIT": evergreen.ArchLinuxPpc64le,
		"LINUX_ZSERIES":    evergreen.ArchLinuxS390x,
		"OSX_64_BIT":       evergreen.ArchDarwinAmd64,
		"OSX_ARM_64_BIT":   evergreen.ArchDarwinArm64,
		"WINDOWS_64_BIT":   evergreen.ArchWindowsAmd64,
	}
	marshalNArch2string = map[string]string{
		evergreen.ArchLinuxAmd64:   "LINUX_64_BIT",
		evergreen.ArchLinuxArm64:   "LINUX_ARM_64_BIT",
		evergreen.ArchLinuxPpc64le: "LINUX_PPC_64_BIT",
		evergreen.ArchLinuxS390x:   "LINUX_ZSERIES",
		evergreen.ArchDarwinAmd64:  "OSX_64_BIT",
		evergreen.ArchDarwinArm64:  "OSX_ARM_64_BIT",
		evergreen.ArchWindowsAmd64: "WINDOWS_64_BIT",
	}
)

func (ec *executionContext) marshalNAuthUser2githubcomevergreencievergreenrestmodelAPIAuthUser(ctx context.Context, sel ast.SelectionSet, v model.APIAuthUser) graphql.Marshaler {
	return ec._AuthUser(ctx, sel, &v)
}

func (ec *executionContext) marshalNAuthUser2githubcomevergreencievergreenrestmodelAPIAuthUser(ctx context.Context, sel ast.SelectionSet, v []model.APIAuthUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAuthUser2githubcomevergreencievergreenrestmodelAPIAuthUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNAuthUserInput2githubcomevergreencievergreenrestmodelAPIAuthUser(ctx context.Context, v any) (model.APIAuthUser, error) {
	res, err := ec.unmarshalInputAuthUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBannerTheme2githubcomevergreencievergreenBannerTheme(ctx context.Context, v any) (evergreen.BannerTheme, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := evergreen.BannerTheme(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBannerTheme2githubcomevergreencievergreenBannerTheme(ctx context.Context, sel ast.SelectionSet, v evergreen.BannerTheme) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBetaFeatures2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx context.Context, sel ast.SelectionSet, v model.APIBetaFeatures) graphql.Marshaler {
	return ec._BetaFeatures(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBetaFeaturesInput2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx context.Context, v any) (model.APIBetaFeatures, error) {
	res, err := ec.unmarshalInputBetaFeaturesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBetaFeaturesInput2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx context.Context, v any) (*model.APIBetaFeatures, error) {
	res, err := ec.unmarshalInputBetaFeaturesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (*bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalBoolean(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBootstrapMethod2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNBootstrapMethod2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBootstrapMethod2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNBootstrapMethod2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNBootstrapMethod2string = map[string]string{
		"LEGACY_SSH": distro.BootstrapMethodLegacySSH,
		"SSH":        distro.BootstrapMethodSSH,
		"USER_DATA":  distro.BootstrapMethodUserData,
	}
	marshalNBootstrapMethod2string = map[string]string{
		distro.BootstrapMethodLegacySSH: "LEGACY_SSH",
		distro.BootstrapMethodSSH:       "SSH",
		distro.BootstrapMethodUserData:  "USER_DATA",
	}
)

func (ec *executionContext) marshalNBootstrapSettings2githubcomevergreencievergreenrestmodelAPIBootstrapSettings(ctx context.Context, sel ast.SelectionSet, v model.APIBootstrapSettings) graphql.Marshaler {
	return ec._BootstrapSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBootstrapSettingsInput2githubcomevergreencievergreenrestmodelAPIBootstrapSettings(ctx context.Context, v any) (model.APIBootstrapSettings, error) {
	res, err := ec.unmarshalInputBootstrapSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuild2githubcomevergreencievergreenrestmodelAPIBuild(ctx context.Context, sel ast.SelectionSet, v []*model.APIBuild) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuild2githubcomevergreencievergreenrestmodelAPIBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBuild2githubcomevergreencievergreenrestmodelAPIBuild(ctx context.Context, sel ast.SelectionSet, v *model.APIBuild) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildBaron2githubcomevergreencievergreengraphqlBuildBaron(ctx context.Context, sel ast.SelectionSet, v BuildBaron) graphql.Marshaler {
	return ec._BuildBaron(ctx, sel, &v)
}

func (ec *executionContext) marshalNBuildBaron2githubcomevergreencievergreengraphqlBuildBaron(ctx context.Context, sel ast.SelectionSet, v *BuildBaron) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildBaron(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildBaronSettings2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings(ctx context.Context, sel ast.SelectionSet, v model.APIBuildBaronSettings) graphql.Marshaler {
	return ec._BuildBaronSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions(ctx context.Context, v any) (BuildVariantOptions, error) {
	res, err := ec.unmarshalInputBuildVariantOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuildVariantTuple2githubcomevergreencievergreenmodeltaskBuildVariantTuple(ctx context.Context, sel ast.SelectionSet, v *task.BuildVariantTuple) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildVariantTuple(ctx, sel, v)
}

func (ec *executionContext) marshalNChildPatchAlias2githubcomevergreencievergreenrestmodelAPIChildPatchAlias(ctx context.Context, sel ast.SelectionSet, v model.APIChildPatchAlias) graphql.Marshaler {
	return ec._ChildPatchAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNClientBinary2githubcomevergreencievergreenrestmodelAPIClientBinary(ctx context.Context, sel ast.SelectionSet, v model.APIClientBinary) graphql.Marshaler {
	return ec._ClientBinary(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommitQueueParams2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx context.Context, sel ast.SelectionSet, v model.APICommitQueueParams) graphql.Marshaler {
	return ec._CommitQueueParams(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNCommunicationMethod2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNCommunicationMethod2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCommunicationMethod2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNCommunicationMethod2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNCommunicationMethod2string = map[string]string{
		"LEGACY_SSH": distro.CommunicationMethodLegacySSH,
		"SSH":        distro.CommunicationMethodSSH,
		"RPC":        distro.CommunicationMethodRPC,
	}
	marshalNCommunicationMethod2string = map[string]string{
		distro.CommunicationMethodLegacySSH: "LEGACY_SSH",
		distro.CommunicationMethodSSH:       "SSH",
		distro.CommunicationMethodRPC:       "RPC",
	}
)

func (ec *executionContext) marshalNContainerPool2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx context.Context, sel ast.SelectionSet, v model.APIContainerPool) graphql.Marshaler {
	return ec._ContainerPool(ctx, sel, &v)
}

func (ec *executionContext) marshalNContainerPool2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx context.Context, sel ast.SelectionSet, v []model.APIContainerPool) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerPool2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNContainerPoolInput2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx context.Context, v any) (model.APIContainerPool, error) {
	res, err := ec.unmarshalInputContainerPoolInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNContainerPoolInput2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx context.Context, v any) ([]model.APIContainerPool, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIContainerPool, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContainerPoolInput2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNContainerResources2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx context.Context, sel ast.SelectionSet, v model.APIContainerResources) graphql.Marshaler {
	return ec._ContainerResources(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNContainerResourcesInput2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx context.Context, v any) (model.APIContainerResources, error) {
	res, err := ec.unmarshalInputContainerResourcesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCopyDistroInput2githubcomevergreencievergreenrestmodelCopyDistroOpts(ctx context.Context, v any) (model.CopyDistroOpts, error) {
	res, err := ec.unmarshalInputCopyDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCopyProjectInput2githubcomevergreencievergreenrestmodelCopyProjectOpts(ctx context.Context, v any) (model.CopyProjectOpts, error) {
	res, err := ec.unmarshalInputCopyProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateDistroInput2githubcomevergreencievergreengraphqlCreateDistroInput(ctx context.Context, v any) (CreateDistroInput, error) {
	res, err := ec.unmarshalInputCreateDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateProjectInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, v any) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputCreateProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursorParams2githubcomevergreencievergreengraphqlCursorParams(ctx context.Context, v any) (*CursorParams, error) {
	res, err := ec.unmarshalInputCursorParams(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDeactivateStepbackTaskInput2githubcomevergreencievergreengraphqlDeactivateStepbackTaskInput(ctx context.Context, v any) (DeactivateStepbackTaskInput, error) {
	res, err := ec.unmarshalInputDeactivateStepbackTaskInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDefaultSectionToRepoInput2githubcomevergreencievergreengraphqlDefaultSectionToRepoInput(ctx context.Context, v any) (DefaultSectionToRepoInput, error) {
	res, err := ec.unmarshalInputDefaultSectionToRepoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDeleteDistroInput2githubcomevergreencievergreengraphqlDeleteDistroInput(ctx context.Context, v any) (DeleteDistroInput, error) {
	res, err := ec.unmarshalInputDeleteDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteDistroPayload2githubcomevergreencievergreengraphqlDeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, v DeleteDistroPayload) graphql.Marshaler {
	return ec._DeleteDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteDistroPayload2githubcomevergreencievergreengraphqlDeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, v *DeleteDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteDistroPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteGithubAppCredentialsInput2githubcomevergreencievergreengraphqlDeleteGithubAppCredentialsInput(ctx context.Context, v any) (DeleteGithubAppCredentialsInput, error) {
	res, err := ec.unmarshalInputDeleteGithubAppCredentialsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDependency2githubcomevergreencievergreengraphqlDependency(ctx context.Context, sel ast.SelectionSet, v *Dependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Dependency(ctx, sel, v)
}

func (ec *executionContext) marshalNDispatcherSettings2githubcomevergreencievergreenrestmodelAPIDispatcherSettings(ctx context.Context, sel ast.SelectionSet, v model.APIDispatcherSettings) graphql.Marshaler {
	return ec._DispatcherSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNDispatcherSettingsInput2githubcomevergreencievergreenrestmodelAPIDispatcherSettings(ctx context.Context, v any) (model.APIDispatcherSettings, error) {
	res, err := ec.unmarshalInputDispatcherSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDispatcherVersion2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNDispatcherVersion2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDispatcherVersion2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNDispatcherVersion2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNDispatcherVersion2string = map[string]string{
		"REVISED_WITH_DEPENDENCIES": evergreen.DispatcherVersionRevisedWithDependencies,
	}
	marshalNDispatcherVersion2string = map[string]string{
		evergreen.DispatcherVersionRevisedWithDependencies: "REVISED_WITH_DEPENDENCIES",
	}
)

func (ec *executionContext) unmarshalNDisplayTask2githubcomevergreencievergreengraphqlDisplayTask(ctx context.Context, v any) ([]*DisplayTask, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*DisplayTask, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDisplayTask2githubcomevergreencievergreengraphqlDisplayTask(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNDisplayTask2githubcomevergreencievergreengraphqlDisplayTask(ctx context.Context, v any) (*DisplayTask, error) {
	res, err := ec.unmarshalInputDisplayTask(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx context.Context, sel ast.SelectionSet, v []*model.APIDistro) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx context.Context, sel ast.SelectionSet, v *model.APIDistro) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Distro(ctx, sel, v)
}

func (ec *executionContext) marshalNDistroEvent2githubcomevergreencievergreengraphqlDistroEvent(ctx context.Context, sel ast.SelectionSet, v []*DistroEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDistroEvent2githubcomevergreencievergreengraphqlDistroEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDistroEvent2githubcomevergreencievergreengraphqlDistroEvent(ctx context.Context, sel ast.SelectionSet, v *DistroEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroEventsInput2githubcomevergreencievergreengraphqlDistroEventsInput(ctx context.Context, v any) (DistroEventsInput, error) {
	res, err := ec.unmarshalInputDistroEventsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroEventsPayload2githubcomevergreencievergreengraphqlDistroEventsPayload(ctx context.Context, sel ast.SelectionSet, v DistroEventsPayload) graphql.Marshaler {
	return ec._DistroEventsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDistroEventsPayload2githubcomevergreencievergreengraphqlDistroEventsPayload(ctx context.Context, sel ast.SelectionSet, v *DistroEventsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroEventsPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroInput2githubcomevergreencievergreenrestmodelAPIDistro(ctx context.Context, v any) (*model.APIDistro, error) {
	res, err := ec.unmarshalInputDistroInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDistroOnSaveOperation2githubcomevergreencievergreengraphqlDistroOnSaveOperation(ctx context.Context, v any) (DistroOnSaveOperation, error) {
	var res DistroOnSaveOperation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroOnSaveOperation2githubcomevergreencievergreengraphqlDistroOnSaveOperation(ctx context.Context, sel ast.SelectionSet, v DistroOnSaveOperation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDistroPermissions2githubcomevergreencievergreengraphqlDistroPermissions(ctx context.Context, sel ast.SelectionSet, v DistroPermissions) graphql.Marshaler {
	return ec._DistroPermissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNDistroPermissions2githubcomevergreencievergreengraphqlDistroPermissions(ctx context.Context, sel ast.SelectionSet, v *DistroPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroPermissionsOptions2githubcomevergreencievergreengraphqlDistroPermissionsOptions(ctx context.Context, v any) (DistroPermissionsOptions, error) {
	res, err := ec.unmarshalInputDistroPermissionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx context.Context, v any) (DistroSettingsAccess, error) {
	var res DistroSettingsAccess
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx context.Context, sel ast.SelectionSet, v DistroSettingsAccess) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, v any) (model.APIDuration, error) {
	res, err := model.UnmarshalAPIDuration(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, sel ast.SelectionSet, v model.APIDuration) graphql.Marshaler {
	_ = sel
	res := model.MarshalAPIDuration(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNEC2Key2githubcomevergreencievergreenrestmodelAPIEC2Key(ctx context.Context, sel ast.SelectionSet, v model.APIEC2Key) graphql.Marshaler {
	return ec._EC2Key(ctx, sel, &v)
}

func (ec *executionContext) marshalNEC2Key2githubcomevergreencievergreenrestmodelAPIEC2Key(ctx context.Context, sel ast.SelectionSet, v []model.APIEC2Key) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEC2Key2githubcomevergreencievergreenrestmodelAPIEC2Key(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNEC2KeyInput2githubcomevergreencievergreenrestmodelAPIEC2Key(ctx context.Context, v any) (model.APIEC2Key, error) {
	res, err := ec.unmarshalInputEC2KeyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEC2KeyInput2githubcomevergreencievergreenrestmodelAPIEC2Key(ctx context.Context, v any) ([]model.APIEC2Key, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIEC2Key, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEC2KeyInput2githubcomevergreencievergreenrestmodelAPIEC2Key(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNECSCapacityProvider2githubcomevergreencievergreenrestmodelAPIECSCapacityProvider(ctx context.Context, sel ast.SelectionSet, v model.APIECSCapacityProvider) graphql.Marshaler {
	return ec._ECSCapacityProvider(ctx, sel, &v)
}

func (ec *executionContext) marshalNECSCapacityProvider2githubcomevergreencievergreenrestmodelAPIECSCapacityProvider(ctx context.Context, sel ast.SelectionSet, v []model.APIECSCapacityProvider) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNECSCapacityProvider2githubcomevergreencievergreenrestmodelAPIECSCapacityProvider(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNECSCapacityProviderInput2githubcomevergreencievergreenrestmodelAPIECSCapacityProvider(ctx context.Context, v any) (model.APIECSCapacityProvider, error) {
	res, err := ec.unmarshalInputECSCapacityProviderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNECSCapacityProviderInput2githubcomevergreencievergreenrestmodelAPIECSCapacityProvider(ctx context.Context, v any) ([]model.APIECSCapacityProvider, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIECSCapacityProvider, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNECSCapacityProviderInput2githubcomevergreencievergreenrestmodelAPIECSCapacityProvider(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNECSClusterConfig2githubcomevergreencievergreenrestmodelAPIECSClusterConfig(ctx context.Context, sel ast.SelectionSet, v model.APIECSClusterConfig) graphql.Marshaler {
	return ec._ECSClusterConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNECSClusterConfig2githubcomevergreencievergreenrestmodelAPIECSClusterConfig(ctx context.Context, sel ast.SelectionSet, v []model.APIECSClusterConfig) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNECSClusterConfig2githubcomevergreencievergreenrestmodelAPIECSClusterConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNECSClusterConfigInput2githubcomevergreencievergreenrestmodelAPIECSClusterConfig(ctx context.Context, v any) (model.APIECSClusterConfig, error) {
	res, err := ec.unmarshalInputECSClusterConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNECSClusterConfigInput2githubcomevergreencievergreenrestmodelAPIECSClusterConfig(ctx context.Context, v any) ([]model.APIECSClusterConfig, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIECSClusterConfig, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNECSClusterConfigInput2githubcomevergreencievergreenrestmodelAPIECSClusterConfig(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNEnvVar2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx context.Context, sel ast.SelectionSet, v model.APIEnvVar) graphql.Marshaler {
	return ec._EnvVar(ctx, sel, &v)
}

func (ec *executionContext) marshalNEnvVar2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx context.Context, sel ast.SelectionSet, v []model.APIEnvVar) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEnvVar2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNEnvVarInput2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx context.Context, v any) (model.APIEnvVar, error) {
	res, err := ec.unmarshalInputEnvVarInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEnvVarInput2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx context.Context, v any) ([]model.APIEnvVar, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIEnvVar, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEnvVarInput2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNExpansion2githubcomevergreencievergreenrestmodelAPIExpansion(ctx context.Context, sel ast.SelectionSet, v model.APIExpansion) graphql.Marshaler {
	return ec._Expansion(ctx, sel, &v)
}

func (ec *executionContext) marshalNExpansion2githubcomevergreencievergreenrestmodelAPIExpansion(ctx context.Context, sel ast.SelectionSet, v []model.APIExpansion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExpansion2githubcomevergreencievergreenrestmodelAPIExpansion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNExpansionInput2githubcomevergreencievergreenrestmodelAPIExpansion(ctx context.Context, v any) (model.APIExpansion, error) {
	res, err := ec.unmarshalInputExpansionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNExpansionInput2githubcomevergreencievergreenrestmodelAPIExpansion(ctx context.Context, v any) ([]model.APIExpansion, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIExpansion, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNExpansionInput2githubcomevergreencievergreenrestmodelAPIExpansion(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNExternalLink2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx context.Context, sel ast.SelectionSet, v model.APIExternalLink) graphql.Marshaler {
	return ec._ExternalLink(ctx, sel, &v)
}

func (ec *executionContext) marshalNExternalLinkForMetadata2githubcomevergreencievergreengraphqlExternalLinkForMetadata(ctx context.Context, sel ast.SelectionSet, v []*ExternalLinkForMetadata) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExternalLinkForMetadata2githubcomevergreencievergreengraphqlExternalLinkForMetadata(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNExternalLinkForMetadata2githubcomevergreencievergreengraphqlExternalLinkForMetadata(ctx context.Context, sel ast.SelectionSet, v *ExternalLinkForMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExternalLinkForMetadata(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExternalLinkInput2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx context.Context, v any) (model.APIExternalLink, error) {
	res, err := ec.unmarshalInputExternalLinkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFailingCommand2githubcomevergreencievergreenrestmodelAPIFailingCommand(ctx context.Context, sel ast.SelectionSet, v model.APIFailingCommand) graphql.Marshaler {
	return ec._FailingCommand(ctx, sel, &v)
}

func (ec *executionContext) marshalNFailingCommand2githubcomevergreencievergreenrestmodelAPIFailingCommand(ctx context.Context, sel ast.SelectionSet, v []model.APIFailingCommand) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFailingCommand2githubcomevergreencievergreenrestmodelAPIFailingCommand(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNFeedbackRule2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNFeedbackRule2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeedbackRule2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNFeedbackRule2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNFeedbackRule2string = map[string]string{
		"WAITS_OVER_THRESH": evergreen.HostAllocatorWaitsOverThreshFeedback,
		"NO_FEEDBACK":       evergreen.HostAllocatorNoFeedback,
		"DEFAULT":           evergreen.HostAllocatorUseDefaultFeedback,
	}
	marshalNFeedbackRule2string = map[string]string{
		evergreen.HostAllocatorWaitsOverThreshFeedback: "WAITS_OVER_THRESH",
		evergreen.HostAllocatorNoFeedback:              "NO_FEEDBACK",
		evergreen.HostAllocatorUseDefaultFeedback:      "DEFAULT",
	}
)

func (ec *executionContext) marshalNFile2githubcomevergreencievergreenrestmodelAPIFile(ctx context.Context, sel ast.SelectionSet, v *model.APIFile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._File(ctx, sel, v)
}

func (ec *executionContext) marshalNFileDiff2githubcomevergreencievergreenrestmodelFileDiff(ctx context.Context, sel ast.SelectionSet, v model.FileDiff) graphql.Marshaler {
	return ec._FileDiff(ctx, sel, &v)
}

func (ec *executionContext) marshalNFileDiff2githubcomevergreencievergreenrestmodelFileDiff(ctx context.Context, sel ast.SelectionSet, v []model.FileDiff) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFileDiff2githubcomevergreencievergreenrestmodelFileDiff(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFinderSettings2githubcomevergreencievergreenrestmodelAPIFinderSettings(ctx context.Context, sel ast.SelectionSet, v model.APIFinderSettings) graphql.Marshaler {
	return ec._FinderSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNFinderSettingsInput2githubcomevergreencievergreenrestmodelAPIFinderSettings(ctx context.Context, v any) (model.APIFinderSettings, error) {
	res, err := ec.unmarshalInputFinderSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFinderVersion2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNFinderVersion2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFinderVersion2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNFinderVersion2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNFinderVersion2string = map[string]string{
		"LEGACY":    evergreen.FinderVersionLegacy,
		"PARALLEL":  evergreen.FinderVersionParallel,
		"PIPELINE":  evergreen.FinderVersionPipeline,
		"ALTERNATE": evergreen.FinderVersionAlternate,
	}
	marshalNFinderVersion2string = map[string]string{
		evergreen.FinderVersionLegacy:    "LEGACY",
		evergreen.FinderVersionParallel:  "PARALLEL",
		evergreen.FinderVersionPipeline:  "PIPELINE",
		evergreen.FinderVersionAlternate: "ALTERNATE",
	}
)

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, sel ast.SelectionSet, v model.APISubscription) graphql.Marshaler {
	return ec._GeneralSubscription(ctx, sel, &v)
}

func (ec *executionContext) marshalNGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, sel ast.SelectionSet, v *model.APISubscription) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GeneralSubscription(ctx, sel, v)
}

func (ec *executionContext) marshalNGeneratedTaskCountResults2githubcomevergreencievergreengraphqlGeneratedTaskCountResults(ctx context.Context, sel ast.SelectionSet, v []*GeneratedTaskCountResults) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneratedTaskCountResults2githubcomevergreencievergreengraphqlGeneratedTaskCountResults(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGeneratedTaskCountResults2githubcomevergreencievergreengraphqlGeneratedTaskCountResults(ctx context.Context, sel ast.SelectionSet, v *GeneratedTaskCountResults) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GeneratedTaskCountResults(ctx, sel, v)
}

func (ec *executionContext) marshalNGitHubDynamicTokenPermissionGroup2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx context.Context, sel ast.SelectionSet, v model.APIGitHubDynamicTokenPermissionGroup) graphql.Marshaler {
	return ec._GitHubDynamicTokenPermissionGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitHubDynamicTokenPermissionGroup2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx context.Context, sel ast.SelectionSet, v []model.APIGitHubDynamicTokenPermissionGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitHubDynamicTokenPermissionGroup2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNGitHubDynamicTokenPermissionGroupInput2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx context.Context, v any) (model.APIGitHubDynamicTokenPermissionGroup, error) {
	res, err := ec.unmarshalInputGitHubDynamicTokenPermissionGroupInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGitTag2githubcomevergreencievergreenrestmodelAPIGitTag(ctx context.Context, sel ast.SelectionSet, v model.APIGitTag) graphql.Marshaler {
	return ec._GitTag(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubProjectConflicts2githubcomevergreencievergreenmodelGithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, v model1.GithubProjectConflicts) graphql.Marshaler {
	return ec._GithubProjectConflicts(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubProjectConflicts2githubcomevergreencievergreenmodelGithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, v *model1.GithubProjectConflicts) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubProjectConflicts(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedBuildVariant2githubcomevergreencievergreengraphqlGroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, v *GroupedBuildVariant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedBuildVariant(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedFiles2githubcomevergreencievergreengraphqlGroupedFiles(ctx context.Context, sel ast.SelectionSet, v []*GroupedFiles) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedFiles2githubcomevergreencievergreengraphqlGroupedFiles(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGroupedFiles2githubcomevergreencievergreengraphqlGroupedFiles(ctx context.Context, sel ast.SelectionSet, v *GroupedFiles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedFiles(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedProjects2githubcomevergreencievergreengraphqlGroupedProjects(ctx context.Context, sel ast.SelectionSet, v []*GroupedProjects) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedProjects2githubcomevergreencievergreengraphqlGroupedProjects(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGroupedProjects2githubcomevergreencievergreengraphqlGroupedProjects(ctx context.Context, sel ast.SelectionSet, v *GroupedProjects) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedProjects(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedTaskStatusCount2githubcomevergreencievergreenmodeltaskGroupedTaskStatusCount(ctx context.Context, sel ast.SelectionSet, v *task.GroupedTaskStatusCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedTaskStatusCount(ctx, sel, v)
}

func (ec *executionContext) marshalNHomeVolumeSettings2githubcomevergreencievergreenrestmodelAPIHomeVolumeSettings(ctx context.Context, sel ast.SelectionSet, v model.APIHomeVolumeSettings) graphql.Marshaler {
	return ec._HomeVolumeSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNHomeVolumeSettingsInput2githubcomevergreencievergreenrestmodelAPIHomeVolumeSettings(ctx context.Context, v any) (model.APIHomeVolumeSettings, error) {
	res, err := ec.unmarshalInputHomeVolumeSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx context.Context, sel ast.SelectionSet, v model.APIHost) graphql.Marshaler {
	return ec._Host(ctx, sel, &v)
}

func (ec *executionContext) marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx context.Context, sel ast.SelectionSet, v []*model.APIHost) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx context.Context, sel ast.SelectionSet, v *model.APIHost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx context.Context, v any) (HostAccessLevel, error) {
	var res HostAccessLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx context.Context, sel ast.SelectionSet, v HostAccessLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNHostAllocatorSettings2githubcomevergreencievergreenrestmodelAPIHostAllocatorSettings(ctx context.Context, sel ast.SelectionSet, v model.APIHostAllocatorSettings) graphql.Marshaler {
	return ec._HostAllocatorSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNHostAllocatorSettingsInput2githubcomevergreencievergreenrestmodelAPIHostAllocatorSettings(ctx context.Context, v any) (model.APIHostAllocatorSettings, error) {
	res, err := ec.unmarshalInputHostAllocatorSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNHostAllocatorVersion2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNHostAllocatorVersion2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostAllocatorVersion2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNHostAllocatorVersion2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNHostAllocatorVersion2string = map[string]string{
		"UTILIZATION": evergreen.HostAllocatorUtilization,
	}
	marshalNHostAllocatorVersion2string = map[string]string{
		evergreen.HostAllocatorUtilization: "UTILIZATION",
	}
)

func (ec *executionContext) marshalNHostEventLogData2githubcomevergreencievergreenrestmodelHostAPIEventData(ctx context.Context, sel ast.SelectionSet, v *model.HostAPIEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNHostEventLogEntry2githubcomevergreencievergreenrestmodelHostAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v []*model.HostAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHostEventLogEntry2githubcomevergreencievergreenrestmodelHostAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHostEventLogEntry2githubcomevergreencievergreenrestmodelHostAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.HostAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHostEventType2string(ctx context.Context, v any) (string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNHostEventType2string[tmp]
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostEventType2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(marshalNHostEventType2string[v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNHostEventType2string = map[string]string{
		"HOST_CREATED":                                     event.EventHostCreated,
		"HOST_CREATED_ERROR":                               event.EventHostCreatedError,
		"HOST_STARTED":                                     event.EventHostStarted,
		"HOST_STOPPED":                                     event.EventHostStopped,
		"HOST_REBOOTED":                                    event.EventHostRebooted,
		"HOST_MODIFIED":                                    event.EventHostModified,
		"HOST_AGENT_DEPLOYED":                              event.EventHostAgentDeployed,
		"HOST_AGENT_DEPLOY_FAILED":                         event.EventHostAgentDeployFailed,
		"HOST_AGENT_MONITOR_DEPLOYED":                      event.EventHostAgentMonitorDeployed,
		"HOST_AGENT_MONITOR_DEPLOY_FAILED":                 event.EventHostAgentMonitorDeployFailed,
		"HOST_JASPER_RESTARTING":                           event.EventHostJasperRestarting,
		"HOST_JASPER_RESTARTED":                            event.EventHostJasperRestarted,
		"HOST_JASPER_RESTART_ERROR":                        event.EventHostJasperRestartError,
		"HOST_CONVERTING_PROVISIONING":                     event.EventHostConvertingProvisioning,
		"HOST_CONVERTED_PROVISIONING":                      event.EventHostConvertedProvisioning,
		"HOST_CONVERTING_PROVISIONING_ERROR":               event.EventHostConvertingProvisioningError,
		"HOST_STATUS_CHANGED":                              event.EventHostStatusChanged,
		"HOST_DNS_NAME_SET":                                event.EventHostDNSNameSet,
		"HOST_PROVISION_ERROR":                             event.EventHostProvisionError,
		"HOST_PROVISION_FAILED":                            event.EventHostProvisionFailed,
		"HOST_PROVISIONED":                                 event.EventHostProvisioned,
		"HOST_RUNNING_TASK_SET":                            event.EventHostRunningTaskSet,
		"HOST_RUNNING_TASK_CLEARED":                        event.EventHostRunningTaskCleared,
		"HOST_TASK_FINISHED":                               event.EventHostTaskFinished,
		"HOST_TERMINATED_EXTERNALLY":                       event.EventHostTerminatedExternally,
		"HOST_EXPIRATION_WARNING_SENT":                     event.EventHostExpirationWarningSent,
		"HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT": event.EventHostTemporaryExemptionExpirationWarningSent,
		"HOST_IDLE_NOTIFICATION":                           event.EventSpawnHostIdleNotification,
		"HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT":        event.EventAlertableInstanceTypeWarningSent,
		"HOST_SCRIPT_EXECUTED":                             event.EventHostScriptExecuted,
		"HOST_SCRIPT_EXECUTE_FAILED":                       event.EventHostScriptExecuteFailed,
		"SPAWN_HOST_CREATED_ERROR":                         event.EventSpawnHostCreatedError,
		"VOLUME_EXPIRATION_WARNING_SENT":                   event.EventVolumeExpirationWarningSent,
		"VOLUME_MIGRATION_FAILED":                          event.EventVolumeMigrationFailed,
	}
	marshalNHostEventType2string = map[string]string{
		event.EventHostCreated:                                 "HOST_CREATED",
		event.EventHostCreatedError:                            "HOST_CREATED_ERROR",
		event.EventHostStarted:                                 "HOST_STARTED",
		event.EventHostStopped:                                 "HOST_STOPPED",
		event.EventHostRebooted:                                "HOST_REBOOTED",
		event.EventHostModified:                                "HOST_MODIFIED",
		event.EventHostAgentDeployed:                           "HOST_AGENT_DEPLOYED",
		event.EventHostAgentDeployFailed:                       "HOST_AGENT_DEPLOY_FAILED",
		event.EventHostAgentMonitorDeployed:                    "HOST_AGENT_MONITOR_DEPLOYED",
		event.EventHostAgentMonitorDeployFailed:                "HOST_AGENT_MONITOR_DEPLOY_FAILED",
		event.EventHostJasperRestarting:                        "HOST_JASPER_RESTARTING",
		event.EventHostJasperRestarted:                         "HOST_JASPER_RESTARTED",
		event.EventHostJasperRestartError:                      "HOST_JASPER_RESTART_ERROR",
		event.EventHostConvertingProvisioning:                  "HOST_CONVERTING_PROVISIONING",
		event.EventHostConvertedProvisioning:                   "HOST_CONVERTED_PROVISIONING",
		event.EventHostConvertingProvisioningError:             "HOST_CONVERTING_PROVISIONING_ERROR",
		event.EventHostStatusChanged:                           "HOST_STATUS_CHANGED",
		event.EventHostDNSNameSet:                              "HOST_DNS_NAME_SET",
		event.EventHostProvisionError:                          "HOST_PROVISION_ERROR",
		event.EventHostProvisionFailed:                         "HOST_PROVISION_FAILED",
		event.EventHostProvisioned:                             "HOST_PROVISIONED",
		event.EventHostRunningTaskSet:                          "HOST_RUNNING_TASK_SET",
		event.EventHostRunningTaskCleared:                      "HOST_RUNNING_TASK_CLEARED",
		event.EventHostTaskFinished:                            "HOST_TASK_FINISHED",
		event.EventHostTerminatedExternally:                    "HOST_TERMINATED_EXTERNALLY",
		event.EventHostExpirationWarningSent:                   "HOST_EXPIRATION_WARNING_SENT",
		event.EventHostTemporaryExemptionExpirationWarningSent: "HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT",
		event.EventSpawnHostIdleNotification:                   "HOST_IDLE_NOTIFICATION",
		event.EventAlertableInstanceTypeWarningSent:            "HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT",
		event.EventHostScriptExecuted:                          "HOST_SCRIPT_EXECUTED",
		event.EventHostScriptExecuteFailed:                     "HOST_SCRIPT_EXECUTE_FAILED",
		event.EventSpawnHostCreatedError:                       "SPAWN_HOST_CREATED_ERROR",
		event.EventVolumeExpirationWarningSent:                 "VOLUME_EXPIRATION_WARNING_SENT",
		event.EventVolumeMigrationFailed:                       "VOLUME_MIGRATION_FAILED",
	}
)

func (ec *executionContext) unmarshalNHostEventType2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHostEventType2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNHostEventType2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHostEventType2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHostEvents2githubcomevergreencievergreengraphqlHostEvents(ctx context.Context, sel ast.SelectionSet, v HostEvents) graphql.Marshaler {
	return ec._HostEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNHostEvents2githubcomevergreencievergreengraphqlHostEvents(ctx context.Context, sel ast.SelectionSet, v *HostEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEvents(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHostEventsInput2githubcomevergreencievergreengraphqlHostEventsInput(ctx context.Context, v any) (HostEventsInput, error) {
	res, err := ec.unmarshalInputHostEventsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostsResponse2githubcomevergreencievergreengraphqlHostsResponse(ctx context.Context, sel ast.SelectionSet, v HostsResponse) graphql.Marshaler {
	return ec._HostsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNHostsResponse2githubcomevergreencievergreengraphqlHostsResponse(ctx context.Context, sel ast.SelectionSet, v *HostsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (*string, error) {
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalID(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIceCreamSettings2githubcomevergreencievergreenrestmodelAPIIceCreamSettings(ctx context.Context, sel ast.SelectionSet, v model.APIIceCreamSettings) graphql.Marshaler {
	return ec._IceCreamSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNIceCreamSettingsInput2githubcomevergreencievergreenrestmodelAPIIceCreamSettings(ctx context.Context, v any) (model.APIIceCreamSettings, error) {
	res, err := ec.unmarshalInputIceCreamSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageEvent2githubcomevergreencievergreenrestmodelAPIImageEvent(ctx context.Context, sel ast.SelectionSet, v []*model.APIImageEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageEvent2githubcomevergreencievergreenrestmodelAPIImageEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImageEvent2githubcomevergreencievergreenrestmodelAPIImageEvent(ctx context.Context, sel ast.SelectionSet, v *model.APIImageEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNImageEventEntry2githubcomevergreencievergreenrestmodelAPIImageEventEntry(ctx context.Context, sel ast.SelectionSet, v model.APIImageEventEntry) graphql.Marshaler {
	return ec._ImageEventEntry(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageEventEntry2githubcomevergreencievergreenrestmodelAPIImageEventEntry(ctx context.Context, sel ast.SelectionSet, v []model.APIImageEventEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageEventEntry2githubcomevergreencievergreenrestmodelAPIImageEventEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNImageEventEntryAction2githubcomevergreencievergreenthirdpartyImageEventEntryAction(ctx context.Context, v any) (thirdparty.ImageEventEntryAction, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := thirdparty.ImageEventEntryAction(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageEventEntryAction2githubcomevergreencievergreenthirdpartyImageEventEntryAction(ctx context.Context, sel ast.SelectionSet, v thirdparty.ImageEventEntryAction) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNImageEventType2githubcomevergreencievergreenthirdpartyImageEventType(ctx context.Context, v any) (thirdparty.ImageEventType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := thirdparty.ImageEventType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageEventType2githubcomevergreencievergreenthirdpartyImageEventType(ctx context.Context, sel ast.SelectionSet, v thirdparty.ImageEventType) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNImageEventsPayload2githubcomevergreencievergreengraphqlImageEventsPayload(ctx context.Context, sel ast.SelectionSet, v ImageEventsPayload) graphql.Marshaler {
	return ec._ImageEventsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageEventsPayload2githubcomevergreencievergreengraphqlImageEventsPayload(ctx context.Context, sel ast.SelectionSet, v *ImageEventsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageEventsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNImageFile2githubcomevergreencievergreenrestmodelAPIImageFile(ctx context.Context, sel ast.SelectionSet, v []*model.APIImageFile) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageFile2githubcomevergreencievergreenrestmodelAPIImageFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImageFile2githubcomevergreencievergreenrestmodelAPIImageFile(ctx context.Context, sel ast.SelectionSet, v *model.APIImageFile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageFile(ctx, sel, v)
}

func (ec *executionContext) unmarshalNImageFileOpts2githubcomevergreencievergreenthirdpartyFileFilterOptions(ctx context.Context, v any) (thirdparty.FileFilterOptions, error) {
	res, err := ec.unmarshalInputImageFileOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageFilesPayload2githubcomevergreencievergreengraphqlImageFilesPayload(ctx context.Context, sel ast.SelectionSet, v ImageFilesPayload) graphql.Marshaler {
	return ec._ImageFilesPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageFilesPayload2githubcomevergreencievergreengraphqlImageFilesPayload(ctx context.Context, sel ast.SelectionSet, v *ImageFilesPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageFilesPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNImageOperatingSystemPayload2githubcomevergreencievergreengraphqlImageOperatingSystemPayload(ctx context.Context, sel ast.SelectionSet, v ImageOperatingSystemPayload) graphql.Marshaler {
	return ec._ImageOperatingSystemPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageOperatingSystemPayload2githubcomevergreencievergreengraphqlImageOperatingSystemPayload(ctx context.Context, sel ast.SelectionSet, v *ImageOperatingSystemPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageOperatingSystemPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNImagePackagesPayload2githubcomevergreencievergreengraphqlImagePackagesPayload(ctx context.Context, sel ast.SelectionSet, v ImagePackagesPayload) graphql.Marshaler {
	return ec._ImagePackagesPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImagePackagesPayload2githubcomevergreencievergreengraphqlImagePackagesPayload(ctx context.Context, sel ast.SelectionSet, v *ImagePackagesPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImagePackagesPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNImageToolchainsPayload2githubcomevergreencievergreengraphqlImageToolchainsPayload(ctx context.Context, sel ast.SelectionSet, v ImageToolchainsPayload) graphql.Marshaler {
	return ec._ImageToolchainsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageToolchainsPayload2githubcomevergreencievergreengraphqlImageToolchainsPayload(ctx context.Context, sel ast.SelectionSet, v *ImageToolchainsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageToolchainsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNIncludedLocalModule2githubcomevergreencievergreenrestmodelAPILocalModuleInclude(ctx context.Context, sel ast.SelectionSet, v []*model.APILocalModuleInclude) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIncludedLocalModule2githubcomevergreencievergreenrestmodelAPILocalModuleInclude(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIncludedLocalModule2githubcomevergreencievergreenrestmodelAPILocalModuleInclude(ctx context.Context, sel ast.SelectionSet, v *model.APILocalModuleInclude) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IncludedLocalModule(ctx, sel, v)
}

func (ec *executionContext) marshalNInstanceTag2githubcomevergreencievergreenmodelhostTag(ctx context.Context, sel ast.SelectionSet, v host.Tag) graphql.Marshaler {
	return ec._InstanceTag(ctx, sel, &v)
}

func (ec *executionContext) marshalNInstanceTag2githubcomevergreencievergreenmodelhostTag(ctx context.Context, sel ast.SelectionSet, v []host.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInstanceTag2githubcomevergreencievergreenmodelhostTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInstanceTagInput2githubcomevergreencievergreenmodelhostTag(ctx context.Context, v any) (*host.Tag, error) {
	res, err := ec.unmarshalInputInstanceTagInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) ([]int, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (*int, error) {
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalInt(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx context.Context, sel ast.SelectionSet, v model.APIIssueLink) graphql.Marshaler {
	return ec._IssueLink(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNIssueLinkInput2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx context.Context, v any) (model.APIIssueLink, error) {
	res, err := ec.unmarshalInputIssueLinkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJiraNotificationsProjectEntry2githubcomevergreencievergreengraphqlJiraNotificationsProjectEntry(ctx context.Context, sel ast.SelectionSet, v []*JiraNotificationsProjectEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJiraNotificationsProjectEntry2githubcomevergreencievergreengraphqlJiraNotificationsProjectEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJiraNotificationsProjectEntry2githubcomevergreencievergreengraphqlJiraNotificationsProjectEntry(ctx context.Context, sel ast.SelectionSet, v *JiraNotificationsProjectEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JiraNotificationsProjectEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNJiraNotificationsProjectEntryInput2githubcomevergreencievergreengraphqlJiraNotificationsProjectEntryInput(ctx context.Context, v any) ([]*JiraNotificationsProjectEntryInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*JiraNotificationsProjectEntryInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNJiraNotificationsProjectEntryInput2githubcomevergreencievergreengraphqlJiraNotificationsProjectEntryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNJiraNotificationsProjectEntryInput2githubcomevergreencievergreengraphqlJiraNotificationsProjectEntryInput(ctx context.Context, v any) (*JiraNotificationsProjectEntryInput, error) {
	res, err := ec.unmarshalInputJiraNotificationsProjectEntryInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJiraStatus2githubcomevergreencievergreenthirdpartyJiraStatus(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JiraStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx context.Context, sel ast.SelectionSet, v thirdparty.JiraTicket) graphql.Marshaler {
	return ec._JiraTicket(ctx, sel, &v)
}

func (ec *executionContext) marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx context.Context, sel ast.SelectionSet, v []thirdparty.JiraTicket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx context.Context, sel ast.SelectionSet, v []*thirdparty.JiraTicket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraTicket) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JiraTicket(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLogBufferingInput2githubcomevergreencievergreenrestmodelAPILogBuffering(ctx context.Context, v any) (*model.APILogBuffering, error) {
	res, err := ec.unmarshalInputLogBufferingInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage(ctx context.Context, sel ast.SelectionSet, v []*apimodels.LogMessage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage(ctx context.Context, sel ast.SelectionSet, v *apimodels.LogMessage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogMessage(ctx, sel, v)
}

func (ec *executionContext) marshalNLogkeeperBuild2githubcomevergreenciplankBuild(ctx context.Context, sel ast.SelectionSet, v plank.Build) graphql.Marshaler {
	return ec._LogkeeperBuild(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogkeeperBuild2githubcomevergreenciplankBuild(ctx context.Context, sel ast.SelectionSet, v *plank.Build) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogkeeperBuild(ctx, sel, v)
}

func (ec *executionContext) marshalNLogkeeperTest2githubcomevergreenciplankTest(ctx context.Context, sel ast.SelectionSet, v plank.Test) graphql.Marshaler {
	return ec._LogkeeperTest(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogkeeperTest2githubcomevergreenciplankTest(ctx context.Context, sel ast.SelectionSet, v []plank.Test) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLogkeeperTest2githubcomevergreenciplankTest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMainlineCommitVersion2githubcomevergreencievergreengraphqlMainlineCommitVersion(ctx context.Context, sel ast.SelectionSet, v []*MainlineCommitVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMainlineCommitVersion2githubcomevergreencievergreengraphqlMainlineCommitVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMainlineCommitVersion2githubcomevergreencievergreengraphqlMainlineCommitVersion(ctx context.Context, sel ast.SelectionSet, v *MainlineCommitVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MainlineCommitVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMainlineCommitsOptions2githubcomevergreencievergreengraphqlMainlineCommitsOptions(ctx context.Context, v any) (MainlineCommitsOptions, error) {
	res, err := ec.unmarshalInputMainlineCommitsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v any) (map[string]any, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v any) ([]map[string]any, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]map[string]any, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMap2map(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v []map[string]any) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNMap2map(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMetStatus2githubcomevergreencievergreengraphqlMetStatus(ctx context.Context, v any) (MetStatus, error) {
	var res MetStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMetStatus2githubcomevergreencievergreengraphqlMetStatus(ctx context.Context, sel ast.SelectionSet, v MetStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMetadataLink2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx context.Context, sel ast.SelectionSet, v model.APIMetadataLink) graphql.Marshaler {
	return ec._MetadataLink(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNMetadataLinkInput2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx context.Context, v any) ([]*model.APIMetadataLink, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.APIMetadataLink, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMetadataLinkInput2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMetadataLinkInput2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx context.Context, v any) (*model.APIMetadataLink, error) {
	res, err := ec.unmarshalInputMetadataLinkInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNModuleCodeChange2githubcomevergreencievergreenrestmodelAPIModulePatch(ctx context.Context, sel ast.SelectionSet, v model.APIModulePatch) graphql.Marshaler {
	return ec._ModuleCodeChange(ctx, sel, &v)
}

func (ec *executionContext) marshalNModuleCodeChange2githubcomevergreencievergreenrestmodelAPIModulePatch(ctx context.Context, sel ast.SelectionSet, v []model.APIModulePatch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNModuleCodeChange2githubcomevergreencievergreenrestmodelAPIModulePatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMoveProjectInput2githubcomevergreencievergreengraphqlMoveProjectInput(ctx context.Context, v any) (MoveProjectInput, error) {
	res, err := ec.unmarshalInputMoveProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNewDistroPayload2githubcomevergreencievergreengraphqlNewDistroPayload(ctx context.Context, sel ast.SelectionSet, v NewDistroPayload) graphql.Marshaler {
	return ec._NewDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNNewDistroPayload2githubcomevergreencievergreengraphqlNewDistroPayload(ctx context.Context, sel ast.SelectionSet, v *NewDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NewDistroPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOSInfo2githubcomevergreencievergreenrestmodelAPIOSInfo(ctx context.Context, sel ast.SelectionSet, v []*model.APIOSInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOSInfo2githubcomevergreencievergreenrestmodelAPIOSInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOSInfo2githubcomevergreencievergreenrestmodelAPIOSInfo(ctx context.Context, sel ast.SelectionSet, v *model.APIOSInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OSInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNOomTrackerInfo2githubcomevergreencievergreenrestmodelAPIOomTrackerInfo(ctx context.Context, sel ast.SelectionSet, v model.APIOomTrackerInfo) graphql.Marshaler {
	return ec._OomTrackerInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNOperatingSystemOpts2githubcomevergreencievergreenthirdpartyOSInfoFilterOptions(ctx context.Context, v any) (thirdparty.OSInfoFilterOptions, error) {
	res, err := ec.unmarshalInputOperatingSystemOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNOverallocatedRule2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNOverallocatedRule2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOverallocatedRule2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNOverallocatedRule2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNOverallocatedRule2string = map[string]string{
		"TERMINATE": evergreen.HostsOverallocatedTerminate,
		"IGNORE":    evergreen.HostsOverallocatedIgnore,
		"DEFAULT":   evergreen.HostsOverallocatedUseDefault,
	}
	marshalNOverallocatedRule2string = map[string]string{
		evergreen.HostsOverallocatedTerminate:  "TERMINATE",
		evergreen.HostsOverallocatedIgnore:     "IGNORE",
		evergreen.HostsOverallocatedUseDefault: "DEFAULT",
	}
)

func (ec *executionContext) marshalNOwnerRepo2githubcomevergreencievergreenrestmodelAPIOwnerRepo(ctx context.Context, sel ast.SelectionSet, v model.APIOwnerRepo) graphql.Marshaler {
	return ec._OwnerRepo(ctx, sel, &v)
}

func (ec *executionContext) marshalNOwnerRepo2githubcomevergreencievergreenrestmodelAPIOwnerRepo(ctx context.Context, sel ast.SelectionSet, v []model.APIOwnerRepo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOwnerRepo2githubcomevergreencievergreenrestmodelAPIOwnerRepo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNOwnerRepoInput2githubcomevergreencievergreenrestmodelAPIOwnerRepo(ctx context.Context, v any) (model.APIOwnerRepo, error) {
	res, err := ec.unmarshalInputOwnerRepoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNOwnerRepoInput2githubcomevergreencievergreenrestmodelAPIOwnerRepo(ctx context.Context, v any) ([]model.APIOwnerRepo, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIOwnerRepo, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNOwnerRepoInput2githubcomevergreencievergreenrestmodelAPIOwnerRepo(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNPackage2githubcomevergreencievergreenrestmodelAPIPackage(ctx context.Context, sel ast.SelectionSet, v []*model.APIPackage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPackage2githubcomevergreencievergreenrestmodelAPIPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPackage2githubcomevergreencievergreenrestmodelAPIPackage(ctx context.Context, sel ast.SelectionSet, v *model.APIPackage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Package(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPackageOpts2githubcomevergreencievergreenthirdpartyPackageFilterOptions(ctx context.Context, v any) (thirdparty.PackageFilterOptions, error) {
	res, err := ec.unmarshalInputPackageOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, sel ast.SelectionSet, v model.APIParameter) graphql.Marshaler {
	return ec._Parameter(ctx, sel, &v)
}

func (ec *executionContext) marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, sel ast.SelectionSet, v []model.APIParameter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, sel ast.SelectionSet, v []*model.APIParameter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, sel ast.SelectionSet, v *model.APIParameter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Parameter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNParameterInput2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, v any) (*model.APIParameter, error) {
	res, err := ec.unmarshalInputParameterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx context.Context, sel ast.SelectionSet, v model.APIParsleyFilter) graphql.Marshaler {
	return ec._ParsleyFilter(ctx, sel, &v)
}

func (ec *executionContext) marshalNParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx context.Context, sel ast.SelectionSet, v []model.APIParsleyFilter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNParsleyFilterInput2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx context.Context, v any) (model.APIParsleyFilter, error) {
	res, err := ec.unmarshalInputParsleyFilterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNParsleySettings2githubcomevergreencievergreenrestmodelAPIParsleySettings(ctx context.Context, sel ast.SelectionSet, v model.APIParsleySettings) graphql.Marshaler {
	return ec._ParsleySettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNParsleySettingsInput2githubcomevergreencievergreenrestmodelAPIParsleySettings(ctx context.Context, v any) (*model.APIParsleySettings, error) {
	res, err := ec.unmarshalInputParsleySettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx context.Context, sel ast.SelectionSet, v model.APIPatch) graphql.Marshaler {
	return ec._Patch(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx context.Context, sel ast.SelectionSet, v []*model.APIPatch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx context.Context, sel ast.SelectionSet, v *model.APIPatch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Patch(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchConfigure2githubcomevergreencievergreengraphqlPatchConfigure(ctx context.Context, v any) (PatchConfigure, error) {
	res, err := ec.unmarshalInputPatchConfigure(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v model.APIPatchTriggerDefinition) graphql.Marshaler {
	return ec._PatchTriggerAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v []*model.APIPatchTriggerDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v *model.APIPatchTriggerDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PatchTriggerAlias(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchTriggerAliasInput2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, v any) (model.APIPatchTriggerDefinition, error) {
	res, err := ec.unmarshalInputPatchTriggerAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatches2githubcomevergreencievergreengraphqlPatches(ctx context.Context, sel ast.SelectionSet, v Patches) graphql.Marshaler {
	return ec._Patches(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatches2githubcomevergreencievergreengraphqlPatches(ctx context.Context, sel ast.SelectionSet, v *Patches) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Patches(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchesInput2githubcomevergreencievergreengraphqlPatchesInput(ctx context.Context, v any) (PatchesInput, error) {
	res, err := ec.unmarshalInputPatchesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPeriodicBuild2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx context.Context, sel ast.SelectionSet, v model.APIPeriodicBuildDefinition) graphql.Marshaler {
	return ec._PeriodicBuild(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNPeriodicBuildInput2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx context.Context, v any) (model.APIPeriodicBuildDefinition, error) {
	res, err := ec.unmarshalInputPeriodicBuildInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPermissions2githubcomevergreencievergreengraphqlPermissions(ctx context.Context, sel ast.SelectionSet, v Permissions) graphql.Marshaler {
	return ec._Permissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNPermissions2githubcomevergreencievergreengraphqlPermissions(ctx context.Context, sel ast.SelectionSet, v *Permissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Permissions(ctx, sel, v)
}

func (ec *executionContext) marshalNPlannerSettings2githubcomevergreencievergreenrestmodelAPIPlannerSettings(ctx context.Context, sel ast.SelectionSet, v model.APIPlannerSettings) graphql.Marshaler {
	return ec._PlannerSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNPlannerSettingsInput2githubcomevergreencievergreenrestmodelAPIPlannerSettings(ctx context.Context, v any) (model.APIPlannerSettings, error) {
	res, err := ec.unmarshalInputPlannerSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPlannerVersion2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNPlannerVersion2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPlannerVersion2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNPlannerVersion2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNPlannerVersion2string = map[string]string{
		"TUNABLE": evergreen.PlannerVersionTunable,
	}
	marshalNPlannerVersion2string = map[string]string{
		evergreen.PlannerVersionTunable: "TUNABLE",
	}
)

func (ec *executionContext) marshalNPod2githubcomevergreencievergreenrestmodelAPIPod(ctx context.Context, sel ast.SelectionSet, v model.APIPod) graphql.Marshaler {
	return ec._Pod(ctx, sel, &v)
}

func (ec *executionContext) marshalNPod2githubcomevergreencievergreenrestmodelAPIPod(ctx context.Context, sel ast.SelectionSet, v *model.APIPod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Pod(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEventLogData2githubcomevergreencievergreenrestmodelPodAPIEventData(ctx context.Context, sel ast.SelectionSet, v *model.PodAPIEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEventLogEntry2githubcomevergreencievergreenrestmodelPodAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v []*model.PodAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPodEventLogEntry2githubcomevergreencievergreenrestmodelPodAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPodEventLogEntry2githubcomevergreencievergreenrestmodelPodAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.PodAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEvents2githubcomevergreencievergreengraphqlPodEvents(ctx context.Context, sel ast.SelectionSet, v PodEvents) graphql.Marshaler {
	return ec._PodEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNPodEvents2githubcomevergreencievergreengraphqlPodEvents(ctx context.Context, sel ast.SelectionSet, v *PodEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEvents(ctx, sel, v)
}

func (ec *executionContext) marshalNPreconditionScript2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx context.Context, sel ast.SelectionSet, v model.APIPreconditionScript) graphql.Marshaler {
	return ec._PreconditionScript(ctx, sel, &v)
}

func (ec *executionContext) marshalNPreconditionScript2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx context.Context, sel ast.SelectionSet, v []model.APIPreconditionScript) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPreconditionScript2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNPreconditionScriptInput2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx context.Context, v any) (model.APIPreconditionScript, error) {
	res, err := ec.unmarshalInputPreconditionScriptInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPreconditionScriptInput2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx context.Context, v any) ([]model.APIPreconditionScript, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIPreconditionScript, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPreconditionScriptInput2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPriorityLevel2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNPriorityLevel2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPriorityLevel2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNPriorityLevel2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNPriorityLevel2string = map[string]string{
		"EMERGENCY": evergreen.PriorityLevelEmergency,
		"ALERT":     evergreen.PriorityLevelAlert,
		"CRITICAL":  evergreen.PriorityLevelCritical,
		"ERROR":     evergreen.PriorityLevelError,
		"WARNING":   evergreen.PriorityLevelWarning,
		"NOTICE":    evergreen.PriorityLevelNotice,
		"INFO":      evergreen.PriorityLevelInfo,
		"DEBUG":     evergreen.PriorityLevelDebug,
		"TRACE":     evergreen.PriorityLevelTrace,
	}
	marshalNPriorityLevel2string = map[string]string{
		evergreen.PriorityLevelEmergency: "EMERGENCY",
		evergreen.PriorityLevelAlert:     "ALERT",
		evergreen.PriorityLevelCritical:  "CRITICAL",
		evergreen.PriorityLevelError:     "ERROR",
		evergreen.PriorityLevelWarning:   "WARNING",
		evergreen.PriorityLevelNotice:    "NOTICE",
		evergreen.PriorityLevelInfo:      "INFO",
		evergreen.PriorityLevelDebug:     "DEBUG",
		evergreen.PriorityLevelTrace:     "TRACE",
	}
)

func (ec *executionContext) marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectRef) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v model.APIProjectAlias) graphql.Marshaler {
	return ec._ProjectAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectAlias(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectAliasInput2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, v any) (model.APIProjectAlias, error) {
	res, err := ec.unmarshalInputProjectAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectBuildVariant2githubcomevergreencievergreengraphqlProjectBuildVariant(ctx context.Context, sel ast.SelectionSet, v []*ProjectBuildVariant) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectBuildVariant2githubcomevergreencievergreengraphqlProjectBuildVariant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProjectBuildVariant2githubcomevergreencievergreengraphqlProjectBuildVariant(ctx context.Context, sel ast.SelectionSet, v *ProjectBuildVariant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectBuildVariant(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectEventLogEntry2githubcomevergreencievergreenrestmodelAPIProjectEvent(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectEventLogEntry2githubcomevergreencievergreenrestmodelAPIProjectEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProjectEventLogEntry2githubcomevergreencievergreenrestmodelAPIProjectEvent(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectEvents2githubcomevergreencievergreengraphqlProjectEvents(ctx context.Context, sel ast.SelectionSet, v ProjectEvents) graphql.Marshaler {
	return ec._ProjectEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectEvents2githubcomevergreencievergreengraphqlProjectEvents(ctx context.Context, sel ast.SelectionSet, v *ProjectEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectEvents(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx context.Context, v any) (model1.ProjectHealthView, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model1.ProjectHealthView(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx context.Context, sel ast.SelectionSet, v model1.ProjectHealthView) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx context.Context, v any) (ProjectPermission, error) {
	var res ProjectPermission
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx context.Context, sel ast.SelectionSet, v ProjectPermission) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProjectPermissions2githubcomevergreencievergreengraphqlProjectPermissions(ctx context.Context, sel ast.SelectionSet, v ProjectPermissions) graphql.Marshaler {
	return ec._ProjectPermissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectPermissions2githubcomevergreencievergreengraphqlProjectPermissions(ctx context.Context, sel ast.SelectionSet, v *ProjectPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectPermissionsOptions2githubcomevergreencievergreengraphqlProjectPermissionsOptions(ctx context.Context, v any) (ProjectPermissionsOptions, error) {
	res, err := ec.unmarshalInputProjectPermissionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectSettings) graphql.Marshaler {
	return ec._ProjectSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectSettingsSection2githubcomevergreencievergreengraphqlProjectSettingsSection(ctx context.Context, v any) (ProjectSettingsSection, error) {
	var res ProjectSettingsSection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectSettingsSection2githubcomevergreencievergreengraphqlProjectSettingsSection(ctx context.Context, sel ast.SelectionSet, v ProjectSettingsSection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProjectTasksPair2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx context.Context, sel ast.SelectionSet, v model.APIProjectTasksPair) graphql.Marshaler {
	return ec._ProjectTasksPair(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectTasksPair2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx context.Context, sel ast.SelectionSet, v []model.APIProjectTasksPair) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectTasksPair2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNProjectTasksPairInput2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx context.Context, v any) (model.APIProjectTasksPair, error) {
	res, err := ec.unmarshalInputProjectTasksPairInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProjectTasksPairInput2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx context.Context, v any) ([]model.APIProjectTasksPair, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIProjectTasksPair, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectTasksPairInput2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPromoteVarsToRepoInput2githubcomevergreencievergreengraphqlPromoteVarsToRepoInput(ctx context.Context, v any) (PromoteVarsToRepoInput, error) {
	res, err := ec.unmarshalInputPromoteVarsToRepoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProvider2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNProvider2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvider2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNProvider2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNProvider2string = map[string]string{
		"DOCKER":        evergreen.ProviderNameDocker,
		"EC2_FLEET":     evergreen.ProviderNameEc2Fleet,
		"EC2_ON_DEMAND": evergreen.ProviderNameEc2OnDemand,
		"STATIC":        evergreen.ProviderNameStatic,
	}
	marshalNProvider2string = map[string]string{
		evergreen.ProviderNameDocker:      "DOCKER",
		evergreen.ProviderNameEc2Fleet:    "EC2_FLEET",
		evergreen.ProviderNameEc2OnDemand: "EC2_ON_DEMAND",
		evergreen.ProviderNameStatic:      "STATIC",
	}
)

func (ec *executionContext) marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey(ctx context.Context, sel ast.SelectionSet, v []*model.APIPubKey) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey(ctx context.Context, sel ast.SelectionSet, v *model.APIPubKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PublicKey(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx context.Context, v any) (PublicKeyInput, error) {
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx context.Context, v any) (*PublicKeyInput, error) {
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNQuarantineTestInput2githubcomevergreencievergreengraphqlQuarantineTestInput(ctx context.Context, v any) (QuarantineTestInput, error) {
	res, err := ec.unmarshalInputQuarantineTestInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNQuarantineTestPayload2githubcomevergreencievergreengraphqlQuarantineTestPayload(ctx context.Context, sel ast.SelectionSet, v QuarantineTestPayload) graphql.Marshaler {
	return ec._QuarantineTestPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNQuarantineTestPayload2githubcomevergreencievergreengraphqlQuarantineTestPayload(ctx context.Context, sel ast.SelectionSet, v *QuarantineTestPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._QuarantineTestPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRemoveFavoriteProjectInput2githubcomevergreencievergreengraphqlRemoveFavoriteProjectInput(ctx context.Context, v any) (RemoveFavoriteProjectInput, error) {
	res, err := ec.unmarshalInputRemoveFavoriteProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepoCommitQueueParams2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx context.Context, sel ast.SelectionSet, v model.APICommitQueueParams) graphql.Marshaler {
	return ec._RepoCommitQueueParams(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoPermissions2githubcomevergreencievergreengraphqlRepoPermissions(ctx context.Context, sel ast.SelectionSet, v RepoPermissions) graphql.Marshaler {
	return ec._RepoPermissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoPermissions2githubcomevergreencievergreengraphqlRepoPermissions(ctx context.Context, sel ast.SelectionSet, v *RepoPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepoPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRepoPermissionsOptions2githubcomevergreencievergreengraphqlRepoPermissionsOptions(ctx context.Context, v any) (RepoPermissionsOptions, error) {
	res, err := ec.unmarshalInputRepoPermissionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepoSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectSettings) graphql.Marshaler {
	return ec._RepoSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepoSettings(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoWorkstationConfig2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationConfig) graphql.Marshaler {
	return ec._RepoWorkstationConfig(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNRequiredStatus2githubcomevergreencievergreengraphqlRequiredStatus(ctx context.Context, v any) (RequiredStatus, error) {
	var res RequiredStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRequiredStatus2githubcomevergreencievergreengraphqlRequiredStatus(ctx context.Context, sel ast.SelectionSet, v RequiredStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNResourceLimits2githubcomevergreencievergreenrestmodelAPIResourceLimits(ctx context.Context, sel ast.SelectionSet, v model.APIResourceLimits) graphql.Marshaler {
	return ec._ResourceLimits(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNResourceLimitsInput2githubcomevergreencievergreenrestmodelAPIResourceLimits(ctx context.Context, v any) (model.APIResourceLimits, error) {
	res, err := ec.unmarshalInputResourceLimitsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRestartAdminTasksOptions2githubcomevergreencievergreenmodelRestartOptions(ctx context.Context, v any) (model1.RestartOptions, error) {
	res, err := ec.unmarshalInputRestartAdminTasksOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRestartAdminTasksPayload2githubcomevergreencievergreengraphqlRestartAdminTasksPayload(ctx context.Context, sel ast.SelectionSet, v RestartAdminTasksPayload) graphql.Marshaler {
	return ec._RestartAdminTasksPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRestartAdminTasksPayload2githubcomevergreencievergreengraphqlRestartAdminTasksPayload(ctx context.Context, sel ast.SelectionSet, v *RestartAdminTasksPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RestartAdminTasksPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRoundingRule2string(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNRoundingRule2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRoundingRule2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNRoundingRule2string[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNRoundingRule2string = map[string]string{
		"DOWN":    evergreen.HostAllocatorRoundDown,
		"UP":      evergreen.HostAllocatorRoundUp,
		"DEFAULT": evergreen.HostAllocatorRoundDefault,
	}
	marshalNRoundingRule2string = map[string]string{
		evergreen.HostAllocatorRoundDown:    "DOWN",
		evergreen.HostAllocatorRoundUp:      "UP",
		evergreen.HostAllocatorRoundDefault: "DEFAULT",
	}
)

func (ec *executionContext) unmarshalNSaveDistroInput2githubcomevergreencievergreengraphqlSaveDistroInput(ctx context.Context, v any) (SaveDistroInput, error) {
	res, err := ec.unmarshalInputSaveDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSaveDistroPayload2githubcomevergreencievergreengraphqlSaveDistroPayload(ctx context.Context, sel ast.SelectionSet, v SaveDistroPayload) graphql.Marshaler {
	return ec._SaveDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSaveDistroPayload2githubcomevergreencievergreengraphqlSaveDistroPayload(ctx context.Context, sel ast.SelectionSet, v *SaveDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SaveDistroPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNSelector2githubcomevergreencievergreenrestmodelAPISelector(ctx context.Context, sel ast.SelectionSet, v model.APISelector) graphql.Marshaler {
	return ec._Selector(ctx, sel, &v)
}

func (ec *executionContext) marshalNSelector2githubcomevergreencievergreenrestmodelAPISelector(ctx context.Context, sel ast.SelectionSet, v []model.APISelector) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSelector2githubcomevergreencievergreenrestmodelAPISelector(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSelectorInput2githubcomevergreencievergreenrestmodelAPISelector(ctx context.Context, v any) (model.APISelector, error) {
	res, err := ec.unmarshalInputSelectorInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSelectorInput2githubcomevergreencievergreenrestmodelAPISelector(ctx context.Context, v any) ([]model.APISelector, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APISelector, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSelectorInput2githubcomevergreencievergreenrestmodelAPISelector(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSetLastRevisionInput2githubcomevergreencievergreengraphqlSetLastRevisionInput(ctx context.Context, v any) (SetLastRevisionInput, error) {
	res, err := ec.unmarshalInputSetLastRevisionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSetLastRevisionPayload2githubcomevergreencievergreengraphqlSetLastRevisionPayload(ctx context.Context, sel ast.SelectionSet, v SetLastRevisionPayload) graphql.Marshaler {
	return ec._SetLastRevisionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetLastRevisionPayload2githubcomevergreencievergreengraphqlSetLastRevisionPayload(ctx context.Context, sel ast.SelectionSet, v *SetLastRevisionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SetLastRevisionPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx context.Context, v any) (SortDirection, error) {
	var res SortDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx context.Context, sel ast.SelectionSet, v SortDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSortOrder2githubcomevergreencievergreengraphqlSortOrder(ctx context.Context, v any) (*SortOrder, error) {
	res, err := ec.unmarshalInputSortOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSource2githubcomevergreencievergreenrestmodelAPISource(ctx context.Context, sel ast.SelectionSet, v *model.APISource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Source(ctx, sel, v)
}

func (ec *executionContext) marshalNSpawnHostConfig2githubcomevergreencievergreenrestmodelAPISpawnHostConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISpawnHostConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SpawnHostConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSpawnHostStatusActions2githubcomevergreencievergreengraphqlSpawnHostStatusActions(ctx context.Context, v any) (SpawnHostStatusActions, error) {
	var res SpawnHostStatusActions
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSpawnHostStatusActions2githubcomevergreencievergreengraphqlSpawnHostStatusActions(ctx context.Context, sel ast.SelectionSet, v SpawnHostStatusActions) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSpawnVolumeInput2githubcomevergreencievergreengraphqlSpawnVolumeInput(ctx context.Context, v any) (SpawnVolumeInput, error) {
	res, err := ec.unmarshalInputSpawnVolumeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSplunkConnectionInfo2githubcomevergreencievergreenrestmodelAPISplunkConnectionInfo(ctx context.Context, sel ast.SelectionSet, v *model.APISplunkConnectionInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SplunkConnectionInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSplunkConnectionInfoInput2githubcomevergreencievergreenrestmodelAPISplunkConnectionInfo(ctx context.Context, v any) (*model.APISplunkConnectionInfo, error) {
	res, err := ec.unmarshalInputSplunkConnectionInfoInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx context.Context, sel ast.SelectionSet, v task.StatusCount) graphql.Marshaler {
	return ec._StatusCount(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx context.Context, sel ast.SelectionSet, v []*task.StatusCount) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx context.Context, sel ast.SelectionSet, v *task.StatusCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StatusCount(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]*string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (*string, error) {
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNStringMap2map(ctx context.Context, v any) (map[string]string, error) {
	res, err := UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := MarshalStringMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNSubnet2githubcomevergreencievergreenrestmodelAPISubnet(ctx context.Context, sel ast.SelectionSet, v model.APISubnet) graphql.Marshaler {
	return ec._Subnet(ctx, sel, &v)
}

func (ec *executionContext) marshalNSubnet2githubcomevergreencievergreenrestmodelAPISubnet(ctx context.Context, sel ast.SelectionSet, v []model.APISubnet) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSubnet2githubcomevergreencievergreenrestmodelAPISubnet(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSubnetInput2githubcomevergreencievergreenrestmodelAPISubnet(ctx context.Context, v any) (model.APISubnet, error) {
	res, err := ec.unmarshalInputSubnetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSubnetInput2githubcomevergreencievergreenrestmodelAPISubnet(ctx context.Context, v any) ([]model.APISubnet, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APISubnet, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSubnetInput2githubcomevergreencievergreenrestmodelAPISubnet(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNSubscriber2githubcomevergreencievergreengraphqlSubscriber(ctx context.Context, sel ast.SelectionSet, v Subscriber) graphql.Marshaler {
	return ec._Subscriber(ctx, sel, &v)
}

func (ec *executionContext) marshalNSubscriber2githubcomevergreencievergreengraphqlSubscriber(ctx context.Context, sel ast.SelectionSet, v *Subscriber) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Subscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSubscriberInput2githubcomevergreencievergreenrestmodelAPISubscriber(ctx context.Context, v any) (model.APISubscriber, error) {
	res, err := ec.unmarshalInputSubscriberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, v any) (model.APISubscription, error) {
	res, err := ec.unmarshalInputSubscriptionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx context.Context, sel ast.SelectionSet, v model.APITask) graphql.Marshaler {
	return ec._Task(ctx, sel, &v)
}

func (ec *executionContext) marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx context.Context, sel ast.SelectionSet, v []*model.APITask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx context.Context, sel ast.SelectionSet, v *model.APITask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskAnnotationSettings2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings(ctx context.Context, sel ast.SelectionSet, v model.APITaskAnnotationSettings) graphql.Marshaler {
	return ec._TaskAnnotationSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskContainerCreationOpts2githubcomevergreencievergreenrestmodelAPIPodTaskContainerCreationOptions(ctx context.Context, sel ast.SelectionSet, v model.APIPodTaskContainerCreationOptions) graphql.Marshaler {
	return ec._TaskContainerCreationOpts(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskEventLogData2githubcomevergreencievergreenrestmodelTaskEventData(ctx context.Context, sel ast.SelectionSet, v *model.TaskEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskEventLogEntry2githubcomevergreencievergreenrestmodelTaskAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v []*model.TaskAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskEventLogEntry2githubcomevergreencievergreenrestmodelTaskAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskEventLogEntry2githubcomevergreencievergreenrestmodelTaskAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.TaskAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskFiles2githubcomevergreencievergreengraphqlTaskFiles(ctx context.Context, sel ast.SelectionSet, v TaskFiles) graphql.Marshaler {
	return ec._TaskFiles(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskFiles2githubcomevergreencievergreengraphqlTaskFiles(ctx context.Context, sel ast.SelectionSet, v *TaskFiles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskFiles(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskFilterOptions2githubcomevergreencievergreengraphqlTaskFilterOptions(ctx context.Context, v any) (TaskFilterOptions, error) {
	res, err := ec.unmarshalInputTaskFilterOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskHistory2githubcomevergreencievergreengraphqlTaskHistory(ctx context.Context, sel ast.SelectionSet, v TaskHistory) graphql.Marshaler {
	return ec._TaskHistory(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskHistory2githubcomevergreencievergreengraphqlTaskHistory(ctx context.Context, sel ast.SelectionSet, v *TaskHistory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskHistory(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskHistoryDirection2githubcomevergreencievergreengraphqlTaskHistoryDirection(ctx context.Context, v any) (TaskHistoryDirection, error) {
	var res TaskHistoryDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskHistoryDirection2githubcomevergreencievergreengraphqlTaskHistoryDirection(ctx context.Context, sel ast.SelectionSet, v TaskHistoryDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTaskHistoryOpts2githubcomevergreencievergreengraphqlTaskHistoryOpts(ctx context.Context, v any) (TaskHistoryOpts, error) {
	res, err := ec.unmarshalInputTaskHistoryOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskHistoryPagination2githubcomevergreencievergreengraphqlTaskHistoryPagination(ctx context.Context, sel ast.SelectionSet, v *TaskHistoryPagination) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskHistoryPagination(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskLogLinks2githubcomevergreencievergreenrestmodelLogLinks(ctx context.Context, sel ast.SelectionSet, v model.LogLinks) graphql.Marshaler {
	return ec._TaskLogLinks(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskLogs2githubcomevergreencievergreengraphqlTaskLogs(ctx context.Context, sel ast.SelectionSet, v TaskLogs) graphql.Marshaler {
	return ec._TaskLogs(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskLogs2githubcomevergreencievergreengraphqlTaskLogs(ctx context.Context, sel ast.SelectionSet, v *TaskLogs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskLogs(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskPriority2githubcomevergreencievergreengraphqlTaskPriority(ctx context.Context, v any) ([]*TaskPriority, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*TaskPriority, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTaskPriority2githubcomevergreencievergreengraphqlTaskPriority(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNTaskPriority2githubcomevergreencievergreengraphqlTaskPriority(ctx context.Context, v any) (*TaskPriority, error) {
	res, err := ec.unmarshalInputTaskPriority(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskQueueDistro2githubcomevergreencievergreengraphqlTaskQueueDistro(ctx context.Context, sel ast.SelectionSet, v []*TaskQueueDistro) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskQueueDistro2githubcomevergreencievergreengraphqlTaskQueueDistro(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskQueueDistro2githubcomevergreencievergreengraphqlTaskQueueDistro(ctx context.Context, sel ast.SelectionSet, v *TaskQueueDistro) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskQueueDistro(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskQueueItem2githubcomevergreencievergreenrestmodelAPITaskQueueItem(ctx context.Context, sel ast.SelectionSet, v []*model.APITaskQueueItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskQueueItem2githubcomevergreencievergreenrestmodelAPITaskQueueItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskQueueItem2githubcomevergreencievergreenrestmodelAPITaskQueueItem(ctx context.Context, sel ast.SelectionSet, v *model.APITaskQueueItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskQueueItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskSortCategory2githubcomevergreencievergreengraphqlTaskSortCategory(ctx context.Context, v any) (TaskSortCategory, error) {
	var res TaskSortCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskSortCategory2githubcomevergreencievergreengraphqlTaskSortCategory(ctx context.Context, sel ast.SelectionSet, v TaskSortCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTaskSpecifier2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx context.Context, sel ast.SelectionSet, v model.APITaskSpecifier) graphql.Marshaler {
	return ec._TaskSpecifier(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNTaskSpecifierInput2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx context.Context, v any) (model.APITaskSpecifier, error) {
	res, err := ec.unmarshalInputTaskSpecifierInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTaskSpecifierInput2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx context.Context, v any) ([]model.APITaskSpecifier, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APITaskSpecifier, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTaskSpecifierInput2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTaskTestResult2githubcomevergreencievergreengraphqlTaskTestResult(ctx context.Context, sel ast.SelectionSet, v TaskTestResult) graphql.Marshaler {
	return ec._TaskTestResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskTestResult2githubcomevergreencievergreengraphqlTaskTestResult(ctx context.Context, sel ast.SelectionSet, v *TaskTestResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskTestResult(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskTestResultSample2githubcomevergreencievergreengraphqlTaskTestResultSample(ctx context.Context, sel ast.SelectionSet, v *TaskTestResultSample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskTestResultSample(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTestFilter2githubcomevergreencievergreengraphqlTestFilter(ctx context.Context, v any) ([]*TestFilter, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*TestFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTestFilter2githubcomevergreencievergreengraphqlTestFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNTestFilter2githubcomevergreencievergreengraphqlTestFilter(ctx context.Context, v any) (*TestFilter, error) {
	res, err := ec.unmarshalInputTestFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTestLog2githubcomevergreencievergreenrestmodelTestLogs(ctx context.Context, sel ast.SelectionSet, v model.TestLogs) graphql.Marshaler {
	return ec._TestLog(ctx, sel, &v)
}

func (ec *executionContext) marshalNTestResult2githubcomevergreencievergreenrestmodelAPITest(ctx context.Context, sel ast.SelectionSet, v []*model.APITest) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTestResult2githubcomevergreencievergreenrestmodelAPITest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTestResult2githubcomevergreencievergreenrestmodelAPITest(ctx context.Context, sel ast.SelectionSet, v *model.APITest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TestResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTestSortCategory2githubcomevergreencievergreengraphqlTestSortCategory(ctx context.Context, v any) (TestSortCategory, error) {
	var res TestSortCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTestSortCategory2githubcomevergreencievergreengraphqlTestSortCategory(ctx context.Context, sel ast.SelectionSet, v TestSortCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTestSortOptions2githubcomevergreencievergreengraphqlTestSortOptions(ctx context.Context, v any) (*TestSortOptions, error) {
	res, err := ec.unmarshalInputTestSortOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTicketFields2githubcomevergreencievergreenthirdpartyTicketFields(ctx context.Context, sel ast.SelectionSet, v *thirdparty.TicketFields) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TicketFields(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNToolchain2githubcomevergreencievergreenrestmodelAPIToolchain(ctx context.Context, sel ast.SelectionSet, v []*model.APIToolchain) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNToolchain2githubcomevergreencievergreenrestmodelAPIToolchain(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNToolchain2githubcomevergreencievergreenrestmodelAPIToolchain(ctx context.Context, sel ast.SelectionSet, v *model.APIToolchain) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Toolchain(ctx, sel, v)
}

func (ec *executionContext) unmarshalNToolchainOpts2githubcomevergreencievergreenthirdpartyToolchainFilterOptions(ctx context.Context, v any) (thirdparty.ToolchainFilterOptions, error) {
	res, err := ec.unmarshalInputToolchainOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx context.Context, sel ast.SelectionSet, v model.APITriggerDefinition) graphql.Marshaler {
	return ec._TriggerAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx context.Context, sel ast.SelectionSet, v []model.APITriggerDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTriggerAliasInput2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx context.Context, v any) (model.APITriggerDefinition, error) {
	res, err := ec.unmarshalInputTriggerAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUIConfig2githubcomevergreencievergreenrestmodelAPIUIConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIUIConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UIConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateBetaFeaturesInput2githubcomevergreencievergreengraphqlUpdateBetaFeaturesInput(ctx context.Context, v any) (UpdateBetaFeaturesInput, error) {
	res, err := ec.unmarshalInputUpdateBetaFeaturesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateParsleySettingsInput2githubcomevergreencievergreengraphqlUpdateParsleySettingsInput(ctx context.Context, v any) (UpdateParsleySettingsInput, error) {
	res, err := ec.unmarshalInputUpdateParsleySettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSpawnHostStatusInput2githubcomevergreencievergreengraphqlUpdateSpawnHostStatusInput(ctx context.Context, v any) (UpdateSpawnHostStatusInput, error) {
	res, err := ec.unmarshalInputUpdateSpawnHostStatusInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateVolumeInput2githubcomevergreencievergreengraphqlUpdateVolumeInput(ctx context.Context, v any) (UpdateVolumeInput, error) {
	res, err := ec.unmarshalInputUpdateVolumeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubcomevergreencievergreenrestmodelAPIDBUser(ctx context.Context, sel ast.SelectionSet, v model.APIDBUser) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomevergreencievergreenrestmodelAPIDBUser(ctx context.Context, sel ast.SelectionSet, v *model.APIDBUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserServiceFlags2githubcomevergreencievergreenrestmodelAPIServiceFlags(ctx context.Context, sel ast.SelectionSet, v *model.APIServiceFlags) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserServiceFlags(ctx, sel, v)
}

func (ec *executionContext) marshalNUserSettings2githubcomevergreencievergreenrestmodelAPIUserSettings(ctx context.Context, sel ast.SelectionSet, v model.APIUserSettings) graphql.Marshaler {
	return ec._UserSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNVariantTask2githubcomevergreencievergreenrestmodelVariantTask(ctx context.Context, sel ast.SelectionSet, v model.VariantTask) graphql.Marshaler {
	return ec._VariantTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNVariantTask2githubcomevergreencievergreenrestmodelVariantTask(ctx context.Context, sel ast.SelectionSet, v []model.VariantTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVariantTask2githubcomevergreencievergreenrestmodelVariantTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNVariantTasks2githubcomevergreencievergreengraphqlVariantTasks(ctx context.Context, v any) ([]*VariantTasks, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*VariantTasks, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVariantTasks2githubcomevergreencievergreengraphqlVariantTasks(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNVariantTasks2githubcomevergreencievergreengraphqlVariantTasks(ctx context.Context, v any) (*VariantTasks, error) {
	res, err := ec.unmarshalInputVariantTasks(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx context.Context, sel ast.SelectionSet, v model.APIVersion) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx context.Context, sel ast.SelectionSet, v []*model.APIVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx context.Context, sel ast.SelectionSet, v *model.APIVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalNVersionTasks2githubcomevergreencievergreengraphqlVersionTasks(ctx context.Context, sel ast.SelectionSet, v VersionTasks) graphql.Marshaler {
	return ec._VersionTasks(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersionTasks2githubcomevergreencievergreengraphqlVersionTasks(ctx context.Context, sel ast.SelectionSet, v *VersionTasks) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VersionTasks(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVersionToRestart2githubcomevergreencievergreenmodelVersionToRestart(ctx context.Context, v any) ([]*model1.VersionToRestart, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model1.VersionToRestart, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVersionToRestart2githubcomevergreencievergreenmodelVersionToRestart(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNVersionToRestart2githubcomevergreencievergreenmodelVersionToRestart(ctx context.Context, v any) (*model1.VersionToRestart, error) {
	res, err := ec.unmarshalInputVersionToRestart(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx context.Context, sel ast.SelectionSet, v []*model.APIVolume) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx context.Context, sel ast.SelectionSet, v *model.APIVolume) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Volume(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVolumeHost2githubcomevergreencievergreengraphqlVolumeHost(ctx context.Context, v any) (VolumeHost, error) {
	res, err := ec.unmarshalInputVolumeHost(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWaterfall2githubcomevergreencievergreengraphqlWaterfall(ctx context.Context, sel ast.SelectionSet, v Waterfall) graphql.Marshaler {
	return ec._Waterfall(ctx, sel, &v)
}

func (ec *executionContext) marshalNWaterfall2githubcomevergreencievergreengraphqlWaterfall(ctx context.Context, sel ast.SelectionSet, v *Waterfall) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Waterfall(ctx, sel, v)
}

func (ec *executionContext) marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx context.Context, sel ast.SelectionSet, v model1.WaterfallBuild) graphql.Marshaler {
	return ec._WaterfallBuild(ctx, sel, &v)
}

func (ec *executionContext) marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx context.Context, sel ast.SelectionSet, v []model1.WaterfallBuild) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx context.Context, sel ast.SelectionSet, v *model1.WaterfallBuild) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WaterfallBuild(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWaterfallOptions2githubcomevergreencievergreengraphqlWaterfallOptions(ctx context.Context, v any) (WaterfallOptions, error) {
	res, err := ec.unmarshalInputWaterfallOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWaterfallPagination2githubcomevergreencievergreengraphqlWaterfallPagination(ctx context.Context, sel ast.SelectionSet, v *WaterfallPagination) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WaterfallPagination(ctx, sel, v)
}

func (ec *executionContext) marshalNWaterfallTask2githubcomevergreencievergreenmodelWaterfallTask(ctx context.Context, sel ast.SelectionSet, v model1.WaterfallTask) graphql.Marshaler {
	return ec._WaterfallTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNWaterfallTask2githubcomevergreencievergreenmodelWaterfallTask(ctx context.Context, sel ast.SelectionSet, v []model1.WaterfallTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaterfallTask2githubcomevergreencievergreenmodelWaterfallTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWebhook2githubcomevergreencievergreenrestmodelAPIWebHook(ctx context.Context, sel ast.SelectionSet, v model.APIWebHook) graphql.Marshaler {
	return ec._Webhook(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhookHeader2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx context.Context, sel ast.SelectionSet, v model.APIWebhookHeader) graphql.Marshaler {
	return ec._WebhookHeader(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhookHeader2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx context.Context, sel ast.SelectionSet, v []model.APIWebhookHeader) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWebhookHeader2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNWebhookHeaderInput2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx context.Context, v any) (model.APIWebhookHeader, error) {
	res, err := ec.unmarshalInputWebhookHeaderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWebhookHeaderInput2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx context.Context, v any) ([]model.APIWebhookHeader, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIWebhookHeader, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWebhookHeaderInput2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNWorkstationConfig2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationConfig) graphql.Marshaler {
	return ec._WorkstationConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkstationSetupCommand2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationSetupCommand) graphql.Marshaler {
	return ec._WorkstationSetupCommand(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNWorkstationSetupCommandInput2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx context.Context, v any) (model.APIWorkstationSetupCommand, error) {
	res, err := ec.unmarshalInputWorkstationSetupCommandInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAPIConfig2githubcomevergreencievergreenrestmodelAPIapiConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIapiConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._APIConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAPIConfigInput2githubcomevergreencievergreenrestmodelAPIapiConfig(ctx context.Context, v any) (*model.APIapiConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAPIConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAWSConfig2githubcomevergreencievergreenrestmodelAPIAWSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAWSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AWSConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAWSConfigInput2githubcomevergreencievergreenrestmodelAPIAWSConfig(ctx context.Context, v any) (*model.APIAWSConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAWSConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAWSPodConfig2githubcomevergreencievergreenrestmodelAPIAWSPodConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAWSPodConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AWSPodConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAWSPodConfigInput2githubcomevergreencievergreenrestmodelAPIAWSPodConfig(ctx context.Context, v any) (*model.APIAWSPodConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAWSPodConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAWSVPCConfig2githubcomevergreencievergreenrestmodelAPIAWSVPCConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAWSVPCConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AWSVPCConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAWSVPCConfigInput2githubcomevergreencievergreenrestmodelAPIAWSVPCConfig(ctx context.Context, v any) (*model.APIAWSVPCConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAWSVPCConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAbortInfo2githubcomevergreencievergreengraphqlAbortInfo(ctx context.Context, sel ast.SelectionSet, v *AbortInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AbortInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOAdminSettings2githubcomevergreencievergreenrestmodelAPIAdminSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIAdminSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdminSettings(ctx, sel, v)
}

func (ec *executionContext) marshalOAmboyConfig2githubcomevergreencievergreenrestmodelAPIAmboyConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAmboyConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AmboyConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAmboyConfigInput2githubcomevergreencievergreenrestmodelAPIAmboyConfig(ctx context.Context, v any) (*model.APIAmboyConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAmboyConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAmboyDBConfig2githubcomevergreencievergreenrestmodelAPIAmboyDBConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAmboyDBConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AmboyDBConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAmboyDBConfigInput2githubcomevergreencievergreenrestmodelAPIAmboyDBConfig(ctx context.Context, v any) (*model.APIAmboyDBConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAmboyDBConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAmboyRetryConfig2githubcomevergreencievergreenrestmodelAPIAmboyRetryConfig(ctx context.Context, sel ast.SelectionSet, v model.APIAmboyRetryConfig) graphql.Marshaler {
	return ec._AmboyRetryConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalOAnnotation2githubcomevergreencievergreenrestmodelAPITaskAnnotation(ctx context.Context, sel ast.SelectionSet, v *model.APITaskAnnotation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Annotation(ctx, sel, v)
}

func (ec *executionContext) marshalOAuthConfig2githubcomevergreencievergreenrestmodelAPIAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAuthConfigInput2githubcomevergreencievergreenrestmodelAPIAuthConfig(ctx context.Context, v any) (*model.APIAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAuthUserInput2githubcomevergreencievergreenrestmodelAPIAuthUser(ctx context.Context, v any) ([]model.APIAuthUser, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIAuthUser, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAuthUserInput2githubcomevergreencievergreenrestmodelAPIAuthUser(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBannerTheme2githubcomevergreencievergreenBannerTheme(ctx context.Context, v any) (*evergreen.BannerTheme, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := evergreen.BannerTheme(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBannerTheme2githubcomevergreencievergreenBannerTheme(ctx context.Context, sel ast.SelectionSet, v *evergreen.BannerTheme) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOBetaFeatures2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx context.Context, sel ast.SelectionSet, v *model.APIBetaFeatures) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BetaFeatures(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOBooleanMap2map(ctx context.Context, v any) (map[string]bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := UnmarshalBooleanMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBooleanMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := MarshalBooleanMap(v)
	return res
}

func (ec *executionContext) marshalOBucketConfig2githubcomevergreencievergreenrestmodelAPIBucketConfig(ctx context.Context, sel ast.SelectionSet, v model.APIBucketConfig) graphql.Marshaler {
	return ec._BucketConfig(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOBucketConfigInput2githubcomevergreencievergreenrestmodelAPIBucketConfig(ctx context.Context, v any) (model.APIBucketConfig, error) {
	res, err := ec.unmarshalInputBucketConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBucketsConfig2githubcomevergreencievergreenrestmodelAPIBucketsConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIBucketsConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BucketsConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBucketsConfigInput2githubcomevergreencievergreenrestmodelAPIBucketsConfig(ctx context.Context, v any) (*model.APIBucketsConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBucketsConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBuildBaronSettingsInput2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings(ctx context.Context, v any) (model.APIBuildBaronSettings, error) {
	res, err := ec.unmarshalInputBuildBaronSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions(ctx context.Context, v any) (*BuildVariantOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBuildVariantOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBuildVariantTuple2githubcomevergreencievergreenmodeltaskBuildVariantTuple(ctx context.Context, sel ast.SelectionSet, v []*task.BuildVariantTuple) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuildVariantTuple2githubcomevergreencievergreenmodeltaskBuildVariantTuple(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCedarConfig2githubcomevergreencievergreenrestmodelAPICedarConfig(ctx context.Context, sel ast.SelectionSet, v *model.APICedarConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CedarConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCedarConfigInput2githubcomevergreencievergreenrestmodelAPICedarConfig(ctx context.Context, v any) (*model.APICedarConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCedarConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChildPatchAlias2githubcomevergreencievergreenrestmodelAPIChildPatchAlias(ctx context.Context, sel ast.SelectionSet, v []model.APIChildPatchAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChildPatchAlias2githubcomevergreencievergreenrestmodelAPIChildPatchAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOClientBinary2githubcomevergreencievergreenrestmodelAPIClientBinary(ctx context.Context, sel ast.SelectionSet, v []model.APIClientBinary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNClientBinary2githubcomevergreencievergreenrestmodelAPIClientBinary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOClientConfig2githubcomevergreencievergreenrestmodelAPIClientConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIClientConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ClientConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOCloudProviderConfig2githubcomevergreencievergreenrestmodelAPICloudProviders(ctx context.Context, sel ast.SelectionSet, v *model.APICloudProviders) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CloudProviderConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCloudProviderConfigInput2githubcomevergreencievergreenrestmodelAPICloudProviders(ctx context.Context, v any) (*model.APICloudProviders, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCloudProviderConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCommitQueueParamsInput2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx context.Context, v any) (model.APICommitQueueParams, error) {
	res, err := ec.unmarshalInputCommitQueueParamsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOContainerPoolsConfig2githubcomevergreencievergreenrestmodelAPIContainerPoolsConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIContainerPoolsConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ContainerPoolsConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOContainerPoolsConfigInput2githubcomevergreencievergreenrestmodelAPIContainerPoolsConfig(ctx context.Context, v any) (*model.APIContainerPoolsConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputContainerPoolsConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOContainerResources2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx context.Context, sel ast.SelectionSet, v []model.APIContainerResources) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerResources2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOContainerResourcesInput2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx context.Context, v any) ([]model.APIContainerResources, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIContainerResources, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContainerResourcesInput2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOCost2githubcomevergreencievergreenmodelcostCost(ctx context.Context, sel ast.SelectionSet, v *cost.Cost) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Cost(ctx, sel, v)
}

func (ec *executionContext) marshalOCostConfig2githubcomevergreencievergreenrestmodelAPICostConfig(ctx context.Context, sel ast.SelectionSet, v *model.APICostConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CostConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCostConfigInput2githubcomevergreencievergreenrestmodelAPICostConfig(ctx context.Context, v any) (*model.APICostConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCostConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCostData2githubcomevergreencievergreenrestmodelAPICostData(ctx context.Context, sel ast.SelectionSet, v model.APICostData) graphql.Marshaler {
	return ec._CostData(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOCostDataInput2githubcomevergreencievergreenrestmodelAPICostData(ctx context.Context, v any) (model.APICostData, error) {
	res, err := ec.unmarshalInputCostDataInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODeleteGithubAppCredentialsPayload2githubcomevergreencievergreengraphqlDeleteGithubAppCredentialsPayload(ctx context.Context, sel ast.SelectionSet, v *DeleteGithubAppCredentialsPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeleteGithubAppCredentialsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalODependency2githubcomevergreencievergreengraphqlDependency(ctx context.Context, sel ast.SelectionSet, v []*Dependency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDependency2githubcomevergreencievergreengraphqlDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx context.Context, sel ast.SelectionSet, v *model.APIDistro) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Distro(ctx, sel, v)
}

func (ec *executionContext) marshalODistroInfo2githubcomevergreencievergreenrestmodelDistroInfo(ctx context.Context, sel ast.SelectionSet, v model.DistroInfo) graphql.Marshaler {
	return ec._DistroInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalODockerConfig2githubcomevergreencievergreenrestmodelAPIDockerConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIDockerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DockerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalODockerConfigInput2githubcomevergreencievergreenrestmodelAPIDockerConfig(ctx context.Context, v any) (*model.APIDockerConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDockerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, v any) (model.APIDuration, error) {
	res, err := model.UnmarshalAPIDuration(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, sel ast.SelectionSet, v model.APIDuration) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := model.MarshalAPIDuration(v)
	return res
}

func (ec *executionContext) unmarshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, v any) (*model.APIDuration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalAPIDuration(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, sel ast.SelectionSet, v *model.APIDuration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := model.MarshalAPIDuration(*v)
	return res
}

func (ec *executionContext) unmarshalOECSArchitecture2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOECSArchitecture2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOECSArchitecture2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOECSArchitecture2string[*v])
	return res
}

var (
	unmarshalOECSArchitecture2string = map[string]string{
		"ECS_ARCH_AMD64": evergreen.ECSArchAMD64,
		"ECS_ARCH_ARM64": evergreen.ECSArchARM64,
	}
	marshalOECSArchitecture2string = map[string]string{
		evergreen.ECSArchAMD64: "ECS_ARCH_AMD64",
		evergreen.ECSArchARM64: "ECS_ARCH_ARM64",
	}
)

func (ec *executionContext) marshalOECSConfig2githubcomevergreencievergreenrestmodelAPIECSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIECSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ECSConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOECSConfigInput2githubcomevergreencievergreenrestmodelAPIECSConfig(ctx context.Context, v any) (*model.APIECSConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputECSConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOECSOperatingSystem2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOECSOperatingSystem2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOECSOperatingSystem2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOECSOperatingSystem2string[*v])
	return res
}

var (
	unmarshalOECSOperatingSystem2string = map[string]string{
		"ECSOSLinux":   evergreen.ECSOSLinux,
		"ECSOSWindows": evergreen.ECSOSWindows,
	}
	marshalOECSOperatingSystem2string = map[string]string{
		evergreen.ECSOSLinux:   "ECSOSLinux",
		evergreen.ECSOSWindows: "ECSOSWindows",
	}
)

func (ec *executionContext) unmarshalOECSWindowsVersion2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOECSWindowsVersion2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOECSWindowsVersion2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOECSWindowsVersion2string[*v])
	return res
}

var (
	unmarshalOECSWindowsVersion2string = map[string]string{
		"ECS_WINDOWS_SERVER_2016": evergreen.ECSWindowsServer2016,
		"ECS_WINDOWS_SERVER_2019": evergreen.ECSWindowsServer2019,
		"ECS_WINDOWS_SERVER_2022": evergreen.ECSWindowsServer2022,
	}
	marshalOECSWindowsVersion2string = map[string]string{
		evergreen.ECSWindowsServer2016: "ECS_WINDOWS_SERVER_2016",
		evergreen.ECSWindowsServer2019: "ECS_WINDOWS_SERVER_2019",
		evergreen.ECSWindowsServer2022: "ECS_WINDOWS_SERVER_2022",
	}
)

func (ec *executionContext) unmarshalOEditSpawnHostInput2githubcomevergreencievergreengraphqlEditSpawnHostInput(ctx context.Context, v any) (*EditSpawnHostInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEditSpawnHostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOExternalLink2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx context.Context, sel ast.SelectionSet, v []model.APIExternalLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExternalLink2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOExternalLinkInput2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx context.Context, v any) ([]model.APIExternalLink, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIExternalLink, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNExternalLinkInput2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFWSConfig2githubcomevergreencievergreenrestmodelAPIFWSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIFWSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FWSConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFWSConfigInput2githubcomevergreencievergreenrestmodelAPIFWSConfig(ctx context.Context, v any) (*model.APIFWSConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFWSConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFeedbackRule2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOFeedbackRule2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedbackRule2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOFeedbackRule2string[*v])
	return res
}

var (
	unmarshalOFeedbackRule2string = map[string]string{
		"WAITS_OVER_THRESH": evergreen.HostAllocatorWaitsOverThreshFeedback,
		"NO_FEEDBACK":       evergreen.HostAllocatorNoFeedback,
		"DEFAULT":           evergreen.HostAllocatorUseDefaultFeedback,
	}
	marshalOFeedbackRule2string = map[string]string{
		evergreen.HostAllocatorWaitsOverThreshFeedback: "WAITS_OVER_THRESH",
		evergreen.HostAllocatorNoFeedback:              "NO_FEEDBACK",
		evergreen.HostAllocatorUseDefaultFeedback:      "DEFAULT",
	}
)

func (ec *executionContext) marshalOFile2githubcomevergreencievergreenrestmodelAPIFile(ctx context.Context, sel ast.SelectionSet, v []*model.APIFile) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFile2githubcomevergreencievergreenrestmodelAPIFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFinderVersion2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOFinderVersion2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFinderVersion2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOFinderVersion2string[*v])
	return res
}

var (
	unmarshalOFinderVersion2string = map[string]string{
		"LEGACY":    evergreen.FinderVersionLegacy,
		"PARALLEL":  evergreen.FinderVersionParallel,
		"PIPELINE":  evergreen.FinderVersionPipeline,
		"ALTERNATE": evergreen.FinderVersionAlternate,
	}
	marshalOFinderVersion2string = map[string]string{
		evergreen.FinderVersionLegacy:    "LEGACY",
		evergreen.FinderVersionParallel:  "PARALLEL",
		evergreen.FinderVersionPipeline:  "PIPELINE",
		evergreen.FinderVersionAlternate: "ALTERNATE",
	}
)

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, sel ast.SelectionSet, v []model.APISubscription) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, sel ast.SelectionSet, v []*model.APISubscription) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGitHubAuthConfig2githubcomevergreencievergreenrestmodelAPIGithubAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GitHubAuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGitHubAuthConfigInput2githubcomevergreencievergreenrestmodelAPIGithubAuthConfig(ctx context.Context, v any) (*model.APIGithubAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGitHubAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGitHubCheckRunConfig2githubcomevergreencievergreenrestmodelAPIGitHubCheckRunConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIGitHubCheckRunConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GitHubCheckRunConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGitHubCheckRunConfigInput2githubcomevergreencievergreenrestmodelAPIGitHubCheckRunConfig(ctx context.Context, v any) (*model.APIGitHubCheckRunConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGitHubCheckRunConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGitHubDynamicTokenPermissionGroupInput2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx context.Context, v any) ([]model.APIGitHubDynamicTokenPermissionGroup, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIGitHubDynamicTokenPermissionGroup, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGitHubDynamicTokenPermissionGroupInput2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOGitTag2githubcomevergreencievergreenrestmodelAPIGitTag(ctx context.Context, sel ast.SelectionSet, v []model.APIGitTag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitTag2githubcomevergreencievergreenrestmodelAPIGitTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGithubAppAuth2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx context.Context, sel ast.SelectionSet, v model.APIGithubAppAuth) graphql.Marshaler {
	return ec._GithubAppAuth(ctx, sel, &v)
}

func (ec *executionContext) marshalOGithubAppAuth2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubAppAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubAppAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubAppAuthInput2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx context.Context, v any) (model.APIGithubAppAuth, error) {
	res, err := ec.unmarshalInputGithubAppAuthInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGithubCheckSubscriber2githubcomevergreencievergreenrestmodelAPIGithubCheckSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubCheckSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubCheckSubscriber(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubPRSubscriber2githubcomevergreencievergreenrestmodelAPIGithubPRSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubPRSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubPRSubscriber(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubPatch2githubcomevergreencievergreenrestmodelAPIGithubPatch(ctx context.Context, sel ast.SelectionSet, v model.APIGithubPatch) graphql.Marshaler {
	return ec._GithubPatch(ctx, sel, &v)
}

func (ec *executionContext) marshalOGithubUser2githubcomevergreencievergreenrestmodelAPIGithubUser(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubUserInput2githubcomevergreencievergreenrestmodelAPIGithubUser(ctx context.Context, v any) (*model.APIGithubUser, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubUserInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGraphiteConfig2githubcomevergreencievergreenrestmodelAPIGraphiteConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIGraphiteConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GraphiteConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGraphiteConfigInput2githubcomevergreencievergreenrestmodelAPIGraphiteConfig(ctx context.Context, v any) (*model.APIGraphiteConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGraphiteConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGroupedBuildVariant2githubcomevergreencievergreengraphqlGroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, v []*GroupedBuildVariant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedBuildVariant2githubcomevergreencievergreengraphqlGroupedBuildVariant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGroupedTaskStatusCount2githubcomevergreencievergreenmodeltaskGroupedTaskStatusCount(ctx context.Context, sel ast.SelectionSet, v []*task.GroupedTaskStatusCount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedTaskStatusCount2githubcomevergreencievergreenmodeltaskGroupedTaskStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOHost2githubcomevergreencievergreenrestmodelAPIHost(ctx context.Context, sel ast.SelectionSet, v *model.APIHost) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHostAllocatorVersion2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOHostAllocatorVersion2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHostAllocatorVersion2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOHostAllocatorVersion2string[*v])
	return res
}

var (
	unmarshalOHostAllocatorVersion2string = map[string]string{
		"UTILIZATION": evergreen.HostAllocatorUtilization,
	}
	marshalOHostAllocatorVersion2string = map[string]string{
		evergreen.HostAllocatorUtilization: "UTILIZATION",
	}
)

func (ec *executionContext) unmarshalOHostEventType2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHostEventType2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOHostEventType2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHostEventType2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHostEventType2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOHostEventType2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHostEventType2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOHostEventType2string[*v])
	return res
}

var (
	unmarshalOHostEventType2string = map[string]string{
		"HOST_CREATED":                                     event.EventHostCreated,
		"HOST_CREATED_ERROR":                               event.EventHostCreatedError,
		"HOST_STARTED":                                     event.EventHostStarted,
		"HOST_STOPPED":                                     event.EventHostStopped,
		"HOST_REBOOTED":                                    event.EventHostRebooted,
		"HOST_MODIFIED":                                    event.EventHostModified,
		"HOST_AGENT_DEPLOYED":                              event.EventHostAgentDeployed,
		"HOST_AGENT_DEPLOY_FAILED":                         event.EventHostAgentDeployFailed,
		"HOST_AGENT_MONITOR_DEPLOYED":                      event.EventHostAgentMonitorDeployed,
		"HOST_AGENT_MONITOR_DEPLOY_FAILED":                 event.EventHostAgentMonitorDeployFailed,
		"HOST_JASPER_RESTARTING":                           event.EventHostJasperRestarting,
		"HOST_JASPER_RESTARTED":                            event.EventHostJasperRestarted,
		"HOST_JASPER_RESTART_ERROR":                        event.EventHostJasperRestartError,
		"HOST_CONVERTING_PROVISIONING":                     event.EventHostConvertingProvisioning,
		"HOST_CONVERTED_PROVISIONING":                      event.EventHostConvertedProvisioning,
		"HOST_CONVERTING_PROVISIONING_ERROR":               event.EventHostConvertingProvisioningError,
		"HOST_STATUS_CHANGED":                              event.EventHostStatusChanged,
		"HOST_DNS_NAME_SET":                                event.EventHostDNSNameSet,
		"HOST_PROVISION_ERROR":                             event.EventHostProvisionError,
		"HOST_PROVISION_FAILED":                            event.EventHostProvisionFailed,
		"HOST_PROVISIONED":                                 event.EventHostProvisioned,
		"HOST_RUNNING_TASK_SET":                            event.EventHostRunningTaskSet,
		"HOST_RUNNING_TASK_CLEARED":                        event.EventHostRunningTaskCleared,
		"HOST_TASK_FINISHED":                               event.EventHostTaskFinished,
		"HOST_TERMINATED_EXTERNALLY":                       event.EventHostTerminatedExternally,
		"HOST_EXPIRATION_WARNING_SENT":                     event.EventHostExpirationWarningSent,
		"HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT": event.EventHostTemporaryExemptionExpirationWarningSent,
		"HOST_IDLE_NOTIFICATION":                           event.EventSpawnHostIdleNotification,
		"HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT":        event.EventAlertableInstanceTypeWarningSent,
		"HOST_SCRIPT_EXECUTED":                             event.EventHostScriptExecuted,
		"HOST_SCRIPT_EXECUTE_FAILED":                       event.EventHostScriptExecuteFailed,
		"SPAWN_HOST_CREATED_ERROR":                         event.EventSpawnHostCreatedError,
		"VOLUME_EXPIRATION_WARNING_SENT":                   event.EventVolumeExpirationWarningSent,
		"VOLUME_MIGRATION_FAILED":                          event.EventVolumeMigrationFailed,
	}
	marshalOHostEventType2string = map[string]string{
		event.EventHostCreated:                                 "HOST_CREATED",
		event.EventHostCreatedError:                            "HOST_CREATED_ERROR",
		event.EventHostStarted:                                 "HOST_STARTED",
		event.EventHostStopped:                                 "HOST_STOPPED",
		event.EventHostRebooted:                                "HOST_REBOOTED",
		event.EventHostModified:                                "HOST_MODIFIED",
		event.EventHostAgentDeployed:                           "HOST_AGENT_DEPLOYED",
		event.EventHostAgentDeployFailed:                       "HOST_AGENT_DEPLOY_FAILED",
		event.EventHostAgentMonitorDeployed:                    "HOST_AGENT_MONITOR_DEPLOYED",
		event.EventHostAgentMonitorDeployFailed:                "HOST_AGENT_MONITOR_DEPLOY_FAILED",
		event.EventHostJasperRestarting:                        "HOST_JASPER_RESTARTING",
		event.EventHostJasperRestarted:                         "HOST_JASPER_RESTARTED",
		event.EventHostJasperRestartError:                      "HOST_JASPER_RESTART_ERROR",
		event.EventHostConvertingProvisioning:                  "HOST_CONVERTING_PROVISIONING",
		event.EventHostConvertedProvisioning:                   "HOST_CONVERTED_PROVISIONING",
		event.EventHostConvertingProvisioningError:             "HOST_CONVERTING_PROVISIONING_ERROR",
		event.EventHostStatusChanged:                           "HOST_STATUS_CHANGED",
		event.EventHostDNSNameSet:                              "HOST_DNS_NAME_SET",
		event.EventHostProvisionError:                          "HOST_PROVISION_ERROR",
		event.EventHostProvisionFailed:                         "HOST_PROVISION_FAILED",
		event.EventHostProvisioned:                             "HOST_PROVISIONED",
		event.EventHostRunningTaskSet:                          "HOST_RUNNING_TASK_SET",
		event.EventHostRunningTaskCleared:                      "HOST_RUNNING_TASK_CLEARED",
		event.EventHostTaskFinished:                            "HOST_TASK_FINISHED",
		event.EventHostTerminatedExternally:                    "HOST_TERMINATED_EXTERNALLY",
		event.EventHostExpirationWarningSent:                   "HOST_EXPIRATION_WARNING_SENT",
		event.EventHostTemporaryExemptionExpirationWarningSent: "HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT",
		event.EventSpawnHostIdleNotification:                   "HOST_IDLE_NOTIFICATION",
		event.EventAlertableInstanceTypeWarningSent:            "HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT",
		event.EventHostScriptExecuted:                          "HOST_SCRIPT_EXECUTED",
		event.EventHostScriptExecuteFailed:                     "HOST_SCRIPT_EXECUTE_FAILED",
		event.EventSpawnHostCreatedError:                       "SPAWN_HOST_CREATED_ERROR",
		event.EventVolumeExpirationWarningSent:                 "VOLUME_EXPIRATION_WARNING_SENT",
		event.EventVolumeMigrationFailed:                       "VOLUME_MIGRATION_FAILED",
	}
)

func (ec *executionContext) marshalOHostInitConfig2githubcomevergreencievergreenrestmodelAPIHostInitConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIHostInitConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HostInitConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHostInitConfigInput2githubcomevergreencievergreenrestmodelAPIHostInitConfig(ctx context.Context, v any) (*model.APIHostInitConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHostInitConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHostJasperConfig2githubcomevergreencievergreenrestmodelAPIHostJasperConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIHostJasperConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HostJasperConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHostJasperConfigInput2githubcomevergreencievergreenrestmodelAPIHostJasperConfig(ctx context.Context, v any) (*model.APIHostJasperConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHostJasperConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOHostSortBy2githubcomevergreencievergreengraphqlHostSortBy(ctx context.Context, v any) (*HostSortBy, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(HostSortBy)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHostSortBy2githubcomevergreencievergreengraphqlHostSortBy(ctx context.Context, sel ast.SelectionSet, v *HostSortBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) marshalOImage2githubcomevergreencievergreenrestmodelAPIImage(ctx context.Context, sel ast.SelectionSet, v *model.APIImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Image(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInstanceTagInput2githubcomevergreencievergreenmodelhostTag(ctx context.Context, v any) ([]*host.Tag, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*host.Tag, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInstanceTagInput2githubcomevergreencievergreenmodelhostTag(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int32(ctx context.Context, v any) (int32, error) {
	res, err := graphql.UnmarshalInt32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalInt32(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalInt64(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx context.Context, sel ast.SelectionSet, v []model.APIIssueLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOJiraConfig2githubcomevergreencievergreenrestmodelAPIJiraConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIJiraConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJiraConfigInput2githubcomevergreencievergreenrestmodelAPIJiraConfig(ctx context.Context, v any) (*model.APIJiraConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJiraConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJiraIssueSubscriber2githubcomevergreencievergreenrestmodelAPIJIRAIssueSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIJIRAIssueSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraIssueSubscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJiraIssueSubscriberInput2githubcomevergreencievergreenrestmodelAPIJIRAIssueSubscriber(ctx context.Context, v any) (*model.APIJIRAIssueSubscriber, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJiraIssueSubscriberInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJiraNotificationsConfig2githubcomevergreencievergreenrestmodelAPIJIRANotificationsConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIJIRANotificationsConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraNotificationsConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJiraNotificationsConfigInput2githubcomevergreencievergreenrestmodelAPIJIRANotificationsConfig(ctx context.Context, v any) (*model.APIJIRANotificationsConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJiraNotificationsConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraTicket) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraTicket(ctx, sel, v)
}

func (ec *executionContext) marshalOKanopyAuthConfig2githubcomevergreencievergreenrestmodelAPIKanopyAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIKanopyAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KanopyAuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOKanopyAuthConfigInput2githubcomevergreencievergreenrestmodelAPIKanopyAuthConfig(ctx context.Context, v any) (*model.APIKanopyAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputKanopyAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLogBuffering2githubcomevergreencievergreenrestmodelAPILogBuffering(ctx context.Context, sel ast.SelectionSet, v *model.APILogBuffering) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LogBuffering(ctx, sel, v)
}

func (ec *executionContext) marshalOLoggerConfig2githubcomevergreencievergreenrestmodelAPILoggerConfig(ctx context.Context, sel ast.SelectionSet, v *model.APILoggerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoggerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoggerConfigInput2githubcomevergreencievergreenrestmodelAPILoggerConfig(ctx context.Context, v any) (*model.APILoggerConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoggerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMainlineCommits2githubcomevergreencievergreengraphqlMainlineCommits(ctx context.Context, sel ast.SelectionSet, v *MainlineCommits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MainlineCommits(ctx, sel, v)
}

func (ec *executionContext) marshalOManifest2githubcomevergreencievergreengraphqlManifest(ctx context.Context, sel ast.SelectionSet, v *Manifest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Manifest(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v any) (map[string]any, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) marshalOMetadataLink2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx context.Context, sel ast.SelectionSet, v []model.APIMetadataLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMetadataLink2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMultiAuthConfig2githubcomevergreencievergreenrestmodelAPIMultiAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIMultiAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MultiAuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMultiAuthConfigInput2githubcomevergreencievergreenrestmodelAPIMultiAuthConfig(ctx context.Context, v any) (*model.APIMultiAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMultiAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONaiveAuthConfig2githubcomevergreencievergreenrestmodelAPINaiveAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APINaiveAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NaiveAuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalONaiveAuthConfigInput2githubcomevergreencievergreenrestmodelAPINaiveAuthConfig(ctx context.Context, v any) (*model.APINaiveAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNaiveAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONote2githubcomevergreencievergreenrestmodelAPINote(ctx context.Context, sel ast.SelectionSet, v *model.APINote) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Note(ctx, sel, v)
}

func (ec *executionContext) marshalONotifications2githubcomevergreencievergreenrestmodelAPINotificationPreferences(ctx context.Context, sel ast.SelectionSet, v *model.APINotificationPreferences) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Notifications(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotificationsInput2githubcomevergreencievergreenrestmodelAPINotificationPreferences(ctx context.Context, v any) (*model.APINotificationPreferences, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotificationsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotifyConfig2githubcomevergreencievergreenrestmodelAPINotifyConfig(ctx context.Context, sel ast.SelectionSet, v *model.APINotifyConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotifyConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotifyConfigInput2githubcomevergreencievergreenrestmodelAPINotifyConfig(ctx context.Context, v any) (*model.APINotifyConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotifyConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOAuthConfig2githubcomevergreencievergreenrestmodelAPIOAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIOAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OAuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOAuthConfigInput2githubcomevergreencievergreenrestmodelAPIOAuthConfig(ctx context.Context, v any) (*model.APIOAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOktaConfig2githubcomevergreencievergreenrestmodelAPIOktaConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIOktaConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OktaConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOktaConfigInput2githubcomevergreencievergreenrestmodelAPIOktaConfig(ctx context.Context, v any) (*model.APIOktaConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOktaConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOOverallocatedRule2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOOverallocatedRule2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOverallocatedRule2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOOverallocatedRule2string[*v])
	return res
}

var (
	unmarshalOOverallocatedRule2string = map[string]string{
		"TERMINATE": evergreen.HostsOverallocatedTerminate,
		"IGNORE":    evergreen.HostsOverallocatedIgnore,
		"DEFAULT":   evergreen.HostsOverallocatedUseDefault,
	}
	marshalOOverallocatedRule2string = map[string]string{
		evergreen.HostsOverallocatedTerminate:  "TERMINATE",
		evergreen.HostsOverallocatedIgnore:     "IGNORE",
		evergreen.HostsOverallocatedUseDefault: "DEFAULT",
	}
)

func (ec *executionContext) unmarshalOParameterInput2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, v any) ([]*model.APIParameter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.APIParameter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNParameterInput2githubcomevergreencievergreenrestmodelAPIParameter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOParameterStoreConfig2githubcomevergreencievergreenrestmodelAPIParameterStoreConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIParameterStoreConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ParameterStoreConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOParameterStoreConfigInput2githubcomevergreencievergreenrestmodelAPIParameterStoreConfig(ctx context.Context, v any) (*model.APIParameterStoreConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputParameterStoreConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOParserProjectS3Config2githubcomevergreencievergreenrestmodelAPIParserProjectS3Config(ctx context.Context, sel ast.SelectionSet, v *model.APIParserProjectS3Config) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ParserProjectS3Config(ctx, sel, v)
}

func (ec *executionContext) unmarshalOParserProjectS3ConfigInput2githubcomevergreencievergreenrestmodelAPIParserProjectS3Config(ctx context.Context, v any) (*model.APIParserProjectS3Config, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputParserProjectS3ConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx context.Context, sel ast.SelectionSet, v []model.APIParsleyFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOParsleyFilterInput2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx context.Context, v any) ([]model.APIParsleyFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIParsleyFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNParsleyFilterInput2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOParsleySettings2githubcomevergreencievergreenrestmodelAPIParsleySettings(ctx context.Context, sel ast.SelectionSet, v *model.APIParsleySettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ParsleySettings(ctx, sel, v)
}

func (ec *executionContext) marshalOPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx context.Context, sel ast.SelectionSet, v []model.APIPatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx context.Context, sel ast.SelectionSet, v *model.APIPatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Patch(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchDuration2githubcomevergreencievergreengraphqlPatchDuration(ctx context.Context, sel ast.SelectionSet, v *PatchDuration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchDuration(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchProject2githubcomevergreencievergreengraphqlPatchProject(ctx context.Context, sel ast.SelectionSet, v *PatchProject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchProject(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchTime2githubcomevergreencievergreengraphqlPatchTime(ctx context.Context, sel ast.SelectionSet, v *PatchTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchTime(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v []model.APIPatchTriggerDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPatchTriggerAliasInput2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, v any) ([]model.APIPatchTriggerDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIPatchTriggerDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPatchTriggerAliasInput2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPeriodicBuild2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx context.Context, sel ast.SelectionSet, v []model.APIPeriodicBuildDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPeriodicBuild2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPeriodicBuildInput2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx context.Context, v any) ([]model.APIPeriodicBuildDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIPeriodicBuildDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPeriodicBuildInput2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPersistentDNSConfig2githubcomevergreencievergreenrestmodelAPIPersistentDNSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIPersistentDNSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PersistentDNSConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPersistentDNSConfigInput2githubcomevergreencievergreenrestmodelAPIPersistentDNSConfig(ctx context.Context, v any) (*model.APIPersistentDNSConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPersistentDNSConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPod2githubcomevergreencievergreenrestmodelAPIPod(ctx context.Context, sel ast.SelectionSet, v *model.APIPod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Pod(ctx, sel, v)
}

func (ec *executionContext) marshalOPodLifecycleConfig2githubcomevergreencievergreenrestmodelAPIPodLifecycleConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIPodLifecycleConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PodLifecycleConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPodLifecycleConfigInput2githubcomevergreencievergreenrestmodelAPIPodLifecycleConfig(ctx context.Context, v any) (*model.APIPodLifecycleConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPodLifecycleConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPreferredAuthType2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOPreferredAuthType2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPreferredAuthType2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOPreferredAuthType2string[*v])
	return res
}

var (
	unmarshalOPreferredAuthType2string = map[string]string{
		"OKTA":   model.OktaPreferredType,
		"NAIVE":  model.NaivePreferredType,
		"GITHUB": model.GithubPreferredType,
		"MULTI":  model.MultiPreferredType,
		"KANOPY": model.KanopyPreferredType,
	}
	marshalOPreferredAuthType2string = map[string]string{
		model.OktaPreferredType:   "OKTA",
		model.NaivePreferredType:  "NAIVE",
		model.GithubPreferredType: "GITHUB",
		model.MultiPreferredType:  "MULTI",
		model.KanopyPreferredType: "KANOPY",
	}
)

func (ec *executionContext) unmarshalOPriorityLevel2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOPriorityLevel2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPriorityLevel2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOPriorityLevel2string[*v])
	return res
}

var (
	unmarshalOPriorityLevel2string = map[string]string{
		"EMERGENCY": evergreen.PriorityLevelEmergency,
		"ALERT":     evergreen.PriorityLevelAlert,
		"CRITICAL":  evergreen.PriorityLevelCritical,
		"ERROR":     evergreen.PriorityLevelError,
		"WARNING":   evergreen.PriorityLevelWarning,
		"NOTICE":    evergreen.PriorityLevelNotice,
		"INFO":      evergreen.PriorityLevelInfo,
		"DEBUG":     evergreen.PriorityLevelDebug,
		"TRACE":     evergreen.PriorityLevelTrace,
	}
	marshalOPriorityLevel2string = map[string]string{
		evergreen.PriorityLevelEmergency: "EMERGENCY",
		evergreen.PriorityLevelAlert:     "ALERT",
		evergreen.PriorityLevelCritical:  "CRITICAL",
		evergreen.PriorityLevelError:     "ERROR",
		evergreen.PriorityLevelWarning:   "WARNING",
		evergreen.PriorityLevelNotice:    "NOTICE",
		evergreen.PriorityLevelInfo:      "INFO",
		evergreen.PriorityLevelDebug:     "DEBUG",
		evergreen.PriorityLevelTrace:     "TRACE",
	}
)

func (ec *executionContext) marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalOProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v []model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOProjectAliasInput2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, v any) ([]model.APIProjectAlias, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIProjectAlias, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectAliasInput2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOProjectBanner2githubcomevergreencievergreenrestmodelAPIProjectBanner(ctx context.Context, sel ast.SelectionSet, v model.APIProjectBanner) graphql.Marshaler {
	return ec._ProjectBanner(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOProjectBannerInput2githubcomevergreencievergreenrestmodelAPIProjectBanner(ctx context.Context, v any) (model.APIProjectBanner, error) {
	res, err := ec.unmarshalInputProjectBannerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectCreationConfig2githubcomevergreencievergreenrestmodelAPIProjectCreationConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectCreationConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectCreationConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProjectCreationConfigInput2githubcomevergreencievergreenrestmodelAPIProjectCreationConfig(ctx context.Context, v any) (*model.APIProjectCreationConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectCreationConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectEventSettings2githubcomevergreencievergreenrestmodelAPIProjectEventSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectEventSettings) graphql.Marshaler {
	return ec._ProjectEventSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx context.Context, v any) (model1.ProjectHealthView, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model1.ProjectHealthView(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx context.Context, sel ast.SelectionSet, v model1.ProjectHealthView) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) unmarshalOProjectInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, v any) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProjectSettingsInput2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, v any) (*model.APIProjectSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectVars2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx context.Context, sel ast.SelectionSet, v model.APIProjectVars) graphql.Marshaler {
	return ec._ProjectVars(ctx, sel, &v)
}

func (ec *executionContext) marshalOProjectVars2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectVars) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectVars(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProjectVarsInput2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx context.Context, v any) (model.APIProjectVars, error) {
	res, err := ec.unmarshalInputProjectVarsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx context.Context, v any) (*PublicKeyInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOReleaseModeConfig2githubcomevergreencievergreenrestmodelAPIReleaseModeConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIReleaseModeConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ReleaseModeConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOReleaseModeConfigInput2githubcomevergreencievergreenrestmodelAPIReleaseModeConfig(ctx context.Context, v any) (*model.APIReleaseModeConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputReleaseModeConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepoRef2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._RepoRef(ctx, sel, &v)
}

func (ec *executionContext) marshalORepoRef2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoRef(ctx, sel, v)
}

func (ec *executionContext) unmarshalORepoRefInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, v any) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputRepoRefInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORepoSettingsInput2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, v any) (*model.APIProjectSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepoSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepoTestSelectionSettings2githubcomevergreencievergreenrestmodelAPITestSelectionSettings(ctx context.Context, sel ast.SelectionSet, v model.APITestSelectionSettings) graphql.Marshaler {
	return ec._RepoTestSelectionSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalORepotrackerConfig2githubcomevergreencievergreenrestmodelAPIRepoTrackerConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIRepoTrackerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepotrackerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalORepotrackerConfigInput2githubcomevergreencievergreenrestmodelAPIRepoTrackerConfig(ctx context.Context, v any) (*model.APIRepoTrackerConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepotrackerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepotrackerError2githubcomevergreencievergreenrestmodelAPIRepositoryErrorDetails(ctx context.Context, sel ast.SelectionSet, v *model.APIRepositoryErrorDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepotrackerError(ctx, sel, v)
}

func (ec *executionContext) unmarshalORoundingRule2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalORoundingRule2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORoundingRule2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalORoundingRule2string[*v])
	return res
}

var (
	unmarshalORoundingRule2string = map[string]string{
		"DOWN":    evergreen.HostAllocatorRoundDown,
		"UP":      evergreen.HostAllocatorRoundUp,
		"DEFAULT": evergreen.HostAllocatorRoundDefault,
	}
	marshalORoundingRule2string = map[string]string{
		evergreen.HostAllocatorRoundDown:    "DOWN",
		evergreen.HostAllocatorRoundUp:      "UP",
		evergreen.HostAllocatorRoundDefault: "DEFAULT",
	}
)

func (ec *executionContext) marshalORuntimeEnvironmentConfig2githubcomevergreencievergreenrestmodelAPIRuntimeEnvironmentsConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIRuntimeEnvironmentsConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RuntimeEnvironmentConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalORuntimeEnvironmentConfigInput2githubcomevergreencievergreenrestmodelAPIRuntimeEnvironmentsConfig(ctx context.Context, v any) (*model.APIRuntimeEnvironmentsConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRuntimeEnvironmentConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOS3Credentials2githubcomevergreencievergreenrestmodelAPIS3Credentials(ctx context.Context, sel ast.SelectionSet, v model.APIS3Credentials) graphql.Marshaler {
	return ec._S3Credentials(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOS3CredentialsInput2githubcomevergreencievergreenrestmodelAPIS3Credentials(ctx context.Context, v any) (model.APIS3Credentials, error) {
	res, err := ec.unmarshalInputS3CredentialsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSESConfig2githubcomevergreencievergreenrestmodelAPISESConfig(ctx context.Context, sel ast.SelectionSet, v model.APISESConfig) graphql.Marshaler {
	return ec._SESConfig(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOSESConfigInput2githubcomevergreencievergreenrestmodelAPISESConfig(ctx context.Context, v any) (model.APISESConfig, error) {
	res, err := ec.unmarshalInputSESConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSSHConfig2githubcomevergreencievergreenrestmodelAPISSHConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISSHConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SSHConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSSHConfigInput2githubcomevergreencievergreenrestmodelAPISSHConfig(ctx context.Context, v any) (*model.APISSHConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSSHConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSSHKeyPair2githubcomevergreencievergreenrestmodelAPISSHKeyPair(ctx context.Context, sel ast.SelectionSet, v model.APISSHKeyPair) graphql.Marshaler {
	return ec._SSHKeyPair(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOSSHKeyPairInput2githubcomevergreencievergreenrestmodelAPISSHKeyPair(ctx context.Context, v any) (model.APISSHKeyPair, error) {
	res, err := ec.unmarshalInputSSHKeyPairInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSchedulerConfig2githubcomevergreencievergreenrestmodelAPISchedulerConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISchedulerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SchedulerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSchedulerConfigInput2githubcomevergreencievergreenrestmodelAPISchedulerConfig(ctx context.Context, v any) (*model.APISchedulerConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSchedulerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSearchReturnInfo2githubcomevergreencievergreenthirdpartySearchReturnInfo(ctx context.Context, sel ast.SelectionSet, v *thirdparty.SearchReturnInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchReturnInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOSecretsManagerConfig2githubcomevergreencievergreenrestmodelAPISecretsManagerConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISecretsManagerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SecretsManagerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSecretsManagerConfigInput2githubcomevergreencievergreenrestmodelAPISecretsManagerConfig(ctx context.Context, v any) (*model.APISecretsManagerConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSecretsManagerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOServiceFlags2githubcomevergreencievergreenrestmodelAPIServiceFlags(ctx context.Context, sel ast.SelectionSet, v *model.APIServiceFlags) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ServiceFlags(ctx, sel, v)
}

func (ec *executionContext) unmarshalOServiceFlagsInput2githubcomevergreencievergreenrestmodelAPIServiceFlags(ctx context.Context, v any) (*model.APIServiceFlags, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputServiceFlagsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSingleTaskDistroConfig2githubcomevergreencievergreenrestmodelAPISingleTaskDistroConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISingleTaskDistroConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SingleTaskDistroConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSingleTaskDistroConfigInput2githubcomevergreencievergreenrestmodelAPISingleTaskDistroConfig(ctx context.Context, v any) (*model.APISingleTaskDistroConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSingleTaskDistroConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSlackConfig2githubcomevergreencievergreenrestmodelAPISlackConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISlackConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SlackConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSlackConfigInput2githubcomevergreencievergreenrestmodelAPISlackConfig(ctx context.Context, v any) (*model.APISlackConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSlackConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSlackOptions2githubcomevergreencievergreenrestmodelAPISlackOptions(ctx context.Context, sel ast.SelectionSet, v *model.APISlackOptions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SlackOptions(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSlackOptionsInput2githubcomevergreencievergreenrestmodelAPISlackOptions(ctx context.Context, v any) (*model.APISlackOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSlackOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSleepSchedule2githubcomevergreencievergreenmodelhostSleepScheduleInfo(ctx context.Context, sel ast.SelectionSet, v *host.SleepScheduleInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SleepSchedule(ctx, sel, v)
}

func (ec *executionContext) marshalOSleepScheduleConfig2githubcomevergreencievergreenrestmodelAPISleepScheduleConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISleepScheduleConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SleepScheduleConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSleepScheduleConfigInput2githubcomevergreencievergreenrestmodelAPISleepScheduleConfig(ctx context.Context, v any) (*model.APISleepScheduleConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSleepScheduleConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSleepScheduleInput2githubcomevergreencievergreenmodelhostSleepScheduleInfo(ctx context.Context, v any) (*host.SleepScheduleInfo, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSleepScheduleInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx context.Context, v any) (*SortDirection, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(SortDirection)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx context.Context, sel ast.SelectionSet, v *SortDirection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSortOrder2githubcomevergreencievergreengraphqlSortOrder(ctx context.Context, v any) ([]*SortOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*SortOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSortOrder2githubcomevergreencievergreengraphqlSortOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSource2githubcomevergreencievergreenrestmodelAPISource(ctx context.Context, sel ast.SelectionSet, v *model.APISource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Source(ctx, sel, v)
}

func (ec *executionContext) marshalOSpawnHostConfig2githubcomevergreencievergreenrestmodelAPISpawnHostConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISpawnHostConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SpawnHostConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSpawnHostConfigInput2githubcomevergreencievergreenrestmodelAPISpawnHostConfig(ctx context.Context, v any) (*model.APISpawnHostConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSpawnHostConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSpawnHostInput2githubcomevergreencievergreengraphqlSpawnHostInput(ctx context.Context, v any) (*SpawnHostInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSpawnHostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSplunkConfig2githubcomevergreencievergreenrestmodelAPISplunkConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISplunkConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SplunkConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSplunkConfigInput2githubcomevergreencievergreenrestmodelAPISplunkConfig(ctx context.Context, v any) (*model.APISplunkConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSplunkConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSpruceConfig2githubcomevergreencievergreenrestmodelAPIAdminSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIAdminSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SpruceConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx context.Context, sel ast.SelectionSet, v []task.StatusCount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOStepbackInfo2githubcomevergreencievergreenrestmodelAPIStepbackInfo(ctx context.Context, sel ast.SelectionSet, v *model.APIStepbackInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StepbackInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStringMap2map(ctx context.Context, v any) (map[string]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := MarshalStringMap(v)
	return res
}

func (ec *executionContext) marshalOSubscriberWrapper2githubcomevergreencievergreenrestmodelAPISubscriber(ctx context.Context, sel ast.SelectionSet, v model.APISubscriber) graphql.Marshaler {
	return ec._SubscriberWrapper(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, v any) ([]model.APISubscription, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APISubscription, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx context.Context, sel ast.SelectionSet, v []*model.APITask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx context.Context, sel ast.SelectionSet, v *model.APITask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskAnnotationSettingsInput2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings(ctx context.Context, v any) (model.APITaskAnnotationSettings, error) {
	res, err := ec.unmarshalInputTaskAnnotationSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTaskCountOptions2githubcomevergreencievergreengraphqlTaskCountOptions(ctx context.Context, v any) (*TaskCountOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTaskCountOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTaskEndDetail2githubcomevergreencievergreenrestmodelApiTaskEndDetail(ctx context.Context, sel ast.SelectionSet, v model.ApiTaskEndDetail) graphql.Marshaler {
	return ec._TaskEndDetail(ctx, sel, &v)
}

func (ec *executionContext) marshalOTaskInfo2githubcomevergreencievergreenrestmodelTaskInfo(ctx context.Context, sel ast.SelectionSet, v model.TaskInfo) graphql.Marshaler {
	return ec._TaskInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalOTaskLimitsConfig2githubcomevergreencievergreenrestmodelAPITaskLimitsConfig(ctx context.Context, sel ast.SelectionSet, v *model.APITaskLimitsConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskLimitsConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskLimitsConfigInput2githubcomevergreencievergreenrestmodelAPITaskLimitsConfig(ctx context.Context, v any) (*model.APITaskLimitsConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTaskLimitsConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTaskOwnerTeam2githubcomevergreencievergreengraphqlTaskOwnerTeam(ctx context.Context, sel ast.SelectionSet, v *TaskOwnerTeam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskOwnerTeam(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskSpecifier2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx context.Context, sel ast.SelectionSet, v []model.APITaskSpecifier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskSpecifier2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTaskStats2githubcomevergreencievergreenmodeltaskTaskStats(ctx context.Context, sel ast.SelectionSet, v *task.TaskStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskStats(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskTestResultSample2githubcomevergreencievergreengraphqlTaskTestResultSample(ctx context.Context, sel ast.SelectionSet, v []*TaskTestResultSample) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskTestResultSample2githubcomevergreencievergreengraphqlTaskTestResultSample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTestFilterOptions2githubcomevergreencievergreengraphqlTestFilterOptions(ctx context.Context, v any) (*TestFilterOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTestFilterOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTestSelectionConfig2githubcomevergreencievergreenrestmodelAPITestSelectionConfig(ctx context.Context, sel ast.SelectionSet, v *model.APITestSelectionConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TestSelectionConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTestSelectionConfigInput2githubcomevergreencievergreenrestmodelAPITestSelectionConfig(ctx context.Context, v any) (*model.APITestSelectionConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTestSelectionConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTestSelectionSettings2githubcomevergreencievergreenrestmodelAPITestSelectionSettings(ctx context.Context, sel ast.SelectionSet, v model.APITestSelectionSettings) graphql.Marshaler {
	return ec._TestSelectionSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOTestSelectionSettingsInput2githubcomevergreencievergreenrestmodelAPITestSelectionSettings(ctx context.Context, v any) (model.APITestSelectionSettings, error) {
	res, err := ec.unmarshalInputTestSelectionSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTestSortOptions2githubcomevergreencievergreengraphqlTestSortOptions(ctx context.Context, v any) ([]*TestSortOptions, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*TestSortOptions, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTestSortOptions2githubcomevergreencievergreengraphqlTestSortOptions(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTracerSettings2githubcomevergreencievergreenrestmodelAPITracerSettings(ctx context.Context, sel ast.SelectionSet, v *model.APITracerSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TracerSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTracerSettingsInput2githubcomevergreencievergreenrestmodelAPITracerSettings(ctx context.Context, v any) (*model.APITracerSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTracerSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx context.Context, sel ast.SelectionSet, v []model.APITriggerDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTriggerAliasInput2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx context.Context, v any) ([]model.APITriggerDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APITriggerDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTriggerAliasInput2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTriggerConfig2githubcomevergreencievergreenrestmodelAPITriggerConfig(ctx context.Context, sel ast.SelectionSet, v *model.APITriggerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TriggerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTriggerConfigInput2githubcomevergreencievergreenrestmodelAPITriggerConfig(ctx context.Context, v any) (*model.APITriggerConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTriggerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUIConfig2githubcomevergreencievergreenrestmodelAPIUIConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIUIConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UIConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUIConfigInput2githubcomevergreencievergreenrestmodelAPIUIConfig(ctx context.Context, v any) (*model.APIUIConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUIConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpdateBetaFeaturesPayload2githubcomevergreencievergreengraphqlUpdateBetaFeaturesPayload(ctx context.Context, sel ast.SelectionSet, v *UpdateBetaFeaturesPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateBetaFeaturesPayload(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateParsleySettingsPayload2githubcomevergreencievergreengraphqlUpdateParsleySettingsPayload(ctx context.Context, sel ast.SelectionSet, v *UpdateParsleySettingsPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateParsleySettingsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalOUpstreamProject2githubcomevergreencievergreengraphqlUpstreamProject(ctx context.Context, sel ast.SelectionSet, v *UpstreamProject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpstreamProject(ctx, sel, v)
}

func (ec *executionContext) marshalOUseSpruceOptions2githubcomevergreencievergreenrestmodelAPIUseSpruceOptions(ctx context.Context, sel ast.SelectionSet, v *model.APIUseSpruceOptions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UseSpruceOptions(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUseSpruceOptionsInput2githubcomevergreencievergreenrestmodelAPIUseSpruceOptions(ctx context.Context, v any) (*model.APIUseSpruceOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUseSpruceOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserConfig2githubcomevergreencievergreengraphqlUserConfig(ctx context.Context, sel ast.SelectionSet, v *UserConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserSettingsInput2githubcomevergreencievergreenrestmodelAPIUserSettings(ctx context.Context, v any) (*model.APIUserSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx context.Context, sel ast.SelectionSet, v []*model.APIVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx context.Context, sel ast.SelectionSet, v *model.APIVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalOVersionTiming2githubcomevergreencievergreengraphqlVersionTiming(ctx context.Context, sel ast.SelectionSet, v *VersionTiming) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VersionTiming(ctx, sel, v)
}

func (ec *executionContext) marshalOVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx context.Context, sel ast.SelectionSet, v *model.APIVolume) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Volume(ctx, sel, v)
}

func (ec *executionContext) marshalOWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx context.Context, sel ast.SelectionSet, v []*model1.WaterfallBuild) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWebhookInput2githubcomevergreencievergreenrestmodelAPIWebHook(ctx context.Context, v any) (model.APIWebHook, error) {
	res, err := ec.unmarshalInputWebhookInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWebhookSubscriber2githubcomevergreencievergreenrestmodelAPIWebhookSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIWebhookSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WebhookSubscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWebhookSubscriberInput2githubcomevergreencievergreenrestmodelAPIWebhookSubscriber(ctx context.Context, v any) (*model.APIWebhookSubscriber, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWebhookSubscriberInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWorkstationConfigInput2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx context.Context, v any) (model.APIWorkstationConfig, error) {
	res, err := ec.unmarshalInputWorkstationConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorkstationSetupCommand2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx context.Context, sel ast.SelectionSet, v []model.APIWorkstationSetupCommand) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkstationSetupCommand2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWorkstationSetupCommandInput2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx context.Context, v any) ([]model.APIWorkstationSetupCommand, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIWorkstationSetupCommand, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWorkstationSetupCommandInput2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
