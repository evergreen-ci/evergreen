// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/evergreen-ci/evergreen"
	"github.com/evergreen-ci/evergreen/apimodels"
	model1 "github.com/evergreen-ci/evergreen/model"
	"github.com/evergreen-ci/evergreen/model/event"
	"github.com/evergreen-ci/evergreen/model/host"
	"github.com/evergreen-ci/evergreen/model/task"
	"github.com/evergreen-ci/evergreen/rest/model"
	"github.com/evergreen-ci/evergreen/thirdparty"
	"github.com/evergreen-ci/plank"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AdminSettings() AdminSettingsResolver
	Annotation() AnnotationResolver
	BootstrapSettings() BootstrapSettingsResolver
	ContainerPool() ContainerPoolResolver
	DispatcherSettings() DispatcherSettingsResolver
	Distro() DistroResolver
	FinderSettings() FinderSettingsResolver
	Host() HostResolver
	HostAllocatorSettings() HostAllocatorSettingsResolver
	Image() ImageResolver
	IssueLink() IssueLinkResolver
	LogkeeperBuild() LogkeeperBuildResolver
	Mutation() MutationResolver
	Patch() PatchResolver
	Permissions() PermissionsResolver
	PlannerSettings() PlannerSettingsResolver
	Pod() PodResolver
	PodEventLogData() PodEventLogDataResolver
	Project() ProjectResolver
	ProjectSettings() ProjectSettingsResolver
	ProjectVars() ProjectVarsResolver
	Query() QueryResolver
	RepoSettings() RepoSettingsResolver
	SleepSchedule() SleepScheduleResolver
	SpruceConfig() SpruceConfigResolver
	SubscriberWrapper() SubscriberWrapperResolver
	Task() TaskResolver
	TaskContainerCreationOpts() TaskContainerCreationOptsResolver
	TaskLogs() TaskLogsResolver
	TaskQueueItem() TaskQueueItemResolver
	TicketFields() TicketFieldsResolver
	User() UserResolver
	Version() VersionResolver
	Volume() VolumeResolver
	BootstrapSettingsInput() BootstrapSettingsInputResolver
	DispatcherSettingsInput() DispatcherSettingsInputResolver
	DistroInput() DistroInputResolver
	FinderSettingsInput() FinderSettingsInputResolver
	HostAllocatorSettingsInput() HostAllocatorSettingsInputResolver
	PlannerSettingsInput() PlannerSettingsInputResolver
	ProjectSettingsInput() ProjectSettingsInputResolver
	RepoSettingsInput() RepoSettingsInputResolver
	SleepScheduleInput() SleepScheduleInputResolver
	SubscriberInput() SubscriberInputResolver
}

type DirectiveRoot struct {
	RedactSecrets                func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireDistroAccess          func(ctx context.Context, obj any, next graphql.Resolver, access DistroSettingsAccess) (res any, err error)
	RequireHostAccess            func(ctx context.Context, obj any, next graphql.Resolver, access HostAccessLevel) (res any, err error)
	RequirePatchOwner            func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireProjectAccess         func(ctx context.Context, obj any, next graphql.Resolver, permission ProjectPermission, access AccessLevel) (res any, err error)
	RequireProjectAdmin          func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireProjectSettingsAccess func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
}

type ComplexityRoot struct {
	AWSConfig struct {
		MaxVolumeSizePerUser func(childComplexity int) int
		Pod                  func(childComplexity int) int
	}

	AWSPodConfig struct {
		ECS func(childComplexity int) int
	}

	AbortInfo struct {
		BuildVariantDisplayName func(childComplexity int) int
		NewVersion              func(childComplexity int) int
		PrClosed                func(childComplexity int) int
		TaskDisplayName         func(childComplexity int) int
		TaskID                  func(childComplexity int) int
		User                    func(childComplexity int) int
	}

	AdminSettings struct {
		Banner      func(childComplexity int) int
		BannerTheme func(childComplexity int) int
	}

	Annotation struct {
		CreatedIssues     func(childComplexity int) int
		Id                func(childComplexity int) int
		Issues            func(childComplexity int) int
		MetadataLinks     func(childComplexity int) int
		Note              func(childComplexity int) int
		SuspectedIssues   func(childComplexity int) int
		TaskExecution     func(childComplexity int) int
		TaskId            func(childComplexity int) int
		WebhookConfigured func(childComplexity int) int
	}

	BetaFeatures struct {
		SpruceWaterfallEnabled func(childComplexity int) int
	}

	BootstrapSettings struct {
		ClientDir             func(childComplexity int) int
		Communication         func(childComplexity int) int
		Env                   func(childComplexity int) int
		JasperBinaryDir       func(childComplexity int) int
		JasperCredentialsPath func(childComplexity int) int
		Method                func(childComplexity int) int
		PreconditionScripts   func(childComplexity int) int
		ResourceLimits        func(childComplexity int) int
		RootDir               func(childComplexity int) int
		ServiceUser           func(childComplexity int) int
		ShellPath             func(childComplexity int) int
	}

	Build struct {
		ActualMakespan    func(childComplexity int) int
		BuildVariant      func(childComplexity int) int
		Id                func(childComplexity int) int
		PredictedMakespan func(childComplexity int) int
		Status            func(childComplexity int) int
	}

	BuildBaron struct {
		BbTicketCreationDefined func(childComplexity int) int
		BuildBaronConfigured    func(childComplexity int) int
		SearchReturnInfo        func(childComplexity int) int
	}

	BuildBaronSettings struct {
		BFSuggestionFeaturesURL func(childComplexity int) int
		BFSuggestionPassword    func(childComplexity int) int
		BFSuggestionServer      func(childComplexity int) int
		BFSuggestionTimeoutSecs func(childComplexity int) int
		BFSuggestionUsername    func(childComplexity int) int
		TicketCreateIssueType   func(childComplexity int) int
		TicketCreateProject     func(childComplexity int) int
		TicketSearchProjects    func(childComplexity int) int
	}

	BuildVariantTuple struct {
		BuildVariant func(childComplexity int) int
		DisplayName  func(childComplexity int) int
	}

	ChildPatchAlias struct {
		Alias   func(childComplexity int) int
		PatchID func(childComplexity int) int
	}

	ClientBinary struct {
		Arch        func(childComplexity int) int
		DisplayName func(childComplexity int) int
		OS          func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	ClientConfig struct {
		ClientBinaries func(childComplexity int) int
		LatestRevision func(childComplexity int) int
	}

	CloudProviderConfig struct {
		AWS func(childComplexity int) int
	}

	CommitQueueParams struct {
		Enabled     func(childComplexity int) int
		MergeMethod func(childComplexity int) int
		Message     func(childComplexity int) int
	}

	ContainerPool struct {
		Distro        func(childComplexity int) int
		Id            func(childComplexity int) int
		MaxContainers func(childComplexity int) int
		Port          func(childComplexity int) int
	}

	ContainerPoolsConfig struct {
		Pools func(childComplexity int) int
	}

	ContainerResources struct {
		CPU      func(childComplexity int) int
		MemoryMB func(childComplexity int) int
		Name     func(childComplexity int) int
	}

	DeleteDistroPayload struct {
		DeletedDistroID func(childComplexity int) int
	}

	DeleteGithubAppCredentialsPayload struct {
		OldAppID func(childComplexity int) int
	}

	Dependency struct {
		BuildVariant   func(childComplexity int) int
		MetStatus      func(childComplexity int) int
		Name           func(childComplexity int) int
		RequiredStatus func(childComplexity int) int
		TaskID         func(childComplexity int) int
	}

	DispatcherSettings struct {
		Version func(childComplexity int) int
	}

	Distro struct {
		AdminOnly             func(childComplexity int) int
		Aliases               func(childComplexity int) int
		Arch                  func(childComplexity int) int
		AuthorizedKeysFile    func(childComplexity int) int
		BootstrapSettings     func(childComplexity int) int
		ContainerPool         func(childComplexity int) int
		DisableShallowClone   func(childComplexity int) int
		Disabled              func(childComplexity int) int
		DispatcherSettings    func(childComplexity int) int
		ExecUser              func(childComplexity int) int
		Expansions            func(childComplexity int) int
		FinderSettings        func(childComplexity int) int
		HomeVolumeSettings    func(childComplexity int) int
		HostAllocatorSettings func(childComplexity int) int
		IcecreamSettings      func(childComplexity int) int
		ImageID               func(childComplexity int) int
		IsCluster             func(childComplexity int) int
		IsVirtualWorkstation  func(childComplexity int) int
		Mountpoints           func(childComplexity int) int
		Name                  func(childComplexity int) int
		Note                  func(childComplexity int) int
		PlannerSettings       func(childComplexity int) int
		Provider              func(childComplexity int) int
		ProviderSettingsList  func(childComplexity int) int
		SSHOptions            func(childComplexity int) int
		Setup                 func(childComplexity int) int
		SetupAsSudo           func(childComplexity int) int
		SingleTaskDistro      func(childComplexity int) int
		User                  func(childComplexity int) int
		UserSpawnAllowed      func(childComplexity int) int
		ValidProjects         func(childComplexity int) int
		WarningNote           func(childComplexity int) int
		WorkDir               func(childComplexity int) int
	}

	DistroEvent struct {
		After     func(childComplexity int) int
		Before    func(childComplexity int) int
		Data      func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	DistroEventsPayload struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	DistroInfo struct {
		BootstrapMethod      func(childComplexity int) int
		Id                   func(childComplexity int) int
		IsVirtualWorkstation func(childComplexity int) int
		IsWindows            func(childComplexity int) int
		User                 func(childComplexity int) int
		WorkDir              func(childComplexity int) int
	}

	DistroPermissions struct {
		Admin func(childComplexity int) int
		Edit  func(childComplexity int) int
		View  func(childComplexity int) int
	}

	ECSConfig struct {
		MaxCPU      func(childComplexity int) int
		MaxMemoryMB func(childComplexity int) int
	}

	EnvVar struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Expansion struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ExternalLink struct {
		DisplayName func(childComplexity int) int
		Requesters  func(childComplexity int) int
		URLTemplate func(childComplexity int) int
	}

	ExternalLinkForMetadata struct {
		DisplayName func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	File struct {
		Link       func(childComplexity int) int
		Name       func(childComplexity int) int
		URLParsley func(childComplexity int) int
		Visibility func(childComplexity int) int
	}

	FileDiff struct {
		Additions   func(childComplexity int) int
		Deletions   func(childComplexity int) int
		Description func(childComplexity int) int
		DiffLink    func(childComplexity int) int
		FileName    func(childComplexity int) int
	}

	FinderSettings struct {
		Version func(childComplexity int) int
	}

	GeneralSubscription struct {
		ID             func(childComplexity int) int
		OwnerType      func(childComplexity int) int
		RegexSelectors func(childComplexity int) int
		ResourceType   func(childComplexity int) int
		Selectors      func(childComplexity int) int
		Subscriber     func(childComplexity int) int
		Trigger        func(childComplexity int) int
		TriggerData    func(childComplexity int) int
	}

	GeneratedTaskCountResults struct {
		BuildVariantName func(childComplexity int) int
		EstimatedTasks   func(childComplexity int) int
		TaskID           func(childComplexity int) int
		TaskName         func(childComplexity int) int
	}

	GitHubDynamicTokenPermissionGroup struct {
		Name        func(childComplexity int) int
		Permissions func(childComplexity int) int
	}

	GitTag struct {
		Pusher func(childComplexity int) int
		Tag    func(childComplexity int) int
	}

	GithubAppAuth struct {
		AppID      func(childComplexity int) int
		PrivateKey func(childComplexity int) int
	}

	GithubCheckSubscriber struct {
		Owner func(childComplexity int) int
		Ref   func(childComplexity int) int
		Repo  func(childComplexity int) int
	}

	GithubPRSubscriber struct {
		Owner    func(childComplexity int) int
		PRNumber func(childComplexity int) int
		Ref      func(childComplexity int) int
		Repo     func(childComplexity int) int
	}

	GithubProjectConflicts struct {
		CommitCheckIdentifiers func(childComplexity int) int
		CommitQueueIdentifiers func(childComplexity int) int
		PRTestingIdentifiers   func(childComplexity int) int
	}

	GithubUser struct {
		LastKnownAs func(childComplexity int) int
		UID         func(childComplexity int) int
	}

	GroupedBuildVariant struct {
		DisplayName func(childComplexity int) int
		Tasks       func(childComplexity int) int
		Variant     func(childComplexity int) int
	}

	GroupedFiles struct {
		Execution func(childComplexity int) int
		Files     func(childComplexity int) int
		TaskID    func(childComplexity int) int
		TaskName  func(childComplexity int) int
	}

	GroupedProjects struct {
		GroupDisplayName func(childComplexity int) int
		Projects         func(childComplexity int) int
		Repo             func(childComplexity int) int
	}

	GroupedTaskStatusCount struct {
		DisplayName  func(childComplexity int) int
		StatusCounts func(childComplexity int) int
		Variant      func(childComplexity int) int
	}

	HomeVolumeSettings struct {
		FormatCommand func(childComplexity int) int
	}

	Host struct {
		Ami                   func(childComplexity int) int
		AvailabilityZone      func(childComplexity int) int
		DisplayName           func(childComplexity int) int
		Distro                func(childComplexity int) int
		DistroID              func(childComplexity int) int
		Elapsed               func(childComplexity int) int
		EventTypes            func(childComplexity int) int
		Events                func(childComplexity int, opts HostEventsInput) int
		Expiration            func(childComplexity int) int
		HomeVolume            func(childComplexity int) int
		HomeVolumeID          func(childComplexity int) int
		HostURL               func(childComplexity int) int
		Id                    func(childComplexity int) int
		InstanceTags          func(childComplexity int) int
		InstanceType          func(childComplexity int) int
		LastCommunicationTime func(childComplexity int) int
		NoExpiration          func(childComplexity int) int
		PersistentDNSName     func(childComplexity int) int
		Provider              func(childComplexity int) int
		RunningTask           func(childComplexity int) int
		SleepSchedule         func(childComplexity int) int
		StartedBy             func(childComplexity int) int
		Status                func(childComplexity int) int
		Tag                   func(childComplexity int) int
		TotalIdleTime         func(childComplexity int) int
		Uptime                func(childComplexity int) int
		User                  func(childComplexity int) int
		Volumes               func(childComplexity int) int
	}

	HostAllocatorSettings struct {
		AcceptableHostIdleTime func(childComplexity int) int
		FeedbackRule           func(childComplexity int) int
		FutureHostFraction     func(childComplexity int) int
		HostsOverallocatedRule func(childComplexity int) int
		MaximumHosts           func(childComplexity int) int
		MinimumHosts           func(childComplexity int) int
		RoundingRule           func(childComplexity int) int
		Version                func(childComplexity int) int
	}

	HostEventLogData struct {
		AgentBuild         func(childComplexity int) int
		AgentRevision      func(childComplexity int) int
		Duration           func(childComplexity int) int
		Execution          func(childComplexity int) int
		Hostname           func(childComplexity int) int
		JasperRevision     func(childComplexity int) int
		Logs               func(childComplexity int) int
		MonitorOp          func(childComplexity int) int
		NewStatus          func(childComplexity int) int
		OldStatus          func(childComplexity int) int
		ProvisioningMethod func(childComplexity int) int
		Successful         func(childComplexity int) int
		TaskId             func(childComplexity int) int
		TaskPid            func(childComplexity int) int
		TaskStatus         func(childComplexity int) int
		User               func(childComplexity int) int
	}

	HostEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	HostEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	HostsResponse struct {
		FilteredHostsCount func(childComplexity int) int
		Hosts              func(childComplexity int) int
		TotalHostsCount    func(childComplexity int) int
	}

	IceCreamSettings struct {
		ConfigPath    func(childComplexity int) int
		SchedulerHost func(childComplexity int) int
	}

	Image struct {
		AMI             func(childComplexity int) int
		Distros         func(childComplexity int) int
		Events          func(childComplexity int, limit int, page int) int
		ID              func(childComplexity int) int
		LastDeployed    func(childComplexity int) int
		LatestTask      func(childComplexity int) int
		OperatingSystem func(childComplexity int, opts thirdparty.OSInfoFilterOptions) int
		Packages        func(childComplexity int, opts thirdparty.PackageFilterOptions) int
		Toolchains      func(childComplexity int, opts thirdparty.ToolchainFilterOptions) int
	}

	ImageEvent struct {
		AMIAfter  func(childComplexity int) int
		AMIBefore func(childComplexity int) int
		Entries   func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	ImageEventEntry struct {
		Action func(childComplexity int) int
		After  func(childComplexity int) int
		Before func(childComplexity int) int
		Name   func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	ImageEventsPayload struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	ImageOperatingSystemPayload struct {
		Data          func(childComplexity int) int
		FilteredCount func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	ImagePackagesPayload struct {
		Data          func(childComplexity int) int
		FilteredCount func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	ImageToolchainsPayload struct {
		Data          func(childComplexity int) int
		FilteredCount func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	InstanceTag struct {
		CanBeModified func(childComplexity int) int
		Key           func(childComplexity int) int
		Value         func(childComplexity int) int
	}

	IssueLink struct {
		ConfidenceScore func(childComplexity int) int
		IssueKey        func(childComplexity int) int
		JiraTicket      func(childComplexity int) int
		Source          func(childComplexity int) int
		URL             func(childComplexity int) int
	}

	JiraConfig struct {
		Email func(childComplexity int) int
		Host  func(childComplexity int) int
	}

	JiraIssueSubscriber struct {
		IssueType func(childComplexity int) int
		Project   func(childComplexity int) int
	}

	JiraStatus struct {
		Id   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	JiraTicket struct {
		Fields func(childComplexity int) int
		Key    func(childComplexity int) int
	}

	LogMessage struct {
		Message   func(childComplexity int) int
		Severity  func(childComplexity int) int
		Timestamp func(childComplexity int) int
		Type      func(childComplexity int) int
		Version   func(childComplexity int) int
	}

	LogkeeperBuild struct {
		BuildNum      func(childComplexity int) int
		Builder       func(childComplexity int) int
		ID            func(childComplexity int) int
		Task          func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
		Tests         func(childComplexity int) int
	}

	LogkeeperTest struct {
		BuildID       func(childComplexity int) int
		Command       func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Phase         func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
	}

	MainlineCommitVersion struct {
		RolledUpVersions func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	MainlineCommits struct {
		NextPageOrderNumber func(childComplexity int) int
		PrevPageOrderNumber func(childComplexity int) int
		Versions            func(childComplexity int) int
	}

	Manifest struct {
		Branch          func(childComplexity int) int
		ID              func(childComplexity int) int
		IsBase          func(childComplexity int) int
		ModuleOverrides func(childComplexity int) int
		Modules         func(childComplexity int) int
		Project         func(childComplexity int) int
		Revision        func(childComplexity int) int
	}

	MetadataLink struct {
		Source func(childComplexity int) int
		Text   func(childComplexity int) int
		URL    func(childComplexity int) int
	}

	ModuleCodeChange struct {
		BranchName func(childComplexity int) int
		FileDiffs  func(childComplexity int) int
		HTMLLink   func(childComplexity int) int
		RawLink    func(childComplexity int) int
	}

	Mutation struct {
		AbortTask                     func(childComplexity int, taskID string) int
		AddAnnotationIssue            func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		AddFavoriteProject            func(childComplexity int, opts AddFavoriteProjectInput) int
		AttachProjectToNewRepo        func(childComplexity int, project MoveProjectInput) int
		AttachProjectToRepo           func(childComplexity int, projectID string) int
		AttachVolumeToHost            func(childComplexity int, volumeAndHost VolumeHost) int
		BbCreateTicket                func(childComplexity int, taskID string, execution *int) int
		ClearMySubscriptions          func(childComplexity int) int
		CopyDistro                    func(childComplexity int, opts model.CopyDistroOpts) int
		CopyProject                   func(childComplexity int, project model.CopyProjectOpts, requestS3Creds *bool) int
		CreateDistro                  func(childComplexity int, opts CreateDistroInput) int
		CreateProject                 func(childComplexity int, project model.APIProjectRef, requestS3Creds *bool) int
		CreatePublicKey               func(childComplexity int, publicKeyInput PublicKeyInput) int
		DeactivateStepbackTask        func(childComplexity int, opts DeactivateStepbackTaskInput) int
		DefaultSectionToRepo          func(childComplexity int, opts DefaultSectionToRepoInput) int
		DeleteDistro                  func(childComplexity int, opts DeleteDistroInput) int
		DeleteGithubAppCredentials    func(childComplexity int, opts DeleteGithubAppCredentialsInput) int
		DeleteProject                 func(childComplexity int, projectID string) int
		DeleteSubscriptions           func(childComplexity int, subscriptionIds []string) int
		DetachProjectFromRepo         func(childComplexity int, projectID string) int
		DetachVolumeFromHost          func(childComplexity int, volumeID string) int
		EditAnnotationNote            func(childComplexity int, taskID string, execution int, originalMessage string, newMessage string) int
		EditSpawnHost                 func(childComplexity int, spawnHost *EditSpawnHostInput) int
		ForceRepotrackerRun           func(childComplexity int, projectID string) int
		MigrateVolume                 func(childComplexity int, volumeID string, spawnHostInput *SpawnHostInput) int
		MoveAnnotationIssue           func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		OverrideTaskDependencies      func(childComplexity int, taskID string) int
		PromoteVarsToRepo             func(childComplexity int, opts PromoteVarsToRepoInput) int
		RemoveAnnotationIssue         func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		RemoveFavoriteProject         func(childComplexity int, opts RemoveFavoriteProjectInput) int
		RemovePublicKey               func(childComplexity int, keyName string) int
		RemoveVolume                  func(childComplexity int, volumeID string) int
		ReprovisionToNew              func(childComplexity int, hostIds []string) int
		RestartJasper                 func(childComplexity int, hostIds []string) int
		RestartTask                   func(childComplexity int, taskID string, failedOnly bool) int
		RestartVersions               func(childComplexity int, versionID string, abort bool, versionsToRestart []*model1.VersionToRestart) int
		SaveDistro                    func(childComplexity int, opts SaveDistroInput) int
		SaveProjectSettingsForSection func(childComplexity int, projectSettings *model.APIProjectSettings, section ProjectSettingsSection) int
		SaveRepoSettingsForSection    func(childComplexity int, repoSettings *model.APIProjectSettings, section ProjectSettingsSection) int
		SaveSubscription              func(childComplexity int, subscription model.APISubscription) int
		SchedulePatch                 func(childComplexity int, patchID string, configure PatchConfigure) int
		ScheduleTasks                 func(childComplexity int, versionID string, taskIds []string) int
		ScheduleUndispatchedBaseTasks func(childComplexity int, versionID string) int
		SetAnnotationMetadataLinks    func(childComplexity int, taskID string, execution int, metadataLinks []*model.APIMetadataLink) int
		SetLastRevision               func(childComplexity int, opts SetLastRevisionInput) int
		SetPatchVisibility            func(childComplexity int, patchIds []string, hidden bool) int
		SetTaskPriority               func(childComplexity int, taskID string, priority int) int
		SetVersionPriority            func(childComplexity int, versionID string, priority int) int
		SpawnHost                     func(childComplexity int, spawnHostInput *SpawnHostInput) int
		SpawnVolume                   func(childComplexity int, spawnVolumeInput SpawnVolumeInput) int
		UnscheduleTask                func(childComplexity int, taskID string) int
		UnscheduleVersionTasks        func(childComplexity int, versionID string, abort bool) int
		UpdateBetaFeatures            func(childComplexity int, opts UpdateBetaFeaturesInput) int
		UpdateHostStatus              func(childComplexity int, hostIds []string, status string, notes *string) int
		UpdateParsleySettings         func(childComplexity int, opts UpdateParsleySettingsInput) int
		UpdatePublicKey               func(childComplexity int, targetKeyName string, updateInfo PublicKeyInput) int
		UpdateSpawnHostStatus         func(childComplexity int, updateSpawnHostStatusInput UpdateSpawnHostStatusInput) int
		UpdateUserSettings            func(childComplexity int, userSettings *model.APIUserSettings) int
		UpdateVolume                  func(childComplexity int, updateVolumeInput UpdateVolumeInput) int
	}

	NewDistroPayload struct {
		NewDistroID func(childComplexity int) int
	}

	Note struct {
		Message func(childComplexity int) int
		Source  func(childComplexity int) int
	}

	Notifications struct {
		BuildBreak            func(childComplexity int) int
		BuildBreakID          func(childComplexity int) int
		PatchFinish           func(childComplexity int) int
		PatchFinishID         func(childComplexity int) int
		PatchFirstFailure     func(childComplexity int) int
		PatchFirstFailureID   func(childComplexity int) int
		SpawnHostExpiration   func(childComplexity int) int
		SpawnHostExpirationID func(childComplexity int) int
		SpawnHostOutcome      func(childComplexity int) int
		SpawnHostOutcomeID    func(childComplexity int) int
	}

	OSInfo struct {
		Name    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	OomTrackerInfo struct {
		Detected func(childComplexity int) int
		Pids     func(childComplexity int) int
	}

	Package struct {
		Manager func(childComplexity int) int
		Name    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	Parameter struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ParsleyFilter struct {
		CaseSensitive func(childComplexity int) int
		ExactMatch    func(childComplexity int) int
		Expression    func(childComplexity int) int
	}

	ParsleySettings struct {
		JumpToFailingLineEnabled func(childComplexity int) int
		SectionsEnabled          func(childComplexity int) int
	}

	Patch struct {
		Activated           func(childComplexity int) int
		Alias               func(childComplexity int) int
		Author              func(childComplexity int) int
		AuthorDisplayName   func(childComplexity int) int
		BaseTaskStatuses    func(childComplexity int) int
		Builds              func(childComplexity int) int
		ChildPatchAliases   func(childComplexity int) int
		ChildPatches        func(childComplexity int) int
		CreateTime          func(childComplexity int) int
		Description         func(childComplexity int) int
		Duration            func(childComplexity int) int
		GeneratedTaskCounts func(childComplexity int) int
		Githash             func(childComplexity int) int
		Hidden              func(childComplexity int) int
		Id                  func(childComplexity int) int
		ModuleCodeChanges   func(childComplexity int) int
		Parameters          func(childComplexity int) int
		PatchNumber         func(childComplexity int) int
		PatchTriggerAliases func(childComplexity int) int
		Project             func(childComplexity int) int
		ProjectId           func(childComplexity int) int
		ProjectIdentifier   func(childComplexity int) int
		ProjectMetadata     func(childComplexity int) int
		Status              func(childComplexity int) int
		TaskCount           func(childComplexity int) int
		TaskStatuses        func(childComplexity int) int
		Tasks               func(childComplexity int) int
		Time                func(childComplexity int) int
		Variants            func(childComplexity int) int
		VariantsTasks       func(childComplexity int) int
		VersionFull         func(childComplexity int) int
	}

	PatchDuration struct {
		Makespan  func(childComplexity int) int
		Time      func(childComplexity int) int
		TimeTaken func(childComplexity int) int
	}

	PatchProject struct {
		Variants func(childComplexity int) int
	}

	PatchTime struct {
		Finished    func(childComplexity int) int
		Started     func(childComplexity int) int
		SubmittedAt func(childComplexity int) int
	}

	PatchTriggerAlias struct {
		Alias                  func(childComplexity int) int
		ChildProjectId         func(childComplexity int) int
		ChildProjectIdentifier func(childComplexity int) int
		DownstreamRevision     func(childComplexity int) int
		ParentAsModule         func(childComplexity int) int
		Status                 func(childComplexity int) int
		TaskSpecifiers         func(childComplexity int) int
		VariantsTasks          func(childComplexity int) int
	}

	Patches struct {
		FilteredPatchCount func(childComplexity int) int
		Patches            func(childComplexity int) int
	}

	PeriodicBuild struct {
		Alias         func(childComplexity int) int
		ConfigFile    func(childComplexity int) int
		Cron          func(childComplexity int) int
		ID            func(childComplexity int) int
		IntervalHours func(childComplexity int) int
		Message       func(childComplexity int) int
		NextRunTime   func(childComplexity int) int
	}

	Permissions struct {
		CanCreateDistro      func(childComplexity int) int
		CanCreateProject     func(childComplexity int) int
		CanEditAdminSettings func(childComplexity int) int
		DistroPermissions    func(childComplexity int, options DistroPermissionsOptions) int
		ProjectPermissions   func(childComplexity int, options ProjectPermissionsOptions) int
		RepoPermissions      func(childComplexity int, options RepoPermissionsOptions) int
		UserID               func(childComplexity int) int
	}

	PlannerSettings struct {
		CommitQueueFactor         func(childComplexity int) int
		ExpectedRuntimeFactor     func(childComplexity int) int
		GenerateTaskFactor        func(childComplexity int) int
		GroupVersions             func(childComplexity int) int
		MainlineTimeInQueueFactor func(childComplexity int) int
		NumDependentsFactor       func(childComplexity int) int
		PatchFactor               func(childComplexity int) int
		PatchTimeInQueueFactor    func(childComplexity int) int
		TargetTime                func(childComplexity int) int
		Version                   func(childComplexity int) int
	}

	Pod struct {
		Events                    func(childComplexity int, limit *int, page *int) int
		ID                        func(childComplexity int) int
		Status                    func(childComplexity int) int
		Task                      func(childComplexity int) int
		TaskContainerCreationOpts func(childComplexity int) int
		Type                      func(childComplexity int) int
	}

	PodEventLogData struct {
		NewStatus     func(childComplexity int) int
		OldStatus     func(childComplexity int) int
		Reason        func(childComplexity int) int
		Task          func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
		TaskStatus    func(childComplexity int) int
	}

	PodEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	PodEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	PreconditionScript struct {
		Path   func(childComplexity int) int
		Script func(childComplexity int) int
	}

	Project struct {
		Admins                             func(childComplexity int) int
		Banner                             func(childComplexity int) int
		BatchTime                          func(childComplexity int) int
		Branch                             func(childComplexity int) int
		BuildBaronSettings                 func(childComplexity int) int
		CommitQueue                        func(childComplexity int) int
		ContainerSizeDefinitions           func(childComplexity int) int
		DeactivatePrevious                 func(childComplexity int) int
		DisabledStatsCache                 func(childComplexity int) int
		DispatchingDisabled                func(childComplexity int) int
		DisplayName                        func(childComplexity int) int
		Enabled                            func(childComplexity int) int
		ExternalLinks                      func(childComplexity int) int
		GitHubDynamicTokenPermissionGroups func(childComplexity int) int
		GitHubPermissionGroupByRequester   func(childComplexity int) int
		GitTagAuthorizedTeams              func(childComplexity int) int
		GitTagAuthorizedUsers              func(childComplexity int) int
		GitTagVersionsEnabled              func(childComplexity int) int
		GithubChecksEnabled                func(childComplexity int) int
		GithubTriggerAliases               func(childComplexity int) int
		Hidden                             func(childComplexity int) int
		Id                                 func(childComplexity int) int
		Identifier                         func(childComplexity int) int
		IsFavorite                         func(childComplexity int) int
		ManualPRTestingEnabled             func(childComplexity int) int
		NotifyOnBuildFailure               func(childComplexity int) int
		OldestAllowedMergeBase             func(childComplexity int) int
		Owner                              func(childComplexity int) int
		PRTestingEnabled                   func(childComplexity int) int
		ParsleyFilters                     func(childComplexity int) int
		PatchTriggerAliases                func(childComplexity int) int
		Patches                            func(childComplexity int, patchesInput PatchesInput) int
		PatchingDisabled                   func(childComplexity int) int
		PerfEnabled                        func(childComplexity int) int
		PeriodicBuilds                     func(childComplexity int) int
		ProjectHealthView                  func(childComplexity int) int
		RemotePath                         func(childComplexity int) int
		Repo                               func(childComplexity int) int
		RepoRefId                          func(childComplexity int) int
		RepotrackerDisabled                func(childComplexity int) int
		RepotrackerError                   func(childComplexity int) int
		Restricted                         func(childComplexity int) int
		SpawnHostScriptPath                func(childComplexity int) int
		StepbackBisect                     func(childComplexity int) int
		StepbackDisabled                   func(childComplexity int) int
		TaskAnnotationSettings             func(childComplexity int) int
		TracksPushEvents                   func(childComplexity int) int
		Triggers                           func(childComplexity int) int
		VersionControlEnabled              func(childComplexity int) int
		WorkstationConfig                  func(childComplexity int) int
	}

	ProjectAlias struct {
		Alias       func(childComplexity int) int
		Description func(childComplexity int) int
		GitTag      func(childComplexity int) int
		ID          func(childComplexity int) int
		Parameters  func(childComplexity int) int
		RemotePath  func(childComplexity int) int
		Task        func(childComplexity int) int
		TaskTags    func(childComplexity int) int
		Variant     func(childComplexity int) int
		VariantTags func(childComplexity int) int
	}

	ProjectBanner struct {
		Text  func(childComplexity int) int
		Theme func(childComplexity int) int
	}

	ProjectBuildVariant struct {
		DisplayName func(childComplexity int) int
		Name        func(childComplexity int) int
		Tasks       func(childComplexity int) int
	}

	ProjectEventLogEntry struct {
		After     func(childComplexity int) int
		Before    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	ProjectEventSettings struct {
		Aliases               func(childComplexity int) int
		GithubAppAuth         func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	ProjectEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	ProjectPermissions struct {
		Edit func(childComplexity int) int
		View func(childComplexity int) int
	}

	ProjectSettings struct {
		Aliases               func(childComplexity int) int
		GithubAppAuth         func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	ProjectTasksPair struct {
		AllowedBVs   func(childComplexity int) int
		AllowedTasks func(childComplexity int) int
		ProjectID    func(childComplexity int) int
	}

	ProjectVars struct {
		AdminOnlyVars func(childComplexity int) int
		PrivateVars   func(childComplexity int) int
		Vars          func(childComplexity int) int
	}

	PublicKey struct {
		Key  func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Query struct {
		AWSRegions               func(childComplexity int) int
		BbGetCreatedTickets      func(childComplexity int, taskID string) int
		BuildBaron               func(childComplexity int, taskID string, execution int) int
		BuildVariantsForTaskName func(childComplexity int, projectIdentifier string, taskName string) int
		ClientConfig             func(childComplexity int) int
		Distro                   func(childComplexity int, distroID string) int
		DistroEvents             func(childComplexity int, opts DistroEventsInput) int
		DistroTaskQueue          func(childComplexity int, distroID string) int
		Distros                  func(childComplexity int, onlySpawnable bool) int
		GithubProjectConflicts   func(childComplexity int, projectID string) int
		HasVersion               func(childComplexity int, patchID string) int
		Host                     func(childComplexity int, hostID string) int
		HostEvents               func(childComplexity int, hostID string, hostTag *string, limit *int, page *int) int
		Hosts                    func(childComplexity int, hostID *string, distroID *string, currentTaskID *string, statuses []string, startedBy *string, sortBy *HostSortBy, sortDir *SortDirection, page *int, limit *int) int
		Image                    func(childComplexity int, imageID string) int
		Images                   func(childComplexity int) int
		InstanceTypes            func(childComplexity int) int
		IsRepo                   func(childComplexity int, projectOrRepoID string) int
		LogkeeperBuildMetadata   func(childComplexity int, buildID string) int
		MainlineCommits          func(childComplexity int, options MainlineCommitsOptions, buildVariantOptions *BuildVariantOptions) int
		MyHosts                  func(childComplexity int) int
		MyPublicKeys             func(childComplexity int) int
		MyVolumes                func(childComplexity int) int
		Patch                    func(childComplexity int, patchID string) int
		Pod                      func(childComplexity int, podID string) int
		Project                  func(childComplexity int, projectIdentifier string) int
		ProjectEvents            func(childComplexity int, projectIdentifier string, limit *int, before *time.Time) int
		ProjectSettings          func(childComplexity int, projectIdentifier string) int
		Projects                 func(childComplexity int) int
		RepoEvents               func(childComplexity int, repoID string, limit *int, before *time.Time) int
		RepoSettings             func(childComplexity int, repoID string) int
		SpruceConfig             func(childComplexity int) int
		SubnetAvailabilityZones  func(childComplexity int) int
		Task                     func(childComplexity int, taskID string, execution *int) int
		TaskAllExecutions        func(childComplexity int, taskID string) int
		TaskHistory              func(childComplexity int, options TaskHistoryOpts) int
		TaskNamesForBuildVariant func(childComplexity int, projectIdentifier string, buildVariant string) int
		TaskQueueDistros         func(childComplexity int) int
		TaskTestSample           func(childComplexity int, versionID string, taskIds []string, filters []*TestFilter) int
		User                     func(childComplexity int, userID *string) int
		UserConfig               func(childComplexity int) int
		Version                  func(childComplexity int, versionID string) int
		ViewableProjectRefs      func(childComplexity int) int
		Waterfall                func(childComplexity int, options WaterfallOptions) int
	}

	RepoCommitQueueParams struct {
		Enabled     func(childComplexity int) int
		MergeMethod func(childComplexity int) int
		Message     func(childComplexity int) int
	}

	RepoPermissions struct {
		Edit func(childComplexity int) int
		View func(childComplexity int) int
	}

	RepoRef struct {
		Admins                             func(childComplexity int) int
		BatchTime                          func(childComplexity int) int
		BuildBaronSettings                 func(childComplexity int) int
		CommitQueue                        func(childComplexity int) int
		ContainerSizeDefinitions           func(childComplexity int) int
		DeactivatePrevious                 func(childComplexity int) int
		DisabledStatsCache                 func(childComplexity int) int
		DispatchingDisabled                func(childComplexity int) int
		DisplayName                        func(childComplexity int) int
		Enabled                            func(childComplexity int) int
		ExternalLinks                      func(childComplexity int) int
		GitHubDynamicTokenPermissionGroups func(childComplexity int) int
		GitHubPermissionGroupByRequester   func(childComplexity int) int
		GitTagAuthorizedTeams              func(childComplexity int) int
		GitTagAuthorizedUsers              func(childComplexity int) int
		GitTagVersionsEnabled              func(childComplexity int) int
		GithubChecksEnabled                func(childComplexity int) int
		GithubTriggerAliases               func(childComplexity int) int
		Id                                 func(childComplexity int) int
		ManualPRTestingEnabled             func(childComplexity int) int
		NotifyOnBuildFailure               func(childComplexity int) int
		OldestAllowedMergeBase             func(childComplexity int) int
		Owner                              func(childComplexity int) int
		PRTestingEnabled                   func(childComplexity int) int
		ParsleyFilters                     func(childComplexity int) int
		PatchTriggerAliases                func(childComplexity int) int
		PatchingDisabled                   func(childComplexity int) int
		PerfEnabled                        func(childComplexity int) int
		PeriodicBuilds                     func(childComplexity int) int
		RemotePath                         func(childComplexity int) int
		Repo                               func(childComplexity int) int
		RepotrackerDisabled                func(childComplexity int) int
		Restricted                         func(childComplexity int) int
		SpawnHostScriptPath                func(childComplexity int) int
		StepbackBisect                     func(childComplexity int) int
		StepbackDisabled                   func(childComplexity int) int
		TaskAnnotationSettings             func(childComplexity int) int
		TracksPushEvents                   func(childComplexity int) int
		Triggers                           func(childComplexity int) int
		VersionControlEnabled              func(childComplexity int) int
		WorkstationConfig                  func(childComplexity int) int
	}

	RepoSettings struct {
		Aliases               func(childComplexity int) int
		GithubAppAuth         func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	RepoWorkstationConfig struct {
		GitClone      func(childComplexity int) int
		SetupCommands func(childComplexity int) int
	}

	RepotrackerError struct {
		Exists            func(childComplexity int) int
		InvalidRevision   func(childComplexity int) int
		MergeBaseRevision func(childComplexity int) int
	}

	ResourceLimits struct {
		LockedMemoryKB  func(childComplexity int) int
		NumFiles        func(childComplexity int) int
		NumProcesses    func(childComplexity int) int
		NumTasks        func(childComplexity int) int
		VirtualMemoryKB func(childComplexity int) int
	}

	SaveDistroPayload struct {
		Distro    func(childComplexity int) int
		HostCount func(childComplexity int) int
	}

	SearchReturnInfo struct {
		FeaturesURL func(childComplexity int) int
		Issues      func(childComplexity int) int
		Search      func(childComplexity int) int
		Source      func(childComplexity int) int
	}

	Selector struct {
		Data func(childComplexity int) int
		Type func(childComplexity int) int
	}

	SetLastRevisionPayload struct {
		MergeBaseRevision func(childComplexity int) int
	}

	SingleTaskDistroConfig struct {
		ProjectTasksPairs func(childComplexity int) int
	}

	SlackConfig struct {
		Name func(childComplexity int) int
	}

	SleepSchedule struct {
		DailyStartTime         func(childComplexity int) int
		DailyStopTime          func(childComplexity int) int
		NextStartTime          func(childComplexity int) int
		NextStopTime           func(childComplexity int) int
		PermanentlyExempt      func(childComplexity int) int
		ShouldKeepOff          func(childComplexity int) int
		TemporarilyExemptUntil func(childComplexity int) int
		TimeZone               func(childComplexity int) int
		WholeWeekdaysOff       func(childComplexity int) int
	}

	Source struct {
		Author    func(childComplexity int) int
		Requester func(childComplexity int) int
		Time      func(childComplexity int) int
	}

	SpawnHostConfig struct {
		SpawnHostsPerUser         func(childComplexity int) int
		UnexpirableHostsPerUser   func(childComplexity int) int
		UnexpirableVolumesPerUser func(childComplexity int) int
	}

	SpruceConfig struct {
		Banner           func(childComplexity int) int
		BannerTheme      func(childComplexity int) int
		ContainerPools   func(childComplexity int) int
		GithubOrgs       func(childComplexity int) int
		Jira             func(childComplexity int) int
		Providers        func(childComplexity int) int
		SecretFields     func(childComplexity int) int
		SingleTaskDistro func(childComplexity int) int
		Slack            func(childComplexity int) int
		Spawnhost        func(childComplexity int) int
		Ui               func(childComplexity int) int
	}

	StatusCount struct {
		Count  func(childComplexity int) int
		Status func(childComplexity int) int
	}

	StepbackInfo struct {
		LastFailingStepbackTaskId func(childComplexity int) int
		LastPassingStepbackTaskId func(childComplexity int) int
		NextStepbackTaskId        func(childComplexity int) int
		PreviousStepbackTaskId    func(childComplexity int) int
	}

	Subscriber struct {
		EmailSubscriber       func(childComplexity int) int
		GithubCheckSubscriber func(childComplexity int) int
		GithubPRSubscriber    func(childComplexity int) int
		JiraCommentSubscriber func(childComplexity int) int
		JiraIssueSubscriber   func(childComplexity int) int
		SlackSubscriber       func(childComplexity int) int
		WebhookSubscriber     func(childComplexity int) int
	}

	SubscriberWrapper struct {
		Subscriber func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	Task struct {
		AbortInfo               func(childComplexity int) int
		Aborted                 func(childComplexity int) int
		Activated               func(childComplexity int) int
		ActivatedBy             func(childComplexity int) int
		ActivatedTime           func(childComplexity int) int
		Ami                     func(childComplexity int) int
		Annotation              func(childComplexity int) int
		BaseStatus              func(childComplexity int) int
		BaseTask                func(childComplexity int) int
		Blocked                 func(childComplexity int) int
		BuildId                 func(childComplexity int) int
		BuildVariant            func(childComplexity int) int
		BuildVariantDisplayName func(childComplexity int) int
		CanAbort                func(childComplexity int) int
		CanDisable              func(childComplexity int) int
		CanModifyAnnotation     func(childComplexity int) int
		CanOverrideDependencies func(childComplexity int) int
		CanRestart              func(childComplexity int) int
		CanSchedule             func(childComplexity int) int
		CanSetPriority          func(childComplexity int) int
		CanUnschedule           func(childComplexity int) int
		ContainerAllocatedTime  func(childComplexity int) int
		CreateTime              func(childComplexity int) int
		DependsOn               func(childComplexity int) int
		Details                 func(childComplexity int) int
		DispatchTime            func(childComplexity int) int
		DisplayName             func(childComplexity int) int
		DisplayOnly             func(childComplexity int) int
		DisplayStatus           func(childComplexity int) int
		DisplayTask             func(childComplexity int) int
		DistroId                func(childComplexity int) int
		EstimatedStart          func(childComplexity int) int
		Execution               func(childComplexity int) int
		ExecutionTasks          func(childComplexity int) int
		ExecutionTasksFull      func(childComplexity int) int
		ExpectedDuration        func(childComplexity int) int
		FailedTestCount         func(childComplexity int) int
		Files                   func(childComplexity int) int
		FinishTime              func(childComplexity int) int
		GenerateTask            func(childComplexity int) int
		GeneratedBy             func(childComplexity int) int
		GeneratedByName         func(childComplexity int) int
		HasCedarResults         func(childComplexity int) int
		HostId                  func(childComplexity int) int
		Id                      func(childComplexity int) int
		ImageID                 func(childComplexity int) int
		IngestTime              func(childComplexity int) int
		IsPerfPluginEnabled     func(childComplexity int) int
		LatestExecution         func(childComplexity int) int
		Logs                    func(childComplexity int) int
		MinQueuePosition        func(childComplexity int) int
		Order                   func(childComplexity int) int
		Patch                   func(childComplexity int) int
		PatchNumber             func(childComplexity int) int
		Pod                     func(childComplexity int) int
		Priority                func(childComplexity int) int
		Project                 func(childComplexity int) int
		ProjectId               func(childComplexity int) int
		ProjectIdentifier       func(childComplexity int) int
		Requester               func(childComplexity int) int
		ResetWhenFinished       func(childComplexity int) int
		Revision                func(childComplexity int) int
		ScheduledTime           func(childComplexity int) int
		SpawnHostLink           func(childComplexity int) int
		StartTime               func(childComplexity int) int
		Status                  func(childComplexity int) int
		StepbackInfo            func(childComplexity int) int
		Tags                    func(childComplexity int) int
		TaskGroup               func(childComplexity int) int
		TaskGroupMaxHosts       func(childComplexity int) int
		TaskLogs                func(childComplexity int) int
		TaskOwnerTeam           func(childComplexity int) int
		Tests                   func(childComplexity int, opts *TestFilterOptions) int
		TimeTaken               func(childComplexity int) int
		TotalTestCount          func(childComplexity int) int
		VersionMetadata         func(childComplexity int) int
	}

	TaskAnnotationSettings struct {
		FileTicketWebhook func(childComplexity int) int
	}

	TaskContainerCreationOpts struct {
		Arch       func(childComplexity int) int
		CPU        func(childComplexity int) int
		Image      func(childComplexity int) int
		MemoryMB   func(childComplexity int) int
		Os         func(childComplexity int) int
		WorkingDir func(childComplexity int) int
	}

	TaskEndDetail struct {
		Description         func(childComplexity int) int
		DiskDevices         func(childComplexity int) int
		FailingCommand      func(childComplexity int) int
		FailureMetadataTags func(childComplexity int) int
		OOMTracker          func(childComplexity int) int
		Status              func(childComplexity int) int
		TimedOut            func(childComplexity int) int
		TimeoutType         func(childComplexity int) int
		TraceID             func(childComplexity int) int
		Type                func(childComplexity int) int
	}

	TaskEventLogData struct {
		BlockedOn func(childComplexity int) int
		HostId    func(childComplexity int) int
		JiraIssue func(childComplexity int) int
		JiraLink  func(childComplexity int) int
		PodId     func(childComplexity int) int
		Priority  func(childComplexity int) int
		Status    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		UserId    func(childComplexity int) int
	}

	TaskEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	TaskFiles struct {
		FileCount    func(childComplexity int) int
		GroupedFiles func(childComplexity int) int
	}

	TaskHistory struct {
		Pagination func(childComplexity int) int
		Tasks      func(childComplexity int) int
	}

	TaskHistoryPagination struct {
		MostRecentTaskOrder func(childComplexity int) int
		OldestTaskOrder     func(childComplexity int) int
	}

	TaskInfo struct {
		Id   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	TaskLogLinks struct {
		AgentLogLink  func(childComplexity int) int
		AllLogLink    func(childComplexity int) int
		EventLogLink  func(childComplexity int) int
		SystemLogLink func(childComplexity int) int
		TaskLogLink   func(childComplexity int) int
	}

	TaskLogs struct {
		AgentLogs  func(childComplexity int) int
		AllLogs    func(childComplexity int) int
		EventLogs  func(childComplexity int) int
		Execution  func(childComplexity int) int
		SystemLogs func(childComplexity int) int
		TaskID     func(childComplexity int) int
		TaskLogs   func(childComplexity int) int
	}

	TaskOwnerTeam struct {
		AssignmentType func(childComplexity int) int
		JiraProject    func(childComplexity int) int
		Messages       func(childComplexity int) int
		TeamName       func(childComplexity int) int
	}

	TaskQueueDistro struct {
		HostCount func(childComplexity int) int
		ID        func(childComplexity int) int
		TaskCount func(childComplexity int) int
	}

	TaskQueueItem struct {
		ActivatedBy       func(childComplexity int) int
		BuildVariant      func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ExpectedDuration  func(childComplexity int) int
		Id                func(childComplexity int) int
		Priority          func(childComplexity int) int
		Project           func(childComplexity int) int
		ProjectIdentifier func(childComplexity int) int
		Requester         func(childComplexity int) int
		Revision          func(childComplexity int) int
		Version           func(childComplexity int) int
	}

	TaskSpecifier struct {
		PatchAlias   func(childComplexity int) int
		TaskRegex    func(childComplexity int) int
		VariantRegex func(childComplexity int) int
	}

	TaskStats struct {
		Counts func(childComplexity int) int
		ETA    func(childComplexity int) int
	}

	TaskTestResult struct {
		FilteredTestCount func(childComplexity int) int
		TestResults       func(childComplexity int) int
		TotalTestCount    func(childComplexity int) int
	}

	TaskTestResultSample struct {
		Execution               func(childComplexity int) int
		MatchingFailedTestNames func(childComplexity int) int
		TaskID                  func(childComplexity int) int
		TotalTestCount          func(childComplexity int) int
	}

	TestLog struct {
		LineNum       func(childComplexity int) int
		RenderingType func(childComplexity int) int
		URL           func(childComplexity int) int
		URLParsley    func(childComplexity int) int
		URLRaw        func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	TestResult struct {
		BaseStatus func(childComplexity int) int
		Duration   func(childComplexity int) int
		EndTime    func(childComplexity int) int
		Execution  func(childComplexity int) int
		ExitCode   func(childComplexity int) int
		GroupID    func(childComplexity int) int
		ID         func(childComplexity int) int
		Logs       func(childComplexity int) int
		StartTime  func(childComplexity int) int
		Status     func(childComplexity int) int
		TaskID     func(childComplexity int) int
		TestFile   func(childComplexity int) int
	}

	TicketFields struct {
		AssignedTeam        func(childComplexity int) int
		AssigneeDisplayName func(childComplexity int) int
		Created             func(childComplexity int) int
		ResolutionName      func(childComplexity int) int
		Status              func(childComplexity int) int
		Summary             func(childComplexity int) int
		Updated             func(childComplexity int) int
	}

	Toolchain struct {
		Name    func(childComplexity int) int
		Path    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	TriggerAlias struct {
		Alias                        func(childComplexity int) int
		BuildVariantRegex            func(childComplexity int) int
		ConfigFile                   func(childComplexity int) int
		DateCutoff                   func(childComplexity int) int
		Level                        func(childComplexity int) int
		Project                      func(childComplexity int) int
		Status                       func(childComplexity int) int
		TaskRegex                    func(childComplexity int) int
		UnscheduleDownstreamVersions func(childComplexity int) int
	}

	UIConfig struct {
		BetaFeatures   func(childComplexity int) int
		DefaultProject func(childComplexity int) int
		UserVoice      func(childComplexity int) int
	}

	UpdateBetaFeaturesPayload struct {
		BetaFeatures func(childComplexity int) int
	}

	UpdateParsleySettingsPayload struct {
		ParsleySettings func(childComplexity int) int
	}

	UpstreamProject struct {
		Owner       func(childComplexity int) int
		Project     func(childComplexity int) int
		Repo        func(childComplexity int) int
		ResourceID  func(childComplexity int) int
		Revision    func(childComplexity int) int
		Task        func(childComplexity int) int
		TriggerID   func(childComplexity int) int
		TriggerType func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	UseSpruceOptions struct {
		HasUsedMainlineCommitsBefore func(childComplexity int) int
		HasUsedSpruceBefore          func(childComplexity int) int
		SpruceV1                     func(childComplexity int) int
	}

	User struct {
		BetaFeatures    func(childComplexity int) int
		DisplayName     func(childComplexity int) int
		EmailAddress    func(childComplexity int) int
		ParsleyFilters  func(childComplexity int) int
		ParsleySettings func(childComplexity int) int
		Patches         func(childComplexity int, patchesInput PatchesInput) int
		Permissions     func(childComplexity int) int
		Settings        func(childComplexity int) int
		Subscriptions   func(childComplexity int) int
		UserID          func(childComplexity int) int
	}

	UserConfig struct {
		APIKey        func(childComplexity int) int
		APIServerHost func(childComplexity int) int
		UIServerHost  func(childComplexity int) int
		User          func(childComplexity int) int
	}

	UserSettings struct {
		DateFormat       func(childComplexity int) int
		GithubUser       func(childComplexity int) int
		Notifications    func(childComplexity int) int
		Region           func(childComplexity int) int
		SlackMemberId    func(childComplexity int) int
		SlackUsername    func(childComplexity int) int
		TimeFormat       func(childComplexity int) int
		Timezone         func(childComplexity int) int
		UseSpruceOptions func(childComplexity int) int
	}

	VariantTask struct {
		Name  func(childComplexity int) int
		Tasks func(childComplexity int) int
	}

	Version struct {
		Activated                func(childComplexity int) int
		Author                   func(childComplexity int) int
		AuthorEmail              func(childComplexity int) int
		BaseTaskStatuses         func(childComplexity int) int
		BaseVersion              func(childComplexity int) int
		Branch                   func(childComplexity int) int
		BuildVariantStats        func(childComplexity int, options BuildVariantOptions) int
		BuildVariants            func(childComplexity int, options BuildVariantOptions) int
		ChildVersions            func(childComplexity int) int
		CreateTime               func(childComplexity int) int
		Errors                   func(childComplexity int) int
		ExternalLinksForMetadata func(childComplexity int) int
		FinishTime               func(childComplexity int) int
		GeneratedTaskCounts      func(childComplexity int) int
		GitTags                  func(childComplexity int) int
		Id                       func(childComplexity int) int
		Ignored                  func(childComplexity int) int
		IsPatch                  func(childComplexity int) int
		Manifest                 func(childComplexity int) int
		Message                  func(childComplexity int) int
		Order                    func(childComplexity int) int
		Parameters               func(childComplexity int) int
		Patch                    func(childComplexity int) int
		PreviousVersion          func(childComplexity int) int
		Project                  func(childComplexity int) int
		ProjectIdentifier        func(childComplexity int) int
		ProjectMetadata          func(childComplexity int) int
		Repo                     func(childComplexity int) int
		Requester                func(childComplexity int) int
		Revision                 func(childComplexity int) int
		StartTime                func(childComplexity int) int
		Status                   func(childComplexity int) int
		TaskCount                func(childComplexity int) int
		TaskStatusStats          func(childComplexity int, options BuildVariantOptions) int
		TaskStatuses             func(childComplexity int) int
		Tasks                    func(childComplexity int, options TaskFilterOptions) int
		UpstreamProject          func(childComplexity int) int
		VersionTiming            func(childComplexity int) int
		Warnings                 func(childComplexity int) int
		WaterfallBuilds          func(childComplexity int) int
	}

	VersionTasks struct {
		Count func(childComplexity int) int
		Data  func(childComplexity int) int
	}

	VersionTiming struct {
		Makespan  func(childComplexity int) int
		TimeTaken func(childComplexity int) int
	}

	Volume struct {
		AvailabilityZone func(childComplexity int) int
		CreatedBy        func(childComplexity int) int
		CreationTime     func(childComplexity int) int
		DeviceName       func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		Expiration       func(childComplexity int) int
		HomeVolume       func(childComplexity int) int
		Host             func(childComplexity int) int
		HostID           func(childComplexity int) int
		ID               func(childComplexity int) int
		Migrating        func(childComplexity int) int
		NoExpiration     func(childComplexity int) int
		Size             func(childComplexity int) int
		Type             func(childComplexity int) int
	}

	Waterfall struct {
		FlattenedVersions func(childComplexity int) int
		Pagination        func(childComplexity int) int
	}

	WaterfallBuild struct {
		Activated    func(childComplexity int) int
		BuildVariant func(childComplexity int) int
		DisplayName  func(childComplexity int) int
		Id           func(childComplexity int) int
		Tasks        func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	WaterfallBuildVariant struct {
		Builds      func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Id          func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	WaterfallPagination struct {
		ActiveVersionIds       func(childComplexity int) int
		HasNextPage            func(childComplexity int) int
		HasPrevPage            func(childComplexity int) int
		MostRecentVersionOrder func(childComplexity int) int
		NextPageOrder          func(childComplexity int) int
		PrevPageOrder          func(childComplexity int) int
	}

	WaterfallTask struct {
		DisplayName        func(childComplexity int) int
		DisplayStatusCache func(childComplexity int) int
		Execution          func(childComplexity int) int
		Id                 func(childComplexity int) int
		Status             func(childComplexity int) int
	}

	WaterfallVersion struct {
		InactiveVersions func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	Webhook struct {
		Endpoint func(childComplexity int) int
		Secret   func(childComplexity int) int
	}

	WebhookHeader struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	WebhookSubscriber struct {
		Headers    func(childComplexity int) int
		MinDelayMS func(childComplexity int) int
		Retries    func(childComplexity int) int
		Secret     func(childComplexity int) int
		TimeoutMS  func(childComplexity int) int
		URL        func(childComplexity int) int
	}

	WorkstationConfig struct {
		GitClone      func(childComplexity int) int
		SetupCommands func(childComplexity int) int
	}

	WorkstationSetupCommand struct {
		Command   func(childComplexity int) int
		Directory func(childComplexity int) int
	}
}

type AdminSettingsResolver interface {
	BannerTheme(ctx context.Context, obj *model.APIAdminSettings) (*evergreen.BannerTheme, error)
}
type AnnotationResolver interface {
	WebhookConfigured(ctx context.Context, obj *model.APITaskAnnotation) (bool, error)
}
type BootstrapSettingsResolver interface {
	Communication(ctx context.Context, obj *model.APIBootstrapSettings) (CommunicationMethod, error)

	Method(ctx context.Context, obj *model.APIBootstrapSettings) (BootstrapMethod, error)
}
type ContainerPoolResolver interface {
	Port(ctx context.Context, obj *model.APIContainerPool) (int, error)
}
type DispatcherSettingsResolver interface {
	Version(ctx context.Context, obj *model.APIDispatcherSettings) (DispatcherVersion, error)
}
type DistroResolver interface {
	Arch(ctx context.Context, obj *model.APIDistro) (Arch, error)

	Provider(ctx context.Context, obj *model.APIDistro) (Provider, error)
	ProviderSettingsList(ctx context.Context, obj *model.APIDistro) ([]map[string]any, error)
}
type FinderSettingsResolver interface {
	Version(ctx context.Context, obj *model.APIFinderSettings) (FinderVersion, error)
}
type HostResolver interface {
	Ami(ctx context.Context, obj *model.APIHost) (*string, error)

	DistroID(ctx context.Context, obj *model.APIHost) (*string, error)
	Elapsed(ctx context.Context, obj *model.APIHost) (*time.Time, error)
	Events(ctx context.Context, obj *model.APIHost, opts HostEventsInput) (*HostEvents, error)
	EventTypes(ctx context.Context, obj *model.APIHost) ([]string, error)

	HomeVolume(ctx context.Context, obj *model.APIHost) (*model.APIVolume, error)

	SleepSchedule(ctx context.Context, obj *model.APIHost) (*host.SleepScheduleInfo, error)

	Uptime(ctx context.Context, obj *model.APIHost) (*time.Time, error)

	Volumes(ctx context.Context, obj *model.APIHost) ([]*model.APIVolume, error)
}
type HostAllocatorSettingsResolver interface {
	FeedbackRule(ctx context.Context, obj *model.APIHostAllocatorSettings) (FeedbackRule, error)

	HostsOverallocatedRule(ctx context.Context, obj *model.APIHostAllocatorSettings) (OverallocatedRule, error)

	RoundingRule(ctx context.Context, obj *model.APIHostAllocatorSettings) (RoundingRule, error)
	Version(ctx context.Context, obj *model.APIHostAllocatorSettings) (HostAllocatorVersion, error)
}
type ImageResolver interface {
	Distros(ctx context.Context, obj *model.APIImage) ([]*model.APIDistro, error)
	Events(ctx context.Context, obj *model.APIImage, limit int, page int) (*ImageEventsPayload, error)

	LatestTask(ctx context.Context, obj *model.APIImage) (*model.APITask, error)
	OperatingSystem(ctx context.Context, obj *model.APIImage, opts thirdparty.OSInfoFilterOptions) (*ImageOperatingSystemPayload, error)
	Packages(ctx context.Context, obj *model.APIImage, opts thirdparty.PackageFilterOptions) (*ImagePackagesPayload, error)
	Toolchains(ctx context.Context, obj *model.APIImage, opts thirdparty.ToolchainFilterOptions) (*ImageToolchainsPayload, error)
}
type IssueLinkResolver interface {
	JiraTicket(ctx context.Context, obj *model.APIIssueLink) (*thirdparty.JiraTicket, error)
}
type LogkeeperBuildResolver interface {
	Task(ctx context.Context, obj *plank.Build) (*model.APITask, error)
}
type MutationResolver interface {
	BbCreateTicket(ctx context.Context, taskID string, execution *int) (bool, error)
	AddAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	EditAnnotationNote(ctx context.Context, taskID string, execution int, originalMessage string, newMessage string) (bool, error)
	MoveAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	RemoveAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	SetAnnotationMetadataLinks(ctx context.Context, taskID string, execution int, metadataLinks []*model.APIMetadataLink) (bool, error)
	DeleteDistro(ctx context.Context, opts DeleteDistroInput) (*DeleteDistroPayload, error)
	CopyDistro(ctx context.Context, opts model.CopyDistroOpts) (*NewDistroPayload, error)
	CreateDistro(ctx context.Context, opts CreateDistroInput) (*NewDistroPayload, error)
	SaveDistro(ctx context.Context, opts SaveDistroInput) (*SaveDistroPayload, error)
	ReprovisionToNew(ctx context.Context, hostIds []string) (int, error)
	RestartJasper(ctx context.Context, hostIds []string) (int, error)
	UpdateHostStatus(ctx context.Context, hostIds []string, status string, notes *string) (int, error)
	SetPatchVisibility(ctx context.Context, patchIds []string, hidden bool) ([]*model.APIPatch, error)
	SchedulePatch(ctx context.Context, patchID string, configure PatchConfigure) (*model.APIPatch, error)
	AttachProjectToNewRepo(ctx context.Context, project MoveProjectInput) (*model.APIProjectRef, error)
	AttachProjectToRepo(ctx context.Context, projectID string) (*model.APIProjectRef, error)
	CreateProject(ctx context.Context, project model.APIProjectRef, requestS3Creds *bool) (*model.APIProjectRef, error)
	CopyProject(ctx context.Context, project model.CopyProjectOpts, requestS3Creds *bool) (*model.APIProjectRef, error)
	DeactivateStepbackTask(ctx context.Context, opts DeactivateStepbackTaskInput) (bool, error)
	DefaultSectionToRepo(ctx context.Context, opts DefaultSectionToRepoInput) (*string, error)
	DeleteGithubAppCredentials(ctx context.Context, opts DeleteGithubAppCredentialsInput) (*DeleteGithubAppCredentialsPayload, error)
	DeleteProject(ctx context.Context, projectID string) (bool, error)
	DetachProjectFromRepo(ctx context.Context, projectID string) (*model.APIProjectRef, error)
	ForceRepotrackerRun(ctx context.Context, projectID string) (bool, error)
	PromoteVarsToRepo(ctx context.Context, opts PromoteVarsToRepoInput) (bool, error)
	SaveProjectSettingsForSection(ctx context.Context, projectSettings *model.APIProjectSettings, section ProjectSettingsSection) (*model.APIProjectSettings, error)
	SaveRepoSettingsForSection(ctx context.Context, repoSettings *model.APIProjectSettings, section ProjectSettingsSection) (*model.APIProjectSettings, error)
	SetLastRevision(ctx context.Context, opts SetLastRevisionInput) (*SetLastRevisionPayload, error)
	AttachVolumeToHost(ctx context.Context, volumeAndHost VolumeHost) (bool, error)
	DetachVolumeFromHost(ctx context.Context, volumeID string) (bool, error)
	EditSpawnHost(ctx context.Context, spawnHost *EditSpawnHostInput) (*model.APIHost, error)
	MigrateVolume(ctx context.Context, volumeID string, spawnHostInput *SpawnHostInput) (bool, error)
	SpawnHost(ctx context.Context, spawnHostInput *SpawnHostInput) (*model.APIHost, error)
	SpawnVolume(ctx context.Context, spawnVolumeInput SpawnVolumeInput) (bool, error)
	RemoveVolume(ctx context.Context, volumeID string) (bool, error)
	UpdateSpawnHostStatus(ctx context.Context, updateSpawnHostStatusInput UpdateSpawnHostStatusInput) (*model.APIHost, error)
	UpdateVolume(ctx context.Context, updateVolumeInput UpdateVolumeInput) (bool, error)
	AbortTask(ctx context.Context, taskID string) (*model.APITask, error)
	OverrideTaskDependencies(ctx context.Context, taskID string) (*model.APITask, error)
	RestartTask(ctx context.Context, taskID string, failedOnly bool) (*model.APITask, error)
	ScheduleTasks(ctx context.Context, versionID string, taskIds []string) ([]*model.APITask, error)
	SetTaskPriority(ctx context.Context, taskID string, priority int) (*model.APITask, error)
	UnscheduleTask(ctx context.Context, taskID string) (*model.APITask, error)
	AddFavoriteProject(ctx context.Context, opts AddFavoriteProjectInput) (*model.APIProjectRef, error)
	ClearMySubscriptions(ctx context.Context) (int, error)
	CreatePublicKey(ctx context.Context, publicKeyInput PublicKeyInput) ([]*model.APIPubKey, error)
	DeleteSubscriptions(ctx context.Context, subscriptionIds []string) (int, error)
	RemoveFavoriteProject(ctx context.Context, opts RemoveFavoriteProjectInput) (*model.APIProjectRef, error)
	RemovePublicKey(ctx context.Context, keyName string) ([]*model.APIPubKey, error)
	SaveSubscription(ctx context.Context, subscription model.APISubscription) (bool, error)
	UpdateBetaFeatures(ctx context.Context, opts UpdateBetaFeaturesInput) (*UpdateBetaFeaturesPayload, error)
	UpdateParsleySettings(ctx context.Context, opts UpdateParsleySettingsInput) (*UpdateParsleySettingsPayload, error)
	UpdatePublicKey(ctx context.Context, targetKeyName string, updateInfo PublicKeyInput) ([]*model.APIPubKey, error)
	UpdateUserSettings(ctx context.Context, userSettings *model.APIUserSettings) (bool, error)
	RestartVersions(ctx context.Context, versionID string, abort bool, versionsToRestart []*model1.VersionToRestart) ([]*model.APIVersion, error)
	ScheduleUndispatchedBaseTasks(ctx context.Context, versionID string) ([]*model.APITask, error)
	SetVersionPriority(ctx context.Context, versionID string, priority int) (*string, error)
	UnscheduleVersionTasks(ctx context.Context, versionID string, abort bool) (*string, error)
}
type PatchResolver interface {
	AuthorDisplayName(ctx context.Context, obj *model.APIPatch) (string, error)
	BaseTaskStatuses(ctx context.Context, obj *model.APIPatch) ([]string, error)
	Builds(ctx context.Context, obj *model.APIPatch) ([]*model.APIBuild, error)

	Duration(ctx context.Context, obj *model.APIPatch) (*PatchDuration, error)
	GeneratedTaskCounts(ctx context.Context, obj *model.APIPatch) ([]*GeneratedTaskCountResults, error)

	PatchTriggerAliases(ctx context.Context, obj *model.APIPatch) ([]*model.APIPatchTriggerDefinition, error)
	Project(ctx context.Context, obj *model.APIPatch) (*PatchProject, error)

	ProjectIdentifier(ctx context.Context, obj *model.APIPatch) (string, error)
	ProjectMetadata(ctx context.Context, obj *model.APIPatch) (*model.APIProjectRef, error)

	TaskCount(ctx context.Context, obj *model.APIPatch) (*int, error)

	TaskStatuses(ctx context.Context, obj *model.APIPatch) ([]string, error)
	Time(ctx context.Context, obj *model.APIPatch) (*PatchTime, error)

	VersionFull(ctx context.Context, obj *model.APIPatch) (*model.APIVersion, error)
}
type PermissionsResolver interface {
	CanCreateDistro(ctx context.Context, obj *Permissions) (bool, error)
	CanCreateProject(ctx context.Context, obj *Permissions) (bool, error)
	CanEditAdminSettings(ctx context.Context, obj *Permissions) (bool, error)
	DistroPermissions(ctx context.Context, obj *Permissions, options DistroPermissionsOptions) (*DistroPermissions, error)
	ProjectPermissions(ctx context.Context, obj *Permissions, options ProjectPermissionsOptions) (*ProjectPermissions, error)
	RepoPermissions(ctx context.Context, obj *Permissions, options RepoPermissionsOptions) (*RepoPermissions, error)
}
type PlannerSettingsResolver interface {
	Version(ctx context.Context, obj *model.APIPlannerSettings) (PlannerVersion, error)
}
type PodResolver interface {
	Events(ctx context.Context, obj *model.APIPod, limit *int, page *int) (*PodEvents, error)

	Status(ctx context.Context, obj *model.APIPod) (string, error)
	Task(ctx context.Context, obj *model.APIPod) (*model.APITask, error)

	Type(ctx context.Context, obj *model.APIPod) (string, error)
}
type PodEventLogDataResolver interface {
	Task(ctx context.Context, obj *model.PodAPIEventData) (*model.APITask, error)
}
type ProjectResolver interface {
	IsFavorite(ctx context.Context, obj *model.APIProjectRef) (bool, error)

	Patches(ctx context.Context, obj *model.APIProjectRef, patchesInput PatchesInput) (*Patches, error)
}
type ProjectSettingsResolver interface {
	Aliases(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APIProjectAlias, error)
	GithubAppAuth(ctx context.Context, obj *model.APIProjectSettings) (*model.APIGithubAppAuth, error)
	GithubWebhooksEnabled(ctx context.Context, obj *model.APIProjectSettings) (bool, error)

	Subscriptions(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APISubscription, error)
	Vars(ctx context.Context, obj *model.APIProjectSettings) (*model.APIProjectVars, error)
}
type ProjectVarsResolver interface {
	AdminOnlyVars(ctx context.Context, obj *model.APIProjectVars) ([]string, error)
	PrivateVars(ctx context.Context, obj *model.APIProjectVars) ([]string, error)
}
type QueryResolver interface {
	BbGetCreatedTickets(ctx context.Context, taskID string) ([]*thirdparty.JiraTicket, error)
	BuildBaron(ctx context.Context, taskID string, execution int) (*BuildBaron, error)
	AWSRegions(ctx context.Context) ([]string, error)
	ClientConfig(ctx context.Context) (*model.APIClientConfig, error)
	InstanceTypes(ctx context.Context) ([]string, error)
	SpruceConfig(ctx context.Context) (*model.APIAdminSettings, error)
	SubnetAvailabilityZones(ctx context.Context) ([]string, error)
	Distro(ctx context.Context, distroID string) (*model.APIDistro, error)
	DistroEvents(ctx context.Context, opts DistroEventsInput) (*DistroEventsPayload, error)
	Distros(ctx context.Context, onlySpawnable bool) ([]*model.APIDistro, error)
	DistroTaskQueue(ctx context.Context, distroID string) ([]*model.APITaskQueueItem, error)
	Host(ctx context.Context, hostID string) (*model.APIHost, error)
	HostEvents(ctx context.Context, hostID string, hostTag *string, limit *int, page *int) (*HostEvents, error)
	Hosts(ctx context.Context, hostID *string, distroID *string, currentTaskID *string, statuses []string, startedBy *string, sortBy *HostSortBy, sortDir *SortDirection, page *int, limit *int) (*HostsResponse, error)
	TaskQueueDistros(ctx context.Context) ([]*TaskQueueDistro, error)
	Pod(ctx context.Context, podID string) (*model.APIPod, error)
	Patch(ctx context.Context, patchID string) (*model.APIPatch, error)
	GithubProjectConflicts(ctx context.Context, projectID string) (*model1.GithubProjectConflicts, error)
	Project(ctx context.Context, projectIdentifier string) (*model.APIProjectRef, error)
	Projects(ctx context.Context) ([]*GroupedProjects, error)
	ProjectEvents(ctx context.Context, projectIdentifier string, limit *int, before *time.Time) (*ProjectEvents, error)
	ProjectSettings(ctx context.Context, projectIdentifier string) (*model.APIProjectSettings, error)
	RepoEvents(ctx context.Context, repoID string, limit *int, before *time.Time) (*ProjectEvents, error)
	RepoSettings(ctx context.Context, repoID string) (*model.APIProjectSettings, error)
	ViewableProjectRefs(ctx context.Context) ([]*GroupedProjects, error)
	IsRepo(ctx context.Context, projectOrRepoID string) (bool, error)
	MyHosts(ctx context.Context) ([]*model.APIHost, error)
	MyVolumes(ctx context.Context) ([]*model.APIVolume, error)
	LogkeeperBuildMetadata(ctx context.Context, buildID string) (*plank.Build, error)
	Task(ctx context.Context, taskID string, execution *int) (*model.APITask, error)
	TaskAllExecutions(ctx context.Context, taskID string) ([]*model.APITask, error)
	TaskTestSample(ctx context.Context, versionID string, taskIds []string, filters []*TestFilter) ([]*TaskTestResultSample, error)
	MyPublicKeys(ctx context.Context) ([]*model.APIPubKey, error)
	User(ctx context.Context, userID *string) (*model.APIDBUser, error)
	UserConfig(ctx context.Context) (*UserConfig, error)
	BuildVariantsForTaskName(ctx context.Context, projectIdentifier string, taskName string) ([]*task.BuildVariantTuple, error)
	MainlineCommits(ctx context.Context, options MainlineCommitsOptions, buildVariantOptions *BuildVariantOptions) (*MainlineCommits, error)
	TaskNamesForBuildVariant(ctx context.Context, projectIdentifier string, buildVariant string) ([]string, error)
	Waterfall(ctx context.Context, options WaterfallOptions) (*Waterfall, error)
	TaskHistory(ctx context.Context, options TaskHistoryOpts) (*TaskHistory, error)
	HasVersion(ctx context.Context, patchID string) (bool, error)
	Version(ctx context.Context, versionID string) (*model.APIVersion, error)
	Image(ctx context.Context, imageID string) (*model.APIImage, error)
	Images(ctx context.Context) ([]string, error)
}
type RepoSettingsResolver interface {
	Aliases(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APIProjectAlias, error)
	GithubAppAuth(ctx context.Context, obj *model.APIProjectSettings) (*model.APIGithubAppAuth, error)
	GithubWebhooksEnabled(ctx context.Context, obj *model.APIProjectSettings) (bool, error)

	Subscriptions(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APISubscription, error)
	Vars(ctx context.Context, obj *model.APIProjectSettings) (*model.APIProjectVars, error)
}
type SleepScheduleResolver interface {
	WholeWeekdaysOff(ctx context.Context, obj *host.SleepScheduleInfo) ([]int, error)
}
type SpruceConfigResolver interface {
	SecretFields(ctx context.Context, obj *model.APIAdminSettings) ([]string, error)
}
type SubscriberWrapperResolver interface {
	Subscriber(ctx context.Context, obj *model.APISubscriber) (*Subscriber, error)
}
type TaskResolver interface {
	AbortInfo(ctx context.Context, obj *model.APITask) (*AbortInfo, error)

	Ami(ctx context.Context, obj *model.APITask) (*string, error)
	Annotation(ctx context.Context, obj *model.APITask) (*model.APITaskAnnotation, error)

	BaseStatus(ctx context.Context, obj *model.APITask) (*string, error)
	BaseTask(ctx context.Context, obj *model.APITask) (*model.APITask, error)

	BuildVariantDisplayName(ctx context.Context, obj *model.APITask) (*string, error)
	CanAbort(ctx context.Context, obj *model.APITask) (bool, error)
	CanDisable(ctx context.Context, obj *model.APITask) (bool, error)
	CanModifyAnnotation(ctx context.Context, obj *model.APITask) (bool, error)
	CanOverrideDependencies(ctx context.Context, obj *model.APITask) (bool, error)
	CanRestart(ctx context.Context, obj *model.APITask) (bool, error)
	CanSchedule(ctx context.Context, obj *model.APITask) (bool, error)
	CanSetPriority(ctx context.Context, obj *model.APITask) (bool, error)
	CanUnschedule(ctx context.Context, obj *model.APITask) (bool, error)

	DependsOn(ctx context.Context, obj *model.APITask) ([]*Dependency, error)

	DisplayTask(ctx context.Context, obj *model.APITask) (*model.APITask, error)

	EstimatedStart(ctx context.Context, obj *model.APITask) (*model.APIDuration, error)

	ExecutionTasksFull(ctx context.Context, obj *model.APITask) ([]*model.APITask, error)

	FailedTestCount(ctx context.Context, obj *model.APITask) (int, error)
	Files(ctx context.Context, obj *model.APITask) (*TaskFiles, error)

	GeneratedByName(ctx context.Context, obj *model.APITask) (*string, error)

	ImageID(ctx context.Context, obj *model.APITask) (string, error)

	IsPerfPluginEnabled(ctx context.Context, obj *model.APITask) (bool, error)
	LatestExecution(ctx context.Context, obj *model.APITask) (int, error)

	MinQueuePosition(ctx context.Context, obj *model.APITask) (int, error)

	Patch(ctx context.Context, obj *model.APITask) (*model.APIPatch, error)
	PatchNumber(ctx context.Context, obj *model.APITask) (*int, error)
	Pod(ctx context.Context, obj *model.APITask) (*model.APIPod, error)

	Project(ctx context.Context, obj *model.APITask) (*model.APIProjectRef, error)

	ProjectIdentifier(ctx context.Context, obj *model.APITask) (*string, error)

	SpawnHostLink(ctx context.Context, obj *model.APITask) (*string, error)

	TaskLogs(ctx context.Context, obj *model.APITask) (*TaskLogs, error)
	TaskOwnerTeam(ctx context.Context, obj *model.APITask) (*TaskOwnerTeam, error)
	Tests(ctx context.Context, obj *model.APITask, opts *TestFilterOptions) (*TaskTestResult, error)

	TotalTestCount(ctx context.Context, obj *model.APITask) (int, error)
	VersionMetadata(ctx context.Context, obj *model.APITask) (*model.APIVersion, error)
}
type TaskContainerCreationOptsResolver interface {
	Os(ctx context.Context, obj *model.APIPodTaskContainerCreationOptions) (string, error)
	Arch(ctx context.Context, obj *model.APIPodTaskContainerCreationOptions) (string, error)
}
type TaskLogsResolver interface {
	AgentLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
	AllLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
	EventLogs(ctx context.Context, obj *TaskLogs) ([]*model.TaskAPIEventLogEntry, error)

	SystemLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)

	TaskLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
}
type TaskQueueItemResolver interface {
	Requester(ctx context.Context, obj *model.APITaskQueueItem) (TaskQueueItemType, error)
}
type TicketFieldsResolver interface {
	AssignedTeam(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)
	AssigneeDisplayName(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)

	ResolutionName(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)
}
type UserResolver interface {
	Patches(ctx context.Context, obj *model.APIDBUser, patchesInput PatchesInput) (*Patches, error)
	Permissions(ctx context.Context, obj *model.APIDBUser) (*Permissions, error)

	Subscriptions(ctx context.Context, obj *model.APIDBUser) ([]*model.APISubscription, error)
}
type VersionResolver interface {
	BaseTaskStatuses(ctx context.Context, obj *model.APIVersion) ([]string, error)
	BaseVersion(ctx context.Context, obj *model.APIVersion) (*model.APIVersion, error)

	BuildVariants(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) ([]*GroupedBuildVariant, error)
	BuildVariantStats(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) ([]*task.GroupedTaskStatusCount, error)
	ChildVersions(ctx context.Context, obj *model.APIVersion) ([]*model.APIVersion, error)

	ExternalLinksForMetadata(ctx context.Context, obj *model.APIVersion) ([]*ExternalLinkForMetadata, error)

	GeneratedTaskCounts(ctx context.Context, obj *model.APIVersion) ([]*GeneratedTaskCountResults, error)

	IsPatch(ctx context.Context, obj *model.APIVersion) (bool, error)
	Manifest(ctx context.Context, obj *model.APIVersion) (*Manifest, error)

	Patch(ctx context.Context, obj *model.APIVersion) (*model.APIPatch, error)
	PreviousVersion(ctx context.Context, obj *model.APIVersion) (*model.APIVersion, error)

	ProjectMetadata(ctx context.Context, obj *model.APIVersion) (*model.APIProjectRef, error)

	Status(ctx context.Context, obj *model.APIVersion) (string, error)
	TaskCount(ctx context.Context, obj *model.APIVersion) (*int, error)
	Tasks(ctx context.Context, obj *model.APIVersion, options TaskFilterOptions) (*VersionTasks, error)
	TaskStatuses(ctx context.Context, obj *model.APIVersion) ([]string, error)
	TaskStatusStats(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) (*task.TaskStats, error)
	UpstreamProject(ctx context.Context, obj *model.APIVersion) (*UpstreamProject, error)
	VersionTiming(ctx context.Context, obj *model.APIVersion) (*VersionTiming, error)
	Warnings(ctx context.Context, obj *model.APIVersion) ([]string, error)
	WaterfallBuilds(ctx context.Context, obj *model.APIVersion) ([]*model1.WaterfallBuild, error)
}
type VolumeResolver interface {
	Host(ctx context.Context, obj *model.APIVolume) (*model.APIHost, error)
}

type BootstrapSettingsInputResolver interface {
	Communication(ctx context.Context, obj *model.APIBootstrapSettings, data CommunicationMethod) error

	Method(ctx context.Context, obj *model.APIBootstrapSettings, data BootstrapMethod) error
}
type DispatcherSettingsInputResolver interface {
	Version(ctx context.Context, obj *model.APIDispatcherSettings, data DispatcherVersion) error
}
type DistroInputResolver interface {
	Arch(ctx context.Context, obj *model.APIDistro, data Arch) error

	Provider(ctx context.Context, obj *model.APIDistro, data Provider) error
	ProviderSettingsList(ctx context.Context, obj *model.APIDistro, data []map[string]any) error
}
type FinderSettingsInputResolver interface {
	Version(ctx context.Context, obj *model.APIFinderSettings, data FinderVersion) error
}
type HostAllocatorSettingsInputResolver interface {
	AcceptableHostIdleTime(ctx context.Context, obj *model.APIHostAllocatorSettings, data int) error
	FeedbackRule(ctx context.Context, obj *model.APIHostAllocatorSettings, data FeedbackRule) error

	HostsOverallocatedRule(ctx context.Context, obj *model.APIHostAllocatorSettings, data OverallocatedRule) error

	RoundingRule(ctx context.Context, obj *model.APIHostAllocatorSettings, data RoundingRule) error
	Version(ctx context.Context, obj *model.APIHostAllocatorSettings, data HostAllocatorVersion) error
}
type PlannerSettingsInputResolver interface {
	TargetTime(ctx context.Context, obj *model.APIPlannerSettings, data int) error
	Version(ctx context.Context, obj *model.APIPlannerSettings, data PlannerVersion) error
}
type ProjectSettingsInputResolver interface {
	ProjectID(ctx context.Context, obj *model.APIProjectSettings, data string) error
}
type RepoSettingsInputResolver interface {
	RepoID(ctx context.Context, obj *model.APIProjectSettings, data string) error
}
type SleepScheduleInputResolver interface {
	WholeWeekdaysOff(ctx context.Context, obj *host.SleepScheduleInfo, data []int) error
}
type SubscriberInputResolver interface {
	Target(ctx context.Context, obj *model.APISubscriber, data string) error
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AWSConfig.maxVolumeSizePerUser":
		if e.complexity.AWSConfig.MaxVolumeSizePerUser == nil {
			break
		}

		return e.complexity.AWSConfig.MaxVolumeSizePerUser(childComplexity), true

	case "AWSConfig.pod":
		if e.complexity.AWSConfig.Pod == nil {
			break
		}

		return e.complexity.AWSConfig.Pod(childComplexity), true

	case "AWSPodConfig.ecs":
		if e.complexity.AWSPodConfig.ECS == nil {
			break
		}

		return e.complexity.AWSPodConfig.ECS(childComplexity), true

	case "AbortInfo.buildVariantDisplayName":
		if e.complexity.AbortInfo.BuildVariantDisplayName == nil {
			break
		}

		return e.complexity.AbortInfo.BuildVariantDisplayName(childComplexity), true

	case "AbortInfo.newVersion":
		if e.complexity.AbortInfo.NewVersion == nil {
			break
		}

		return e.complexity.AbortInfo.NewVersion(childComplexity), true

	case "AbortInfo.prClosed":
		if e.complexity.AbortInfo.PrClosed == nil {
			break
		}

		return e.complexity.AbortInfo.PrClosed(childComplexity), true

	case "AbortInfo.taskDisplayName":
		if e.complexity.AbortInfo.TaskDisplayName == nil {
			break
		}

		return e.complexity.AbortInfo.TaskDisplayName(childComplexity), true

	case "AbortInfo.taskID":
		if e.complexity.AbortInfo.TaskID == nil {
			break
		}

		return e.complexity.AbortInfo.TaskID(childComplexity), true

	case "AbortInfo.user":
		if e.complexity.AbortInfo.User == nil {
			break
		}

		return e.complexity.AbortInfo.User(childComplexity), true

	case "AdminSettings.banner":
		if e.complexity.AdminSettings.Banner == nil {
			break
		}

		return e.complexity.AdminSettings.Banner(childComplexity), true

	case "AdminSettings.bannerTheme":
		if e.complexity.AdminSettings.BannerTheme == nil {
			break
		}

		return e.complexity.AdminSettings.BannerTheme(childComplexity), true

	case "Annotation.createdIssues":
		if e.complexity.Annotation.CreatedIssues == nil {
			break
		}

		return e.complexity.Annotation.CreatedIssues(childComplexity), true

	case "Annotation.id":
		if e.complexity.Annotation.Id == nil {
			break
		}

		return e.complexity.Annotation.Id(childComplexity), true

	case "Annotation.issues":
		if e.complexity.Annotation.Issues == nil {
			break
		}

		return e.complexity.Annotation.Issues(childComplexity), true

	case "Annotation.metadataLinks":
		if e.complexity.Annotation.MetadataLinks == nil {
			break
		}

		return e.complexity.Annotation.MetadataLinks(childComplexity), true

	case "Annotation.note":
		if e.complexity.Annotation.Note == nil {
			break
		}

		return e.complexity.Annotation.Note(childComplexity), true

	case "Annotation.suspectedIssues":
		if e.complexity.Annotation.SuspectedIssues == nil {
			break
		}

		return e.complexity.Annotation.SuspectedIssues(childComplexity), true

	case "Annotation.taskExecution":
		if e.complexity.Annotation.TaskExecution == nil {
			break
		}

		return e.complexity.Annotation.TaskExecution(childComplexity), true

	case "Annotation.taskId":
		if e.complexity.Annotation.TaskId == nil {
			break
		}

		return e.complexity.Annotation.TaskId(childComplexity), true

	case "Annotation.webhookConfigured":
		if e.complexity.Annotation.WebhookConfigured == nil {
			break
		}

		return e.complexity.Annotation.WebhookConfigured(childComplexity), true

	case "BetaFeatures.spruceWaterfallEnabled":
		if e.complexity.BetaFeatures.SpruceWaterfallEnabled == nil {
			break
		}

		return e.complexity.BetaFeatures.SpruceWaterfallEnabled(childComplexity), true

	case "BootstrapSettings.clientDir":
		if e.complexity.BootstrapSettings.ClientDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.ClientDir(childComplexity), true

	case "BootstrapSettings.communication":
		if e.complexity.BootstrapSettings.Communication == nil {
			break
		}

		return e.complexity.BootstrapSettings.Communication(childComplexity), true

	case "BootstrapSettings.env":
		if e.complexity.BootstrapSettings.Env == nil {
			break
		}

		return e.complexity.BootstrapSettings.Env(childComplexity), true

	case "BootstrapSettings.jasperBinaryDir":
		if e.complexity.BootstrapSettings.JasperBinaryDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.JasperBinaryDir(childComplexity), true

	case "BootstrapSettings.jasperCredentialsPath":
		if e.complexity.BootstrapSettings.JasperCredentialsPath == nil {
			break
		}

		return e.complexity.BootstrapSettings.JasperCredentialsPath(childComplexity), true

	case "BootstrapSettings.method":
		if e.complexity.BootstrapSettings.Method == nil {
			break
		}

		return e.complexity.BootstrapSettings.Method(childComplexity), true

	case "BootstrapSettings.preconditionScripts":
		if e.complexity.BootstrapSettings.PreconditionScripts == nil {
			break
		}

		return e.complexity.BootstrapSettings.PreconditionScripts(childComplexity), true

	case "BootstrapSettings.resourceLimits":
		if e.complexity.BootstrapSettings.ResourceLimits == nil {
			break
		}

		return e.complexity.BootstrapSettings.ResourceLimits(childComplexity), true

	case "BootstrapSettings.rootDir":
		if e.complexity.BootstrapSettings.RootDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.RootDir(childComplexity), true

	case "BootstrapSettings.serviceUser":
		if e.complexity.BootstrapSettings.ServiceUser == nil {
			break
		}

		return e.complexity.BootstrapSettings.ServiceUser(childComplexity), true

	case "BootstrapSettings.shellPath":
		if e.complexity.BootstrapSettings.ShellPath == nil {
			break
		}

		return e.complexity.BootstrapSettings.ShellPath(childComplexity), true

	case "Build.actualMakespan":
		if e.complexity.Build.ActualMakespan == nil {
			break
		}

		return e.complexity.Build.ActualMakespan(childComplexity), true

	case "Build.buildVariant":
		if e.complexity.Build.BuildVariant == nil {
			break
		}

		return e.complexity.Build.BuildVariant(childComplexity), true

	case "Build.id":
		if e.complexity.Build.Id == nil {
			break
		}

		return e.complexity.Build.Id(childComplexity), true

	case "Build.predictedMakespan":
		if e.complexity.Build.PredictedMakespan == nil {
			break
		}

		return e.complexity.Build.PredictedMakespan(childComplexity), true

	case "Build.status":
		if e.complexity.Build.Status == nil {
			break
		}

		return e.complexity.Build.Status(childComplexity), true

	case "BuildBaron.bbTicketCreationDefined":
		if e.complexity.BuildBaron.BbTicketCreationDefined == nil {
			break
		}

		return e.complexity.BuildBaron.BbTicketCreationDefined(childComplexity), true

	case "BuildBaron.buildBaronConfigured":
		if e.complexity.BuildBaron.BuildBaronConfigured == nil {
			break
		}

		return e.complexity.BuildBaron.BuildBaronConfigured(childComplexity), true

	case "BuildBaron.searchReturnInfo":
		if e.complexity.BuildBaron.SearchReturnInfo == nil {
			break
		}

		return e.complexity.BuildBaron.SearchReturnInfo(childComplexity), true

	case "BuildBaronSettings.bfSuggestionFeaturesURL":
		if e.complexity.BuildBaronSettings.BFSuggestionFeaturesURL == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionFeaturesURL(childComplexity), true

	case "BuildBaronSettings.bfSuggestionPassword":
		if e.complexity.BuildBaronSettings.BFSuggestionPassword == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionPassword(childComplexity), true

	case "BuildBaronSettings.bfSuggestionServer":
		if e.complexity.BuildBaronSettings.BFSuggestionServer == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionServer(childComplexity), true

	case "BuildBaronSettings.bfSuggestionTimeoutSecs":
		if e.complexity.BuildBaronSettings.BFSuggestionTimeoutSecs == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionTimeoutSecs(childComplexity), true

	case "BuildBaronSettings.bfSuggestionUsername":
		if e.complexity.BuildBaronSettings.BFSuggestionUsername == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionUsername(childComplexity), true

	case "BuildBaronSettings.ticketCreateIssueType":
		if e.complexity.BuildBaronSettings.TicketCreateIssueType == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketCreateIssueType(childComplexity), true

	case "BuildBaronSettings.ticketCreateProject":
		if e.complexity.BuildBaronSettings.TicketCreateProject == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketCreateProject(childComplexity), true

	case "BuildBaronSettings.ticketSearchProjects":
		if e.complexity.BuildBaronSettings.TicketSearchProjects == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketSearchProjects(childComplexity), true

	case "BuildVariantTuple.buildVariant":
		if e.complexity.BuildVariantTuple.BuildVariant == nil {
			break
		}

		return e.complexity.BuildVariantTuple.BuildVariant(childComplexity), true

	case "BuildVariantTuple.displayName":
		if e.complexity.BuildVariantTuple.DisplayName == nil {
			break
		}

		return e.complexity.BuildVariantTuple.DisplayName(childComplexity), true

	case "ChildPatchAlias.alias":
		if e.complexity.ChildPatchAlias.Alias == nil {
			break
		}

		return e.complexity.ChildPatchAlias.Alias(childComplexity), true

	case "ChildPatchAlias.patchId":
		if e.complexity.ChildPatchAlias.PatchID == nil {
			break
		}

		return e.complexity.ChildPatchAlias.PatchID(childComplexity), true

	case "ClientBinary.arch":
		if e.complexity.ClientBinary.Arch == nil {
			break
		}

		return e.complexity.ClientBinary.Arch(childComplexity), true

	case "ClientBinary.displayName":
		if e.complexity.ClientBinary.DisplayName == nil {
			break
		}

		return e.complexity.ClientBinary.DisplayName(childComplexity), true

	case "ClientBinary.os":
		if e.complexity.ClientBinary.OS == nil {
			break
		}

		return e.complexity.ClientBinary.OS(childComplexity), true

	case "ClientBinary.url":
		if e.complexity.ClientBinary.URL == nil {
			break
		}

		return e.complexity.ClientBinary.URL(childComplexity), true

	case "ClientConfig.clientBinaries":
		if e.complexity.ClientConfig.ClientBinaries == nil {
			break
		}

		return e.complexity.ClientConfig.ClientBinaries(childComplexity), true

	case "ClientConfig.latestRevision":
		if e.complexity.ClientConfig.LatestRevision == nil {
			break
		}

		return e.complexity.ClientConfig.LatestRevision(childComplexity), true

	case "CloudProviderConfig.aws":
		if e.complexity.CloudProviderConfig.AWS == nil {
			break
		}

		return e.complexity.CloudProviderConfig.AWS(childComplexity), true

	case "CommitQueueParams.enabled":
		if e.complexity.CommitQueueParams.Enabled == nil {
			break
		}

		return e.complexity.CommitQueueParams.Enabled(childComplexity), true

	case "CommitQueueParams.mergeMethod":
		if e.complexity.CommitQueueParams.MergeMethod == nil {
			break
		}

		return e.complexity.CommitQueueParams.MergeMethod(childComplexity), true

	case "CommitQueueParams.message":
		if e.complexity.CommitQueueParams.Message == nil {
			break
		}

		return e.complexity.CommitQueueParams.Message(childComplexity), true

	case "ContainerPool.distro":
		if e.complexity.ContainerPool.Distro == nil {
			break
		}

		return e.complexity.ContainerPool.Distro(childComplexity), true

	case "ContainerPool.id":
		if e.complexity.ContainerPool.Id == nil {
			break
		}

		return e.complexity.ContainerPool.Id(childComplexity), true

	case "ContainerPool.maxContainers":
		if e.complexity.ContainerPool.MaxContainers == nil {
			break
		}

		return e.complexity.ContainerPool.MaxContainers(childComplexity), true

	case "ContainerPool.port":
		if e.complexity.ContainerPool.Port == nil {
			break
		}

		return e.complexity.ContainerPool.Port(childComplexity), true

	case "ContainerPoolsConfig.pools":
		if e.complexity.ContainerPoolsConfig.Pools == nil {
			break
		}

		return e.complexity.ContainerPoolsConfig.Pools(childComplexity), true

	case "ContainerResources.cpu":
		if e.complexity.ContainerResources.CPU == nil {
			break
		}

		return e.complexity.ContainerResources.CPU(childComplexity), true

	case "ContainerResources.memoryMb":
		if e.complexity.ContainerResources.MemoryMB == nil {
			break
		}

		return e.complexity.ContainerResources.MemoryMB(childComplexity), true

	case "ContainerResources.name":
		if e.complexity.ContainerResources.Name == nil {
			break
		}

		return e.complexity.ContainerResources.Name(childComplexity), true

	case "DeleteDistroPayload.deletedDistroId":
		if e.complexity.DeleteDistroPayload.DeletedDistroID == nil {
			break
		}

		return e.complexity.DeleteDistroPayload.DeletedDistroID(childComplexity), true

	case "DeleteGithubAppCredentialsPayload.oldAppId":
		if e.complexity.DeleteGithubAppCredentialsPayload.OldAppID == nil {
			break
		}

		return e.complexity.DeleteGithubAppCredentialsPayload.OldAppID(childComplexity), true

	case "Dependency.buildVariant":
		if e.complexity.Dependency.BuildVariant == nil {
			break
		}

		return e.complexity.Dependency.BuildVariant(childComplexity), true

	case "Dependency.metStatus":
		if e.complexity.Dependency.MetStatus == nil {
			break
		}

		return e.complexity.Dependency.MetStatus(childComplexity), true

	case "Dependency.name":
		if e.complexity.Dependency.Name == nil {
			break
		}

		return e.complexity.Dependency.Name(childComplexity), true

	case "Dependency.requiredStatus":
		if e.complexity.Dependency.RequiredStatus == nil {
			break
		}

		return e.complexity.Dependency.RequiredStatus(childComplexity), true

	case "Dependency.taskId":
		if e.complexity.Dependency.TaskID == nil {
			break
		}

		return e.complexity.Dependency.TaskID(childComplexity), true

	case "DispatcherSettings.version":
		if e.complexity.DispatcherSettings.Version == nil {
			break
		}

		return e.complexity.DispatcherSettings.Version(childComplexity), true

	case "Distro.adminOnly":
		if e.complexity.Distro.AdminOnly == nil {
			break
		}

		return e.complexity.Distro.AdminOnly(childComplexity), true

	case "Distro.aliases":
		if e.complexity.Distro.Aliases == nil {
			break
		}

		return e.complexity.Distro.Aliases(childComplexity), true

	case "Distro.arch":
		if e.complexity.Distro.Arch == nil {
			break
		}

		return e.complexity.Distro.Arch(childComplexity), true

	case "Distro.authorizedKeysFile":
		if e.complexity.Distro.AuthorizedKeysFile == nil {
			break
		}

		return e.complexity.Distro.AuthorizedKeysFile(childComplexity), true

	case "Distro.bootstrapSettings":
		if e.complexity.Distro.BootstrapSettings == nil {
			break
		}

		return e.complexity.Distro.BootstrapSettings(childComplexity), true

	case "Distro.containerPool":
		if e.complexity.Distro.ContainerPool == nil {
			break
		}

		return e.complexity.Distro.ContainerPool(childComplexity), true

	case "Distro.disableShallowClone":
		if e.complexity.Distro.DisableShallowClone == nil {
			break
		}

		return e.complexity.Distro.DisableShallowClone(childComplexity), true

	case "Distro.disabled":
		if e.complexity.Distro.Disabled == nil {
			break
		}

		return e.complexity.Distro.Disabled(childComplexity), true

	case "Distro.dispatcherSettings":
		if e.complexity.Distro.DispatcherSettings == nil {
			break
		}

		return e.complexity.Distro.DispatcherSettings(childComplexity), true

	case "Distro.execUser":
		if e.complexity.Distro.ExecUser == nil {
			break
		}

		return e.complexity.Distro.ExecUser(childComplexity), true

	case "Distro.expansions":
		if e.complexity.Distro.Expansions == nil {
			break
		}

		return e.complexity.Distro.Expansions(childComplexity), true

	case "Distro.finderSettings":
		if e.complexity.Distro.FinderSettings == nil {
			break
		}

		return e.complexity.Distro.FinderSettings(childComplexity), true

	case "Distro.homeVolumeSettings":
		if e.complexity.Distro.HomeVolumeSettings == nil {
			break
		}

		return e.complexity.Distro.HomeVolumeSettings(childComplexity), true

	case "Distro.hostAllocatorSettings":
		if e.complexity.Distro.HostAllocatorSettings == nil {
			break
		}

		return e.complexity.Distro.HostAllocatorSettings(childComplexity), true

	case "Distro.iceCreamSettings":
		if e.complexity.Distro.IcecreamSettings == nil {
			break
		}

		return e.complexity.Distro.IcecreamSettings(childComplexity), true

	case "Distro.imageId":
		if e.complexity.Distro.ImageID == nil {
			break
		}

		return e.complexity.Distro.ImageID(childComplexity), true

	case "Distro.isCluster":
		if e.complexity.Distro.IsCluster == nil {
			break
		}

		return e.complexity.Distro.IsCluster(childComplexity), true

	case "Distro.isVirtualWorkStation":
		if e.complexity.Distro.IsVirtualWorkstation == nil {
			break
		}

		return e.complexity.Distro.IsVirtualWorkstation(childComplexity), true

	case "Distro.mountpoints":
		if e.complexity.Distro.Mountpoints == nil {
			break
		}

		return e.complexity.Distro.Mountpoints(childComplexity), true

	case "Distro.name":
		if e.complexity.Distro.Name == nil {
			break
		}

		return e.complexity.Distro.Name(childComplexity), true

	case "Distro.note":
		if e.complexity.Distro.Note == nil {
			break
		}

		return e.complexity.Distro.Note(childComplexity), true

	case "Distro.plannerSettings":
		if e.complexity.Distro.PlannerSettings == nil {
			break
		}

		return e.complexity.Distro.PlannerSettings(childComplexity), true

	case "Distro.provider":
		if e.complexity.Distro.Provider == nil {
			break
		}

		return e.complexity.Distro.Provider(childComplexity), true

	case "Distro.providerSettingsList":
		if e.complexity.Distro.ProviderSettingsList == nil {
			break
		}

		return e.complexity.Distro.ProviderSettingsList(childComplexity), true

	case "Distro.sshOptions":
		if e.complexity.Distro.SSHOptions == nil {
			break
		}

		return e.complexity.Distro.SSHOptions(childComplexity), true

	case "Distro.setup":
		if e.complexity.Distro.Setup == nil {
			break
		}

		return e.complexity.Distro.Setup(childComplexity), true

	case "Distro.setupAsSudo":
		if e.complexity.Distro.SetupAsSudo == nil {
			break
		}

		return e.complexity.Distro.SetupAsSudo(childComplexity), true

	case "Distro.singleTaskDistro":
		if e.complexity.Distro.SingleTaskDistro == nil {
			break
		}

		return e.complexity.Distro.SingleTaskDistro(childComplexity), true

	case "Distro.user":
		if e.complexity.Distro.User == nil {
			break
		}

		return e.complexity.Distro.User(childComplexity), true

	case "Distro.userSpawnAllowed":
		if e.complexity.Distro.UserSpawnAllowed == nil {
			break
		}

		return e.complexity.Distro.UserSpawnAllowed(childComplexity), true

	case "Distro.validProjects":
		if e.complexity.Distro.ValidProjects == nil {
			break
		}

		return e.complexity.Distro.ValidProjects(childComplexity), true

	case "Distro.warningNote":
		if e.complexity.Distro.WarningNote == nil {
			break
		}

		return e.complexity.Distro.WarningNote(childComplexity), true

	case "Distro.workDir":
		if e.complexity.Distro.WorkDir == nil {
			break
		}

		return e.complexity.Distro.WorkDir(childComplexity), true

	case "DistroEvent.after":
		if e.complexity.DistroEvent.After == nil {
			break
		}

		return e.complexity.DistroEvent.After(childComplexity), true

	case "DistroEvent.before":
		if e.complexity.DistroEvent.Before == nil {
			break
		}

		return e.complexity.DistroEvent.Before(childComplexity), true

	case "DistroEvent.data":
		if e.complexity.DistroEvent.Data == nil {
			break
		}

		return e.complexity.DistroEvent.Data(childComplexity), true

	case "DistroEvent.timestamp":
		if e.complexity.DistroEvent.Timestamp == nil {
			break
		}

		return e.complexity.DistroEvent.Timestamp(childComplexity), true

	case "DistroEvent.user":
		if e.complexity.DistroEvent.User == nil {
			break
		}

		return e.complexity.DistroEvent.User(childComplexity), true

	case "DistroEventsPayload.count":
		if e.complexity.DistroEventsPayload.Count == nil {
			break
		}

		return e.complexity.DistroEventsPayload.Count(childComplexity), true

	case "DistroEventsPayload.eventLogEntries":
		if e.complexity.DistroEventsPayload.EventLogEntries == nil {
			break
		}

		return e.complexity.DistroEventsPayload.EventLogEntries(childComplexity), true

	case "DistroInfo.bootstrapMethod":
		if e.complexity.DistroInfo.BootstrapMethod == nil {
			break
		}

		return e.complexity.DistroInfo.BootstrapMethod(childComplexity), true

	case "DistroInfo.id":
		if e.complexity.DistroInfo.Id == nil {
			break
		}

		return e.complexity.DistroInfo.Id(childComplexity), true

	case "DistroInfo.isVirtualWorkStation":
		if e.complexity.DistroInfo.IsVirtualWorkstation == nil {
			break
		}

		return e.complexity.DistroInfo.IsVirtualWorkstation(childComplexity), true

	case "DistroInfo.isWindows":
		if e.complexity.DistroInfo.IsWindows == nil {
			break
		}

		return e.complexity.DistroInfo.IsWindows(childComplexity), true

	case "DistroInfo.user":
		if e.complexity.DistroInfo.User == nil {
			break
		}

		return e.complexity.DistroInfo.User(childComplexity), true

	case "DistroInfo.workDir":
		if e.complexity.DistroInfo.WorkDir == nil {
			break
		}

		return e.complexity.DistroInfo.WorkDir(childComplexity), true

	case "DistroPermissions.admin":
		if e.complexity.DistroPermissions.Admin == nil {
			break
		}

		return e.complexity.DistroPermissions.Admin(childComplexity), true

	case "DistroPermissions.edit":
		if e.complexity.DistroPermissions.Edit == nil {
			break
		}

		return e.complexity.DistroPermissions.Edit(childComplexity), true

	case "DistroPermissions.view":
		if e.complexity.DistroPermissions.View == nil {
			break
		}

		return e.complexity.DistroPermissions.View(childComplexity), true

	case "ECSConfig.maxCPU":
		if e.complexity.ECSConfig.MaxCPU == nil {
			break
		}

		return e.complexity.ECSConfig.MaxCPU(childComplexity), true

	case "ECSConfig.maxMemoryMb":
		if e.complexity.ECSConfig.MaxMemoryMB == nil {
			break
		}

		return e.complexity.ECSConfig.MaxMemoryMB(childComplexity), true

	case "EnvVar.key":
		if e.complexity.EnvVar.Key == nil {
			break
		}

		return e.complexity.EnvVar.Key(childComplexity), true

	case "EnvVar.value":
		if e.complexity.EnvVar.Value == nil {
			break
		}

		return e.complexity.EnvVar.Value(childComplexity), true

	case "Expansion.key":
		if e.complexity.Expansion.Key == nil {
			break
		}

		return e.complexity.Expansion.Key(childComplexity), true

	case "Expansion.value":
		if e.complexity.Expansion.Value == nil {
			break
		}

		return e.complexity.Expansion.Value(childComplexity), true

	case "ExternalLink.displayName":
		if e.complexity.ExternalLink.DisplayName == nil {
			break
		}

		return e.complexity.ExternalLink.DisplayName(childComplexity), true

	case "ExternalLink.requesters":
		if e.complexity.ExternalLink.Requesters == nil {
			break
		}

		return e.complexity.ExternalLink.Requesters(childComplexity), true

	case "ExternalLink.urlTemplate":
		if e.complexity.ExternalLink.URLTemplate == nil {
			break
		}

		return e.complexity.ExternalLink.URLTemplate(childComplexity), true

	case "ExternalLinkForMetadata.displayName":
		if e.complexity.ExternalLinkForMetadata.DisplayName == nil {
			break
		}

		return e.complexity.ExternalLinkForMetadata.DisplayName(childComplexity), true

	case "ExternalLinkForMetadata.url":
		if e.complexity.ExternalLinkForMetadata.URL == nil {
			break
		}

		return e.complexity.ExternalLinkForMetadata.URL(childComplexity), true

	case "File.link":
		if e.complexity.File.Link == nil {
			break
		}

		return e.complexity.File.Link(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.urlParsley":
		if e.complexity.File.URLParsley == nil {
			break
		}

		return e.complexity.File.URLParsley(childComplexity), true

	case "File.visibility":
		if e.complexity.File.Visibility == nil {
			break
		}

		return e.complexity.File.Visibility(childComplexity), true

	case "FileDiff.additions":
		if e.complexity.FileDiff.Additions == nil {
			break
		}

		return e.complexity.FileDiff.Additions(childComplexity), true

	case "FileDiff.deletions":
		if e.complexity.FileDiff.Deletions == nil {
			break
		}

		return e.complexity.FileDiff.Deletions(childComplexity), true

	case "FileDiff.description":
		if e.complexity.FileDiff.Description == nil {
			break
		}

		return e.complexity.FileDiff.Description(childComplexity), true

	case "FileDiff.diffLink":
		if e.complexity.FileDiff.DiffLink == nil {
			break
		}

		return e.complexity.FileDiff.DiffLink(childComplexity), true

	case "FileDiff.fileName":
		if e.complexity.FileDiff.FileName == nil {
			break
		}

		return e.complexity.FileDiff.FileName(childComplexity), true

	case "FinderSettings.version":
		if e.complexity.FinderSettings.Version == nil {
			break
		}

		return e.complexity.FinderSettings.Version(childComplexity), true

	case "GeneralSubscription.id":
		if e.complexity.GeneralSubscription.ID == nil {
			break
		}

		return e.complexity.GeneralSubscription.ID(childComplexity), true

	case "GeneralSubscription.ownerType":
		if e.complexity.GeneralSubscription.OwnerType == nil {
			break
		}

		return e.complexity.GeneralSubscription.OwnerType(childComplexity), true

	case "GeneralSubscription.regexSelectors":
		if e.complexity.GeneralSubscription.RegexSelectors == nil {
			break
		}

		return e.complexity.GeneralSubscription.RegexSelectors(childComplexity), true

	case "GeneralSubscription.resourceType":
		if e.complexity.GeneralSubscription.ResourceType == nil {
			break
		}

		return e.complexity.GeneralSubscription.ResourceType(childComplexity), true

	case "GeneralSubscription.selectors":
		if e.complexity.GeneralSubscription.Selectors == nil {
			break
		}

		return e.complexity.GeneralSubscription.Selectors(childComplexity), true

	case "GeneralSubscription.subscriber":
		if e.complexity.GeneralSubscription.Subscriber == nil {
			break
		}

		return e.complexity.GeneralSubscription.Subscriber(childComplexity), true

	case "GeneralSubscription.trigger":
		if e.complexity.GeneralSubscription.Trigger == nil {
			break
		}

		return e.complexity.GeneralSubscription.Trigger(childComplexity), true

	case "GeneralSubscription.triggerData":
		if e.complexity.GeneralSubscription.TriggerData == nil {
			break
		}

		return e.complexity.GeneralSubscription.TriggerData(childComplexity), true

	case "GeneratedTaskCountResults.buildVariantName":
		if e.complexity.GeneratedTaskCountResults.BuildVariantName == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.BuildVariantName(childComplexity), true

	case "GeneratedTaskCountResults.estimatedTasks":
		if e.complexity.GeneratedTaskCountResults.EstimatedTasks == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.EstimatedTasks(childComplexity), true

	case "GeneratedTaskCountResults.taskId":
		if e.complexity.GeneratedTaskCountResults.TaskID == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.TaskID(childComplexity), true

	case "GeneratedTaskCountResults.taskName":
		if e.complexity.GeneratedTaskCountResults.TaskName == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.TaskName(childComplexity), true

	case "GitHubDynamicTokenPermissionGroup.name":
		if e.complexity.GitHubDynamicTokenPermissionGroup.Name == nil {
			break
		}

		return e.complexity.GitHubDynamicTokenPermissionGroup.Name(childComplexity), true

	case "GitHubDynamicTokenPermissionGroup.permissions":
		if e.complexity.GitHubDynamicTokenPermissionGroup.Permissions == nil {
			break
		}

		return e.complexity.GitHubDynamicTokenPermissionGroup.Permissions(childComplexity), true

	case "GitTag.pusher":
		if e.complexity.GitTag.Pusher == nil {
			break
		}

		return e.complexity.GitTag.Pusher(childComplexity), true

	case "GitTag.tag":
		if e.complexity.GitTag.Tag == nil {
			break
		}

		return e.complexity.GitTag.Tag(childComplexity), true

	case "GithubAppAuth.appId":
		if e.complexity.GithubAppAuth.AppID == nil {
			break
		}

		return e.complexity.GithubAppAuth.AppID(childComplexity), true

	case "GithubAppAuth.privateKey":
		if e.complexity.GithubAppAuth.PrivateKey == nil {
			break
		}

		return e.complexity.GithubAppAuth.PrivateKey(childComplexity), true

	case "GithubCheckSubscriber.owner":
		if e.complexity.GithubCheckSubscriber.Owner == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Owner(childComplexity), true

	case "GithubCheckSubscriber.ref":
		if e.complexity.GithubCheckSubscriber.Ref == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Ref(childComplexity), true

	case "GithubCheckSubscriber.repo":
		if e.complexity.GithubCheckSubscriber.Repo == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Repo(childComplexity), true

	case "GithubPRSubscriber.owner":
		if e.complexity.GithubPRSubscriber.Owner == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Owner(childComplexity), true

	case "GithubPRSubscriber.prNumber":
		if e.complexity.GithubPRSubscriber.PRNumber == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.PRNumber(childComplexity), true

	case "GithubPRSubscriber.ref":
		if e.complexity.GithubPRSubscriber.Ref == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Ref(childComplexity), true

	case "GithubPRSubscriber.repo":
		if e.complexity.GithubPRSubscriber.Repo == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Repo(childComplexity), true

	case "GithubProjectConflicts.commitCheckIdentifiers":
		if e.complexity.GithubProjectConflicts.CommitCheckIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.CommitCheckIdentifiers(childComplexity), true

	case "GithubProjectConflicts.commitQueueIdentifiers":
		if e.complexity.GithubProjectConflicts.CommitQueueIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.CommitQueueIdentifiers(childComplexity), true

	case "GithubProjectConflicts.prTestingIdentifiers":
		if e.complexity.GithubProjectConflicts.PRTestingIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.PRTestingIdentifiers(childComplexity), true

	case "GithubUser.lastKnownAs":
		if e.complexity.GithubUser.LastKnownAs == nil {
			break
		}

		return e.complexity.GithubUser.LastKnownAs(childComplexity), true

	case "GithubUser.uid":
		if e.complexity.GithubUser.UID == nil {
			break
		}

		return e.complexity.GithubUser.UID(childComplexity), true

	case "GroupedBuildVariant.displayName":
		if e.complexity.GroupedBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.DisplayName(childComplexity), true

	case "GroupedBuildVariant.tasks":
		if e.complexity.GroupedBuildVariant.Tasks == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.Tasks(childComplexity), true

	case "GroupedBuildVariant.variant":
		if e.complexity.GroupedBuildVariant.Variant == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.Variant(childComplexity), true

	case "GroupedFiles.execution":
		if e.complexity.GroupedFiles.Execution == nil {
			break
		}

		return e.complexity.GroupedFiles.Execution(childComplexity), true

	case "GroupedFiles.files":
		if e.complexity.GroupedFiles.Files == nil {
			break
		}

		return e.complexity.GroupedFiles.Files(childComplexity), true

	case "GroupedFiles.taskId":
		if e.complexity.GroupedFiles.TaskID == nil {
			break
		}

		return e.complexity.GroupedFiles.TaskID(childComplexity), true

	case "GroupedFiles.taskName":
		if e.complexity.GroupedFiles.TaskName == nil {
			break
		}

		return e.complexity.GroupedFiles.TaskName(childComplexity), true

	case "GroupedProjects.groupDisplayName":
		if e.complexity.GroupedProjects.GroupDisplayName == nil {
			break
		}

		return e.complexity.GroupedProjects.GroupDisplayName(childComplexity), true

	case "GroupedProjects.projects":
		if e.complexity.GroupedProjects.Projects == nil {
			break
		}

		return e.complexity.GroupedProjects.Projects(childComplexity), true

	case "GroupedProjects.repo":
		if e.complexity.GroupedProjects.Repo == nil {
			break
		}

		return e.complexity.GroupedProjects.Repo(childComplexity), true

	case "GroupedTaskStatusCount.displayName":
		if e.complexity.GroupedTaskStatusCount.DisplayName == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.DisplayName(childComplexity), true

	case "GroupedTaskStatusCount.statusCounts":
		if e.complexity.GroupedTaskStatusCount.StatusCounts == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.StatusCounts(childComplexity), true

	case "GroupedTaskStatusCount.variant":
		if e.complexity.GroupedTaskStatusCount.Variant == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.Variant(childComplexity), true

	case "HomeVolumeSettings.formatCommand":
		if e.complexity.HomeVolumeSettings.FormatCommand == nil {
			break
		}

		return e.complexity.HomeVolumeSettings.FormatCommand(childComplexity), true

	case "Host.ami":
		if e.complexity.Host.Ami == nil {
			break
		}

		return e.complexity.Host.Ami(childComplexity), true

	case "Host.availabilityZone":
		if e.complexity.Host.AvailabilityZone == nil {
			break
		}

		return e.complexity.Host.AvailabilityZone(childComplexity), true

	case "Host.displayName":
		if e.complexity.Host.DisplayName == nil {
			break
		}

		return e.complexity.Host.DisplayName(childComplexity), true

	case "Host.distro":
		if e.complexity.Host.Distro == nil {
			break
		}

		return e.complexity.Host.Distro(childComplexity), true

	case "Host.distroId":
		if e.complexity.Host.DistroID == nil {
			break
		}

		return e.complexity.Host.DistroID(childComplexity), true

	case "Host.elapsed":
		if e.complexity.Host.Elapsed == nil {
			break
		}

		return e.complexity.Host.Elapsed(childComplexity), true

	case "Host.eventTypes":
		if e.complexity.Host.EventTypes == nil {
			break
		}

		return e.complexity.Host.EventTypes(childComplexity), true

	case "Host.events":
		if e.complexity.Host.Events == nil {
			break
		}

		args, err := ec.field_Host_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Events(childComplexity, args["opts"].(HostEventsInput)), true

	case "Host.expiration":
		if e.complexity.Host.Expiration == nil {
			break
		}

		return e.complexity.Host.Expiration(childComplexity), true

	case "Host.homeVolume":
		if e.complexity.Host.HomeVolume == nil {
			break
		}

		return e.complexity.Host.HomeVolume(childComplexity), true

	case "Host.homeVolumeID":
		if e.complexity.Host.HomeVolumeID == nil {
			break
		}

		return e.complexity.Host.HomeVolumeID(childComplexity), true

	case "Host.hostUrl":
		if e.complexity.Host.HostURL == nil {
			break
		}

		return e.complexity.Host.HostURL(childComplexity), true

	case "Host.id":
		if e.complexity.Host.Id == nil {
			break
		}

		return e.complexity.Host.Id(childComplexity), true

	case "Host.instanceTags":
		if e.complexity.Host.InstanceTags == nil {
			break
		}

		return e.complexity.Host.InstanceTags(childComplexity), true

	case "Host.instanceType":
		if e.complexity.Host.InstanceType == nil {
			break
		}

		return e.complexity.Host.InstanceType(childComplexity), true

	case "Host.lastCommunicationTime":
		if e.complexity.Host.LastCommunicationTime == nil {
			break
		}

		return e.complexity.Host.LastCommunicationTime(childComplexity), true

	case "Host.noExpiration":
		if e.complexity.Host.NoExpiration == nil {
			break
		}

		return e.complexity.Host.NoExpiration(childComplexity), true

	case "Host.persistentDnsName":
		if e.complexity.Host.PersistentDNSName == nil {
			break
		}

		return e.complexity.Host.PersistentDNSName(childComplexity), true

	case "Host.provider":
		if e.complexity.Host.Provider == nil {
			break
		}

		return e.complexity.Host.Provider(childComplexity), true

	case "Host.runningTask":
		if e.complexity.Host.RunningTask == nil {
			break
		}

		return e.complexity.Host.RunningTask(childComplexity), true

	case "Host.sleepSchedule":
		if e.complexity.Host.SleepSchedule == nil {
			break
		}

		return e.complexity.Host.SleepSchedule(childComplexity), true

	case "Host.startedBy":
		if e.complexity.Host.StartedBy == nil {
			break
		}

		return e.complexity.Host.StartedBy(childComplexity), true

	case "Host.status":
		if e.complexity.Host.Status == nil {
			break
		}

		return e.complexity.Host.Status(childComplexity), true

	case "Host.tag":
		if e.complexity.Host.Tag == nil {
			break
		}

		return e.complexity.Host.Tag(childComplexity), true

	case "Host.totalIdleTime":
		if e.complexity.Host.TotalIdleTime == nil {
			break
		}

		return e.complexity.Host.TotalIdleTime(childComplexity), true

	case "Host.uptime":
		if e.complexity.Host.Uptime == nil {
			break
		}

		return e.complexity.Host.Uptime(childComplexity), true

	case "Host.user":
		if e.complexity.Host.User == nil {
			break
		}

		return e.complexity.Host.User(childComplexity), true

	case "Host.volumes":
		if e.complexity.Host.Volumes == nil {
			break
		}

		return e.complexity.Host.Volumes(childComplexity), true

	case "HostAllocatorSettings.acceptableHostIdleTime":
		if e.complexity.HostAllocatorSettings.AcceptableHostIdleTime == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.AcceptableHostIdleTime(childComplexity), true

	case "HostAllocatorSettings.feedbackRule":
		if e.complexity.HostAllocatorSettings.FeedbackRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.FeedbackRule(childComplexity), true

	case "HostAllocatorSettings.futureHostFraction":
		if e.complexity.HostAllocatorSettings.FutureHostFraction == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.FutureHostFraction(childComplexity), true

	case "HostAllocatorSettings.hostsOverallocatedRule":
		if e.complexity.HostAllocatorSettings.HostsOverallocatedRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.HostsOverallocatedRule(childComplexity), true

	case "HostAllocatorSettings.maximumHosts":
		if e.complexity.HostAllocatorSettings.MaximumHosts == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.MaximumHosts(childComplexity), true

	case "HostAllocatorSettings.minimumHosts":
		if e.complexity.HostAllocatorSettings.MinimumHosts == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.MinimumHosts(childComplexity), true

	case "HostAllocatorSettings.roundingRule":
		if e.complexity.HostAllocatorSettings.RoundingRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.RoundingRule(childComplexity), true

	case "HostAllocatorSettings.version":
		if e.complexity.HostAllocatorSettings.Version == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.Version(childComplexity), true

	case "HostEventLogData.agentBuild":
		if e.complexity.HostEventLogData.AgentBuild == nil {
			break
		}

		return e.complexity.HostEventLogData.AgentBuild(childComplexity), true

	case "HostEventLogData.agentRevision":
		if e.complexity.HostEventLogData.AgentRevision == nil {
			break
		}

		return e.complexity.HostEventLogData.AgentRevision(childComplexity), true

	case "HostEventLogData.duration":
		if e.complexity.HostEventLogData.Duration == nil {
			break
		}

		return e.complexity.HostEventLogData.Duration(childComplexity), true

	case "HostEventLogData.execution":
		if e.complexity.HostEventLogData.Execution == nil {
			break
		}

		return e.complexity.HostEventLogData.Execution(childComplexity), true

	case "HostEventLogData.hostname":
		if e.complexity.HostEventLogData.Hostname == nil {
			break
		}

		return e.complexity.HostEventLogData.Hostname(childComplexity), true

	case "HostEventLogData.jasperRevision":
		if e.complexity.HostEventLogData.JasperRevision == nil {
			break
		}

		return e.complexity.HostEventLogData.JasperRevision(childComplexity), true

	case "HostEventLogData.logs":
		if e.complexity.HostEventLogData.Logs == nil {
			break
		}

		return e.complexity.HostEventLogData.Logs(childComplexity), true

	case "HostEventLogData.monitorOp":
		if e.complexity.HostEventLogData.MonitorOp == nil {
			break
		}

		return e.complexity.HostEventLogData.MonitorOp(childComplexity), true

	case "HostEventLogData.newStatus":
		if e.complexity.HostEventLogData.NewStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.NewStatus(childComplexity), true

	case "HostEventLogData.oldStatus":
		if e.complexity.HostEventLogData.OldStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.OldStatus(childComplexity), true

	case "HostEventLogData.provisioningMethod":
		if e.complexity.HostEventLogData.ProvisioningMethod == nil {
			break
		}

		return e.complexity.HostEventLogData.ProvisioningMethod(childComplexity), true

	case "HostEventLogData.successful":
		if e.complexity.HostEventLogData.Successful == nil {
			break
		}

		return e.complexity.HostEventLogData.Successful(childComplexity), true

	case "HostEventLogData.taskId":
		if e.complexity.HostEventLogData.TaskId == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskId(childComplexity), true

	case "HostEventLogData.taskPid":
		if e.complexity.HostEventLogData.TaskPid == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskPid(childComplexity), true

	case "HostEventLogData.taskStatus":
		if e.complexity.HostEventLogData.TaskStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskStatus(childComplexity), true

	case "HostEventLogData.user":
		if e.complexity.HostEventLogData.User == nil {
			break
		}

		return e.complexity.HostEventLogData.User(childComplexity), true

	case "HostEventLogEntry.data":
		if e.complexity.HostEventLogEntry.Data == nil {
			break
		}

		return e.complexity.HostEventLogEntry.Data(childComplexity), true

	case "HostEventLogEntry.eventType":
		if e.complexity.HostEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.HostEventLogEntry.EventType(childComplexity), true

	case "HostEventLogEntry.id":
		if e.complexity.HostEventLogEntry.ID == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ID(childComplexity), true

	case "HostEventLogEntry.processedAt":
		if e.complexity.HostEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ProcessedAt(childComplexity), true

	case "HostEventLogEntry.resourceId":
		if e.complexity.HostEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ResourceId(childComplexity), true

	case "HostEventLogEntry.resourceType":
		if e.complexity.HostEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ResourceType(childComplexity), true

	case "HostEventLogEntry.timestamp":
		if e.complexity.HostEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.HostEventLogEntry.Timestamp(childComplexity), true

	case "HostEvents.count":
		if e.complexity.HostEvents.Count == nil {
			break
		}

		return e.complexity.HostEvents.Count(childComplexity), true

	case "HostEvents.eventLogEntries":
		if e.complexity.HostEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.HostEvents.EventLogEntries(childComplexity), true

	case "HostsResponse.filteredHostsCount":
		if e.complexity.HostsResponse.FilteredHostsCount == nil {
			break
		}

		return e.complexity.HostsResponse.FilteredHostsCount(childComplexity), true

	case "HostsResponse.hosts":
		if e.complexity.HostsResponse.Hosts == nil {
			break
		}

		return e.complexity.HostsResponse.Hosts(childComplexity), true

	case "HostsResponse.totalHostsCount":
		if e.complexity.HostsResponse.TotalHostsCount == nil {
			break
		}

		return e.complexity.HostsResponse.TotalHostsCount(childComplexity), true

	case "IceCreamSettings.configPath":
		if e.complexity.IceCreamSettings.ConfigPath == nil {
			break
		}

		return e.complexity.IceCreamSettings.ConfigPath(childComplexity), true

	case "IceCreamSettings.schedulerHost":
		if e.complexity.IceCreamSettings.SchedulerHost == nil {
			break
		}

		return e.complexity.IceCreamSettings.SchedulerHost(childComplexity), true

	case "Image.ami":
		if e.complexity.Image.AMI == nil {
			break
		}

		return e.complexity.Image.AMI(childComplexity), true

	case "Image.distros":
		if e.complexity.Image.Distros == nil {
			break
		}

		return e.complexity.Image.Distros(childComplexity), true

	case "Image.events":
		if e.complexity.Image.Events == nil {
			break
		}

		args, err := ec.field_Image_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.Events(childComplexity, args["limit"].(int), args["page"].(int)), true

	case "Image.id":
		if e.complexity.Image.ID == nil {
			break
		}

		return e.complexity.Image.ID(childComplexity), true

	case "Image.lastDeployed":
		if e.complexity.Image.LastDeployed == nil {
			break
		}

		return e.complexity.Image.LastDeployed(childComplexity), true

	case "Image.latestTask":
		if e.complexity.Image.LatestTask == nil {
			break
		}

		return e.complexity.Image.LatestTask(childComplexity), true

	case "Image.operatingSystem":
		if e.complexity.Image.OperatingSystem == nil {
			break
		}

		args, err := ec.field_Image_operatingSystem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.OperatingSystem(childComplexity, args["opts"].(thirdparty.OSInfoFilterOptions)), true

	case "Image.packages":
		if e.complexity.Image.Packages == nil {
			break
		}

		args, err := ec.field_Image_packages_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.Packages(childComplexity, args["opts"].(thirdparty.PackageFilterOptions)), true

	case "Image.toolchains":
		if e.complexity.Image.Toolchains == nil {
			break
		}

		args, err := ec.field_Image_toolchains_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.Toolchains(childComplexity, args["opts"].(thirdparty.ToolchainFilterOptions)), true

	case "ImageEvent.amiAfter":
		if e.complexity.ImageEvent.AMIAfter == nil {
			break
		}

		return e.complexity.ImageEvent.AMIAfter(childComplexity), true

	case "ImageEvent.amiBefore":
		if e.complexity.ImageEvent.AMIBefore == nil {
			break
		}

		return e.complexity.ImageEvent.AMIBefore(childComplexity), true

	case "ImageEvent.entries":
		if e.complexity.ImageEvent.Entries == nil {
			break
		}

		return e.complexity.ImageEvent.Entries(childComplexity), true

	case "ImageEvent.timestamp":
		if e.complexity.ImageEvent.Timestamp == nil {
			break
		}

		return e.complexity.ImageEvent.Timestamp(childComplexity), true

	case "ImageEventEntry.action":
		if e.complexity.ImageEventEntry.Action == nil {
			break
		}

		return e.complexity.ImageEventEntry.Action(childComplexity), true

	case "ImageEventEntry.after":
		if e.complexity.ImageEventEntry.After == nil {
			break
		}

		return e.complexity.ImageEventEntry.After(childComplexity), true

	case "ImageEventEntry.before":
		if e.complexity.ImageEventEntry.Before == nil {
			break
		}

		return e.complexity.ImageEventEntry.Before(childComplexity), true

	case "ImageEventEntry.name":
		if e.complexity.ImageEventEntry.Name == nil {
			break
		}

		return e.complexity.ImageEventEntry.Name(childComplexity), true

	case "ImageEventEntry.type":
		if e.complexity.ImageEventEntry.Type == nil {
			break
		}

		return e.complexity.ImageEventEntry.Type(childComplexity), true

	case "ImageEventsPayload.count":
		if e.complexity.ImageEventsPayload.Count == nil {
			break
		}

		return e.complexity.ImageEventsPayload.Count(childComplexity), true

	case "ImageEventsPayload.eventLogEntries":
		if e.complexity.ImageEventsPayload.EventLogEntries == nil {
			break
		}

		return e.complexity.ImageEventsPayload.EventLogEntries(childComplexity), true

	case "ImageOperatingSystemPayload.data":
		if e.complexity.ImageOperatingSystemPayload.Data == nil {
			break
		}

		return e.complexity.ImageOperatingSystemPayload.Data(childComplexity), true

	case "ImageOperatingSystemPayload.filteredCount":
		if e.complexity.ImageOperatingSystemPayload.FilteredCount == nil {
			break
		}

		return e.complexity.ImageOperatingSystemPayload.FilteredCount(childComplexity), true

	case "ImageOperatingSystemPayload.totalCount":
		if e.complexity.ImageOperatingSystemPayload.TotalCount == nil {
			break
		}

		return e.complexity.ImageOperatingSystemPayload.TotalCount(childComplexity), true

	case "ImagePackagesPayload.data":
		if e.complexity.ImagePackagesPayload.Data == nil {
			break
		}

		return e.complexity.ImagePackagesPayload.Data(childComplexity), true

	case "ImagePackagesPayload.filteredCount":
		if e.complexity.ImagePackagesPayload.FilteredCount == nil {
			break
		}

		return e.complexity.ImagePackagesPayload.FilteredCount(childComplexity), true

	case "ImagePackagesPayload.totalCount":
		if e.complexity.ImagePackagesPayload.TotalCount == nil {
			break
		}

		return e.complexity.ImagePackagesPayload.TotalCount(childComplexity), true

	case "ImageToolchainsPayload.data":
		if e.complexity.ImageToolchainsPayload.Data == nil {
			break
		}

		return e.complexity.ImageToolchainsPayload.Data(childComplexity), true

	case "ImageToolchainsPayload.filteredCount":
		if e.complexity.ImageToolchainsPayload.FilteredCount == nil {
			break
		}

		return e.complexity.ImageToolchainsPayload.FilteredCount(childComplexity), true

	case "ImageToolchainsPayload.totalCount":
		if e.complexity.ImageToolchainsPayload.TotalCount == nil {
			break
		}

		return e.complexity.ImageToolchainsPayload.TotalCount(childComplexity), true

	case "InstanceTag.canBeModified":
		if e.complexity.InstanceTag.CanBeModified == nil {
			break
		}

		return e.complexity.InstanceTag.CanBeModified(childComplexity), true

	case "InstanceTag.key":
		if e.complexity.InstanceTag.Key == nil {
			break
		}

		return e.complexity.InstanceTag.Key(childComplexity), true

	case "InstanceTag.value":
		if e.complexity.InstanceTag.Value == nil {
			break
		}

		return e.complexity.InstanceTag.Value(childComplexity), true

	case "IssueLink.confidenceScore":
		if e.complexity.IssueLink.ConfidenceScore == nil {
			break
		}

		return e.complexity.IssueLink.ConfidenceScore(childComplexity), true

	case "IssueLink.issueKey":
		if e.complexity.IssueLink.IssueKey == nil {
			break
		}

		return e.complexity.IssueLink.IssueKey(childComplexity), true

	case "IssueLink.jiraTicket":
		if e.complexity.IssueLink.JiraTicket == nil {
			break
		}

		return e.complexity.IssueLink.JiraTicket(childComplexity), true

	case "IssueLink.source":
		if e.complexity.IssueLink.Source == nil {
			break
		}

		return e.complexity.IssueLink.Source(childComplexity), true

	case "IssueLink.url":
		if e.complexity.IssueLink.URL == nil {
			break
		}

		return e.complexity.IssueLink.URL(childComplexity), true

	case "JiraConfig.email":
		if e.complexity.JiraConfig.Email == nil {
			break
		}

		return e.complexity.JiraConfig.Email(childComplexity), true

	case "JiraConfig.host":
		if e.complexity.JiraConfig.Host == nil {
			break
		}

		return e.complexity.JiraConfig.Host(childComplexity), true

	case "JiraIssueSubscriber.issueType":
		if e.complexity.JiraIssueSubscriber.IssueType == nil {
			break
		}

		return e.complexity.JiraIssueSubscriber.IssueType(childComplexity), true

	case "JiraIssueSubscriber.project":
		if e.complexity.JiraIssueSubscriber.Project == nil {
			break
		}

		return e.complexity.JiraIssueSubscriber.Project(childComplexity), true

	case "JiraStatus.id":
		if e.complexity.JiraStatus.Id == nil {
			break
		}

		return e.complexity.JiraStatus.Id(childComplexity), true

	case "JiraStatus.name":
		if e.complexity.JiraStatus.Name == nil {
			break
		}

		return e.complexity.JiraStatus.Name(childComplexity), true

	case "JiraTicket.fields":
		if e.complexity.JiraTicket.Fields == nil {
			break
		}

		return e.complexity.JiraTicket.Fields(childComplexity), true

	case "JiraTicket.key":
		if e.complexity.JiraTicket.Key == nil {
			break
		}

		return e.complexity.JiraTicket.Key(childComplexity), true

	case "LogMessage.message":
		if e.complexity.LogMessage.Message == nil {
			break
		}

		return e.complexity.LogMessage.Message(childComplexity), true

	case "LogMessage.severity":
		if e.complexity.LogMessage.Severity == nil {
			break
		}

		return e.complexity.LogMessage.Severity(childComplexity), true

	case "LogMessage.timestamp":
		if e.complexity.LogMessage.Timestamp == nil {
			break
		}

		return e.complexity.LogMessage.Timestamp(childComplexity), true

	case "LogMessage.type":
		if e.complexity.LogMessage.Type == nil {
			break
		}

		return e.complexity.LogMessage.Type(childComplexity), true

	case "LogMessage.version":
		if e.complexity.LogMessage.Version == nil {
			break
		}

		return e.complexity.LogMessage.Version(childComplexity), true

	case "LogkeeperBuild.buildNum":
		if e.complexity.LogkeeperBuild.BuildNum == nil {
			break
		}

		return e.complexity.LogkeeperBuild.BuildNum(childComplexity), true

	case "LogkeeperBuild.builder":
		if e.complexity.LogkeeperBuild.Builder == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Builder(childComplexity), true

	case "LogkeeperBuild.id":
		if e.complexity.LogkeeperBuild.ID == nil {
			break
		}

		return e.complexity.LogkeeperBuild.ID(childComplexity), true

	case "LogkeeperBuild.task":
		if e.complexity.LogkeeperBuild.Task == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Task(childComplexity), true

	case "LogkeeperBuild.taskExecution":
		if e.complexity.LogkeeperBuild.TaskExecution == nil {
			break
		}

		return e.complexity.LogkeeperBuild.TaskExecution(childComplexity), true

	case "LogkeeperBuild.taskId":
		if e.complexity.LogkeeperBuild.TaskID == nil {
			break
		}

		return e.complexity.LogkeeperBuild.TaskID(childComplexity), true

	case "LogkeeperBuild.tests":
		if e.complexity.LogkeeperBuild.Tests == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Tests(childComplexity), true

	case "LogkeeperTest.buildId":
		if e.complexity.LogkeeperTest.BuildID == nil {
			break
		}

		return e.complexity.LogkeeperTest.BuildID(childComplexity), true

	case "LogkeeperTest.command":
		if e.complexity.LogkeeperTest.Command == nil {
			break
		}

		return e.complexity.LogkeeperTest.Command(childComplexity), true

	case "LogkeeperTest.id":
		if e.complexity.LogkeeperTest.ID == nil {
			break
		}

		return e.complexity.LogkeeperTest.ID(childComplexity), true

	case "LogkeeperTest.name":
		if e.complexity.LogkeeperTest.Name == nil {
			break
		}

		return e.complexity.LogkeeperTest.Name(childComplexity), true

	case "LogkeeperTest.phase":
		if e.complexity.LogkeeperTest.Phase == nil {
			break
		}

		return e.complexity.LogkeeperTest.Phase(childComplexity), true

	case "LogkeeperTest.taskExecution":
		if e.complexity.LogkeeperTest.TaskExecution == nil {
			break
		}

		return e.complexity.LogkeeperTest.TaskExecution(childComplexity), true

	case "LogkeeperTest.taskId":
		if e.complexity.LogkeeperTest.TaskID == nil {
			break
		}

		return e.complexity.LogkeeperTest.TaskID(childComplexity), true

	case "MainlineCommitVersion.rolledUpVersions":
		if e.complexity.MainlineCommitVersion.RolledUpVersions == nil {
			break
		}

		return e.complexity.MainlineCommitVersion.RolledUpVersions(childComplexity), true

	case "MainlineCommitVersion.version":
		if e.complexity.MainlineCommitVersion.Version == nil {
			break
		}

		return e.complexity.MainlineCommitVersion.Version(childComplexity), true

	case "MainlineCommits.nextPageOrderNumber":
		if e.complexity.MainlineCommits.NextPageOrderNumber == nil {
			break
		}

		return e.complexity.MainlineCommits.NextPageOrderNumber(childComplexity), true

	case "MainlineCommits.prevPageOrderNumber":
		if e.complexity.MainlineCommits.PrevPageOrderNumber == nil {
			break
		}

		return e.complexity.MainlineCommits.PrevPageOrderNumber(childComplexity), true

	case "MainlineCommits.versions":
		if e.complexity.MainlineCommits.Versions == nil {
			break
		}

		return e.complexity.MainlineCommits.Versions(childComplexity), true

	case "Manifest.branch":
		if e.complexity.Manifest.Branch == nil {
			break
		}

		return e.complexity.Manifest.Branch(childComplexity), true

	case "Manifest.id":
		if e.complexity.Manifest.ID == nil {
			break
		}

		return e.complexity.Manifest.ID(childComplexity), true

	case "Manifest.isBase":
		if e.complexity.Manifest.IsBase == nil {
			break
		}

		return e.complexity.Manifest.IsBase(childComplexity), true

	case "Manifest.moduleOverrides":
		if e.complexity.Manifest.ModuleOverrides == nil {
			break
		}

		return e.complexity.Manifest.ModuleOverrides(childComplexity), true

	case "Manifest.modules":
		if e.complexity.Manifest.Modules == nil {
			break
		}

		return e.complexity.Manifest.Modules(childComplexity), true

	case "Manifest.project":
		if e.complexity.Manifest.Project == nil {
			break
		}

		return e.complexity.Manifest.Project(childComplexity), true

	case "Manifest.revision":
		if e.complexity.Manifest.Revision == nil {
			break
		}

		return e.complexity.Manifest.Revision(childComplexity), true

	case "MetadataLink.source":
		if e.complexity.MetadataLink.Source == nil {
			break
		}

		return e.complexity.MetadataLink.Source(childComplexity), true

	case "MetadataLink.text":
		if e.complexity.MetadataLink.Text == nil {
			break
		}

		return e.complexity.MetadataLink.Text(childComplexity), true

	case "MetadataLink.url":
		if e.complexity.MetadataLink.URL == nil {
			break
		}

		return e.complexity.MetadataLink.URL(childComplexity), true

	case "ModuleCodeChange.branchName":
		if e.complexity.ModuleCodeChange.BranchName == nil {
			break
		}

		return e.complexity.ModuleCodeChange.BranchName(childComplexity), true

	case "ModuleCodeChange.fileDiffs":
		if e.complexity.ModuleCodeChange.FileDiffs == nil {
			break
		}

		return e.complexity.ModuleCodeChange.FileDiffs(childComplexity), true

	case "ModuleCodeChange.htmlLink":
		if e.complexity.ModuleCodeChange.HTMLLink == nil {
			break
		}

		return e.complexity.ModuleCodeChange.HTMLLink(childComplexity), true

	case "ModuleCodeChange.rawLink":
		if e.complexity.ModuleCodeChange.RawLink == nil {
			break
		}

		return e.complexity.ModuleCodeChange.RawLink(childComplexity), true

	case "Mutation.abortTask":
		if e.complexity.Mutation.AbortTask == nil {
			break
		}

		args, err := ec.field_Mutation_abortTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AbortTask(childComplexity, args["taskId"].(string)), true

	case "Mutation.addAnnotationIssue":
		if e.complexity.Mutation.AddAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_addAnnotationIssue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true

	case "Mutation.addFavoriteProject":
		if e.complexity.Mutation.AddFavoriteProject == nil {
			break
		}

		args, err := ec.field_Mutation_addFavoriteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddFavoriteProject(childComplexity, args["opts"].(AddFavoriteProjectInput)), true

	case "Mutation.attachProjectToNewRepo":
		if e.complexity.Mutation.AttachProjectToNewRepo == nil {
			break
		}

		args, err := ec.field_Mutation_attachProjectToNewRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachProjectToNewRepo(childComplexity, args["project"].(MoveProjectInput)), true

	case "Mutation.attachProjectToRepo":
		if e.complexity.Mutation.AttachProjectToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_attachProjectToRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachProjectToRepo(childComplexity, args["projectId"].(string)), true

	case "Mutation.attachVolumeToHost":
		if e.complexity.Mutation.AttachVolumeToHost == nil {
			break
		}

		args, err := ec.field_Mutation_attachVolumeToHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachVolumeToHost(childComplexity, args["volumeAndHost"].(VolumeHost)), true

	case "Mutation.bbCreateTicket":
		if e.complexity.Mutation.BbCreateTicket == nil {
			break
		}

		args, err := ec.field_Mutation_bbCreateTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BbCreateTicket(childComplexity, args["taskId"].(string), args["execution"].(*int)), true

	case "Mutation.clearMySubscriptions":
		if e.complexity.Mutation.ClearMySubscriptions == nil {
			break
		}

		return e.complexity.Mutation.ClearMySubscriptions(childComplexity), true

	case "Mutation.copyDistro":
		if e.complexity.Mutation.CopyDistro == nil {
			break
		}

		args, err := ec.field_Mutation_copyDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CopyDistro(childComplexity, args["opts"].(model.CopyDistroOpts)), true

	case "Mutation.copyProject":
		if e.complexity.Mutation.CopyProject == nil {
			break
		}

		args, err := ec.field_Mutation_copyProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CopyProject(childComplexity, args["project"].(model.CopyProjectOpts), args["requestS3Creds"].(*bool)), true

	case "Mutation.createDistro":
		if e.complexity.Mutation.CreateDistro == nil {
			break
		}

		args, err := ec.field_Mutation_createDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDistro(childComplexity, args["opts"].(CreateDistroInput)), true

	case "Mutation.createProject":
		if e.complexity.Mutation.CreateProject == nil {
			break
		}

		args, err := ec.field_Mutation_createProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProject(childComplexity, args["project"].(model.APIProjectRef), args["requestS3Creds"].(*bool)), true

	case "Mutation.createPublicKey":
		if e.complexity.Mutation.CreatePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_createPublicKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePublicKey(childComplexity, args["publicKeyInput"].(PublicKeyInput)), true

	case "Mutation.deactivateStepbackTask":
		if e.complexity.Mutation.DeactivateStepbackTask == nil {
			break
		}

		args, err := ec.field_Mutation_deactivateStepbackTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeactivateStepbackTask(childComplexity, args["opts"].(DeactivateStepbackTaskInput)), true

	case "Mutation.defaultSectionToRepo":
		if e.complexity.Mutation.DefaultSectionToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_defaultSectionToRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DefaultSectionToRepo(childComplexity, args["opts"].(DefaultSectionToRepoInput)), true

	case "Mutation.deleteDistro":
		if e.complexity.Mutation.DeleteDistro == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDistro(childComplexity, args["opts"].(DeleteDistroInput)), true

	case "Mutation.deleteGithubAppCredentials":
		if e.complexity.Mutation.DeleteGithubAppCredentials == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGithubAppCredentials_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGithubAppCredentials(childComplexity, args["opts"].(DeleteGithubAppCredentialsInput)), true

	case "Mutation.deleteProject":
		if e.complexity.Mutation.DeleteProject == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProject(childComplexity, args["projectId"].(string)), true

	case "Mutation.deleteSubscriptions":
		if e.complexity.Mutation.DeleteSubscriptions == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSubscriptions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSubscriptions(childComplexity, args["subscriptionIds"].([]string)), true

	case "Mutation.detachProjectFromRepo":
		if e.complexity.Mutation.DetachProjectFromRepo == nil {
			break
		}

		args, err := ec.field_Mutation_detachProjectFromRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DetachProjectFromRepo(childComplexity, args["projectId"].(string)), true

	case "Mutation.detachVolumeFromHost":
		if e.complexity.Mutation.DetachVolumeFromHost == nil {
			break
		}

		args, err := ec.field_Mutation_detachVolumeFromHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DetachVolumeFromHost(childComplexity, args["volumeId"].(string)), true

	case "Mutation.editAnnotationNote":
		if e.complexity.Mutation.EditAnnotationNote == nil {
			break
		}

		args, err := ec.field_Mutation_editAnnotationNote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditAnnotationNote(childComplexity, args["taskId"].(string), args["execution"].(int), args["originalMessage"].(string), args["newMessage"].(string)), true

	case "Mutation.editSpawnHost":
		if e.complexity.Mutation.EditSpawnHost == nil {
			break
		}

		args, err := ec.field_Mutation_editSpawnHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditSpawnHost(childComplexity, args["spawnHost"].(*EditSpawnHostInput)), true

	case "Mutation.forceRepotrackerRun":
		if e.complexity.Mutation.ForceRepotrackerRun == nil {
			break
		}

		args, err := ec.field_Mutation_forceRepotrackerRun_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ForceRepotrackerRun(childComplexity, args["projectId"].(string)), true

	case "Mutation.migrateVolume":
		if e.complexity.Mutation.MigrateVolume == nil {
			break
		}

		args, err := ec.field_Mutation_migrateVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MigrateVolume(childComplexity, args["volumeId"].(string), args["spawnHostInput"].(*SpawnHostInput)), true

	case "Mutation.moveAnnotationIssue":
		if e.complexity.Mutation.MoveAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_moveAnnotationIssue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MoveAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true

	case "Mutation.overrideTaskDependencies":
		if e.complexity.Mutation.OverrideTaskDependencies == nil {
			break
		}

		args, err := ec.field_Mutation_overrideTaskDependencies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OverrideTaskDependencies(childComplexity, args["taskId"].(string)), true

	case "Mutation.promoteVarsToRepo":
		if e.complexity.Mutation.PromoteVarsToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_promoteVarsToRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PromoteVarsToRepo(childComplexity, args["opts"].(PromoteVarsToRepoInput)), true

	case "Mutation.removeAnnotationIssue":
		if e.complexity.Mutation.RemoveAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_removeAnnotationIssue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true

	case "Mutation.removeFavoriteProject":
		if e.complexity.Mutation.RemoveFavoriteProject == nil {
			break
		}

		args, err := ec.field_Mutation_removeFavoriteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveFavoriteProject(childComplexity, args["opts"].(RemoveFavoriteProjectInput)), true

	case "Mutation.removePublicKey":
		if e.complexity.Mutation.RemovePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_removePublicKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemovePublicKey(childComplexity, args["keyName"].(string)), true

	case "Mutation.removeVolume":
		if e.complexity.Mutation.RemoveVolume == nil {
			break
		}

		args, err := ec.field_Mutation_removeVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveVolume(childComplexity, args["volumeId"].(string)), true

	case "Mutation.reprovisionToNew":
		if e.complexity.Mutation.ReprovisionToNew == nil {
			break
		}

		args, err := ec.field_Mutation_reprovisionToNew_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReprovisionToNew(childComplexity, args["hostIds"].([]string)), true

	case "Mutation.restartJasper":
		if e.complexity.Mutation.RestartJasper == nil {
			break
		}

		args, err := ec.field_Mutation_restartJasper_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartJasper(childComplexity, args["hostIds"].([]string)), true

	case "Mutation.restartTask":
		if e.complexity.Mutation.RestartTask == nil {
			break
		}

		args, err := ec.field_Mutation_restartTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartTask(childComplexity, args["taskId"].(string), args["failedOnly"].(bool)), true

	case "Mutation.restartVersions":
		if e.complexity.Mutation.RestartVersions == nil {
			break
		}

		args, err := ec.field_Mutation_restartVersions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartVersions(childComplexity, args["versionId"].(string), args["abort"].(bool), args["versionsToRestart"].([]*model1.VersionToRestart)), true

	case "Mutation.saveDistro":
		if e.complexity.Mutation.SaveDistro == nil {
			break
		}

		args, err := ec.field_Mutation_saveDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveDistro(childComplexity, args["opts"].(SaveDistroInput)), true

	case "Mutation.saveProjectSettingsForSection":
		if e.complexity.Mutation.SaveProjectSettingsForSection == nil {
			break
		}

		args, err := ec.field_Mutation_saveProjectSettingsForSection_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveProjectSettingsForSection(childComplexity, args["projectSettings"].(*model.APIProjectSettings), args["section"].(ProjectSettingsSection)), true

	case "Mutation.saveRepoSettingsForSection":
		if e.complexity.Mutation.SaveRepoSettingsForSection == nil {
			break
		}

		args, err := ec.field_Mutation_saveRepoSettingsForSection_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveRepoSettingsForSection(childComplexity, args["repoSettings"].(*model.APIProjectSettings), args["section"].(ProjectSettingsSection)), true

	case "Mutation.saveSubscription":
		if e.complexity.Mutation.SaveSubscription == nil {
			break
		}

		args, err := ec.field_Mutation_saveSubscription_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveSubscription(childComplexity, args["subscription"].(model.APISubscription)), true

	case "Mutation.schedulePatch":
		if e.complexity.Mutation.SchedulePatch == nil {
			break
		}

		args, err := ec.field_Mutation_schedulePatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SchedulePatch(childComplexity, args["patchId"].(string), args["configure"].(PatchConfigure)), true

	case "Mutation.scheduleTasks":
		if e.complexity.Mutation.ScheduleTasks == nil {
			break
		}

		args, err := ec.field_Mutation_scheduleTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScheduleTasks(childComplexity, args["versionId"].(string), args["taskIds"].([]string)), true

	case "Mutation.scheduleUndispatchedBaseTasks":
		if e.complexity.Mutation.ScheduleUndispatchedBaseTasks == nil {
			break
		}

		args, err := ec.field_Mutation_scheduleUndispatchedBaseTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScheduleUndispatchedBaseTasks(childComplexity, args["versionId"].(string)), true

	case "Mutation.setAnnotationMetadataLinks":
		if e.complexity.Mutation.SetAnnotationMetadataLinks == nil {
			break
		}

		args, err := ec.field_Mutation_setAnnotationMetadataLinks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetAnnotationMetadataLinks(childComplexity, args["taskId"].(string), args["execution"].(int), args["metadataLinks"].([]*model.APIMetadataLink)), true

	case "Mutation.setLastRevision":
		if e.complexity.Mutation.SetLastRevision == nil {
			break
		}

		args, err := ec.field_Mutation_setLastRevision_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetLastRevision(childComplexity, args["opts"].(SetLastRevisionInput)), true

	case "Mutation.setPatchVisibility":
		if e.complexity.Mutation.SetPatchVisibility == nil {
			break
		}

		args, err := ec.field_Mutation_setPatchVisibility_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetPatchVisibility(childComplexity, args["patchIds"].([]string), args["hidden"].(bool)), true

	case "Mutation.setTaskPriority":
		if e.complexity.Mutation.SetTaskPriority == nil {
			break
		}

		args, err := ec.field_Mutation_setTaskPriority_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTaskPriority(childComplexity, args["taskId"].(string), args["priority"].(int)), true

	case "Mutation.setVersionPriority":
		if e.complexity.Mutation.SetVersionPriority == nil {
			break
		}

		args, err := ec.field_Mutation_setVersionPriority_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetVersionPriority(childComplexity, args["versionId"].(string), args["priority"].(int)), true

	case "Mutation.spawnHost":
		if e.complexity.Mutation.SpawnHost == nil {
			break
		}

		args, err := ec.field_Mutation_spawnHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SpawnHost(childComplexity, args["spawnHostInput"].(*SpawnHostInput)), true

	case "Mutation.spawnVolume":
		if e.complexity.Mutation.SpawnVolume == nil {
			break
		}

		args, err := ec.field_Mutation_spawnVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SpawnVolume(childComplexity, args["spawnVolumeInput"].(SpawnVolumeInput)), true

	case "Mutation.unscheduleTask":
		if e.complexity.Mutation.UnscheduleTask == nil {
			break
		}

		args, err := ec.field_Mutation_unscheduleTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnscheduleTask(childComplexity, args["taskId"].(string)), true

	case "Mutation.unscheduleVersionTasks":
		if e.complexity.Mutation.UnscheduleVersionTasks == nil {
			break
		}

		args, err := ec.field_Mutation_unscheduleVersionTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnscheduleVersionTasks(childComplexity, args["versionId"].(string), args["abort"].(bool)), true

	case "Mutation.updateBetaFeatures":
		if e.complexity.Mutation.UpdateBetaFeatures == nil {
			break
		}

		args, err := ec.field_Mutation_updateBetaFeatures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBetaFeatures(childComplexity, args["opts"].(UpdateBetaFeaturesInput)), true

	case "Mutation.updateHostStatus":
		if e.complexity.Mutation.UpdateHostStatus == nil {
			break
		}

		args, err := ec.field_Mutation_updateHostStatus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateHostStatus(childComplexity, args["hostIds"].([]string), args["status"].(string), args["notes"].(*string)), true

	case "Mutation.updateParsleySettings":
		if e.complexity.Mutation.UpdateParsleySettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateParsleySettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateParsleySettings(childComplexity, args["opts"].(UpdateParsleySettingsInput)), true

	case "Mutation.updatePublicKey":
		if e.complexity.Mutation.UpdatePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_updatePublicKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePublicKey(childComplexity, args["targetKeyName"].(string), args["updateInfo"].(PublicKeyInput)), true

	case "Mutation.updateSpawnHostStatus":
		if e.complexity.Mutation.UpdateSpawnHostStatus == nil {
			break
		}

		args, err := ec.field_Mutation_updateSpawnHostStatus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSpawnHostStatus(childComplexity, args["updateSpawnHostStatusInput"].(UpdateSpawnHostStatusInput)), true

	case "Mutation.updateUserSettings":
		if e.complexity.Mutation.UpdateUserSettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserSettings(childComplexity, args["userSettings"].(*model.APIUserSettings)), true

	case "Mutation.updateVolume":
		if e.complexity.Mutation.UpdateVolume == nil {
			break
		}

		args, err := ec.field_Mutation_updateVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVolume(childComplexity, args["updateVolumeInput"].(UpdateVolumeInput)), true

	case "NewDistroPayload.newDistroId":
		if e.complexity.NewDistroPayload.NewDistroID == nil {
			break
		}

		return e.complexity.NewDistroPayload.NewDistroID(childComplexity), true

	case "Note.message":
		if e.complexity.Note.Message == nil {
			break
		}

		return e.complexity.Note.Message(childComplexity), true

	case "Note.source":
		if e.complexity.Note.Source == nil {
			break
		}

		return e.complexity.Note.Source(childComplexity), true

	case "Notifications.buildBreak":
		if e.complexity.Notifications.BuildBreak == nil {
			break
		}

		return e.complexity.Notifications.BuildBreak(childComplexity), true

	case "Notifications.buildBreakId":
		if e.complexity.Notifications.BuildBreakID == nil {
			break
		}

		return e.complexity.Notifications.BuildBreakID(childComplexity), true

	case "Notifications.patchFinish":
		if e.complexity.Notifications.PatchFinish == nil {
			break
		}

		return e.complexity.Notifications.PatchFinish(childComplexity), true

	case "Notifications.patchFinishId":
		if e.complexity.Notifications.PatchFinishID == nil {
			break
		}

		return e.complexity.Notifications.PatchFinishID(childComplexity), true

	case "Notifications.patchFirstFailure":
		if e.complexity.Notifications.PatchFirstFailure == nil {
			break
		}

		return e.complexity.Notifications.PatchFirstFailure(childComplexity), true

	case "Notifications.patchFirstFailureId":
		if e.complexity.Notifications.PatchFirstFailureID == nil {
			break
		}

		return e.complexity.Notifications.PatchFirstFailureID(childComplexity), true

	case "Notifications.spawnHostExpiration":
		if e.complexity.Notifications.SpawnHostExpiration == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostExpiration(childComplexity), true

	case "Notifications.spawnHostExpirationId":
		if e.complexity.Notifications.SpawnHostExpirationID == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostExpirationID(childComplexity), true

	case "Notifications.spawnHostOutcome":
		if e.complexity.Notifications.SpawnHostOutcome == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostOutcome(childComplexity), true

	case "Notifications.spawnHostOutcomeId":
		if e.complexity.Notifications.SpawnHostOutcomeID == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostOutcomeID(childComplexity), true

	case "OSInfo.name":
		if e.complexity.OSInfo.Name == nil {
			break
		}

		return e.complexity.OSInfo.Name(childComplexity), true

	case "OSInfo.version":
		if e.complexity.OSInfo.Version == nil {
			break
		}

		return e.complexity.OSInfo.Version(childComplexity), true

	case "OomTrackerInfo.detected":
		if e.complexity.OomTrackerInfo.Detected == nil {
			break
		}

		return e.complexity.OomTrackerInfo.Detected(childComplexity), true

	case "OomTrackerInfo.pids":
		if e.complexity.OomTrackerInfo.Pids == nil {
			break
		}

		return e.complexity.OomTrackerInfo.Pids(childComplexity), true

	case "Package.manager":
		if e.complexity.Package.Manager == nil {
			break
		}

		return e.complexity.Package.Manager(childComplexity), true

	case "Package.name":
		if e.complexity.Package.Name == nil {
			break
		}

		return e.complexity.Package.Name(childComplexity), true

	case "Package.version":
		if e.complexity.Package.Version == nil {
			break
		}

		return e.complexity.Package.Version(childComplexity), true

	case "Parameter.key":
		if e.complexity.Parameter.Key == nil {
			break
		}

		return e.complexity.Parameter.Key(childComplexity), true

	case "Parameter.value":
		if e.complexity.Parameter.Value == nil {
			break
		}

		return e.complexity.Parameter.Value(childComplexity), true

	case "ParsleyFilter.caseSensitive":
		if e.complexity.ParsleyFilter.CaseSensitive == nil {
			break
		}

		return e.complexity.ParsleyFilter.CaseSensitive(childComplexity), true

	case "ParsleyFilter.exactMatch":
		if e.complexity.ParsleyFilter.ExactMatch == nil {
			break
		}

		return e.complexity.ParsleyFilter.ExactMatch(childComplexity), true

	case "ParsleyFilter.expression":
		if e.complexity.ParsleyFilter.Expression == nil {
			break
		}

		return e.complexity.ParsleyFilter.Expression(childComplexity), true

	case "ParsleySettings.jumpToFailingLineEnabled":
		if e.complexity.ParsleySettings.JumpToFailingLineEnabled == nil {
			break
		}

		return e.complexity.ParsleySettings.JumpToFailingLineEnabled(childComplexity), true

	case "ParsleySettings.sectionsEnabled":
		if e.complexity.ParsleySettings.SectionsEnabled == nil {
			break
		}

		return e.complexity.ParsleySettings.SectionsEnabled(childComplexity), true

	case "Patch.activated":
		if e.complexity.Patch.Activated == nil {
			break
		}

		return e.complexity.Patch.Activated(childComplexity), true

	case "Patch.alias":
		if e.complexity.Patch.Alias == nil {
			break
		}

		return e.complexity.Patch.Alias(childComplexity), true

	case "Patch.author":
		if e.complexity.Patch.Author == nil {
			break
		}

		return e.complexity.Patch.Author(childComplexity), true

	case "Patch.authorDisplayName":
		if e.complexity.Patch.AuthorDisplayName == nil {
			break
		}

		return e.complexity.Patch.AuthorDisplayName(childComplexity), true

	case "Patch.baseTaskStatuses":
		if e.complexity.Patch.BaseTaskStatuses == nil {
			break
		}

		return e.complexity.Patch.BaseTaskStatuses(childComplexity), true

	case "Patch.builds":
		if e.complexity.Patch.Builds == nil {
			break
		}

		return e.complexity.Patch.Builds(childComplexity), true

	case "Patch.childPatchAliases":
		if e.complexity.Patch.ChildPatchAliases == nil {
			break
		}

		return e.complexity.Patch.ChildPatchAliases(childComplexity), true

	case "Patch.childPatches":
		if e.complexity.Patch.ChildPatches == nil {
			break
		}

		return e.complexity.Patch.ChildPatches(childComplexity), true

	case "Patch.createTime":
		if e.complexity.Patch.CreateTime == nil {
			break
		}

		return e.complexity.Patch.CreateTime(childComplexity), true

	case "Patch.description":
		if e.complexity.Patch.Description == nil {
			break
		}

		return e.complexity.Patch.Description(childComplexity), true

	case "Patch.duration":
		if e.complexity.Patch.Duration == nil {
			break
		}

		return e.complexity.Patch.Duration(childComplexity), true

	case "Patch.generatedTaskCounts":
		if e.complexity.Patch.GeneratedTaskCounts == nil {
			break
		}

		return e.complexity.Patch.GeneratedTaskCounts(childComplexity), true

	case "Patch.githash":
		if e.complexity.Patch.Githash == nil {
			break
		}

		return e.complexity.Patch.Githash(childComplexity), true

	case "Patch.hidden":
		if e.complexity.Patch.Hidden == nil {
			break
		}

		return e.complexity.Patch.Hidden(childComplexity), true

	case "Patch.id":
		if e.complexity.Patch.Id == nil {
			break
		}

		return e.complexity.Patch.Id(childComplexity), true

	case "Patch.moduleCodeChanges":
		if e.complexity.Patch.ModuleCodeChanges == nil {
			break
		}

		return e.complexity.Patch.ModuleCodeChanges(childComplexity), true

	case "Patch.parameters":
		if e.complexity.Patch.Parameters == nil {
			break
		}

		return e.complexity.Patch.Parameters(childComplexity), true

	case "Patch.patchNumber":
		if e.complexity.Patch.PatchNumber == nil {
			break
		}

		return e.complexity.Patch.PatchNumber(childComplexity), true

	case "Patch.patchTriggerAliases":
		if e.complexity.Patch.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.Patch.PatchTriggerAliases(childComplexity), true

	case "Patch.project":
		if e.complexity.Patch.Project == nil {
			break
		}

		return e.complexity.Patch.Project(childComplexity), true

	case "Patch.projectID":
		if e.complexity.Patch.ProjectId == nil {
			break
		}

		return e.complexity.Patch.ProjectId(childComplexity), true

	case "Patch.projectIdentifier":
		if e.complexity.Patch.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Patch.ProjectIdentifier(childComplexity), true

	case "Patch.projectMetadata":
		if e.complexity.Patch.ProjectMetadata == nil {
			break
		}

		return e.complexity.Patch.ProjectMetadata(childComplexity), true

	case "Patch.status":
		if e.complexity.Patch.Status == nil {
			break
		}

		return e.complexity.Patch.Status(childComplexity), true

	case "Patch.taskCount":
		if e.complexity.Patch.TaskCount == nil {
			break
		}

		return e.complexity.Patch.TaskCount(childComplexity), true

	case "Patch.taskStatuses":
		if e.complexity.Patch.TaskStatuses == nil {
			break
		}

		return e.complexity.Patch.TaskStatuses(childComplexity), true

	case "Patch.tasks":
		if e.complexity.Patch.Tasks == nil {
			break
		}

		return e.complexity.Patch.Tasks(childComplexity), true

	case "Patch.time":
		if e.complexity.Patch.Time == nil {
			break
		}

		return e.complexity.Patch.Time(childComplexity), true

	case "Patch.variants":
		if e.complexity.Patch.Variants == nil {
			break
		}

		return e.complexity.Patch.Variants(childComplexity), true

	case "Patch.variantsTasks":
		if e.complexity.Patch.VariantsTasks == nil {
			break
		}

		return e.complexity.Patch.VariantsTasks(childComplexity), true

	case "Patch.versionFull":
		if e.complexity.Patch.VersionFull == nil {
			break
		}

		return e.complexity.Patch.VersionFull(childComplexity), true

	case "PatchDuration.makespan":
		if e.complexity.PatchDuration.Makespan == nil {
			break
		}

		return e.complexity.PatchDuration.Makespan(childComplexity), true

	case "PatchDuration.time":
		if e.complexity.PatchDuration.Time == nil {
			break
		}

		return e.complexity.PatchDuration.Time(childComplexity), true

	case "PatchDuration.timeTaken":
		if e.complexity.PatchDuration.TimeTaken == nil {
			break
		}

		return e.complexity.PatchDuration.TimeTaken(childComplexity), true

	case "PatchProject.variants":
		if e.complexity.PatchProject.Variants == nil {
			break
		}

		return e.complexity.PatchProject.Variants(childComplexity), true

	case "PatchTime.finished":
		if e.complexity.PatchTime.Finished == nil {
			break
		}

		return e.complexity.PatchTime.Finished(childComplexity), true

	case "PatchTime.started":
		if e.complexity.PatchTime.Started == nil {
			break
		}

		return e.complexity.PatchTime.Started(childComplexity), true

	case "PatchTime.submittedAt":
		if e.complexity.PatchTime.SubmittedAt == nil {
			break
		}

		return e.complexity.PatchTime.SubmittedAt(childComplexity), true

	case "PatchTriggerAlias.alias":
		if e.complexity.PatchTriggerAlias.Alias == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.Alias(childComplexity), true

	case "PatchTriggerAlias.childProjectId":
		if e.complexity.PatchTriggerAlias.ChildProjectId == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ChildProjectId(childComplexity), true

	case "PatchTriggerAlias.childProjectIdentifier":
		if e.complexity.PatchTriggerAlias.ChildProjectIdentifier == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ChildProjectIdentifier(childComplexity), true

	case "PatchTriggerAlias.downstreamRevision":
		if e.complexity.PatchTriggerAlias.DownstreamRevision == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.DownstreamRevision(childComplexity), true

	case "PatchTriggerAlias.parentAsModule":
		if e.complexity.PatchTriggerAlias.ParentAsModule == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ParentAsModule(childComplexity), true

	case "PatchTriggerAlias.status":
		if e.complexity.PatchTriggerAlias.Status == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.Status(childComplexity), true

	case "PatchTriggerAlias.taskSpecifiers":
		if e.complexity.PatchTriggerAlias.TaskSpecifiers == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.TaskSpecifiers(childComplexity), true

	case "PatchTriggerAlias.variantsTasks":
		if e.complexity.PatchTriggerAlias.VariantsTasks == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.VariantsTasks(childComplexity), true

	case "Patches.filteredPatchCount":
		if e.complexity.Patches.FilteredPatchCount == nil {
			break
		}

		return e.complexity.Patches.FilteredPatchCount(childComplexity), true

	case "Patches.patches":
		if e.complexity.Patches.Patches == nil {
			break
		}

		return e.complexity.Patches.Patches(childComplexity), true

	case "PeriodicBuild.alias":
		if e.complexity.PeriodicBuild.Alias == nil {
			break
		}

		return e.complexity.PeriodicBuild.Alias(childComplexity), true

	case "PeriodicBuild.configFile":
		if e.complexity.PeriodicBuild.ConfigFile == nil {
			break
		}

		return e.complexity.PeriodicBuild.ConfigFile(childComplexity), true

	case "PeriodicBuild.cron":
		if e.complexity.PeriodicBuild.Cron == nil {
			break
		}

		return e.complexity.PeriodicBuild.Cron(childComplexity), true

	case "PeriodicBuild.id":
		if e.complexity.PeriodicBuild.ID == nil {
			break
		}

		return e.complexity.PeriodicBuild.ID(childComplexity), true

	case "PeriodicBuild.intervalHours":
		if e.complexity.PeriodicBuild.IntervalHours == nil {
			break
		}

		return e.complexity.PeriodicBuild.IntervalHours(childComplexity), true

	case "PeriodicBuild.message":
		if e.complexity.PeriodicBuild.Message == nil {
			break
		}

		return e.complexity.PeriodicBuild.Message(childComplexity), true

	case "PeriodicBuild.nextRunTime":
		if e.complexity.PeriodicBuild.NextRunTime == nil {
			break
		}

		return e.complexity.PeriodicBuild.NextRunTime(childComplexity), true

	case "Permissions.canCreateDistro":
		if e.complexity.Permissions.CanCreateDistro == nil {
			break
		}

		return e.complexity.Permissions.CanCreateDistro(childComplexity), true

	case "Permissions.canCreateProject":
		if e.complexity.Permissions.CanCreateProject == nil {
			break
		}

		return e.complexity.Permissions.CanCreateProject(childComplexity), true

	case "Permissions.canEditAdminSettings":
		if e.complexity.Permissions.CanEditAdminSettings == nil {
			break
		}

		return e.complexity.Permissions.CanEditAdminSettings(childComplexity), true

	case "Permissions.distroPermissions":
		if e.complexity.Permissions.DistroPermissions == nil {
			break
		}

		args, err := ec.field_Permissions_distroPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Permissions.DistroPermissions(childComplexity, args["options"].(DistroPermissionsOptions)), true

	case "Permissions.projectPermissions":
		if e.complexity.Permissions.ProjectPermissions == nil {
			break
		}

		args, err := ec.field_Permissions_projectPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Permissions.ProjectPermissions(childComplexity, args["options"].(ProjectPermissionsOptions)), true

	case "Permissions.repoPermissions":
		if e.complexity.Permissions.RepoPermissions == nil {
			break
		}

		args, err := ec.field_Permissions_repoPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Permissions.RepoPermissions(childComplexity, args["options"].(RepoPermissionsOptions)), true

	case "Permissions.userId":
		if e.complexity.Permissions.UserID == nil {
			break
		}

		return e.complexity.Permissions.UserID(childComplexity), true

	case "PlannerSettings.commitQueueFactor":
		if e.complexity.PlannerSettings.CommitQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.CommitQueueFactor(childComplexity), true

	case "PlannerSettings.expectedRuntimeFactor":
		if e.complexity.PlannerSettings.ExpectedRuntimeFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.ExpectedRuntimeFactor(childComplexity), true

	case "PlannerSettings.generateTaskFactor":
		if e.complexity.PlannerSettings.GenerateTaskFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.GenerateTaskFactor(childComplexity), true

	case "PlannerSettings.groupVersions":
		if e.complexity.PlannerSettings.GroupVersions == nil {
			break
		}

		return e.complexity.PlannerSettings.GroupVersions(childComplexity), true

	case "PlannerSettings.mainlineTimeInQueueFactor":
		if e.complexity.PlannerSettings.MainlineTimeInQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.MainlineTimeInQueueFactor(childComplexity), true

	case "PlannerSettings.numDependentsFactor":
		if e.complexity.PlannerSettings.NumDependentsFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.NumDependentsFactor(childComplexity), true

	case "PlannerSettings.patchFactor":
		if e.complexity.PlannerSettings.PatchFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.PatchFactor(childComplexity), true

	case "PlannerSettings.patchTimeInQueueFactor":
		if e.complexity.PlannerSettings.PatchTimeInQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.PatchTimeInQueueFactor(childComplexity), true

	case "PlannerSettings.targetTime":
		if e.complexity.PlannerSettings.TargetTime == nil {
			break
		}

		return e.complexity.PlannerSettings.TargetTime(childComplexity), true

	case "PlannerSettings.version":
		if e.complexity.PlannerSettings.Version == nil {
			break
		}

		return e.complexity.PlannerSettings.Version(childComplexity), true

	case "Pod.events":
		if e.complexity.Pod.Events == nil {
			break
		}

		args, err := ec.field_Pod_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Pod.Events(childComplexity, args["limit"].(*int), args["page"].(*int)), true

	case "Pod.id":
		if e.complexity.Pod.ID == nil {
			break
		}

		return e.complexity.Pod.ID(childComplexity), true

	case "Pod.status":
		if e.complexity.Pod.Status == nil {
			break
		}

		return e.complexity.Pod.Status(childComplexity), true

	case "Pod.task":
		if e.complexity.Pod.Task == nil {
			break
		}

		return e.complexity.Pod.Task(childComplexity), true

	case "Pod.taskContainerCreationOpts":
		if e.complexity.Pod.TaskContainerCreationOpts == nil {
			break
		}

		return e.complexity.Pod.TaskContainerCreationOpts(childComplexity), true

	case "Pod.type":
		if e.complexity.Pod.Type == nil {
			break
		}

		return e.complexity.Pod.Type(childComplexity), true

	case "PodEventLogData.newStatus":
		if e.complexity.PodEventLogData.NewStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.NewStatus(childComplexity), true

	case "PodEventLogData.oldStatus":
		if e.complexity.PodEventLogData.OldStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.OldStatus(childComplexity), true

	case "PodEventLogData.reason":
		if e.complexity.PodEventLogData.Reason == nil {
			break
		}

		return e.complexity.PodEventLogData.Reason(childComplexity), true

	case "PodEventLogData.task":
		if e.complexity.PodEventLogData.Task == nil {
			break
		}

		return e.complexity.PodEventLogData.Task(childComplexity), true

	case "PodEventLogData.taskExecution":
		if e.complexity.PodEventLogData.TaskExecution == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskExecution(childComplexity), true

	case "PodEventLogData.taskID":
		if e.complexity.PodEventLogData.TaskID == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskID(childComplexity), true

	case "PodEventLogData.taskStatus":
		if e.complexity.PodEventLogData.TaskStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskStatus(childComplexity), true

	case "PodEventLogEntry.data":
		if e.complexity.PodEventLogEntry.Data == nil {
			break
		}

		return e.complexity.PodEventLogEntry.Data(childComplexity), true

	case "PodEventLogEntry.eventType":
		if e.complexity.PodEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.PodEventLogEntry.EventType(childComplexity), true

	case "PodEventLogEntry.id":
		if e.complexity.PodEventLogEntry.ID == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ID(childComplexity), true

	case "PodEventLogEntry.processedAt":
		if e.complexity.PodEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ProcessedAt(childComplexity), true

	case "PodEventLogEntry.resourceId":
		if e.complexity.PodEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ResourceId(childComplexity), true

	case "PodEventLogEntry.resourceType":
		if e.complexity.PodEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ResourceType(childComplexity), true

	case "PodEventLogEntry.timestamp":
		if e.complexity.PodEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.PodEventLogEntry.Timestamp(childComplexity), true

	case "PodEvents.count":
		if e.complexity.PodEvents.Count == nil {
			break
		}

		return e.complexity.PodEvents.Count(childComplexity), true

	case "PodEvents.eventLogEntries":
		if e.complexity.PodEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.PodEvents.EventLogEntries(childComplexity), true

	case "PreconditionScript.path":
		if e.complexity.PreconditionScript.Path == nil {
			break
		}

		return e.complexity.PreconditionScript.Path(childComplexity), true

	case "PreconditionScript.script":
		if e.complexity.PreconditionScript.Script == nil {
			break
		}

		return e.complexity.PreconditionScript.Script(childComplexity), true

	case "Project.admins":
		if e.complexity.Project.Admins == nil {
			break
		}

		return e.complexity.Project.Admins(childComplexity), true

	case "Project.banner":
		if e.complexity.Project.Banner == nil {
			break
		}

		return e.complexity.Project.Banner(childComplexity), true

	case "Project.batchTime":
		if e.complexity.Project.BatchTime == nil {
			break
		}

		return e.complexity.Project.BatchTime(childComplexity), true

	case "Project.branch":
		if e.complexity.Project.Branch == nil {
			break
		}

		return e.complexity.Project.Branch(childComplexity), true

	case "Project.buildBaronSettings":
		if e.complexity.Project.BuildBaronSettings == nil {
			break
		}

		return e.complexity.Project.BuildBaronSettings(childComplexity), true

	case "Project.commitQueue":
		if e.complexity.Project.CommitQueue == nil {
			break
		}

		return e.complexity.Project.CommitQueue(childComplexity), true

	case "Project.containerSizeDefinitions":
		if e.complexity.Project.ContainerSizeDefinitions == nil {
			break
		}

		return e.complexity.Project.ContainerSizeDefinitions(childComplexity), true

	case "Project.deactivatePrevious":
		if e.complexity.Project.DeactivatePrevious == nil {
			break
		}

		return e.complexity.Project.DeactivatePrevious(childComplexity), true

	case "Project.disabledStatsCache":
		if e.complexity.Project.DisabledStatsCache == nil {
			break
		}

		return e.complexity.Project.DisabledStatsCache(childComplexity), true

	case "Project.dispatchingDisabled":
		if e.complexity.Project.DispatchingDisabled == nil {
			break
		}

		return e.complexity.Project.DispatchingDisabled(childComplexity), true

	case "Project.displayName":
		if e.complexity.Project.DisplayName == nil {
			break
		}

		return e.complexity.Project.DisplayName(childComplexity), true

	case "Project.enabled":
		if e.complexity.Project.Enabled == nil {
			break
		}

		return e.complexity.Project.Enabled(childComplexity), true

	case "Project.externalLinks":
		if e.complexity.Project.ExternalLinks == nil {
			break
		}

		return e.complexity.Project.ExternalLinks(childComplexity), true

	case "Project.githubDynamicTokenPermissionGroups":
		if e.complexity.Project.GitHubDynamicTokenPermissionGroups == nil {
			break
		}

		return e.complexity.Project.GitHubDynamicTokenPermissionGroups(childComplexity), true

	case "Project.githubPermissionGroupByRequester":
		if e.complexity.Project.GitHubPermissionGroupByRequester == nil {
			break
		}

		return e.complexity.Project.GitHubPermissionGroupByRequester(childComplexity), true

	case "Project.gitTagAuthorizedTeams":
		if e.complexity.Project.GitTagAuthorizedTeams == nil {
			break
		}

		return e.complexity.Project.GitTagAuthorizedTeams(childComplexity), true

	case "Project.gitTagAuthorizedUsers":
		if e.complexity.Project.GitTagAuthorizedUsers == nil {
			break
		}

		return e.complexity.Project.GitTagAuthorizedUsers(childComplexity), true

	case "Project.gitTagVersionsEnabled":
		if e.complexity.Project.GitTagVersionsEnabled == nil {
			break
		}

		return e.complexity.Project.GitTagVersionsEnabled(childComplexity), true

	case "Project.githubChecksEnabled":
		if e.complexity.Project.GithubChecksEnabled == nil {
			break
		}

		return e.complexity.Project.GithubChecksEnabled(childComplexity), true

	case "Project.githubTriggerAliases":
		if e.complexity.Project.GithubTriggerAliases == nil {
			break
		}

		return e.complexity.Project.GithubTriggerAliases(childComplexity), true

	case "Project.hidden":
		if e.complexity.Project.Hidden == nil {
			break
		}

		return e.complexity.Project.Hidden(childComplexity), true

	case "Project.id":
		if e.complexity.Project.Id == nil {
			break
		}

		return e.complexity.Project.Id(childComplexity), true

	case "Project.identifier":
		if e.complexity.Project.Identifier == nil {
			break
		}

		return e.complexity.Project.Identifier(childComplexity), true

	case "Project.isFavorite":
		if e.complexity.Project.IsFavorite == nil {
			break
		}

		return e.complexity.Project.IsFavorite(childComplexity), true

	case "Project.manualPrTestingEnabled":
		if e.complexity.Project.ManualPRTestingEnabled == nil {
			break
		}

		return e.complexity.Project.ManualPRTestingEnabled(childComplexity), true

	case "Project.notifyOnBuildFailure":
		if e.complexity.Project.NotifyOnBuildFailure == nil {
			break
		}

		return e.complexity.Project.NotifyOnBuildFailure(childComplexity), true

	case "Project.oldestAllowedMergeBase":
		if e.complexity.Project.OldestAllowedMergeBase == nil {
			break
		}

		return e.complexity.Project.OldestAllowedMergeBase(childComplexity), true

	case "Project.owner":
		if e.complexity.Project.Owner == nil {
			break
		}

		return e.complexity.Project.Owner(childComplexity), true

	case "Project.prTestingEnabled":
		if e.complexity.Project.PRTestingEnabled == nil {
			break
		}

		return e.complexity.Project.PRTestingEnabled(childComplexity), true

	case "Project.parsleyFilters":
		if e.complexity.Project.ParsleyFilters == nil {
			break
		}

		return e.complexity.Project.ParsleyFilters(childComplexity), true

	case "Project.patchTriggerAliases":
		if e.complexity.Project.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.Project.PatchTriggerAliases(childComplexity), true

	case "Project.patches":
		if e.complexity.Project.Patches == nil {
			break
		}

		args, err := ec.field_Project_patches_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.Patches(childComplexity, args["patchesInput"].(PatchesInput)), true

	case "Project.patchingDisabled":
		if e.complexity.Project.PatchingDisabled == nil {
			break
		}

		return e.complexity.Project.PatchingDisabled(childComplexity), true

	case "Project.perfEnabled":
		if e.complexity.Project.PerfEnabled == nil {
			break
		}

		return e.complexity.Project.PerfEnabled(childComplexity), true

	case "Project.periodicBuilds":
		if e.complexity.Project.PeriodicBuilds == nil {
			break
		}

		return e.complexity.Project.PeriodicBuilds(childComplexity), true

	case "Project.projectHealthView":
		if e.complexity.Project.ProjectHealthView == nil {
			break
		}

		return e.complexity.Project.ProjectHealthView(childComplexity), true

	case "Project.remotePath":
		if e.complexity.Project.RemotePath == nil {
			break
		}

		return e.complexity.Project.RemotePath(childComplexity), true

	case "Project.repo":
		if e.complexity.Project.Repo == nil {
			break
		}

		return e.complexity.Project.Repo(childComplexity), true

	case "Project.repoRefId":
		if e.complexity.Project.RepoRefId == nil {
			break
		}

		return e.complexity.Project.RepoRefId(childComplexity), true

	case "Project.repotrackerDisabled":
		if e.complexity.Project.RepotrackerDisabled == nil {
			break
		}

		return e.complexity.Project.RepotrackerDisabled(childComplexity), true

	case "Project.repotrackerError":
		if e.complexity.Project.RepotrackerError == nil {
			break
		}

		return e.complexity.Project.RepotrackerError(childComplexity), true

	case "Project.restricted":
		if e.complexity.Project.Restricted == nil {
			break
		}

		return e.complexity.Project.Restricted(childComplexity), true

	case "Project.spawnHostScriptPath":
		if e.complexity.Project.SpawnHostScriptPath == nil {
			break
		}

		return e.complexity.Project.SpawnHostScriptPath(childComplexity), true

	case "Project.stepbackBisect":
		if e.complexity.Project.StepbackBisect == nil {
			break
		}

		return e.complexity.Project.StepbackBisect(childComplexity), true

	case "Project.stepbackDisabled":
		if e.complexity.Project.StepbackDisabled == nil {
			break
		}

		return e.complexity.Project.StepbackDisabled(childComplexity), true

	case "Project.taskAnnotationSettings":
		if e.complexity.Project.TaskAnnotationSettings == nil {
			break
		}

		return e.complexity.Project.TaskAnnotationSettings(childComplexity), true

	case "Project.tracksPushEvents":
		if e.complexity.Project.TracksPushEvents == nil {
			break
		}

		return e.complexity.Project.TracksPushEvents(childComplexity), true

	case "Project.triggers":
		if e.complexity.Project.Triggers == nil {
			break
		}

		return e.complexity.Project.Triggers(childComplexity), true

	case "Project.versionControlEnabled":
		if e.complexity.Project.VersionControlEnabled == nil {
			break
		}

		return e.complexity.Project.VersionControlEnabled(childComplexity), true

	case "Project.workstationConfig":
		if e.complexity.Project.WorkstationConfig == nil {
			break
		}

		return e.complexity.Project.WorkstationConfig(childComplexity), true

	case "ProjectAlias.alias":
		if e.complexity.ProjectAlias.Alias == nil {
			break
		}

		return e.complexity.ProjectAlias.Alias(childComplexity), true

	case "ProjectAlias.description":
		if e.complexity.ProjectAlias.Description == nil {
			break
		}

		return e.complexity.ProjectAlias.Description(childComplexity), true

	case "ProjectAlias.gitTag":
		if e.complexity.ProjectAlias.GitTag == nil {
			break
		}

		return e.complexity.ProjectAlias.GitTag(childComplexity), true

	case "ProjectAlias.id":
		if e.complexity.ProjectAlias.ID == nil {
			break
		}

		return e.complexity.ProjectAlias.ID(childComplexity), true

	case "ProjectAlias.parameters":
		if e.complexity.ProjectAlias.Parameters == nil {
			break
		}

		return e.complexity.ProjectAlias.Parameters(childComplexity), true

	case "ProjectAlias.remotePath":
		if e.complexity.ProjectAlias.RemotePath == nil {
			break
		}

		return e.complexity.ProjectAlias.RemotePath(childComplexity), true

	case "ProjectAlias.task":
		if e.complexity.ProjectAlias.Task == nil {
			break
		}

		return e.complexity.ProjectAlias.Task(childComplexity), true

	case "ProjectAlias.taskTags":
		if e.complexity.ProjectAlias.TaskTags == nil {
			break
		}

		return e.complexity.ProjectAlias.TaskTags(childComplexity), true

	case "ProjectAlias.variant":
		if e.complexity.ProjectAlias.Variant == nil {
			break
		}

		return e.complexity.ProjectAlias.Variant(childComplexity), true

	case "ProjectAlias.variantTags":
		if e.complexity.ProjectAlias.VariantTags == nil {
			break
		}

		return e.complexity.ProjectAlias.VariantTags(childComplexity), true

	case "ProjectBanner.text":
		if e.complexity.ProjectBanner.Text == nil {
			break
		}

		return e.complexity.ProjectBanner.Text(childComplexity), true

	case "ProjectBanner.theme":
		if e.complexity.ProjectBanner.Theme == nil {
			break
		}

		return e.complexity.ProjectBanner.Theme(childComplexity), true

	case "ProjectBuildVariant.displayName":
		if e.complexity.ProjectBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.DisplayName(childComplexity), true

	case "ProjectBuildVariant.name":
		if e.complexity.ProjectBuildVariant.Name == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.Name(childComplexity), true

	case "ProjectBuildVariant.tasks":
		if e.complexity.ProjectBuildVariant.Tasks == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.Tasks(childComplexity), true

	case "ProjectEventLogEntry.after":
		if e.complexity.ProjectEventLogEntry.After == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.After(childComplexity), true

	case "ProjectEventLogEntry.before":
		if e.complexity.ProjectEventLogEntry.Before == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.Before(childComplexity), true

	case "ProjectEventLogEntry.timestamp":
		if e.complexity.ProjectEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.Timestamp(childComplexity), true

	case "ProjectEventLogEntry.user":
		if e.complexity.ProjectEventLogEntry.User == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.User(childComplexity), true

	case "ProjectEventSettings.aliases":
		if e.complexity.ProjectEventSettings.Aliases == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Aliases(childComplexity), true

	case "ProjectEventSettings.githubAppAuth":
		if e.complexity.ProjectEventSettings.GithubAppAuth == nil {
			break
		}

		return e.complexity.ProjectEventSettings.GithubAppAuth(childComplexity), true

	case "ProjectEventSettings.githubWebhooksEnabled":
		if e.complexity.ProjectEventSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.ProjectEventSettings.GithubWebhooksEnabled(childComplexity), true

	case "ProjectEventSettings.projectRef":
		if e.complexity.ProjectEventSettings.ProjectRef == nil {
			break
		}

		return e.complexity.ProjectEventSettings.ProjectRef(childComplexity), true

	case "ProjectEventSettings.subscriptions":
		if e.complexity.ProjectEventSettings.Subscriptions == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Subscriptions(childComplexity), true

	case "ProjectEventSettings.vars":
		if e.complexity.ProjectEventSettings.Vars == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Vars(childComplexity), true

	case "ProjectEvents.count":
		if e.complexity.ProjectEvents.Count == nil {
			break
		}

		return e.complexity.ProjectEvents.Count(childComplexity), true

	case "ProjectEvents.eventLogEntries":
		if e.complexity.ProjectEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.ProjectEvents.EventLogEntries(childComplexity), true

	case "ProjectPermissions.edit":
		if e.complexity.ProjectPermissions.Edit == nil {
			break
		}

		return e.complexity.ProjectPermissions.Edit(childComplexity), true

	case "ProjectPermissions.view":
		if e.complexity.ProjectPermissions.View == nil {
			break
		}

		return e.complexity.ProjectPermissions.View(childComplexity), true

	case "ProjectSettings.aliases":
		if e.complexity.ProjectSettings.Aliases == nil {
			break
		}

		return e.complexity.ProjectSettings.Aliases(childComplexity), true

	case "ProjectSettings.githubAppAuth":
		if e.complexity.ProjectSettings.GithubAppAuth == nil {
			break
		}

		return e.complexity.ProjectSettings.GithubAppAuth(childComplexity), true

	case "ProjectSettings.githubWebhooksEnabled":
		if e.complexity.ProjectSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.ProjectSettings.GithubWebhooksEnabled(childComplexity), true

	case "ProjectSettings.projectRef":
		if e.complexity.ProjectSettings.ProjectRef == nil {
			break
		}

		return e.complexity.ProjectSettings.ProjectRef(childComplexity), true

	case "ProjectSettings.subscriptions":
		if e.complexity.ProjectSettings.Subscriptions == nil {
			break
		}

		return e.complexity.ProjectSettings.Subscriptions(childComplexity), true

	case "ProjectSettings.vars":
		if e.complexity.ProjectSettings.Vars == nil {
			break
		}

		return e.complexity.ProjectSettings.Vars(childComplexity), true

	case "ProjectTasksPair.allowedBVs":
		if e.complexity.ProjectTasksPair.AllowedBVs == nil {
			break
		}

		return e.complexity.ProjectTasksPair.AllowedBVs(childComplexity), true

	case "ProjectTasksPair.allowedTasks":
		if e.complexity.ProjectTasksPair.AllowedTasks == nil {
			break
		}

		return e.complexity.ProjectTasksPair.AllowedTasks(childComplexity), true

	case "ProjectTasksPair.projectId":
		if e.complexity.ProjectTasksPair.ProjectID == nil {
			break
		}

		return e.complexity.ProjectTasksPair.ProjectID(childComplexity), true

	case "ProjectVars.adminOnlyVars":
		if e.complexity.ProjectVars.AdminOnlyVars == nil {
			break
		}

		return e.complexity.ProjectVars.AdminOnlyVars(childComplexity), true

	case "ProjectVars.privateVars":
		if e.complexity.ProjectVars.PrivateVars == nil {
			break
		}

		return e.complexity.ProjectVars.PrivateVars(childComplexity), true

	case "ProjectVars.vars":
		if e.complexity.ProjectVars.Vars == nil {
			break
		}

		return e.complexity.ProjectVars.Vars(childComplexity), true

	case "PublicKey.key":
		if e.complexity.PublicKey.Key == nil {
			break
		}

		return e.complexity.PublicKey.Key(childComplexity), true

	case "PublicKey.name":
		if e.complexity.PublicKey.Name == nil {
			break
		}

		return e.complexity.PublicKey.Name(childComplexity), true

	case "Query.awsRegions":
		if e.complexity.Query.AWSRegions == nil {
			break
		}

		return e.complexity.Query.AWSRegions(childComplexity), true

	case "Query.bbGetCreatedTickets":
		if e.complexity.Query.BbGetCreatedTickets == nil {
			break
		}

		args, err := ec.field_Query_bbGetCreatedTickets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BbGetCreatedTickets(childComplexity, args["taskId"].(string)), true

	case "Query.buildBaron":
		if e.complexity.Query.BuildBaron == nil {
			break
		}

		args, err := ec.field_Query_buildBaron_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildBaron(childComplexity, args["taskId"].(string), args["execution"].(int)), true

	case "Query.buildVariantsForTaskName":
		if e.complexity.Query.BuildVariantsForTaskName == nil {
			break
		}

		args, err := ec.field_Query_buildVariantsForTaskName_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildVariantsForTaskName(childComplexity, args["projectIdentifier"].(string), args["taskName"].(string)), true

	case "Query.clientConfig":
		if e.complexity.Query.ClientConfig == nil {
			break
		}

		return e.complexity.Query.ClientConfig(childComplexity), true

	case "Query.distro":
		if e.complexity.Query.Distro == nil {
			break
		}

		args, err := ec.field_Query_distro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Distro(childComplexity, args["distroId"].(string)), true

	case "Query.distroEvents":
		if e.complexity.Query.DistroEvents == nil {
			break
		}

		args, err := ec.field_Query_distroEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DistroEvents(childComplexity, args["opts"].(DistroEventsInput)), true

	case "Query.distroTaskQueue":
		if e.complexity.Query.DistroTaskQueue == nil {
			break
		}

		args, err := ec.field_Query_distroTaskQueue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DistroTaskQueue(childComplexity, args["distroId"].(string)), true

	case "Query.distros":
		if e.complexity.Query.Distros == nil {
			break
		}

		args, err := ec.field_Query_distros_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Distros(childComplexity, args["onlySpawnable"].(bool)), true

	case "Query.githubProjectConflicts":
		if e.complexity.Query.GithubProjectConflicts == nil {
			break
		}

		args, err := ec.field_Query_githubProjectConflicts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubProjectConflicts(childComplexity, args["projectId"].(string)), true

	case "Query.hasVersion":
		if e.complexity.Query.HasVersion == nil {
			break
		}

		args, err := ec.field_Query_hasVersion_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasVersion(childComplexity, args["patchId"].(string)), true

	case "Query.host":
		if e.complexity.Query.Host == nil {
			break
		}

		args, err := ec.field_Query_host_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Host(childComplexity, args["hostId"].(string)), true

	case "Query.hostEvents":
		if e.complexity.Query.HostEvents == nil {
			break
		}

		args, err := ec.field_Query_hostEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HostEvents(childComplexity, args["hostId"].(string), args["hostTag"].(*string), args["limit"].(*int), args["page"].(*int)), true

	case "Query.hosts":
		if e.complexity.Query.Hosts == nil {
			break
		}

		args, err := ec.field_Query_hosts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hosts(childComplexity, args["hostId"].(*string), args["distroId"].(*string), args["currentTaskId"].(*string), args["statuses"].([]string), args["startedBy"].(*string), args["sortBy"].(*HostSortBy), args["sortDir"].(*SortDirection), args["page"].(*int), args["limit"].(*int)), true

	case "Query.image":
		if e.complexity.Query.Image == nil {
			break
		}

		args, err := ec.field_Query_image_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Image(childComplexity, args["imageId"].(string)), true

	case "Query.images":
		if e.complexity.Query.Images == nil {
			break
		}

		return e.complexity.Query.Images(childComplexity), true

	case "Query.instanceTypes":
		if e.complexity.Query.InstanceTypes == nil {
			break
		}

		return e.complexity.Query.InstanceTypes(childComplexity), true

	case "Query.isRepo":
		if e.complexity.Query.IsRepo == nil {
			break
		}

		args, err := ec.field_Query_isRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsRepo(childComplexity, args["projectOrRepoId"].(string)), true

	case "Query.logkeeperBuildMetadata":
		if e.complexity.Query.LogkeeperBuildMetadata == nil {
			break
		}

		args, err := ec.field_Query_logkeeperBuildMetadata_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LogkeeperBuildMetadata(childComplexity, args["buildId"].(string)), true

	case "Query.mainlineCommits":
		if e.complexity.Query.MainlineCommits == nil {
			break
		}

		args, err := ec.field_Query_mainlineCommits_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MainlineCommits(childComplexity, args["options"].(MainlineCommitsOptions), args["buildVariantOptions"].(*BuildVariantOptions)), true

	case "Query.myHosts":
		if e.complexity.Query.MyHosts == nil {
			break
		}

		return e.complexity.Query.MyHosts(childComplexity), true

	case "Query.myPublicKeys":
		if e.complexity.Query.MyPublicKeys == nil {
			break
		}

		return e.complexity.Query.MyPublicKeys(childComplexity), true

	case "Query.myVolumes":
		if e.complexity.Query.MyVolumes == nil {
			break
		}

		return e.complexity.Query.MyVolumes(childComplexity), true

	case "Query.patch":
		if e.complexity.Query.Patch == nil {
			break
		}

		args, err := ec.field_Query_patch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Patch(childComplexity, args["patchId"].(string)), true

	case "Query.pod":
		if e.complexity.Query.Pod == nil {
			break
		}

		args, err := ec.field_Query_pod_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Pod(childComplexity, args["podId"].(string)), true

	case "Query.project":
		if e.complexity.Query.Project == nil {
			break
		}

		args, err := ec.field_Query_project_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Project(childComplexity, args["projectIdentifier"].(string)), true

	case "Query.projectEvents":
		if e.complexity.Query.ProjectEvents == nil {
			break
		}

		args, err := ec.field_Query_projectEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectEvents(childComplexity, args["projectIdentifier"].(string), args["limit"].(*int), args["before"].(*time.Time)), true

	case "Query.projectSettings":
		if e.complexity.Query.ProjectSettings == nil {
			break
		}

		args, err := ec.field_Query_projectSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectSettings(childComplexity, args["projectIdentifier"].(string)), true

	case "Query.projects":
		if e.complexity.Query.Projects == nil {
			break
		}

		return e.complexity.Query.Projects(childComplexity), true

	case "Query.repoEvents":
		if e.complexity.Query.RepoEvents == nil {
			break
		}

		args, err := ec.field_Query_repoEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RepoEvents(childComplexity, args["repoId"].(string), args["limit"].(*int), args["before"].(*time.Time)), true

	case "Query.repoSettings":
		if e.complexity.Query.RepoSettings == nil {
			break
		}

		args, err := ec.field_Query_repoSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RepoSettings(childComplexity, args["repoId"].(string)), true

	case "Query.spruceConfig":
		if e.complexity.Query.SpruceConfig == nil {
			break
		}

		return e.complexity.Query.SpruceConfig(childComplexity), true

	case "Query.subnetAvailabilityZones":
		if e.complexity.Query.SubnetAvailabilityZones == nil {
			break
		}

		return e.complexity.Query.SubnetAvailabilityZones(childComplexity), true

	case "Query.task":
		if e.complexity.Query.Task == nil {
			break
		}

		args, err := ec.field_Query_task_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Task(childComplexity, args["taskId"].(string), args["execution"].(*int)), true

	case "Query.taskAllExecutions":
		if e.complexity.Query.TaskAllExecutions == nil {
			break
		}

		args, err := ec.field_Query_taskAllExecutions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskAllExecutions(childComplexity, args["taskId"].(string)), true

	case "Query.taskHistory":
		if e.complexity.Query.TaskHistory == nil {
			break
		}

		args, err := ec.field_Query_taskHistory_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskHistory(childComplexity, args["options"].(TaskHistoryOpts)), true

	case "Query.taskNamesForBuildVariant":
		if e.complexity.Query.TaskNamesForBuildVariant == nil {
			break
		}

		args, err := ec.field_Query_taskNamesForBuildVariant_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskNamesForBuildVariant(childComplexity, args["projectIdentifier"].(string), args["buildVariant"].(string)), true

	case "Query.taskQueueDistros":
		if e.complexity.Query.TaskQueueDistros == nil {
			break
		}

		return e.complexity.Query.TaskQueueDistros(childComplexity), true

	case "Query.taskTestSample":
		if e.complexity.Query.TaskTestSample == nil {
			break
		}

		args, err := ec.field_Query_taskTestSample_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskTestSample(childComplexity, args["versionId"].(string), args["taskIds"].([]string), args["filters"].([]*TestFilter)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["userId"].(*string)), true

	case "Query.userConfig":
		if e.complexity.Query.UserConfig == nil {
			break
		}

		return e.complexity.Query.UserConfig(childComplexity), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		args, err := ec.field_Query_version_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Version(childComplexity, args["versionId"].(string)), true

	case "Query.viewableProjectRefs":
		if e.complexity.Query.ViewableProjectRefs == nil {
			break
		}

		return e.complexity.Query.ViewableProjectRefs(childComplexity), true

	case "Query.waterfall":
		if e.complexity.Query.Waterfall == nil {
			break
		}

		args, err := ec.field_Query_waterfall_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Waterfall(childComplexity, args["options"].(WaterfallOptions)), true

	case "RepoCommitQueueParams.enabled":
		if e.complexity.RepoCommitQueueParams.Enabled == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.Enabled(childComplexity), true

	case "RepoCommitQueueParams.mergeMethod":
		if e.complexity.RepoCommitQueueParams.MergeMethod == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.MergeMethod(childComplexity), true

	case "RepoCommitQueueParams.message":
		if e.complexity.RepoCommitQueueParams.Message == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.Message(childComplexity), true

	case "RepoPermissions.edit":
		if e.complexity.RepoPermissions.Edit == nil {
			break
		}

		return e.complexity.RepoPermissions.Edit(childComplexity), true

	case "RepoPermissions.view":
		if e.complexity.RepoPermissions.View == nil {
			break
		}

		return e.complexity.RepoPermissions.View(childComplexity), true

	case "RepoRef.admins":
		if e.complexity.RepoRef.Admins == nil {
			break
		}

		return e.complexity.RepoRef.Admins(childComplexity), true

	case "RepoRef.batchTime":
		if e.complexity.RepoRef.BatchTime == nil {
			break
		}

		return e.complexity.RepoRef.BatchTime(childComplexity), true

	case "RepoRef.buildBaronSettings":
		if e.complexity.RepoRef.BuildBaronSettings == nil {
			break
		}

		return e.complexity.RepoRef.BuildBaronSettings(childComplexity), true

	case "RepoRef.commitQueue":
		if e.complexity.RepoRef.CommitQueue == nil {
			break
		}

		return e.complexity.RepoRef.CommitQueue(childComplexity), true

	case "RepoRef.containerSizeDefinitions":
		if e.complexity.RepoRef.ContainerSizeDefinitions == nil {
			break
		}

		return e.complexity.RepoRef.ContainerSizeDefinitions(childComplexity), true

	case "RepoRef.deactivatePrevious":
		if e.complexity.RepoRef.DeactivatePrevious == nil {
			break
		}

		return e.complexity.RepoRef.DeactivatePrevious(childComplexity), true

	case "RepoRef.disabledStatsCache":
		if e.complexity.RepoRef.DisabledStatsCache == nil {
			break
		}

		return e.complexity.RepoRef.DisabledStatsCache(childComplexity), true

	case "RepoRef.dispatchingDisabled":
		if e.complexity.RepoRef.DispatchingDisabled == nil {
			break
		}

		return e.complexity.RepoRef.DispatchingDisabled(childComplexity), true

	case "RepoRef.displayName":
		if e.complexity.RepoRef.DisplayName == nil {
			break
		}

		return e.complexity.RepoRef.DisplayName(childComplexity), true

	case "RepoRef.enabled":
		if e.complexity.RepoRef.Enabled == nil {
			break
		}

		return e.complexity.RepoRef.Enabled(childComplexity), true

	case "RepoRef.externalLinks":
		if e.complexity.RepoRef.ExternalLinks == nil {
			break
		}

		return e.complexity.RepoRef.ExternalLinks(childComplexity), true

	case "RepoRef.githubDynamicTokenPermissionGroups":
		if e.complexity.RepoRef.GitHubDynamicTokenPermissionGroups == nil {
			break
		}

		return e.complexity.RepoRef.GitHubDynamicTokenPermissionGroups(childComplexity), true

	case "RepoRef.githubPermissionGroupByRequester":
		if e.complexity.RepoRef.GitHubPermissionGroupByRequester == nil {
			break
		}

		return e.complexity.RepoRef.GitHubPermissionGroupByRequester(childComplexity), true

	case "RepoRef.gitTagAuthorizedTeams":
		if e.complexity.RepoRef.GitTagAuthorizedTeams == nil {
			break
		}

		return e.complexity.RepoRef.GitTagAuthorizedTeams(childComplexity), true

	case "RepoRef.gitTagAuthorizedUsers":
		if e.complexity.RepoRef.GitTagAuthorizedUsers == nil {
			break
		}

		return e.complexity.RepoRef.GitTagAuthorizedUsers(childComplexity), true

	case "RepoRef.gitTagVersionsEnabled":
		if e.complexity.RepoRef.GitTagVersionsEnabled == nil {
			break
		}

		return e.complexity.RepoRef.GitTagVersionsEnabled(childComplexity), true

	case "RepoRef.githubChecksEnabled":
		if e.complexity.RepoRef.GithubChecksEnabled == nil {
			break
		}

		return e.complexity.RepoRef.GithubChecksEnabled(childComplexity), true

	case "RepoRef.githubTriggerAliases":
		if e.complexity.RepoRef.GithubTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.GithubTriggerAliases(childComplexity), true

	case "RepoRef.id":
		if e.complexity.RepoRef.Id == nil {
			break
		}

		return e.complexity.RepoRef.Id(childComplexity), true

	case "RepoRef.manualPrTestingEnabled":
		if e.complexity.RepoRef.ManualPRTestingEnabled == nil {
			break
		}

		return e.complexity.RepoRef.ManualPRTestingEnabled(childComplexity), true

	case "RepoRef.notifyOnBuildFailure":
		if e.complexity.RepoRef.NotifyOnBuildFailure == nil {
			break
		}

		return e.complexity.RepoRef.NotifyOnBuildFailure(childComplexity), true

	case "RepoRef.oldestAllowedMergeBase":
		if e.complexity.RepoRef.OldestAllowedMergeBase == nil {
			break
		}

		return e.complexity.RepoRef.OldestAllowedMergeBase(childComplexity), true

	case "RepoRef.owner":
		if e.complexity.RepoRef.Owner == nil {
			break
		}

		return e.complexity.RepoRef.Owner(childComplexity), true

	case "RepoRef.prTestingEnabled":
		if e.complexity.RepoRef.PRTestingEnabled == nil {
			break
		}

		return e.complexity.RepoRef.PRTestingEnabled(childComplexity), true

	case "RepoRef.parsleyFilters":
		if e.complexity.RepoRef.ParsleyFilters == nil {
			break
		}

		return e.complexity.RepoRef.ParsleyFilters(childComplexity), true

	case "RepoRef.patchTriggerAliases":
		if e.complexity.RepoRef.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.PatchTriggerAliases(childComplexity), true

	case "RepoRef.patchingDisabled":
		if e.complexity.RepoRef.PatchingDisabled == nil {
			break
		}

		return e.complexity.RepoRef.PatchingDisabled(childComplexity), true

	case "RepoRef.perfEnabled":
		if e.complexity.RepoRef.PerfEnabled == nil {
			break
		}

		return e.complexity.RepoRef.PerfEnabled(childComplexity), true

	case "RepoRef.periodicBuilds":
		if e.complexity.RepoRef.PeriodicBuilds == nil {
			break
		}

		return e.complexity.RepoRef.PeriodicBuilds(childComplexity), true

	case "RepoRef.remotePath":
		if e.complexity.RepoRef.RemotePath == nil {
			break
		}

		return e.complexity.RepoRef.RemotePath(childComplexity), true

	case "RepoRef.repo":
		if e.complexity.RepoRef.Repo == nil {
			break
		}

		return e.complexity.RepoRef.Repo(childComplexity), true

	case "RepoRef.repotrackerDisabled":
		if e.complexity.RepoRef.RepotrackerDisabled == nil {
			break
		}

		return e.complexity.RepoRef.RepotrackerDisabled(childComplexity), true

	case "RepoRef.restricted":
		if e.complexity.RepoRef.Restricted == nil {
			break
		}

		return e.complexity.RepoRef.Restricted(childComplexity), true

	case "RepoRef.spawnHostScriptPath":
		if e.complexity.RepoRef.SpawnHostScriptPath == nil {
			break
		}

		return e.complexity.RepoRef.SpawnHostScriptPath(childComplexity), true

	case "RepoRef.stepbackBisect":
		if e.complexity.RepoRef.StepbackBisect == nil {
			break
		}

		return e.complexity.RepoRef.StepbackBisect(childComplexity), true

	case "RepoRef.stepbackDisabled":
		if e.complexity.RepoRef.StepbackDisabled == nil {
			break
		}

		return e.complexity.RepoRef.StepbackDisabled(childComplexity), true

	case "RepoRef.taskAnnotationSettings":
		if e.complexity.RepoRef.TaskAnnotationSettings == nil {
			break
		}

		return e.complexity.RepoRef.TaskAnnotationSettings(childComplexity), true

	case "RepoRef.tracksPushEvents":
		if e.complexity.RepoRef.TracksPushEvents == nil {
			break
		}

		return e.complexity.RepoRef.TracksPushEvents(childComplexity), true

	case "RepoRef.triggers":
		if e.complexity.RepoRef.Triggers == nil {
			break
		}

		return e.complexity.RepoRef.Triggers(childComplexity), true

	case "RepoRef.versionControlEnabled":
		if e.complexity.RepoRef.VersionControlEnabled == nil {
			break
		}

		return e.complexity.RepoRef.VersionControlEnabled(childComplexity), true

	case "RepoRef.workstationConfig":
		if e.complexity.RepoRef.WorkstationConfig == nil {
			break
		}

		return e.complexity.RepoRef.WorkstationConfig(childComplexity), true

	case "RepoSettings.aliases":
		if e.complexity.RepoSettings.Aliases == nil {
			break
		}

		return e.complexity.RepoSettings.Aliases(childComplexity), true

	case "RepoSettings.githubAppAuth":
		if e.complexity.RepoSettings.GithubAppAuth == nil {
			break
		}

		return e.complexity.RepoSettings.GithubAppAuth(childComplexity), true

	case "RepoSettings.githubWebhooksEnabled":
		if e.complexity.RepoSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.RepoSettings.GithubWebhooksEnabled(childComplexity), true

	case "RepoSettings.projectRef":
		if e.complexity.RepoSettings.ProjectRef == nil {
			break
		}

		return e.complexity.RepoSettings.ProjectRef(childComplexity), true

	case "RepoSettings.subscriptions":
		if e.complexity.RepoSettings.Subscriptions == nil {
			break
		}

		return e.complexity.RepoSettings.Subscriptions(childComplexity), true

	case "RepoSettings.vars":
		if e.complexity.RepoSettings.Vars == nil {
			break
		}

		return e.complexity.RepoSettings.Vars(childComplexity), true

	case "RepoWorkstationConfig.gitClone":
		if e.complexity.RepoWorkstationConfig.GitClone == nil {
			break
		}

		return e.complexity.RepoWorkstationConfig.GitClone(childComplexity), true

	case "RepoWorkstationConfig.setupCommands":
		if e.complexity.RepoWorkstationConfig.SetupCommands == nil {
			break
		}

		return e.complexity.RepoWorkstationConfig.SetupCommands(childComplexity), true

	case "RepotrackerError.exists":
		if e.complexity.RepotrackerError.Exists == nil {
			break
		}

		return e.complexity.RepotrackerError.Exists(childComplexity), true

	case "RepotrackerError.invalidRevision":
		if e.complexity.RepotrackerError.InvalidRevision == nil {
			break
		}

		return e.complexity.RepotrackerError.InvalidRevision(childComplexity), true

	case "RepotrackerError.mergeBaseRevision":
		if e.complexity.RepotrackerError.MergeBaseRevision == nil {
			break
		}

		return e.complexity.RepotrackerError.MergeBaseRevision(childComplexity), true

	case "ResourceLimits.lockedMemoryKb":
		if e.complexity.ResourceLimits.LockedMemoryKB == nil {
			break
		}

		return e.complexity.ResourceLimits.LockedMemoryKB(childComplexity), true

	case "ResourceLimits.numFiles":
		if e.complexity.ResourceLimits.NumFiles == nil {
			break
		}

		return e.complexity.ResourceLimits.NumFiles(childComplexity), true

	case "ResourceLimits.numProcesses":
		if e.complexity.ResourceLimits.NumProcesses == nil {
			break
		}

		return e.complexity.ResourceLimits.NumProcesses(childComplexity), true

	case "ResourceLimits.numTasks":
		if e.complexity.ResourceLimits.NumTasks == nil {
			break
		}

		return e.complexity.ResourceLimits.NumTasks(childComplexity), true

	case "ResourceLimits.virtualMemoryKb":
		if e.complexity.ResourceLimits.VirtualMemoryKB == nil {
			break
		}

		return e.complexity.ResourceLimits.VirtualMemoryKB(childComplexity), true

	case "SaveDistroPayload.distro":
		if e.complexity.SaveDistroPayload.Distro == nil {
			break
		}

		return e.complexity.SaveDistroPayload.Distro(childComplexity), true

	case "SaveDistroPayload.hostCount":
		if e.complexity.SaveDistroPayload.HostCount == nil {
			break
		}

		return e.complexity.SaveDistroPayload.HostCount(childComplexity), true

	case "SearchReturnInfo.featuresURL":
		if e.complexity.SearchReturnInfo.FeaturesURL == nil {
			break
		}

		return e.complexity.SearchReturnInfo.FeaturesURL(childComplexity), true

	case "SearchReturnInfo.issues":
		if e.complexity.SearchReturnInfo.Issues == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Issues(childComplexity), true

	case "SearchReturnInfo.search":
		if e.complexity.SearchReturnInfo.Search == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Search(childComplexity), true

	case "SearchReturnInfo.source":
		if e.complexity.SearchReturnInfo.Source == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Source(childComplexity), true

	case "Selector.data":
		if e.complexity.Selector.Data == nil {
			break
		}

		return e.complexity.Selector.Data(childComplexity), true

	case "Selector.type":
		if e.complexity.Selector.Type == nil {
			break
		}

		return e.complexity.Selector.Type(childComplexity), true

	case "SetLastRevisionPayload.mergeBaseRevision":
		if e.complexity.SetLastRevisionPayload.MergeBaseRevision == nil {
			break
		}

		return e.complexity.SetLastRevisionPayload.MergeBaseRevision(childComplexity), true

	case "SingleTaskDistroConfig.projectTasksPairs":
		if e.complexity.SingleTaskDistroConfig.ProjectTasksPairs == nil {
			break
		}

		return e.complexity.SingleTaskDistroConfig.ProjectTasksPairs(childComplexity), true

	case "SlackConfig.name":
		if e.complexity.SlackConfig.Name == nil {
			break
		}

		return e.complexity.SlackConfig.Name(childComplexity), true

	case "SleepSchedule.dailyStartTime":
		if e.complexity.SleepSchedule.DailyStartTime == nil {
			break
		}

		return e.complexity.SleepSchedule.DailyStartTime(childComplexity), true

	case "SleepSchedule.dailyStopTime":
		if e.complexity.SleepSchedule.DailyStopTime == nil {
			break
		}

		return e.complexity.SleepSchedule.DailyStopTime(childComplexity), true

	case "SleepSchedule.nextStartTime":
		if e.complexity.SleepSchedule.NextStartTime == nil {
			break
		}

		return e.complexity.SleepSchedule.NextStartTime(childComplexity), true

	case "SleepSchedule.nextStopTime":
		if e.complexity.SleepSchedule.NextStopTime == nil {
			break
		}

		return e.complexity.SleepSchedule.NextStopTime(childComplexity), true

	case "SleepSchedule.permanentlyExempt":
		if e.complexity.SleepSchedule.PermanentlyExempt == nil {
			break
		}

		return e.complexity.SleepSchedule.PermanentlyExempt(childComplexity), true

	case "SleepSchedule.shouldKeepOff":
		if e.complexity.SleepSchedule.ShouldKeepOff == nil {
			break
		}

		return e.complexity.SleepSchedule.ShouldKeepOff(childComplexity), true

	case "SleepSchedule.temporarilyExemptUntil":
		if e.complexity.SleepSchedule.TemporarilyExemptUntil == nil {
			break
		}

		return e.complexity.SleepSchedule.TemporarilyExemptUntil(childComplexity), true

	case "SleepSchedule.timeZone":
		if e.complexity.SleepSchedule.TimeZone == nil {
			break
		}

		return e.complexity.SleepSchedule.TimeZone(childComplexity), true

	case "SleepSchedule.wholeWeekdaysOff":
		if e.complexity.SleepSchedule.WholeWeekdaysOff == nil {
			break
		}

		return e.complexity.SleepSchedule.WholeWeekdaysOff(childComplexity), true

	case "Source.author":
		if e.complexity.Source.Author == nil {
			break
		}

		return e.complexity.Source.Author(childComplexity), true

	case "Source.requester":
		if e.complexity.Source.Requester == nil {
			break
		}

		return e.complexity.Source.Requester(childComplexity), true

	case "Source.time":
		if e.complexity.Source.Time == nil {
			break
		}

		return e.complexity.Source.Time(childComplexity), true

	case "SpawnHostConfig.spawnHostsPerUser":
		if e.complexity.SpawnHostConfig.SpawnHostsPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.SpawnHostsPerUser(childComplexity), true

	case "SpawnHostConfig.unexpirableHostsPerUser":
		if e.complexity.SpawnHostConfig.UnexpirableHostsPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.UnexpirableHostsPerUser(childComplexity), true

	case "SpawnHostConfig.unexpirableVolumesPerUser":
		if e.complexity.SpawnHostConfig.UnexpirableVolumesPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.UnexpirableVolumesPerUser(childComplexity), true

	case "SpruceConfig.banner":
		if e.complexity.SpruceConfig.Banner == nil {
			break
		}

		return e.complexity.SpruceConfig.Banner(childComplexity), true

	case "SpruceConfig.bannerTheme":
		if e.complexity.SpruceConfig.BannerTheme == nil {
			break
		}

		return e.complexity.SpruceConfig.BannerTheme(childComplexity), true

	case "SpruceConfig.containerPools":
		if e.complexity.SpruceConfig.ContainerPools == nil {
			break
		}

		return e.complexity.SpruceConfig.ContainerPools(childComplexity), true

	case "SpruceConfig.githubOrgs":
		if e.complexity.SpruceConfig.GithubOrgs == nil {
			break
		}

		return e.complexity.SpruceConfig.GithubOrgs(childComplexity), true

	case "SpruceConfig.jira":
		if e.complexity.SpruceConfig.Jira == nil {
			break
		}

		return e.complexity.SpruceConfig.Jira(childComplexity), true

	case "SpruceConfig.providers":
		if e.complexity.SpruceConfig.Providers == nil {
			break
		}

		return e.complexity.SpruceConfig.Providers(childComplexity), true

	case "SpruceConfig.secretFields":
		if e.complexity.SpruceConfig.SecretFields == nil {
			break
		}

		return e.complexity.SpruceConfig.SecretFields(childComplexity), true

	case "SpruceConfig.singleTaskDistro":
		if e.complexity.SpruceConfig.SingleTaskDistro == nil {
			break
		}

		return e.complexity.SpruceConfig.SingleTaskDistro(childComplexity), true

	case "SpruceConfig.slack":
		if e.complexity.SpruceConfig.Slack == nil {
			break
		}

		return e.complexity.SpruceConfig.Slack(childComplexity), true

	case "SpruceConfig.spawnHost":
		if e.complexity.SpruceConfig.Spawnhost == nil {
			break
		}

		return e.complexity.SpruceConfig.Spawnhost(childComplexity), true

	case "SpruceConfig.ui":
		if e.complexity.SpruceConfig.Ui == nil {
			break
		}

		return e.complexity.SpruceConfig.Ui(childComplexity), true

	case "StatusCount.count":
		if e.complexity.StatusCount.Count == nil {
			break
		}

		return e.complexity.StatusCount.Count(childComplexity), true

	case "StatusCount.status":
		if e.complexity.StatusCount.Status == nil {
			break
		}

		return e.complexity.StatusCount.Status(childComplexity), true

	case "StepbackInfo.lastFailingStepbackTaskId":
		if e.complexity.StepbackInfo.LastFailingStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.LastFailingStepbackTaskId(childComplexity), true

	case "StepbackInfo.lastPassingStepbackTaskId":
		if e.complexity.StepbackInfo.LastPassingStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.LastPassingStepbackTaskId(childComplexity), true

	case "StepbackInfo.nextStepbackTaskId":
		if e.complexity.StepbackInfo.NextStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.NextStepbackTaskId(childComplexity), true

	case "StepbackInfo.previousStepbackTaskId":
		if e.complexity.StepbackInfo.PreviousStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.PreviousStepbackTaskId(childComplexity), true

	case "Subscriber.emailSubscriber":
		if e.complexity.Subscriber.EmailSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.EmailSubscriber(childComplexity), true

	case "Subscriber.githubCheckSubscriber":
		if e.complexity.Subscriber.GithubCheckSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.GithubCheckSubscriber(childComplexity), true

	case "Subscriber.githubPRSubscriber":
		if e.complexity.Subscriber.GithubPRSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.GithubPRSubscriber(childComplexity), true

	case "Subscriber.jiraCommentSubscriber":
		if e.complexity.Subscriber.JiraCommentSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.JiraCommentSubscriber(childComplexity), true

	case "Subscriber.jiraIssueSubscriber":
		if e.complexity.Subscriber.JiraIssueSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.JiraIssueSubscriber(childComplexity), true

	case "Subscriber.slackSubscriber":
		if e.complexity.Subscriber.SlackSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.SlackSubscriber(childComplexity), true

	case "Subscriber.webhookSubscriber":
		if e.complexity.Subscriber.WebhookSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.WebhookSubscriber(childComplexity), true

	case "SubscriberWrapper.subscriber":
		if e.complexity.SubscriberWrapper.Subscriber == nil {
			break
		}

		return e.complexity.SubscriberWrapper.Subscriber(childComplexity), true

	case "SubscriberWrapper.type":
		if e.complexity.SubscriberWrapper.Type == nil {
			break
		}

		return e.complexity.SubscriberWrapper.Type(childComplexity), true

	case "Task.abortInfo":
		if e.complexity.Task.AbortInfo == nil {
			break
		}

		return e.complexity.Task.AbortInfo(childComplexity), true

	case "Task.aborted":
		if e.complexity.Task.Aborted == nil {
			break
		}

		return e.complexity.Task.Aborted(childComplexity), true

	case "Task.activated":
		if e.complexity.Task.Activated == nil {
			break
		}

		return e.complexity.Task.Activated(childComplexity), true

	case "Task.activatedBy":
		if e.complexity.Task.ActivatedBy == nil {
			break
		}

		return e.complexity.Task.ActivatedBy(childComplexity), true

	case "Task.activatedTime":
		if e.complexity.Task.ActivatedTime == nil {
			break
		}

		return e.complexity.Task.ActivatedTime(childComplexity), true

	case "Task.ami":
		if e.complexity.Task.Ami == nil {
			break
		}

		return e.complexity.Task.Ami(childComplexity), true

	case "Task.annotation":
		if e.complexity.Task.Annotation == nil {
			break
		}

		return e.complexity.Task.Annotation(childComplexity), true

	case "Task.baseStatus":
		if e.complexity.Task.BaseStatus == nil {
			break
		}

		return e.complexity.Task.BaseStatus(childComplexity), true

	case "Task.baseTask":
		if e.complexity.Task.BaseTask == nil {
			break
		}

		return e.complexity.Task.BaseTask(childComplexity), true

	case "Task.blocked":
		if e.complexity.Task.Blocked == nil {
			break
		}

		return e.complexity.Task.Blocked(childComplexity), true

	case "Task.buildId":
		if e.complexity.Task.BuildId == nil {
			break
		}

		return e.complexity.Task.BuildId(childComplexity), true

	case "Task.buildVariant":
		if e.complexity.Task.BuildVariant == nil {
			break
		}

		return e.complexity.Task.BuildVariant(childComplexity), true

	case "Task.buildVariantDisplayName":
		if e.complexity.Task.BuildVariantDisplayName == nil {
			break
		}

		return e.complexity.Task.BuildVariantDisplayName(childComplexity), true

	case "Task.canAbort":
		if e.complexity.Task.CanAbort == nil {
			break
		}

		return e.complexity.Task.CanAbort(childComplexity), true

	case "Task.canDisable":
		if e.complexity.Task.CanDisable == nil {
			break
		}

		return e.complexity.Task.CanDisable(childComplexity), true

	case "Task.canModifyAnnotation":
		if e.complexity.Task.CanModifyAnnotation == nil {
			break
		}

		return e.complexity.Task.CanModifyAnnotation(childComplexity), true

	case "Task.canOverrideDependencies":
		if e.complexity.Task.CanOverrideDependencies == nil {
			break
		}

		return e.complexity.Task.CanOverrideDependencies(childComplexity), true

	case "Task.canRestart":
		if e.complexity.Task.CanRestart == nil {
			break
		}

		return e.complexity.Task.CanRestart(childComplexity), true

	case "Task.canSchedule":
		if e.complexity.Task.CanSchedule == nil {
			break
		}

		return e.complexity.Task.CanSchedule(childComplexity), true

	case "Task.canSetPriority":
		if e.complexity.Task.CanSetPriority == nil {
			break
		}

		return e.complexity.Task.CanSetPriority(childComplexity), true

	case "Task.canUnschedule":
		if e.complexity.Task.CanUnschedule == nil {
			break
		}

		return e.complexity.Task.CanUnschedule(childComplexity), true

	case "Task.containerAllocatedTime":
		if e.complexity.Task.ContainerAllocatedTime == nil {
			break
		}

		return e.complexity.Task.ContainerAllocatedTime(childComplexity), true

	case "Task.createTime":
		if e.complexity.Task.CreateTime == nil {
			break
		}

		return e.complexity.Task.CreateTime(childComplexity), true

	case "Task.dependsOn":
		if e.complexity.Task.DependsOn == nil {
			break
		}

		return e.complexity.Task.DependsOn(childComplexity), true

	case "Task.details":
		if e.complexity.Task.Details == nil {
			break
		}

		return e.complexity.Task.Details(childComplexity), true

	case "Task.dispatchTime":
		if e.complexity.Task.DispatchTime == nil {
			break
		}

		return e.complexity.Task.DispatchTime(childComplexity), true

	case "Task.displayName":
		if e.complexity.Task.DisplayName == nil {
			break
		}

		return e.complexity.Task.DisplayName(childComplexity), true

	case "Task.displayOnly":
		if e.complexity.Task.DisplayOnly == nil {
			break
		}

		return e.complexity.Task.DisplayOnly(childComplexity), true

	case "Task.displayStatus":
		if e.complexity.Task.DisplayStatus == nil {
			break
		}

		return e.complexity.Task.DisplayStatus(childComplexity), true

	case "Task.displayTask":
		if e.complexity.Task.DisplayTask == nil {
			break
		}

		return e.complexity.Task.DisplayTask(childComplexity), true

	case "Task.distroId":
		if e.complexity.Task.DistroId == nil {
			break
		}

		return e.complexity.Task.DistroId(childComplexity), true

	case "Task.estimatedStart":
		if e.complexity.Task.EstimatedStart == nil {
			break
		}

		return e.complexity.Task.EstimatedStart(childComplexity), true

	case "Task.execution":
		if e.complexity.Task.Execution == nil {
			break
		}

		return e.complexity.Task.Execution(childComplexity), true

	case "Task.executionTasks":
		if e.complexity.Task.ExecutionTasks == nil {
			break
		}

		return e.complexity.Task.ExecutionTasks(childComplexity), true

	case "Task.executionTasksFull":
		if e.complexity.Task.ExecutionTasksFull == nil {
			break
		}

		return e.complexity.Task.ExecutionTasksFull(childComplexity), true

	case "Task.expectedDuration":
		if e.complexity.Task.ExpectedDuration == nil {
			break
		}

		return e.complexity.Task.ExpectedDuration(childComplexity), true

	case "Task.failedTestCount":
		if e.complexity.Task.FailedTestCount == nil {
			break
		}

		return e.complexity.Task.FailedTestCount(childComplexity), true

	case "Task.files":
		if e.complexity.Task.Files == nil {
			break
		}

		return e.complexity.Task.Files(childComplexity), true

	case "Task.finishTime":
		if e.complexity.Task.FinishTime == nil {
			break
		}

		return e.complexity.Task.FinishTime(childComplexity), true

	case "Task.generateTask":
		if e.complexity.Task.GenerateTask == nil {
			break
		}

		return e.complexity.Task.GenerateTask(childComplexity), true

	case "Task.generatedBy":
		if e.complexity.Task.GeneratedBy == nil {
			break
		}

		return e.complexity.Task.GeneratedBy(childComplexity), true

	case "Task.generatedByName":
		if e.complexity.Task.GeneratedByName == nil {
			break
		}

		return e.complexity.Task.GeneratedByName(childComplexity), true

	case "Task.hasCedarResults":
		if e.complexity.Task.HasCedarResults == nil {
			break
		}

		return e.complexity.Task.HasCedarResults(childComplexity), true

	case "Task.hostId":
		if e.complexity.Task.HostId == nil {
			break
		}

		return e.complexity.Task.HostId(childComplexity), true

	case "Task.id":
		if e.complexity.Task.Id == nil {
			break
		}

		return e.complexity.Task.Id(childComplexity), true

	case "Task.imageId":
		if e.complexity.Task.ImageID == nil {
			break
		}

		return e.complexity.Task.ImageID(childComplexity), true

	case "Task.ingestTime":
		if e.complexity.Task.IngestTime == nil {
			break
		}

		return e.complexity.Task.IngestTime(childComplexity), true

	case "Task.isPerfPluginEnabled":
		if e.complexity.Task.IsPerfPluginEnabled == nil {
			break
		}

		return e.complexity.Task.IsPerfPluginEnabled(childComplexity), true

	case "Task.latestExecution":
		if e.complexity.Task.LatestExecution == nil {
			break
		}

		return e.complexity.Task.LatestExecution(childComplexity), true

	case "Task.logs":
		if e.complexity.Task.Logs == nil {
			break
		}

		return e.complexity.Task.Logs(childComplexity), true

	case "Task.minQueuePosition":
		if e.complexity.Task.MinQueuePosition == nil {
			break
		}

		return e.complexity.Task.MinQueuePosition(childComplexity), true

	case "Task.order":
		if e.complexity.Task.Order == nil {
			break
		}

		return e.complexity.Task.Order(childComplexity), true

	case "Task.patch":
		if e.complexity.Task.Patch == nil {
			break
		}

		return e.complexity.Task.Patch(childComplexity), true

	case "Task.patchNumber":
		if e.complexity.Task.PatchNumber == nil {
			break
		}

		return e.complexity.Task.PatchNumber(childComplexity), true

	case "Task.pod":
		if e.complexity.Task.Pod == nil {
			break
		}

		return e.complexity.Task.Pod(childComplexity), true

	case "Task.priority":
		if e.complexity.Task.Priority == nil {
			break
		}

		return e.complexity.Task.Priority(childComplexity), true

	case "Task.project":
		if e.complexity.Task.Project == nil {
			break
		}

		return e.complexity.Task.Project(childComplexity), true

	case "Task.projectId":
		if e.complexity.Task.ProjectId == nil {
			break
		}

		return e.complexity.Task.ProjectId(childComplexity), true

	case "Task.projectIdentifier":
		if e.complexity.Task.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Task.ProjectIdentifier(childComplexity), true

	case "Task.requester":
		if e.complexity.Task.Requester == nil {
			break
		}

		return e.complexity.Task.Requester(childComplexity), true

	case "Task.resetWhenFinished":
		if e.complexity.Task.ResetWhenFinished == nil {
			break
		}

		return e.complexity.Task.ResetWhenFinished(childComplexity), true

	case "Task.revision":
		if e.complexity.Task.Revision == nil {
			break
		}

		return e.complexity.Task.Revision(childComplexity), true

	case "Task.scheduledTime":
		if e.complexity.Task.ScheduledTime == nil {
			break
		}

		return e.complexity.Task.ScheduledTime(childComplexity), true

	case "Task.spawnHostLink":
		if e.complexity.Task.SpawnHostLink == nil {
			break
		}

		return e.complexity.Task.SpawnHostLink(childComplexity), true

	case "Task.startTime":
		if e.complexity.Task.StartTime == nil {
			break
		}

		return e.complexity.Task.StartTime(childComplexity), true

	case "Task.status":
		if e.complexity.Task.Status == nil {
			break
		}

		return e.complexity.Task.Status(childComplexity), true

	case "Task.stepbackInfo":
		if e.complexity.Task.StepbackInfo == nil {
			break
		}

		return e.complexity.Task.StepbackInfo(childComplexity), true

	case "Task.tags":
		if e.complexity.Task.Tags == nil {
			break
		}

		return e.complexity.Task.Tags(childComplexity), true

	case "Task.taskGroup":
		if e.complexity.Task.TaskGroup == nil {
			break
		}

		return e.complexity.Task.TaskGroup(childComplexity), true

	case "Task.taskGroupMaxHosts":
		if e.complexity.Task.TaskGroupMaxHosts == nil {
			break
		}

		return e.complexity.Task.TaskGroupMaxHosts(childComplexity), true

	case "Task.taskLogs":
		if e.complexity.Task.TaskLogs == nil {
			break
		}

		return e.complexity.Task.TaskLogs(childComplexity), true

	case "Task.taskOwnerTeam":
		if e.complexity.Task.TaskOwnerTeam == nil {
			break
		}

		return e.complexity.Task.TaskOwnerTeam(childComplexity), true

	case "Task.tests":
		if e.complexity.Task.Tests == nil {
			break
		}

		args, err := ec.field_Task_tests_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.Tests(childComplexity, args["opts"].(*TestFilterOptions)), true

	case "Task.timeTaken":
		if e.complexity.Task.TimeTaken == nil {
			break
		}

		return e.complexity.Task.TimeTaken(childComplexity), true

	case "Task.totalTestCount":
		if e.complexity.Task.TotalTestCount == nil {
			break
		}

		return e.complexity.Task.TotalTestCount(childComplexity), true

	case "Task.versionMetadata":
		if e.complexity.Task.VersionMetadata == nil {
			break
		}

		return e.complexity.Task.VersionMetadata(childComplexity), true

	case "TaskAnnotationSettings.fileTicketWebhook":
		if e.complexity.TaskAnnotationSettings.FileTicketWebhook == nil {
			break
		}

		return e.complexity.TaskAnnotationSettings.FileTicketWebhook(childComplexity), true

	case "TaskContainerCreationOpts.arch":
		if e.complexity.TaskContainerCreationOpts.Arch == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Arch(childComplexity), true

	case "TaskContainerCreationOpts.cpu":
		if e.complexity.TaskContainerCreationOpts.CPU == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.CPU(childComplexity), true

	case "TaskContainerCreationOpts.image":
		if e.complexity.TaskContainerCreationOpts.Image == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Image(childComplexity), true

	case "TaskContainerCreationOpts.memoryMB":
		if e.complexity.TaskContainerCreationOpts.MemoryMB == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.MemoryMB(childComplexity), true

	case "TaskContainerCreationOpts.os":
		if e.complexity.TaskContainerCreationOpts.Os == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Os(childComplexity), true

	case "TaskContainerCreationOpts.workingDir":
		if e.complexity.TaskContainerCreationOpts.WorkingDir == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.WorkingDir(childComplexity), true

	case "TaskEndDetail.description":
		if e.complexity.TaskEndDetail.Description == nil {
			break
		}

		return e.complexity.TaskEndDetail.Description(childComplexity), true

	case "TaskEndDetail.diskDevices":
		if e.complexity.TaskEndDetail.DiskDevices == nil {
			break
		}

		return e.complexity.TaskEndDetail.DiskDevices(childComplexity), true

	case "TaskEndDetail.failingCommand":
		if e.complexity.TaskEndDetail.FailingCommand == nil {
			break
		}

		return e.complexity.TaskEndDetail.FailingCommand(childComplexity), true

	case "TaskEndDetail.failureMetadataTags":
		if e.complexity.TaskEndDetail.FailureMetadataTags == nil {
			break
		}

		return e.complexity.TaskEndDetail.FailureMetadataTags(childComplexity), true

	case "TaskEndDetail.oomTracker":
		if e.complexity.TaskEndDetail.OOMTracker == nil {
			break
		}

		return e.complexity.TaskEndDetail.OOMTracker(childComplexity), true

	case "TaskEndDetail.status":
		if e.complexity.TaskEndDetail.Status == nil {
			break
		}

		return e.complexity.TaskEndDetail.Status(childComplexity), true

	case "TaskEndDetail.timedOut":
		if e.complexity.TaskEndDetail.TimedOut == nil {
			break
		}

		return e.complexity.TaskEndDetail.TimedOut(childComplexity), true

	case "TaskEndDetail.timeoutType":
		if e.complexity.TaskEndDetail.TimeoutType == nil {
			break
		}

		return e.complexity.TaskEndDetail.TimeoutType(childComplexity), true

	case "TaskEndDetail.traceID":
		if e.complexity.TaskEndDetail.TraceID == nil {
			break
		}

		return e.complexity.TaskEndDetail.TraceID(childComplexity), true

	case "TaskEndDetail.type":
		if e.complexity.TaskEndDetail.Type == nil {
			break
		}

		return e.complexity.TaskEndDetail.Type(childComplexity), true

	case "TaskEventLogData.blockedOn":
		if e.complexity.TaskEventLogData.BlockedOn == nil {
			break
		}

		return e.complexity.TaskEventLogData.BlockedOn(childComplexity), true

	case "TaskEventLogData.hostId":
		if e.complexity.TaskEventLogData.HostId == nil {
			break
		}

		return e.complexity.TaskEventLogData.HostId(childComplexity), true

	case "TaskEventLogData.jiraIssue":
		if e.complexity.TaskEventLogData.JiraIssue == nil {
			break
		}

		return e.complexity.TaskEventLogData.JiraIssue(childComplexity), true

	case "TaskEventLogData.jiraLink":
		if e.complexity.TaskEventLogData.JiraLink == nil {
			break
		}

		return e.complexity.TaskEventLogData.JiraLink(childComplexity), true

	case "TaskEventLogData.podId":
		if e.complexity.TaskEventLogData.PodId == nil {
			break
		}

		return e.complexity.TaskEventLogData.PodId(childComplexity), true

	case "TaskEventLogData.priority":
		if e.complexity.TaskEventLogData.Priority == nil {
			break
		}

		return e.complexity.TaskEventLogData.Priority(childComplexity), true

	case "TaskEventLogData.status":
		if e.complexity.TaskEventLogData.Status == nil {
			break
		}

		return e.complexity.TaskEventLogData.Status(childComplexity), true

	case "TaskEventLogData.timestamp":
		if e.complexity.TaskEventLogData.Timestamp == nil {
			break
		}

		return e.complexity.TaskEventLogData.Timestamp(childComplexity), true

	case "TaskEventLogData.userId":
		if e.complexity.TaskEventLogData.UserId == nil {
			break
		}

		return e.complexity.TaskEventLogData.UserId(childComplexity), true

	case "TaskEventLogEntry.data":
		if e.complexity.TaskEventLogEntry.Data == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.Data(childComplexity), true

	case "TaskEventLogEntry.eventType":
		if e.complexity.TaskEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.EventType(childComplexity), true

	case "TaskEventLogEntry.id":
		if e.complexity.TaskEventLogEntry.ID == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ID(childComplexity), true

	case "TaskEventLogEntry.processedAt":
		if e.complexity.TaskEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ProcessedAt(childComplexity), true

	case "TaskEventLogEntry.resourceId":
		if e.complexity.TaskEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ResourceId(childComplexity), true

	case "TaskEventLogEntry.resourceType":
		if e.complexity.TaskEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ResourceType(childComplexity), true

	case "TaskEventLogEntry.timestamp":
		if e.complexity.TaskEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.Timestamp(childComplexity), true

	case "TaskFiles.fileCount":
		if e.complexity.TaskFiles.FileCount == nil {
			break
		}

		return e.complexity.TaskFiles.FileCount(childComplexity), true

	case "TaskFiles.groupedFiles":
		if e.complexity.TaskFiles.GroupedFiles == nil {
			break
		}

		return e.complexity.TaskFiles.GroupedFiles(childComplexity), true

	case "TaskHistory.pagination":
		if e.complexity.TaskHistory.Pagination == nil {
			break
		}

		return e.complexity.TaskHistory.Pagination(childComplexity), true

	case "TaskHistory.tasks":
		if e.complexity.TaskHistory.Tasks == nil {
			break
		}

		return e.complexity.TaskHistory.Tasks(childComplexity), true

	case "TaskHistoryPagination.mostRecentTaskOrder":
		if e.complexity.TaskHistoryPagination.MostRecentTaskOrder == nil {
			break
		}

		return e.complexity.TaskHistoryPagination.MostRecentTaskOrder(childComplexity), true

	case "TaskHistoryPagination.oldestTaskOrder":
		if e.complexity.TaskHistoryPagination.OldestTaskOrder == nil {
			break
		}

		return e.complexity.TaskHistoryPagination.OldestTaskOrder(childComplexity), true

	case "TaskInfo.id":
		if e.complexity.TaskInfo.Id == nil {
			break
		}

		return e.complexity.TaskInfo.Id(childComplexity), true

	case "TaskInfo.name":
		if e.complexity.TaskInfo.Name == nil {
			break
		}

		return e.complexity.TaskInfo.Name(childComplexity), true

	case "TaskLogLinks.agentLogLink":
		if e.complexity.TaskLogLinks.AgentLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.AgentLogLink(childComplexity), true

	case "TaskLogLinks.allLogLink":
		if e.complexity.TaskLogLinks.AllLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.AllLogLink(childComplexity), true

	case "TaskLogLinks.eventLogLink":
		if e.complexity.TaskLogLinks.EventLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.EventLogLink(childComplexity), true

	case "TaskLogLinks.systemLogLink":
		if e.complexity.TaskLogLinks.SystemLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.SystemLogLink(childComplexity), true

	case "TaskLogLinks.taskLogLink":
		if e.complexity.TaskLogLinks.TaskLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.TaskLogLink(childComplexity), true

	case "TaskLogs.agentLogs":
		if e.complexity.TaskLogs.AgentLogs == nil {
			break
		}

		return e.complexity.TaskLogs.AgentLogs(childComplexity), true

	case "TaskLogs.allLogs":
		if e.complexity.TaskLogs.AllLogs == nil {
			break
		}

		return e.complexity.TaskLogs.AllLogs(childComplexity), true

	case "TaskLogs.eventLogs":
		if e.complexity.TaskLogs.EventLogs == nil {
			break
		}

		return e.complexity.TaskLogs.EventLogs(childComplexity), true

	case "TaskLogs.execution":
		if e.complexity.TaskLogs.Execution == nil {
			break
		}

		return e.complexity.TaskLogs.Execution(childComplexity), true

	case "TaskLogs.systemLogs":
		if e.complexity.TaskLogs.SystemLogs == nil {
			break
		}

		return e.complexity.TaskLogs.SystemLogs(childComplexity), true

	case "TaskLogs.taskId":
		if e.complexity.TaskLogs.TaskID == nil {
			break
		}

		return e.complexity.TaskLogs.TaskID(childComplexity), true

	case "TaskLogs.taskLogs":
		if e.complexity.TaskLogs.TaskLogs == nil {
			break
		}

		return e.complexity.TaskLogs.TaskLogs(childComplexity), true

	case "TaskOwnerTeam.assignmentType":
		if e.complexity.TaskOwnerTeam.AssignmentType == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.AssignmentType(childComplexity), true

	case "TaskOwnerTeam.jiraProject":
		if e.complexity.TaskOwnerTeam.JiraProject == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.JiraProject(childComplexity), true

	case "TaskOwnerTeam.messages":
		if e.complexity.TaskOwnerTeam.Messages == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.Messages(childComplexity), true

	case "TaskOwnerTeam.teamName":
		if e.complexity.TaskOwnerTeam.TeamName == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.TeamName(childComplexity), true

	case "TaskQueueDistro.hostCount":
		if e.complexity.TaskQueueDistro.HostCount == nil {
			break
		}

		return e.complexity.TaskQueueDistro.HostCount(childComplexity), true

	case "TaskQueueDistro.id":
		if e.complexity.TaskQueueDistro.ID == nil {
			break
		}

		return e.complexity.TaskQueueDistro.ID(childComplexity), true

	case "TaskQueueDistro.taskCount":
		if e.complexity.TaskQueueDistro.TaskCount == nil {
			break
		}

		return e.complexity.TaskQueueDistro.TaskCount(childComplexity), true

	case "TaskQueueItem.activatedBy":
		if e.complexity.TaskQueueItem.ActivatedBy == nil {
			break
		}

		return e.complexity.TaskQueueItem.ActivatedBy(childComplexity), true

	case "TaskQueueItem.buildVariant":
		if e.complexity.TaskQueueItem.BuildVariant == nil {
			break
		}

		return e.complexity.TaskQueueItem.BuildVariant(childComplexity), true

	case "TaskQueueItem.displayName":
		if e.complexity.TaskQueueItem.DisplayName == nil {
			break
		}

		return e.complexity.TaskQueueItem.DisplayName(childComplexity), true

	case "TaskQueueItem.expectedDuration":
		if e.complexity.TaskQueueItem.ExpectedDuration == nil {
			break
		}

		return e.complexity.TaskQueueItem.ExpectedDuration(childComplexity), true

	case "TaskQueueItem.id":
		if e.complexity.TaskQueueItem.Id == nil {
			break
		}

		return e.complexity.TaskQueueItem.Id(childComplexity), true

	case "TaskQueueItem.priority":
		if e.complexity.TaskQueueItem.Priority == nil {
			break
		}

		return e.complexity.TaskQueueItem.Priority(childComplexity), true

	case "TaskQueueItem.project":
		if e.complexity.TaskQueueItem.Project == nil {
			break
		}

		return e.complexity.TaskQueueItem.Project(childComplexity), true

	case "TaskQueueItem.projectIdentifier":
		if e.complexity.TaskQueueItem.ProjectIdentifier == nil {
			break
		}

		return e.complexity.TaskQueueItem.ProjectIdentifier(childComplexity), true

	case "TaskQueueItem.requester":
		if e.complexity.TaskQueueItem.Requester == nil {
			break
		}

		return e.complexity.TaskQueueItem.Requester(childComplexity), true

	case "TaskQueueItem.revision":
		if e.complexity.TaskQueueItem.Revision == nil {
			break
		}

		return e.complexity.TaskQueueItem.Revision(childComplexity), true

	case "TaskQueueItem.version":
		if e.complexity.TaskQueueItem.Version == nil {
			break
		}

		return e.complexity.TaskQueueItem.Version(childComplexity), true

	case "TaskSpecifier.patchAlias":
		if e.complexity.TaskSpecifier.PatchAlias == nil {
			break
		}

		return e.complexity.TaskSpecifier.PatchAlias(childComplexity), true

	case "TaskSpecifier.taskRegex":
		if e.complexity.TaskSpecifier.TaskRegex == nil {
			break
		}

		return e.complexity.TaskSpecifier.TaskRegex(childComplexity), true

	case "TaskSpecifier.variantRegex":
		if e.complexity.TaskSpecifier.VariantRegex == nil {
			break
		}

		return e.complexity.TaskSpecifier.VariantRegex(childComplexity), true

	case "TaskStats.counts":
		if e.complexity.TaskStats.Counts == nil {
			break
		}

		return e.complexity.TaskStats.Counts(childComplexity), true

	case "TaskStats.eta":
		if e.complexity.TaskStats.ETA == nil {
			break
		}

		return e.complexity.TaskStats.ETA(childComplexity), true

	case "TaskTestResult.filteredTestCount":
		if e.complexity.TaskTestResult.FilteredTestCount == nil {
			break
		}

		return e.complexity.TaskTestResult.FilteredTestCount(childComplexity), true

	case "TaskTestResult.testResults":
		if e.complexity.TaskTestResult.TestResults == nil {
			break
		}

		return e.complexity.TaskTestResult.TestResults(childComplexity), true

	case "TaskTestResult.totalTestCount":
		if e.complexity.TaskTestResult.TotalTestCount == nil {
			break
		}

		return e.complexity.TaskTestResult.TotalTestCount(childComplexity), true

	case "TaskTestResultSample.execution":
		if e.complexity.TaskTestResultSample.Execution == nil {
			break
		}

		return e.complexity.TaskTestResultSample.Execution(childComplexity), true

	case "TaskTestResultSample.matchingFailedTestNames":
		if e.complexity.TaskTestResultSample.MatchingFailedTestNames == nil {
			break
		}

		return e.complexity.TaskTestResultSample.MatchingFailedTestNames(childComplexity), true

	case "TaskTestResultSample.taskId":
		if e.complexity.TaskTestResultSample.TaskID == nil {
			break
		}

		return e.complexity.TaskTestResultSample.TaskID(childComplexity), true

	case "TaskTestResultSample.totalTestCount":
		if e.complexity.TaskTestResultSample.TotalTestCount == nil {
			break
		}

		return e.complexity.TaskTestResultSample.TotalTestCount(childComplexity), true

	case "TestLog.lineNum":
		if e.complexity.TestLog.LineNum == nil {
			break
		}

		return e.complexity.TestLog.LineNum(childComplexity), true

	case "TestLog.renderingType":
		if e.complexity.TestLog.RenderingType == nil {
			break
		}

		return e.complexity.TestLog.RenderingType(childComplexity), true

	case "TestLog.url":
		if e.complexity.TestLog.URL == nil {
			break
		}

		return e.complexity.TestLog.URL(childComplexity), true

	case "TestLog.urlParsley":
		if e.complexity.TestLog.URLParsley == nil {
			break
		}

		return e.complexity.TestLog.URLParsley(childComplexity), true

	case "TestLog.urlRaw":
		if e.complexity.TestLog.URLRaw == nil {
			break
		}

		return e.complexity.TestLog.URLRaw(childComplexity), true

	case "TestLog.version":
		if e.complexity.TestLog.Version == nil {
			break
		}

		return e.complexity.TestLog.Version(childComplexity), true

	case "TestResult.baseStatus":
		if e.complexity.TestResult.BaseStatus == nil {
			break
		}

		return e.complexity.TestResult.BaseStatus(childComplexity), true

	case "TestResult.duration":
		if e.complexity.TestResult.Duration == nil {
			break
		}

		return e.complexity.TestResult.Duration(childComplexity), true

	case "TestResult.endTime":
		if e.complexity.TestResult.EndTime == nil {
			break
		}

		return e.complexity.TestResult.EndTime(childComplexity), true

	case "TestResult.execution":
		if e.complexity.TestResult.Execution == nil {
			break
		}

		return e.complexity.TestResult.Execution(childComplexity), true

	case "TestResult.exitCode":
		if e.complexity.TestResult.ExitCode == nil {
			break
		}

		return e.complexity.TestResult.ExitCode(childComplexity), true

	case "TestResult.groupID":
		if e.complexity.TestResult.GroupID == nil {
			break
		}

		return e.complexity.TestResult.GroupID(childComplexity), true

	case "TestResult.id":
		if e.complexity.TestResult.ID == nil {
			break
		}

		return e.complexity.TestResult.ID(childComplexity), true

	case "TestResult.logs":
		if e.complexity.TestResult.Logs == nil {
			break
		}

		return e.complexity.TestResult.Logs(childComplexity), true

	case "TestResult.startTime":
		if e.complexity.TestResult.StartTime == nil {
			break
		}

		return e.complexity.TestResult.StartTime(childComplexity), true

	case "TestResult.status":
		if e.complexity.TestResult.Status == nil {
			break
		}

		return e.complexity.TestResult.Status(childComplexity), true

	case "TestResult.taskId":
		if e.complexity.TestResult.TaskID == nil {
			break
		}

		return e.complexity.TestResult.TaskID(childComplexity), true

	case "TestResult.testFile":
		if e.complexity.TestResult.TestFile == nil {
			break
		}

		return e.complexity.TestResult.TestFile(childComplexity), true

	case "TicketFields.assignedTeam":
		if e.complexity.TicketFields.AssignedTeam == nil {
			break
		}

		return e.complexity.TicketFields.AssignedTeam(childComplexity), true

	case "TicketFields.assigneeDisplayName":
		if e.complexity.TicketFields.AssigneeDisplayName == nil {
			break
		}

		return e.complexity.TicketFields.AssigneeDisplayName(childComplexity), true

	case "TicketFields.created":
		if e.complexity.TicketFields.Created == nil {
			break
		}

		return e.complexity.TicketFields.Created(childComplexity), true

	case "TicketFields.resolutionName":
		if e.complexity.TicketFields.ResolutionName == nil {
			break
		}

		return e.complexity.TicketFields.ResolutionName(childComplexity), true

	case "TicketFields.status":
		if e.complexity.TicketFields.Status == nil {
			break
		}

		return e.complexity.TicketFields.Status(childComplexity), true

	case "TicketFields.summary":
		if e.complexity.TicketFields.Summary == nil {
			break
		}

		return e.complexity.TicketFields.Summary(childComplexity), true

	case "TicketFields.updated":
		if e.complexity.TicketFields.Updated == nil {
			break
		}

		return e.complexity.TicketFields.Updated(childComplexity), true

	case "Toolchain.name":
		if e.complexity.Toolchain.Name == nil {
			break
		}

		return e.complexity.Toolchain.Name(childComplexity), true

	case "Toolchain.path":
		if e.complexity.Toolchain.Path == nil {
			break
		}

		return e.complexity.Toolchain.Path(childComplexity), true

	case "Toolchain.version":
		if e.complexity.Toolchain.Version == nil {
			break
		}

		return e.complexity.Toolchain.Version(childComplexity), true

	case "TriggerAlias.alias":
		if e.complexity.TriggerAlias.Alias == nil {
			break
		}

		return e.complexity.TriggerAlias.Alias(childComplexity), true

	case "TriggerAlias.buildVariantRegex":
		if e.complexity.TriggerAlias.BuildVariantRegex == nil {
			break
		}

		return e.complexity.TriggerAlias.BuildVariantRegex(childComplexity), true

	case "TriggerAlias.configFile":
		if e.complexity.TriggerAlias.ConfigFile == nil {
			break
		}

		return e.complexity.TriggerAlias.ConfigFile(childComplexity), true

	case "TriggerAlias.dateCutoff":
		if e.complexity.TriggerAlias.DateCutoff == nil {
			break
		}

		return e.complexity.TriggerAlias.DateCutoff(childComplexity), true

	case "TriggerAlias.level":
		if e.complexity.TriggerAlias.Level == nil {
			break
		}

		return e.complexity.TriggerAlias.Level(childComplexity), true

	case "TriggerAlias.project":
		if e.complexity.TriggerAlias.Project == nil {
			break
		}

		return e.complexity.TriggerAlias.Project(childComplexity), true

	case "TriggerAlias.status":
		if e.complexity.TriggerAlias.Status == nil {
			break
		}

		return e.complexity.TriggerAlias.Status(childComplexity), true

	case "TriggerAlias.taskRegex":
		if e.complexity.TriggerAlias.TaskRegex == nil {
			break
		}

		return e.complexity.TriggerAlias.TaskRegex(childComplexity), true

	case "TriggerAlias.unscheduleDownstreamVersions":
		if e.complexity.TriggerAlias.UnscheduleDownstreamVersions == nil {
			break
		}

		return e.complexity.TriggerAlias.UnscheduleDownstreamVersions(childComplexity), true

	case "UIConfig.betaFeatures":
		if e.complexity.UIConfig.BetaFeatures == nil {
			break
		}

		return e.complexity.UIConfig.BetaFeatures(childComplexity), true

	case "UIConfig.defaultProject":
		if e.complexity.UIConfig.DefaultProject == nil {
			break
		}

		return e.complexity.UIConfig.DefaultProject(childComplexity), true

	case "UIConfig.userVoice":
		if e.complexity.UIConfig.UserVoice == nil {
			break
		}

		return e.complexity.UIConfig.UserVoice(childComplexity), true

	case "UpdateBetaFeaturesPayload.betaFeatures":
		if e.complexity.UpdateBetaFeaturesPayload.BetaFeatures == nil {
			break
		}

		return e.complexity.UpdateBetaFeaturesPayload.BetaFeatures(childComplexity), true

	case "UpdateParsleySettingsPayload.parsleySettings":
		if e.complexity.UpdateParsleySettingsPayload.ParsleySettings == nil {
			break
		}

		return e.complexity.UpdateParsleySettingsPayload.ParsleySettings(childComplexity), true

	case "UpstreamProject.owner":
		if e.complexity.UpstreamProject.Owner == nil {
			break
		}

		return e.complexity.UpstreamProject.Owner(childComplexity), true

	case "UpstreamProject.project":
		if e.complexity.UpstreamProject.Project == nil {
			break
		}

		return e.complexity.UpstreamProject.Project(childComplexity), true

	case "UpstreamProject.repo":
		if e.complexity.UpstreamProject.Repo == nil {
			break
		}

		return e.complexity.UpstreamProject.Repo(childComplexity), true

	case "UpstreamProject.resourceID":
		if e.complexity.UpstreamProject.ResourceID == nil {
			break
		}

		return e.complexity.UpstreamProject.ResourceID(childComplexity), true

	case "UpstreamProject.revision":
		if e.complexity.UpstreamProject.Revision == nil {
			break
		}

		return e.complexity.UpstreamProject.Revision(childComplexity), true

	case "UpstreamProject.task":
		if e.complexity.UpstreamProject.Task == nil {
			break
		}

		return e.complexity.UpstreamProject.Task(childComplexity), true

	case "UpstreamProject.triggerID":
		if e.complexity.UpstreamProject.TriggerID == nil {
			break
		}

		return e.complexity.UpstreamProject.TriggerID(childComplexity), true

	case "UpstreamProject.triggerType":
		if e.complexity.UpstreamProject.TriggerType == nil {
			break
		}

		return e.complexity.UpstreamProject.TriggerType(childComplexity), true

	case "UpstreamProject.version":
		if e.complexity.UpstreamProject.Version == nil {
			break
		}

		return e.complexity.UpstreamProject.Version(childComplexity), true

	case "UseSpruceOptions.hasUsedMainlineCommitsBefore":
		if e.complexity.UseSpruceOptions.HasUsedMainlineCommitsBefore == nil {
			break
		}

		return e.complexity.UseSpruceOptions.HasUsedMainlineCommitsBefore(childComplexity), true

	case "UseSpruceOptions.hasUsedSpruceBefore":
		if e.complexity.UseSpruceOptions.HasUsedSpruceBefore == nil {
			break
		}

		return e.complexity.UseSpruceOptions.HasUsedSpruceBefore(childComplexity), true

	case "UseSpruceOptions.spruceV1":
		if e.complexity.UseSpruceOptions.SpruceV1 == nil {
			break
		}

		return e.complexity.UseSpruceOptions.SpruceV1(childComplexity), true

	case "User.betaFeatures":
		if e.complexity.User.BetaFeatures == nil {
			break
		}

		return e.complexity.User.BetaFeatures(childComplexity), true

	case "User.displayName":
		if e.complexity.User.DisplayName == nil {
			break
		}

		return e.complexity.User.DisplayName(childComplexity), true

	case "User.emailAddress":
		if e.complexity.User.EmailAddress == nil {
			break
		}

		return e.complexity.User.EmailAddress(childComplexity), true

	case "User.parsleyFilters":
		if e.complexity.User.ParsleyFilters == nil {
			break
		}

		return e.complexity.User.ParsleyFilters(childComplexity), true

	case "User.parsleySettings":
		if e.complexity.User.ParsleySettings == nil {
			break
		}

		return e.complexity.User.ParsleySettings(childComplexity), true

	case "User.patches":
		if e.complexity.User.Patches == nil {
			break
		}

		args, err := ec.field_User_patches_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Patches(childComplexity, args["patchesInput"].(PatchesInput)), true

	case "User.permissions":
		if e.complexity.User.Permissions == nil {
			break
		}

		return e.complexity.User.Permissions(childComplexity), true

	case "User.settings":
		if e.complexity.User.Settings == nil {
			break
		}

		return e.complexity.User.Settings(childComplexity), true

	case "User.subscriptions":
		if e.complexity.User.Subscriptions == nil {
			break
		}

		return e.complexity.User.Subscriptions(childComplexity), true

	case "User.userId":
		if e.complexity.User.UserID == nil {
			break
		}

		return e.complexity.User.UserID(childComplexity), true

	case "UserConfig.api_key":
		if e.complexity.UserConfig.APIKey == nil {
			break
		}

		return e.complexity.UserConfig.APIKey(childComplexity), true

	case "UserConfig.api_server_host":
		if e.complexity.UserConfig.APIServerHost == nil {
			break
		}

		return e.complexity.UserConfig.APIServerHost(childComplexity), true

	case "UserConfig.ui_server_host":
		if e.complexity.UserConfig.UIServerHost == nil {
			break
		}

		return e.complexity.UserConfig.UIServerHost(childComplexity), true

	case "UserConfig.user":
		if e.complexity.UserConfig.User == nil {
			break
		}

		return e.complexity.UserConfig.User(childComplexity), true

	case "UserSettings.dateFormat":
		if e.complexity.UserSettings.DateFormat == nil {
			break
		}

		return e.complexity.UserSettings.DateFormat(childComplexity), true

	case "UserSettings.githubUser":
		if e.complexity.UserSettings.GithubUser == nil {
			break
		}

		return e.complexity.UserSettings.GithubUser(childComplexity), true

	case "UserSettings.notifications":
		if e.complexity.UserSettings.Notifications == nil {
			break
		}

		return e.complexity.UserSettings.Notifications(childComplexity), true

	case "UserSettings.region":
		if e.complexity.UserSettings.Region == nil {
			break
		}

		return e.complexity.UserSettings.Region(childComplexity), true

	case "UserSettings.slackMemberId":
		if e.complexity.UserSettings.SlackMemberId == nil {
			break
		}

		return e.complexity.UserSettings.SlackMemberId(childComplexity), true

	case "UserSettings.slackUsername":
		if e.complexity.UserSettings.SlackUsername == nil {
			break
		}

		return e.complexity.UserSettings.SlackUsername(childComplexity), true

	case "UserSettings.timeFormat":
		if e.complexity.UserSettings.TimeFormat == nil {
			break
		}

		return e.complexity.UserSettings.TimeFormat(childComplexity), true

	case "UserSettings.timezone":
		if e.complexity.UserSettings.Timezone == nil {
			break
		}

		return e.complexity.UserSettings.Timezone(childComplexity), true

	case "UserSettings.useSpruceOptions":
		if e.complexity.UserSettings.UseSpruceOptions == nil {
			break
		}

		return e.complexity.UserSettings.UseSpruceOptions(childComplexity), true

	case "VariantTask.name":
		if e.complexity.VariantTask.Name == nil {
			break
		}

		return e.complexity.VariantTask.Name(childComplexity), true

	case "VariantTask.tasks":
		if e.complexity.VariantTask.Tasks == nil {
			break
		}

		return e.complexity.VariantTask.Tasks(childComplexity), true

	case "Version.activated":
		if e.complexity.Version.Activated == nil {
			break
		}

		return e.complexity.Version.Activated(childComplexity), true

	case "Version.author":
		if e.complexity.Version.Author == nil {
			break
		}

		return e.complexity.Version.Author(childComplexity), true

	case "Version.authorEmail":
		if e.complexity.Version.AuthorEmail == nil {
			break
		}

		return e.complexity.Version.AuthorEmail(childComplexity), true

	case "Version.baseTaskStatuses":
		if e.complexity.Version.BaseTaskStatuses == nil {
			break
		}

		return e.complexity.Version.BaseTaskStatuses(childComplexity), true

	case "Version.baseVersion":
		if e.complexity.Version.BaseVersion == nil {
			break
		}

		return e.complexity.Version.BaseVersion(childComplexity), true

	case "Version.branch":
		if e.complexity.Version.Branch == nil {
			break
		}

		return e.complexity.Version.Branch(childComplexity), true

	case "Version.buildVariantStats":
		if e.complexity.Version.BuildVariantStats == nil {
			break
		}

		args, err := ec.field_Version_buildVariantStats_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.BuildVariantStats(childComplexity, args["options"].(BuildVariantOptions)), true

	case "Version.buildVariants":
		if e.complexity.Version.BuildVariants == nil {
			break
		}

		args, err := ec.field_Version_buildVariants_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.BuildVariants(childComplexity, args["options"].(BuildVariantOptions)), true

	case "Version.childVersions":
		if e.complexity.Version.ChildVersions == nil {
			break
		}

		return e.complexity.Version.ChildVersions(childComplexity), true

	case "Version.createTime":
		if e.complexity.Version.CreateTime == nil {
			break
		}

		return e.complexity.Version.CreateTime(childComplexity), true

	case "Version.errors":
		if e.complexity.Version.Errors == nil {
			break
		}

		return e.complexity.Version.Errors(childComplexity), true

	case "Version.externalLinksForMetadata":
		if e.complexity.Version.ExternalLinksForMetadata == nil {
			break
		}

		return e.complexity.Version.ExternalLinksForMetadata(childComplexity), true

	case "Version.finishTime":
		if e.complexity.Version.FinishTime == nil {
			break
		}

		return e.complexity.Version.FinishTime(childComplexity), true

	case "Version.generatedTaskCounts":
		if e.complexity.Version.GeneratedTaskCounts == nil {
			break
		}

		return e.complexity.Version.GeneratedTaskCounts(childComplexity), true

	case "Version.gitTags":
		if e.complexity.Version.GitTags == nil {
			break
		}

		return e.complexity.Version.GitTags(childComplexity), true

	case "Version.id":
		if e.complexity.Version.Id == nil {
			break
		}

		return e.complexity.Version.Id(childComplexity), true

	case "Version.ignored":
		if e.complexity.Version.Ignored == nil {
			break
		}

		return e.complexity.Version.Ignored(childComplexity), true

	case "Version.isPatch":
		if e.complexity.Version.IsPatch == nil {
			break
		}

		return e.complexity.Version.IsPatch(childComplexity), true

	case "Version.manifest":
		if e.complexity.Version.Manifest == nil {
			break
		}

		return e.complexity.Version.Manifest(childComplexity), true

	case "Version.message":
		if e.complexity.Version.Message == nil {
			break
		}

		return e.complexity.Version.Message(childComplexity), true

	case "Version.order":
		if e.complexity.Version.Order == nil {
			break
		}

		return e.complexity.Version.Order(childComplexity), true

	case "Version.parameters":
		if e.complexity.Version.Parameters == nil {
			break
		}

		return e.complexity.Version.Parameters(childComplexity), true

	case "Version.patch":
		if e.complexity.Version.Patch == nil {
			break
		}

		return e.complexity.Version.Patch(childComplexity), true

	case "Version.previousVersion":
		if e.complexity.Version.PreviousVersion == nil {
			break
		}

		return e.complexity.Version.PreviousVersion(childComplexity), true

	case "Version.project":
		if e.complexity.Version.Project == nil {
			break
		}

		return e.complexity.Version.Project(childComplexity), true

	case "Version.projectIdentifier":
		if e.complexity.Version.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Version.ProjectIdentifier(childComplexity), true

	case "Version.projectMetadata":
		if e.complexity.Version.ProjectMetadata == nil {
			break
		}

		return e.complexity.Version.ProjectMetadata(childComplexity), true

	case "Version.repo":
		if e.complexity.Version.Repo == nil {
			break
		}

		return e.complexity.Version.Repo(childComplexity), true

	case "Version.requester":
		if e.complexity.Version.Requester == nil {
			break
		}

		return e.complexity.Version.Requester(childComplexity), true

	case "Version.revision":
		if e.complexity.Version.Revision == nil {
			break
		}

		return e.complexity.Version.Revision(childComplexity), true

	case "Version.startTime":
		if e.complexity.Version.StartTime == nil {
			break
		}

		return e.complexity.Version.StartTime(childComplexity), true

	case "Version.status":
		if e.complexity.Version.Status == nil {
			break
		}

		return e.complexity.Version.Status(childComplexity), true

	case "Version.taskCount":
		if e.complexity.Version.TaskCount == nil {
			break
		}

		return e.complexity.Version.TaskCount(childComplexity), true

	case "Version.taskStatusStats":
		if e.complexity.Version.TaskStatusStats == nil {
			break
		}

		args, err := ec.field_Version_taskStatusStats_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.TaskStatusStats(childComplexity, args["options"].(BuildVariantOptions)), true

	case "Version.taskStatuses":
		if e.complexity.Version.TaskStatuses == nil {
			break
		}

		return e.complexity.Version.TaskStatuses(childComplexity), true

	case "Version.tasks":
		if e.complexity.Version.Tasks == nil {
			break
		}

		args, err := ec.field_Version_tasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.Tasks(childComplexity, args["options"].(TaskFilterOptions)), true

	case "Version.upstreamProject":
		if e.complexity.Version.UpstreamProject == nil {
			break
		}

		return e.complexity.Version.UpstreamProject(childComplexity), true

	case "Version.versionTiming":
		if e.complexity.Version.VersionTiming == nil {
			break
		}

		return e.complexity.Version.VersionTiming(childComplexity), true

	case "Version.warnings":
		if e.complexity.Version.Warnings == nil {
			break
		}

		return e.complexity.Version.Warnings(childComplexity), true

	case "Version.waterfallBuilds":
		if e.complexity.Version.WaterfallBuilds == nil {
			break
		}

		return e.complexity.Version.WaterfallBuilds(childComplexity), true

	case "VersionTasks.count":
		if e.complexity.VersionTasks.Count == nil {
			break
		}

		return e.complexity.VersionTasks.Count(childComplexity), true

	case "VersionTasks.data":
		if e.complexity.VersionTasks.Data == nil {
			break
		}

		return e.complexity.VersionTasks.Data(childComplexity), true

	case "VersionTiming.makespan":
		if e.complexity.VersionTiming.Makespan == nil {
			break
		}

		return e.complexity.VersionTiming.Makespan(childComplexity), true

	case "VersionTiming.timeTaken":
		if e.complexity.VersionTiming.TimeTaken == nil {
			break
		}

		return e.complexity.VersionTiming.TimeTaken(childComplexity), true

	case "Volume.availabilityZone":
		if e.complexity.Volume.AvailabilityZone == nil {
			break
		}

		return e.complexity.Volume.AvailabilityZone(childComplexity), true

	case "Volume.createdBy":
		if e.complexity.Volume.CreatedBy == nil {
			break
		}

		return e.complexity.Volume.CreatedBy(childComplexity), true

	case "Volume.creationTime":
		if e.complexity.Volume.CreationTime == nil {
			break
		}

		return e.complexity.Volume.CreationTime(childComplexity), true

	case "Volume.deviceName":
		if e.complexity.Volume.DeviceName == nil {
			break
		}

		return e.complexity.Volume.DeviceName(childComplexity), true

	case "Volume.displayName":
		if e.complexity.Volume.DisplayName == nil {
			break
		}

		return e.complexity.Volume.DisplayName(childComplexity), true

	case "Volume.expiration":
		if e.complexity.Volume.Expiration == nil {
			break
		}

		return e.complexity.Volume.Expiration(childComplexity), true

	case "Volume.homeVolume":
		if e.complexity.Volume.HomeVolume == nil {
			break
		}

		return e.complexity.Volume.HomeVolume(childComplexity), true

	case "Volume.host":
		if e.complexity.Volume.Host == nil {
			break
		}

		return e.complexity.Volume.Host(childComplexity), true

	case "Volume.hostID":
		if e.complexity.Volume.HostID == nil {
			break
		}

		return e.complexity.Volume.HostID(childComplexity), true

	case "Volume.id":
		if e.complexity.Volume.ID == nil {
			break
		}

		return e.complexity.Volume.ID(childComplexity), true

	case "Volume.migrating":
		if e.complexity.Volume.Migrating == nil {
			break
		}

		return e.complexity.Volume.Migrating(childComplexity), true

	case "Volume.noExpiration":
		if e.complexity.Volume.NoExpiration == nil {
			break
		}

		return e.complexity.Volume.NoExpiration(childComplexity), true

	case "Volume.size":
		if e.complexity.Volume.Size == nil {
			break
		}

		return e.complexity.Volume.Size(childComplexity), true

	case "Volume.type":
		if e.complexity.Volume.Type == nil {
			break
		}

		return e.complexity.Volume.Type(childComplexity), true

	case "Waterfall.flattenedVersions":
		if e.complexity.Waterfall.FlattenedVersions == nil {
			break
		}

		return e.complexity.Waterfall.FlattenedVersions(childComplexity), true

	case "Waterfall.pagination":
		if e.complexity.Waterfall.Pagination == nil {
			break
		}

		return e.complexity.Waterfall.Pagination(childComplexity), true

	case "WaterfallBuild.activated":
		if e.complexity.WaterfallBuild.Activated == nil {
			break
		}

		return e.complexity.WaterfallBuild.Activated(childComplexity), true

	case "WaterfallBuild.buildVariant":
		if e.complexity.WaterfallBuild.BuildVariant == nil {
			break
		}

		return e.complexity.WaterfallBuild.BuildVariant(childComplexity), true

	case "WaterfallBuild.displayName":
		if e.complexity.WaterfallBuild.DisplayName == nil {
			break
		}

		return e.complexity.WaterfallBuild.DisplayName(childComplexity), true

	case "WaterfallBuild.id":
		if e.complexity.WaterfallBuild.Id == nil {
			break
		}

		return e.complexity.WaterfallBuild.Id(childComplexity), true

	case "WaterfallBuild.tasks":
		if e.complexity.WaterfallBuild.Tasks == nil {
			break
		}

		return e.complexity.WaterfallBuild.Tasks(childComplexity), true

	case "WaterfallBuild.version":
		if e.complexity.WaterfallBuild.Version == nil {
			break
		}

		return e.complexity.WaterfallBuild.Version(childComplexity), true

	case "WaterfallBuildVariant.builds":
		if e.complexity.WaterfallBuildVariant.Builds == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.Builds(childComplexity), true

	case "WaterfallBuildVariant.displayName":
		if e.complexity.WaterfallBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.DisplayName(childComplexity), true

	case "WaterfallBuildVariant.id":
		if e.complexity.WaterfallBuildVariant.Id == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.Id(childComplexity), true

	case "WaterfallBuildVariant.version":
		if e.complexity.WaterfallBuildVariant.Version == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.Version(childComplexity), true

	case "WaterfallPagination.activeVersionIds":
		if e.complexity.WaterfallPagination.ActiveVersionIds == nil {
			break
		}

		return e.complexity.WaterfallPagination.ActiveVersionIds(childComplexity), true

	case "WaterfallPagination.hasNextPage":
		if e.complexity.WaterfallPagination.HasNextPage == nil {
			break
		}

		return e.complexity.WaterfallPagination.HasNextPage(childComplexity), true

	case "WaterfallPagination.hasPrevPage":
		if e.complexity.WaterfallPagination.HasPrevPage == nil {
			break
		}

		return e.complexity.WaterfallPagination.HasPrevPage(childComplexity), true

	case "WaterfallPagination.mostRecentVersionOrder":
		if e.complexity.WaterfallPagination.MostRecentVersionOrder == nil {
			break
		}

		return e.complexity.WaterfallPagination.MostRecentVersionOrder(childComplexity), true

	case "WaterfallPagination.nextPageOrder":
		if e.complexity.WaterfallPagination.NextPageOrder == nil {
			break
		}

		return e.complexity.WaterfallPagination.NextPageOrder(childComplexity), true

	case "WaterfallPagination.prevPageOrder":
		if e.complexity.WaterfallPagination.PrevPageOrder == nil {
			break
		}

		return e.complexity.WaterfallPagination.PrevPageOrder(childComplexity), true

	case "WaterfallTask.displayName":
		if e.complexity.WaterfallTask.DisplayName == nil {
			break
		}

		return e.complexity.WaterfallTask.DisplayName(childComplexity), true

	case "WaterfallTask.displayStatusCache":
		if e.complexity.WaterfallTask.DisplayStatusCache == nil {
			break
		}

		return e.complexity.WaterfallTask.DisplayStatusCache(childComplexity), true

	case "WaterfallTask.execution":
		if e.complexity.WaterfallTask.Execution == nil {
			break
		}

		return e.complexity.WaterfallTask.Execution(childComplexity), true

	case "WaterfallTask.id":
		if e.complexity.WaterfallTask.Id == nil {
			break
		}

		return e.complexity.WaterfallTask.Id(childComplexity), true

	case "WaterfallTask.status":
		if e.complexity.WaterfallTask.Status == nil {
			break
		}

		return e.complexity.WaterfallTask.Status(childComplexity), true

	case "WaterfallVersion.inactiveVersions":
		if e.complexity.WaterfallVersion.InactiveVersions == nil {
			break
		}

		return e.complexity.WaterfallVersion.InactiveVersions(childComplexity), true

	case "WaterfallVersion.version":
		if e.complexity.WaterfallVersion.Version == nil {
			break
		}

		return e.complexity.WaterfallVersion.Version(childComplexity), true

	case "Webhook.endpoint":
		if e.complexity.Webhook.Endpoint == nil {
			break
		}

		return e.complexity.Webhook.Endpoint(childComplexity), true

	case "Webhook.secret":
		if e.complexity.Webhook.Secret == nil {
			break
		}

		return e.complexity.Webhook.Secret(childComplexity), true

	case "WebhookHeader.key":
		if e.complexity.WebhookHeader.Key == nil {
			break
		}

		return e.complexity.WebhookHeader.Key(childComplexity), true

	case "WebhookHeader.value":
		if e.complexity.WebhookHeader.Value == nil {
			break
		}

		return e.complexity.WebhookHeader.Value(childComplexity), true

	case "WebhookSubscriber.headers":
		if e.complexity.WebhookSubscriber.Headers == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Headers(childComplexity), true

	case "WebhookSubscriber.minDelayMs":
		if e.complexity.WebhookSubscriber.MinDelayMS == nil {
			break
		}

		return e.complexity.WebhookSubscriber.MinDelayMS(childComplexity), true

	case "WebhookSubscriber.retries":
		if e.complexity.WebhookSubscriber.Retries == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Retries(childComplexity), true

	case "WebhookSubscriber.secret":
		if e.complexity.WebhookSubscriber.Secret == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Secret(childComplexity), true

	case "WebhookSubscriber.timeoutMs":
		if e.complexity.WebhookSubscriber.TimeoutMS == nil {
			break
		}

		return e.complexity.WebhookSubscriber.TimeoutMS(childComplexity), true

	case "WebhookSubscriber.url":
		if e.complexity.WebhookSubscriber.URL == nil {
			break
		}

		return e.complexity.WebhookSubscriber.URL(childComplexity), true

	case "WorkstationConfig.gitClone":
		if e.complexity.WorkstationConfig.GitClone == nil {
			break
		}

		return e.complexity.WorkstationConfig.GitClone(childComplexity), true

	case "WorkstationConfig.setupCommands":
		if e.complexity.WorkstationConfig.SetupCommands == nil {
			break
		}

		return e.complexity.WorkstationConfig.SetupCommands(childComplexity), true

	case "WorkstationSetupCommand.command":
		if e.complexity.WorkstationSetupCommand.Command == nil {
			break
		}

		return e.complexity.WorkstationSetupCommand.Command(childComplexity), true

	case "WorkstationSetupCommand.directory":
		if e.complexity.WorkstationSetupCommand.Directory == nil {
			break
		}

		return e.complexity.WorkstationSetupCommand.Directory(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddFavoriteProjectInput,
		ec.unmarshalInputBetaFeaturesInput,
		ec.unmarshalInputBootstrapSettingsInput,
		ec.unmarshalInputBuildBaronSettingsInput,
		ec.unmarshalInputBuildVariantOptions,
		ec.unmarshalInputCommitQueueParamsInput,
		ec.unmarshalInputContainerResourcesInput,
		ec.unmarshalInputCopyDistroInput,
		ec.unmarshalInputCopyProjectInput,
		ec.unmarshalInputCreateDistroInput,
		ec.unmarshalInputCreateProjectInput,
		ec.unmarshalInputCursorParams,
		ec.unmarshalInputDeactivateStepbackTaskInput,
		ec.unmarshalInputDefaultSectionToRepoInput,
		ec.unmarshalInputDeleteDistroInput,
		ec.unmarshalInputDeleteGithubAppCredentialsInput,
		ec.unmarshalInputDispatcherSettingsInput,
		ec.unmarshalInputDisplayTask,
		ec.unmarshalInputDistroEventsInput,
		ec.unmarshalInputDistroInput,
		ec.unmarshalInputDistroPermissionsOptions,
		ec.unmarshalInputEditSpawnHostInput,
		ec.unmarshalInputEnvVarInput,
		ec.unmarshalInputExpansionInput,
		ec.unmarshalInputExternalLinkInput,
		ec.unmarshalInputFinderSettingsInput,
		ec.unmarshalInputGitHubDynamicTokenPermissionGroupInput,
		ec.unmarshalInputGithubAppAuthInput,
		ec.unmarshalInputGithubUserInput,
		ec.unmarshalInputHomeVolumeSettingsInput,
		ec.unmarshalInputHostAllocatorSettingsInput,
		ec.unmarshalInputHostEventsInput,
		ec.unmarshalInputIceCreamSettingsInput,
		ec.unmarshalInputInstanceTagInput,
		ec.unmarshalInputIssueLinkInput,
		ec.unmarshalInputJiraIssueSubscriberInput,
		ec.unmarshalInputMainlineCommitsOptions,
		ec.unmarshalInputMetadataLinkInput,
		ec.unmarshalInputMoveProjectInput,
		ec.unmarshalInputNotificationsInput,
		ec.unmarshalInputOperatingSystemOpts,
		ec.unmarshalInputPackageOpts,
		ec.unmarshalInputParameterInput,
		ec.unmarshalInputParsleyFilterInput,
		ec.unmarshalInputParsleySettingsInput,
		ec.unmarshalInputPatchConfigure,
		ec.unmarshalInputPatchTriggerAliasInput,
		ec.unmarshalInputPatchesInput,
		ec.unmarshalInputPeriodicBuildInput,
		ec.unmarshalInputPlannerSettingsInput,
		ec.unmarshalInputPreconditionScriptInput,
		ec.unmarshalInputProjectAliasInput,
		ec.unmarshalInputProjectBannerInput,
		ec.unmarshalInputProjectInput,
		ec.unmarshalInputProjectPermissionsOptions,
		ec.unmarshalInputProjectSettingsInput,
		ec.unmarshalInputProjectVarsInput,
		ec.unmarshalInputPromoteVarsToRepoInput,
		ec.unmarshalInputPublicKeyInput,
		ec.unmarshalInputRemoveFavoriteProjectInput,
		ec.unmarshalInputRepoPermissionsOptions,
		ec.unmarshalInputRepoRefInput,
		ec.unmarshalInputRepoSettingsInput,
		ec.unmarshalInputResourceLimitsInput,
		ec.unmarshalInputSaveDistroInput,
		ec.unmarshalInputSelectorInput,
		ec.unmarshalInputSetLastRevisionInput,
		ec.unmarshalInputSleepScheduleInput,
		ec.unmarshalInputSortOrder,
		ec.unmarshalInputSpawnHostInput,
		ec.unmarshalInputSpawnVolumeInput,
		ec.unmarshalInputSubscriberInput,
		ec.unmarshalInputSubscriptionInput,
		ec.unmarshalInputTaskAnnotationSettingsInput,
		ec.unmarshalInputTaskFilterOptions,
		ec.unmarshalInputTaskHistoryOpts,
		ec.unmarshalInputTaskSpecifierInput,
		ec.unmarshalInputTestFilter,
		ec.unmarshalInputTestFilterOptions,
		ec.unmarshalInputTestSortOptions,
		ec.unmarshalInputToolchainOpts,
		ec.unmarshalInputTriggerAliasInput,
		ec.unmarshalInputUpdateBetaFeaturesInput,
		ec.unmarshalInputUpdateParsleySettingsInput,
		ec.unmarshalInputUpdateSpawnHostStatusInput,
		ec.unmarshalInputUpdateVolumeInput,
		ec.unmarshalInputUseSpruceOptionsInput,
		ec.unmarshalInputUserSettingsInput,
		ec.unmarshalInputVariantTasks,
		ec.unmarshalInputVersionToRestart,
		ec.unmarshalInputVolumeHost,
		ec.unmarshalInputWaterfallOptions,
		ec.unmarshalInputWebhookHeaderInput,
		ec.unmarshalInputWebhookInput,
		ec.unmarshalInputWebhookSubscriberInput,
		ec.unmarshalInputWorkstationConfigInput,
		ec.unmarshalInputWorkstationSetupCommandInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "schema/directives.graphql" "schema/mutation.graphql" "schema/query.graphql" "schema/scalars.graphql" "schema/types/annotation.graphql" "schema/types/config.graphql" "schema/types/distro.graphql" "schema/types/host.graphql" "schema/types/image.graphql" "schema/types/issue_link.graphql" "schema/types/logkeeper.graphql" "schema/types/mainline_commits.graphql" "schema/types/patch.graphql" "schema/types/permissions.graphql" "schema/types/pod.graphql" "schema/types/project.graphql" "schema/types/project_settings.graphql" "schema/types/project_subscriber.graphql" "schema/types/project_vars.graphql" "schema/types/repo_ref.graphql" "schema/types/repo_settings.graphql" "schema/types/spawn.graphql" "schema/types/subscriptions.graphql" "schema/types/task.graphql" "schema/types/task_history.graphql" "schema/types/task_logs.graphql" "schema/types/task_queue_item.graphql" "schema/types/ticket_fields.graphql" "schema/types/user.graphql" "schema/types/version.graphql" "schema/types/volume.graphql" "schema/types/waterfall.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema/directives.graphql", Input: sourceData("schema/directives.graphql"), BuiltIn: false},
	{Name: "schema/mutation.graphql", Input: sourceData("schema/mutation.graphql"), BuiltIn: false},
	{Name: "schema/query.graphql", Input: sourceData("schema/query.graphql"), BuiltIn: false},
	{Name: "schema/scalars.graphql", Input: sourceData("schema/scalars.graphql"), BuiltIn: false},
	{Name: "schema/types/annotation.graphql", Input: sourceData("schema/types/annotation.graphql"), BuiltIn: false},
	{Name: "schema/types/config.graphql", Input: sourceData("schema/types/config.graphql"), BuiltIn: false},
	{Name: "schema/types/distro.graphql", Input: sourceData("schema/types/distro.graphql"), BuiltIn: false},
	{Name: "schema/types/host.graphql", Input: sourceData("schema/types/host.graphql"), BuiltIn: false},
	{Name: "schema/types/image.graphql", Input: sourceData("schema/types/image.graphql"), BuiltIn: false},
	{Name: "schema/types/issue_link.graphql", Input: sourceData("schema/types/issue_link.graphql"), BuiltIn: false},
	{Name: "schema/types/logkeeper.graphql", Input: sourceData("schema/types/logkeeper.graphql"), BuiltIn: false},
	{Name: "schema/types/mainline_commits.graphql", Input: sourceData("schema/types/mainline_commits.graphql"), BuiltIn: false},
	{Name: "schema/types/patch.graphql", Input: sourceData("schema/types/patch.graphql"), BuiltIn: false},
	{Name: "schema/types/permissions.graphql", Input: sourceData("schema/types/permissions.graphql"), BuiltIn: false},
	{Name: "schema/types/pod.graphql", Input: sourceData("schema/types/pod.graphql"), BuiltIn: false},
	{Name: "schema/types/project.graphql", Input: sourceData("schema/types/project.graphql"), BuiltIn: false},
	{Name: "schema/types/project_settings.graphql", Input: sourceData("schema/types/project_settings.graphql"), BuiltIn: false},
	{Name: "schema/types/project_subscriber.graphql", Input: sourceData("schema/types/project_subscriber.graphql"), BuiltIn: false},
	{Name: "schema/types/project_vars.graphql", Input: sourceData("schema/types/project_vars.graphql"), BuiltIn: false},
	{Name: "schema/types/repo_ref.graphql", Input: sourceData("schema/types/repo_ref.graphql"), BuiltIn: false},
	{Name: "schema/types/repo_settings.graphql", Input: sourceData("schema/types/repo_settings.graphql"), BuiltIn: false},
	{Name: "schema/types/spawn.graphql", Input: sourceData("schema/types/spawn.graphql"), BuiltIn: false},
	{Name: "schema/types/subscriptions.graphql", Input: sourceData("schema/types/subscriptions.graphql"), BuiltIn: false},
	{Name: "schema/types/task.graphql", Input: sourceData("schema/types/task.graphql"), BuiltIn: false},
	{Name: "schema/types/task_history.graphql", Input: sourceData("schema/types/task_history.graphql"), BuiltIn: false},
	{Name: "schema/types/task_logs.graphql", Input: sourceData("schema/types/task_logs.graphql"), BuiltIn: false},
	{Name: "schema/types/task_queue_item.graphql", Input: sourceData("schema/types/task_queue_item.graphql"), BuiltIn: false},
	{Name: "schema/types/ticket_fields.graphql", Input: sourceData("schema/types/ticket_fields.graphql"), BuiltIn: false},
	{Name: "schema/types/user.graphql", Input: sourceData("schema/types/user.graphql"), BuiltIn: false},
	{Name: "schema/types/version.graphql", Input: sourceData("schema/types/version.graphql"), BuiltIn: false},
	{Name: "schema/types/volume.graphql", Input: sourceData("schema/types/volume.graphql"), BuiltIn: false},
	{Name: "schema/types/waterfall.graphql", Input: sourceData("schema/types/waterfall.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_requireDistroAccess_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_requireDistroAccess_argsAccess(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["access"] = arg0
	return args, nil
}
func (ec *executionContext) dir_requireDistroAccess_argsAccess(
	ctx context.Context,
	rawArgs map[string]any,
) (DistroSettingsAccess, error) {
	if _, ok := rawArgs["access"]; !ok {
		var zeroVal DistroSettingsAccess
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
	if tmp, ok := rawArgs["access"]; ok {
		return ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, tmp)
	}

	var zeroVal DistroSettingsAccess
	return zeroVal, nil
}

func (ec *executionContext) dir_requireHostAccess_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_requireHostAccess_argsAccess(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["access"] = arg0
	return args, nil
}
func (ec *executionContext) dir_requireHostAccess_argsAccess(
	ctx context.Context,
	rawArgs map[string]any,
) (HostAccessLevel, error) {
	if _, ok := rawArgs["access"]; !ok {
		var zeroVal HostAccessLevel
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
	if tmp, ok := rawArgs["access"]; ok {
		return ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, tmp)
	}

	var zeroVal HostAccessLevel
	return zeroVal, nil
}

func (ec *executionContext) dir_requireProjectAccess_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_requireProjectAccess_argsPermission(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["permission"] = arg0
	arg1, err := ec.dir_requireProjectAccess_argsAccess(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["access"] = arg1
	return args, nil
}
func (ec *executionContext) dir_requireProjectAccess_argsPermission(
	ctx context.Context,
	rawArgs map[string]any,
) (ProjectPermission, error) {
	if _, ok := rawArgs["permission"]; !ok {
		var zeroVal ProjectPermission
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("permission"))
	if tmp, ok := rawArgs["permission"]; ok {
		return ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, tmp)
	}

	var zeroVal ProjectPermission
	return zeroVal, nil
}

func (ec *executionContext) dir_requireProjectAccess_argsAccess(
	ctx context.Context,
	rawArgs map[string]any,
) (AccessLevel, error) {
	if _, ok := rawArgs["access"]; !ok {
		var zeroVal AccessLevel
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
	if tmp, ok := rawArgs["access"]; ok {
		return ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, tmp)
	}

	var zeroVal AccessLevel
	return zeroVal, nil
}

func (ec *executionContext) field_Host_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Host_events_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Host_events_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (HostEventsInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal HostEventsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNHostEventsInput2githubcomevergreencievergreengraphqlHostEventsInput(ctx, tmp)
	}

	var zeroVal HostEventsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Image_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Image_events_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := ec.field_Image_events_argsPage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["page"] = arg1
	return args, nil
}
func (ec *executionContext) field_Image_events_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Image_events_argsPage(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["page"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
	if tmp, ok := rawArgs["page"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Image_operatingSystem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Image_operatingSystem_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Image_operatingSystem_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (thirdparty.OSInfoFilterOptions, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal thirdparty.OSInfoFilterOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNOperatingSystemOpts2githubcomevergreencievergreenthirdpartyOSInfoFilterOptions(ctx, tmp)
	}

	var zeroVal thirdparty.OSInfoFilterOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Image_packages_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Image_packages_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Image_packages_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (thirdparty.PackageFilterOptions, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal thirdparty.PackageFilterOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNPackageOpts2githubcomevergreencievergreenthirdpartyPackageFilterOptions(ctx, tmp)
	}

	var zeroVal thirdparty.PackageFilterOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Image_toolchains_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Image_toolchains_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Image_toolchains_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (thirdparty.ToolchainFilterOptions, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal thirdparty.ToolchainFilterOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNToolchainOpts2githubcomevergreencievergreenthirdpartyToolchainFilterOptions(ctx, tmp)
	}

	var zeroVal thirdparty.ToolchainFilterOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_abortTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_abortTask_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_abortTask_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_addAnnotationIssue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addAnnotationIssue_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_addAnnotationIssue_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := ec.field_Mutation_addAnnotationIssue_argsAPIIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["apiIssue"] = arg2
	arg3, err := ec.field_Mutation_addAnnotationIssue_argsIsIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isIssue"] = arg3
	return args, nil
}
func (ec *executionContext) field_Mutation_addAnnotationIssue_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addAnnotationIssue_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addAnnotationIssue_argsAPIIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APIIssueLink, error) {
	if _, ok := rawArgs["apiIssue"]; !ok {
		var zeroVal model.APIIssueLink
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("apiIssue"))
	if tmp, ok := rawArgs["apiIssue"]; ok {
		return ec.unmarshalNIssueLinkInput2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx, tmp)
	}

	var zeroVal model.APIIssueLink
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addAnnotationIssue_argsIsIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["isIssue"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isIssue"))
	if tmp, ok := rawArgs["isIssue"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addFavoriteProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addFavoriteProject_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addFavoriteProject_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (AddFavoriteProjectInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal AddFavoriteProjectInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNAddFavoriteProjectInput2githubcomevergreencievergreengraphqlAddFavoriteProjectInput(ctx, tmp)
	}

	var zeroVal AddFavoriteProjectInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_attachProjectToNewRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_attachProjectToNewRepo_argsProject(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["project"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_attachProjectToNewRepo_argsProject(
	ctx context.Context,
	rawArgs map[string]any,
) (MoveProjectInput, error) {
	if _, ok := rawArgs["project"]; !ok {
		var zeroVal MoveProjectInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
	if tmp, ok := rawArgs["project"]; ok {
		return ec.unmarshalNMoveProjectInput2githubcomevergreencievergreengraphqlMoveProjectInput(ctx, tmp)
	}

	var zeroVal MoveProjectInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_attachProjectToRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_attachProjectToRepo_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_attachProjectToRepo_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_attachVolumeToHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_attachVolumeToHost_argsVolumeAndHost(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["volumeAndHost"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_attachVolumeToHost_argsVolumeAndHost(
	ctx context.Context,
	rawArgs map[string]any,
) (VolumeHost, error) {
	if _, ok := rawArgs["volumeAndHost"]; !ok {
		var zeroVal VolumeHost
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeAndHost"))
	if tmp, ok := rawArgs["volumeAndHost"]; ok {
		return ec.unmarshalNVolumeHost2githubcomevergreencievergreengraphqlVolumeHost(ctx, tmp)
	}

	var zeroVal VolumeHost
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_bbCreateTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_bbCreateTicket_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_bbCreateTicket_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_bbCreateTicket_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_bbCreateTicket_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_copyDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_copyDistro_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_copyDistro_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (model.CopyDistroOpts, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal model.CopyDistroOpts
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["opts"]
		if !ok {
			var zeroVal model.CopyDistroOpts
			return zeroVal, nil
		}
		return ec.unmarshalNCopyDistroInput2githubcomevergreencievergreenrestmodelCopyDistroOpts(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "CREATE")
		if err != nil {
			var zeroVal model.CopyDistroOpts
			return zeroVal, err
		}
		if ec.directives.RequireDistroAccess == nil {
			var zeroVal model.CopyDistroOpts
			return zeroVal, errors.New("directive requireDistroAccess is not implemented")
		}
		return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal model.CopyDistroOpts
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(model.CopyDistroOpts); ok {
		return data, nil
	} else {
		var zeroVal model.CopyDistroOpts
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.CopyDistroOpts`, tmp))
	}
}

func (ec *executionContext) field_Mutation_copyProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_copyProject_argsProject(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["project"] = arg0
	arg1, err := ec.field_Mutation_copyProject_argsRequestS3Creds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["requestS3Creds"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_copyProject_argsProject(
	ctx context.Context,
	rawArgs map[string]any,
) (model.CopyProjectOpts, error) {
	if _, ok := rawArgs["project"]; !ok {
		var zeroVal model.CopyProjectOpts
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["project"]
		if !ok {
			var zeroVal model.CopyProjectOpts
			return zeroVal, nil
		}
		return ec.unmarshalNCopyProjectInput2githubcomevergreencievergreenrestmodelCopyProjectOpts(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal model.CopyProjectOpts
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal model.CopyProjectOpts
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(model.CopyProjectOpts); ok {
		return data, nil
	} else {
		var zeroVal model.CopyProjectOpts
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.CopyProjectOpts`, tmp))
	}
}

func (ec *executionContext) field_Mutation_copyProject_argsRequestS3Creds(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["requestS3Creds"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("requestS3Creds"))
	if tmp, ok := rawArgs["requestS3Creds"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createDistro_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createDistro_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (CreateDistroInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal CreateDistroInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["opts"]
		if !ok {
			var zeroVal CreateDistroInput
			return zeroVal, nil
		}
		return ec.unmarshalNCreateDistroInput2githubcomevergreencievergreengraphqlCreateDistroInput(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "CREATE")
		if err != nil {
			var zeroVal CreateDistroInput
			return zeroVal, err
		}
		if ec.directives.RequireDistroAccess == nil {
			var zeroVal CreateDistroInput
			return zeroVal, errors.New("directive requireDistroAccess is not implemented")
		}
		return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal CreateDistroInput
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(CreateDistroInput); ok {
		return data, nil
	} else {
		var zeroVal CreateDistroInput
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/graphql.CreateDistroInput`, tmp))
	}
}

func (ec *executionContext) field_Mutation_createProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createProject_argsProject(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["project"] = arg0
	arg1, err := ec.field_Mutation_createProject_argsRequestS3Creds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["requestS3Creds"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_createProject_argsProject(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APIProjectRef, error) {
	if _, ok := rawArgs["project"]; !ok {
		var zeroVal model.APIProjectRef
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["project"]
		if !ok {
			var zeroVal model.APIProjectRef
			return zeroVal, nil
		}
		return ec.unmarshalNCreateProjectInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal model.APIProjectRef
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal model.APIProjectRef
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(model.APIProjectRef); ok {
		return data, nil
	} else {
		var zeroVal model.APIProjectRef
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectRef`, tmp))
	}
}

func (ec *executionContext) field_Mutation_createProject_argsRequestS3Creds(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["requestS3Creds"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("requestS3Creds"))
	if tmp, ok := rawArgs["requestS3Creds"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createPublicKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createPublicKey_argsPublicKeyInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["publicKeyInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createPublicKey_argsPublicKeyInput(
	ctx context.Context,
	rawArgs map[string]any,
) (PublicKeyInput, error) {
	if _, ok := rawArgs["publicKeyInput"]; !ok {
		var zeroVal PublicKeyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKeyInput"))
	if tmp, ok := rawArgs["publicKeyInput"]; ok {
		return ec.unmarshalNPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx, tmp)
	}

	var zeroVal PublicKeyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deactivateStepbackTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deactivateStepbackTask_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deactivateStepbackTask_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (DeactivateStepbackTaskInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal DeactivateStepbackTaskInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNDeactivateStepbackTaskInput2githubcomevergreencievergreengraphqlDeactivateStepbackTaskInput(ctx, tmp)
	}

	var zeroVal DeactivateStepbackTaskInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_defaultSectionToRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_defaultSectionToRepo_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_defaultSectionToRepo_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (DefaultSectionToRepoInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal DefaultSectionToRepoInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNDefaultSectionToRepoInput2githubcomevergreencievergreengraphqlDefaultSectionToRepoInput(ctx, tmp)
	}

	var zeroVal DefaultSectionToRepoInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteDistro_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteDistro_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (DeleteDistroInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal DeleteDistroInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNDeleteDistroInput2githubcomevergreencievergreengraphqlDeleteDistroInput(ctx, tmp)
	}

	var zeroVal DeleteDistroInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteGithubAppCredentials_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteGithubAppCredentials_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteGithubAppCredentials_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (DeleteGithubAppCredentialsInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal DeleteGithubAppCredentialsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNDeleteGithubAppCredentialsInput2githubcomevergreencievergreengraphqlDeleteGithubAppCredentialsInput(ctx, tmp)
	}

	var zeroVal DeleteGithubAppCredentialsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteProject_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteProject_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_deleteSubscriptions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteSubscriptions_argsSubscriptionIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["subscriptionIds"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteSubscriptions_argsSubscriptionIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["subscriptionIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptionIds"))
	if tmp, ok := rawArgs["subscriptionIds"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_detachProjectFromRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_detachProjectFromRepo_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_detachProjectFromRepo_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_detachVolumeFromHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_detachVolumeFromHost_argsVolumeID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["volumeId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_detachVolumeFromHost_argsVolumeID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["volumeId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
	if tmp, ok := rawArgs["volumeId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editAnnotationNote_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_editAnnotationNote_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_editAnnotationNote_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := ec.field_Mutation_editAnnotationNote_argsOriginalMessage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["originalMessage"] = arg2
	arg3, err := ec.field_Mutation_editAnnotationNote_argsNewMessage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["newMessage"] = arg3
	return args, nil
}
func (ec *executionContext) field_Mutation_editAnnotationNote_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editAnnotationNote_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editAnnotationNote_argsOriginalMessage(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["originalMessage"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("originalMessage"))
	if tmp, ok := rawArgs["originalMessage"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editAnnotationNote_argsNewMessage(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["newMessage"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("newMessage"))
	if tmp, ok := rawArgs["newMessage"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editSpawnHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_editSpawnHost_argsSpawnHost(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spawnHost"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_editSpawnHost_argsSpawnHost(
	ctx context.Context,
	rawArgs map[string]any,
) (*EditSpawnHostInput, error) {
	if _, ok := rawArgs["spawnHost"]; !ok {
		var zeroVal *EditSpawnHostInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHost"))
	if tmp, ok := rawArgs["spawnHost"]; ok {
		return ec.unmarshalOEditSpawnHostInput2githubcomevergreencievergreengraphqlEditSpawnHostInput(ctx, tmp)
	}

	var zeroVal *EditSpawnHostInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_forceRepotrackerRun_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_forceRepotrackerRun_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_forceRepotrackerRun_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_migrateVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_migrateVolume_argsVolumeID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["volumeId"] = arg0
	arg1, err := ec.field_Mutation_migrateVolume_argsSpawnHostInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spawnHostInput"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_migrateVolume_argsVolumeID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["volumeId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
	if tmp, ok := rawArgs["volumeId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_migrateVolume_argsSpawnHostInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*SpawnHostInput, error) {
	if _, ok := rawArgs["spawnHostInput"]; !ok {
		var zeroVal *SpawnHostInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostInput"))
	if tmp, ok := rawArgs["spawnHostInput"]; ok {
		return ec.unmarshalOSpawnHostInput2githubcomevergreencievergreengraphqlSpawnHostInput(ctx, tmp)
	}

	var zeroVal *SpawnHostInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_moveAnnotationIssue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_moveAnnotationIssue_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_moveAnnotationIssue_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := ec.field_Mutation_moveAnnotationIssue_argsAPIIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["apiIssue"] = arg2
	arg3, err := ec.field_Mutation_moveAnnotationIssue_argsIsIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isIssue"] = arg3
	return args, nil
}
func (ec *executionContext) field_Mutation_moveAnnotationIssue_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_moveAnnotationIssue_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_moveAnnotationIssue_argsAPIIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APIIssueLink, error) {
	if _, ok := rawArgs["apiIssue"]; !ok {
		var zeroVal model.APIIssueLink
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("apiIssue"))
	if tmp, ok := rawArgs["apiIssue"]; ok {
		return ec.unmarshalNIssueLinkInput2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx, tmp)
	}

	var zeroVal model.APIIssueLink
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_moveAnnotationIssue_argsIsIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["isIssue"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isIssue"))
	if tmp, ok := rawArgs["isIssue"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_overrideTaskDependencies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_overrideTaskDependencies_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_overrideTaskDependencies_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_promoteVarsToRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_promoteVarsToRepo_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_promoteVarsToRepo_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (PromoteVarsToRepoInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal PromoteVarsToRepoInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNPromoteVarsToRepoInput2githubcomevergreencievergreengraphqlPromoteVarsToRepoInput(ctx, tmp)
	}

	var zeroVal PromoteVarsToRepoInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeAnnotationIssue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeAnnotationIssue_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_removeAnnotationIssue_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := ec.field_Mutation_removeAnnotationIssue_argsAPIIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["apiIssue"] = arg2
	arg3, err := ec.field_Mutation_removeAnnotationIssue_argsIsIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isIssue"] = arg3
	return args, nil
}
func (ec *executionContext) field_Mutation_removeAnnotationIssue_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeAnnotationIssue_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeAnnotationIssue_argsAPIIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APIIssueLink, error) {
	if _, ok := rawArgs["apiIssue"]; !ok {
		var zeroVal model.APIIssueLink
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("apiIssue"))
	if tmp, ok := rawArgs["apiIssue"]; ok {
		return ec.unmarshalNIssueLinkInput2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx, tmp)
	}

	var zeroVal model.APIIssueLink
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeAnnotationIssue_argsIsIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["isIssue"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isIssue"))
	if tmp, ok := rawArgs["isIssue"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeFavoriteProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeFavoriteProject_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeFavoriteProject_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (RemoveFavoriteProjectInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal RemoveFavoriteProjectInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNRemoveFavoriteProjectInput2githubcomevergreencievergreengraphqlRemoveFavoriteProjectInput(ctx, tmp)
	}

	var zeroVal RemoveFavoriteProjectInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removePublicKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removePublicKey_argsKeyName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["keyName"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removePublicKey_argsKeyName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["keyName"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("keyName"))
	if tmp, ok := rawArgs["keyName"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeVolume_argsVolumeID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["volumeId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeVolume_argsVolumeID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["volumeId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
	if tmp, ok := rawArgs["volumeId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_reprovisionToNew_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_reprovisionToNew_argsHostIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostIds"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_reprovisionToNew_argsHostIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["hostIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal []string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartJasper_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_restartJasper_argsHostIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostIds"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_restartJasper_argsHostIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["hostIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal []string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_restartTask_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_restartTask_argsFailedOnly(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["failedOnly"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_restartTask_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartTask_argsFailedOnly(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["failedOnly"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("failedOnly"))
	if tmp, ok := rawArgs["failedOnly"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_restartVersions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_restartVersions_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := ec.field_Mutation_restartVersions_argsAbort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["abort"] = arg1
	arg2, err := ec.field_Mutation_restartVersions_argsVersionsToRestart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionsToRestart"] = arg2
	return args, nil
}
func (ec *executionContext) field_Mutation_restartVersions_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartVersions_argsAbort(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["abort"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("abort"))
	if tmp, ok := rawArgs["abort"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_restartVersions_argsVersionsToRestart(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model1.VersionToRestart, error) {
	if _, ok := rawArgs["versionsToRestart"]; !ok {
		var zeroVal []*model1.VersionToRestart
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionsToRestart"))
	if tmp, ok := rawArgs["versionsToRestart"]; ok {
		return ec.unmarshalNVersionToRestart2githubcomevergreencievergreenmodelVersionToRestart(ctx, tmp)
	}

	var zeroVal []*model1.VersionToRestart
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveDistro_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_saveDistro_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (SaveDistroInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal SaveDistroInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNSaveDistroInput2githubcomevergreencievergreengraphqlSaveDistroInput(ctx, tmp)
	}

	var zeroVal SaveDistroInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveProjectSettingsForSection_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveProjectSettingsForSection_argsProjectSettings(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectSettings"] = arg0
	arg1, err := ec.field_Mutation_saveProjectSettingsForSection_argsSection(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["section"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_saveProjectSettingsForSection_argsProjectSettings(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.APIProjectSettings, error) {
	if _, ok := rawArgs["projectSettings"]; !ok {
		var zeroVal *model.APIProjectSettings
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectSettings"))
	if tmp, ok := rawArgs["projectSettings"]; ok {
		return ec.unmarshalOProjectSettingsInput2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx, tmp)
	}

	var zeroVal *model.APIProjectSettings
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveProjectSettingsForSection_argsSection(
	ctx context.Context,
	rawArgs map[string]any,
) (ProjectSettingsSection, error) {
	if _, ok := rawArgs["section"]; !ok {
		var zeroVal ProjectSettingsSection
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("section"))
	if tmp, ok := rawArgs["section"]; ok {
		return ec.unmarshalNProjectSettingsSection2githubcomevergreencievergreengraphqlProjectSettingsSection(ctx, tmp)
	}

	var zeroVal ProjectSettingsSection
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveRepoSettingsForSection_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveRepoSettingsForSection_argsRepoSettings(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["repoSettings"] = arg0
	arg1, err := ec.field_Mutation_saveRepoSettingsForSection_argsSection(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["section"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_saveRepoSettingsForSection_argsRepoSettings(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.APIProjectSettings, error) {
	if _, ok := rawArgs["repoSettings"]; !ok {
		var zeroVal *model.APIProjectSettings
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("repoSettings"))
	if tmp, ok := rawArgs["repoSettings"]; ok {
		return ec.unmarshalORepoSettingsInput2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx, tmp)
	}

	var zeroVal *model.APIProjectSettings
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveRepoSettingsForSection_argsSection(
	ctx context.Context,
	rawArgs map[string]any,
) (ProjectSettingsSection, error) {
	if _, ok := rawArgs["section"]; !ok {
		var zeroVal ProjectSettingsSection
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("section"))
	if tmp, ok := rawArgs["section"]; ok {
		return ec.unmarshalNProjectSettingsSection2githubcomevergreencievergreengraphqlProjectSettingsSection(ctx, tmp)
	}

	var zeroVal ProjectSettingsSection
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveSubscription_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveSubscription_argsSubscription(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["subscription"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_saveSubscription_argsSubscription(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APISubscription, error) {
	if _, ok := rawArgs["subscription"]; !ok {
		var zeroVal model.APISubscription
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("subscription"))
	if tmp, ok := rawArgs["subscription"]; ok {
		return ec.unmarshalNSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx, tmp)
	}

	var zeroVal model.APISubscription
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_schedulePatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_schedulePatch_argsPatchID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchId"] = arg0
	arg1, err := ec.field_Mutation_schedulePatch_argsConfigure(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["configure"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_schedulePatch_argsPatchID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["patchId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["patchId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "PATCHES")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_schedulePatch_argsConfigure(
	ctx context.Context,
	rawArgs map[string]any,
) (PatchConfigure, error) {
	if _, ok := rawArgs["configure"]; !ok {
		var zeroVal PatchConfigure
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("configure"))
	if tmp, ok := rawArgs["configure"]; ok {
		return ec.unmarshalNPatchConfigure2githubcomevergreencievergreengraphqlPatchConfigure(ctx, tmp)
	}

	var zeroVal PatchConfigure
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_scheduleTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_scheduleTasks_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := ec.field_Mutation_scheduleTasks_argsTaskIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskIds"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_scheduleTasks_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_scheduleTasks_argsTaskIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["taskIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskIds"))
	if tmp, ok := rawArgs["taskIds"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_scheduleUndispatchedBaseTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_scheduleUndispatchedBaseTasks_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_scheduleUndispatchedBaseTasks_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setAnnotationMetadataLinks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setAnnotationMetadataLinks_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_setAnnotationMetadataLinks_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := ec.field_Mutation_setAnnotationMetadataLinks_argsMetadataLinks(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["metadataLinks"] = arg2
	return args, nil
}
func (ec *executionContext) field_Mutation_setAnnotationMetadataLinks_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setAnnotationMetadataLinks_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setAnnotationMetadataLinks_argsMetadataLinks(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.APIMetadataLink, error) {
	if _, ok := rawArgs["metadataLinks"]; !ok {
		var zeroVal []*model.APIMetadataLink
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("metadataLinks"))
	if tmp, ok := rawArgs["metadataLinks"]; ok {
		return ec.unmarshalNMetadataLinkInput2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx, tmp)
	}

	var zeroVal []*model.APIMetadataLink
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setLastRevision_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setLastRevision_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_setLastRevision_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (SetLastRevisionInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal SetLastRevisionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["opts"]
		if !ok {
			var zeroVal SetLastRevisionInput
			return zeroVal, nil
		}
		return ec.unmarshalNSetLastRevisionInput2githubcomevergreencievergreengraphqlSetLastRevisionInput(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal SetLastRevisionInput
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal SetLastRevisionInput
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(SetLastRevisionInput); ok {
		return data, nil
	} else {
		var zeroVal SetLastRevisionInput
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/graphql.SetLastRevisionInput`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setPatchVisibility_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setPatchVisibility_argsPatchIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchIds"] = arg0
	arg1, err := ec.field_Mutation_setPatchVisibility_argsHidden(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hidden"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_setPatchVisibility_argsPatchIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["patchIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["patchIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequirePatchOwner == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requirePatchOwner is not implemented")
		}
		return ec.directives.RequirePatchOwner(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setPatchVisibility_argsHidden(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["hidden"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
	if tmp, ok := rawArgs["hidden"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setTaskPriority_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setTaskPriority_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_setTaskPriority_argsPriority(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["priority"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_setTaskPriority_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setTaskPriority_argsPriority(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["priority"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
	if tmp, ok := rawArgs["priority"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setVersionPriority_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setVersionPriority_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := ec.field_Mutation_setVersionPriority_argsPriority(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["priority"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_setVersionPriority_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setVersionPriority_argsPriority(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["priority"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
	if tmp, ok := rawArgs["priority"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_spawnHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_spawnHost_argsSpawnHostInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spawnHostInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_spawnHost_argsSpawnHostInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*SpawnHostInput, error) {
	if _, ok := rawArgs["spawnHostInput"]; !ok {
		var zeroVal *SpawnHostInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostInput"))
	if tmp, ok := rawArgs["spawnHostInput"]; ok {
		return ec.unmarshalOSpawnHostInput2githubcomevergreencievergreengraphqlSpawnHostInput(ctx, tmp)
	}

	var zeroVal *SpawnHostInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_spawnVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_spawnVolume_argsSpawnVolumeInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spawnVolumeInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_spawnVolume_argsSpawnVolumeInput(
	ctx context.Context,
	rawArgs map[string]any,
) (SpawnVolumeInput, error) {
	if _, ok := rawArgs["spawnVolumeInput"]; !ok {
		var zeroVal SpawnVolumeInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnVolumeInput"))
	if tmp, ok := rawArgs["spawnVolumeInput"]; ok {
		return ec.unmarshalNSpawnVolumeInput2githubcomevergreencievergreengraphqlSpawnVolumeInput(ctx, tmp)
	}

	var zeroVal SpawnVolumeInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_unscheduleTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_unscheduleTask_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_unscheduleTask_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_unscheduleVersionTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_unscheduleVersionTasks_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := ec.field_Mutation_unscheduleVersionTasks_argsAbort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["abort"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_unscheduleVersionTasks_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_unscheduleVersionTasks_argsAbort(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["abort"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("abort"))
	if tmp, ok := rawArgs["abort"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateBetaFeatures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateBetaFeatures_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateBetaFeatures_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (UpdateBetaFeaturesInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal UpdateBetaFeaturesInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNUpdateBetaFeaturesInput2githubcomevergreencievergreengraphqlUpdateBetaFeaturesInput(ctx, tmp)
	}

	var zeroVal UpdateBetaFeaturesInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateHostStatus_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateHostStatus_argsHostIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostIds"] = arg0
	arg1, err := ec.field_Mutation_updateHostStatus_argsStatus(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["status"] = arg1
	arg2, err := ec.field_Mutation_updateHostStatus_argsNotes(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["notes"] = arg2
	return args, nil
}
func (ec *executionContext) field_Mutation_updateHostStatus_argsHostIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["hostIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal []string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_updateHostStatus_argsStatus(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["status"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
	if tmp, ok := rawArgs["status"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateHostStatus_argsNotes(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["notes"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("notes"))
	if tmp, ok := rawArgs["notes"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateParsleySettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateParsleySettings_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateParsleySettings_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (UpdateParsleySettingsInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal UpdateParsleySettingsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNUpdateParsleySettingsInput2githubcomevergreencievergreengraphqlUpdateParsleySettingsInput(ctx, tmp)
	}

	var zeroVal UpdateParsleySettingsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updatePublicKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updatePublicKey_argsTargetKeyName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["targetKeyName"] = arg0
	arg1, err := ec.field_Mutation_updatePublicKey_argsUpdateInfo(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["updateInfo"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updatePublicKey_argsTargetKeyName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["targetKeyName"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("targetKeyName"))
	if tmp, ok := rawArgs["targetKeyName"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updatePublicKey_argsUpdateInfo(
	ctx context.Context,
	rawArgs map[string]any,
) (PublicKeyInput, error) {
	if _, ok := rawArgs["updateInfo"]; !ok {
		var zeroVal PublicKeyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("updateInfo"))
	if tmp, ok := rawArgs["updateInfo"]; ok {
		return ec.unmarshalNPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx, tmp)
	}

	var zeroVal PublicKeyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSpawnHostStatus_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateSpawnHostStatus_argsUpdateSpawnHostStatusInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["updateSpawnHostStatusInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateSpawnHostStatus_argsUpdateSpawnHostStatusInput(
	ctx context.Context,
	rawArgs map[string]any,
) (UpdateSpawnHostStatusInput, error) {
	if _, ok := rawArgs["updateSpawnHostStatusInput"]; !ok {
		var zeroVal UpdateSpawnHostStatusInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("updateSpawnHostStatusInput"))
	if tmp, ok := rawArgs["updateSpawnHostStatusInput"]; ok {
		return ec.unmarshalNUpdateSpawnHostStatusInput2githubcomevergreencievergreengraphqlUpdateSpawnHostStatusInput(ctx, tmp)
	}

	var zeroVal UpdateSpawnHostStatusInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateUserSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateUserSettings_argsUserSettings(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["userSettings"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateUserSettings_argsUserSettings(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.APIUserSettings, error) {
	if _, ok := rawArgs["userSettings"]; !ok {
		var zeroVal *model.APIUserSettings
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userSettings"))
	if tmp, ok := rawArgs["userSettings"]; ok {
		return ec.unmarshalOUserSettingsInput2githubcomevergreencievergreenrestmodelAPIUserSettings(ctx, tmp)
	}

	var zeroVal *model.APIUserSettings
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateVolume_argsUpdateVolumeInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["updateVolumeInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateVolume_argsUpdateVolumeInput(
	ctx context.Context,
	rawArgs map[string]any,
) (UpdateVolumeInput, error) {
	if _, ok := rawArgs["updateVolumeInput"]; !ok {
		var zeroVal UpdateVolumeInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("updateVolumeInput"))
	if tmp, ok := rawArgs["updateVolumeInput"]; ok {
		return ec.unmarshalNUpdateVolumeInput2githubcomevergreencievergreengraphqlUpdateVolumeInput(ctx, tmp)
	}

	var zeroVal UpdateVolumeInput
	return zeroVal, nil
}

func (ec *executionContext) field_Permissions_distroPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Permissions_distroPermissions_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Permissions_distroPermissions_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (DistroPermissionsOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal DistroPermissionsOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNDistroPermissionsOptions2githubcomevergreencievergreengraphqlDistroPermissionsOptions(ctx, tmp)
	}

	var zeroVal DistroPermissionsOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Permissions_projectPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Permissions_projectPermissions_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Permissions_projectPermissions_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (ProjectPermissionsOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal ProjectPermissionsOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNProjectPermissionsOptions2githubcomevergreencievergreengraphqlProjectPermissionsOptions(ctx, tmp)
	}

	var zeroVal ProjectPermissionsOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Permissions_repoPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Permissions_repoPermissions_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Permissions_repoPermissions_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (RepoPermissionsOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal RepoPermissionsOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNRepoPermissionsOptions2githubcomevergreencievergreengraphqlRepoPermissionsOptions(ctx, tmp)
	}

	var zeroVal RepoPermissionsOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Pod_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Pod_events_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := ec.field_Pod_events_argsPage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["page"] = arg1
	return args, nil
}
func (ec *executionContext) field_Pod_events_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Pod_events_argsPage(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["page"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
	if tmp, ok := rawArgs["page"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Project_patches_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Project_patches_argsPatchesInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchesInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Project_patches_argsPatchesInput(
	ctx context.Context,
	rawArgs map[string]any,
) (PatchesInput, error) {
	if _, ok := rawArgs["patchesInput"]; !ok {
		var zeroVal PatchesInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchesInput"))
	if tmp, ok := rawArgs["patchesInput"]; ok {
		return ec.unmarshalNPatchesInput2githubcomevergreencievergreengraphqlPatchesInput(ctx, tmp)
	}

	var zeroVal PatchesInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_bbGetCreatedTickets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_bbGetCreatedTickets_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_bbGetCreatedTickets_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "ANNOTATIONS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_buildBaron_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_buildBaron_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Query_buildBaron_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_buildBaron_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "ANNOTATIONS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_buildBaron_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_buildVariantsForTaskName_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_buildVariantsForTaskName_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	arg1, err := ec.field_Query_buildVariantsForTaskName_argsTaskName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskName"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_buildVariantsForTaskName_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_buildVariantsForTaskName_argsTaskName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskName"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
	if tmp, ok := rawArgs["taskName"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_distroEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_distroEvents_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_distroEvents_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (DistroEventsInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal DistroEventsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNDistroEventsInput2githubcomevergreencievergreengraphqlDistroEventsInput(ctx, tmp)
	}

	var zeroVal DistroEventsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_distroTaskQueue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_distroTaskQueue_argsDistroID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["distroId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_distroTaskQueue_argsDistroID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["distroId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
	if tmp, ok := rawArgs["distroId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_distro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_distro_argsDistroID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["distroId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_distro_argsDistroID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["distroId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["distroId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireDistroAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireDistroAccess is not implemented")
		}
		return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_distros_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_distros_argsOnlySpawnable(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["onlySpawnable"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_distros_argsOnlySpawnable(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["onlySpawnable"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("onlySpawnable"))
	if tmp, ok := rawArgs["onlySpawnable"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_githubProjectConflicts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_githubProjectConflicts_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_githubProjectConflicts_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_hasVersion_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_hasVersion_argsPatchID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_hasVersion_argsPatchID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["patchId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
	if tmp, ok := rawArgs["patchId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hostEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_hostEvents_argsHostID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostId"] = arg0
	arg1, err := ec.field_Query_hostEvents_argsHostTag(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostTag"] = arg1
	arg2, err := ec.field_Query_hostEvents_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg2
	arg3, err := ec.field_Query_hostEvents_argsPage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["page"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_hostEvents_argsHostID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["hostId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_hostEvents_argsHostTag(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["hostTag"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostTag"))
	if tmp, ok := rawArgs["hostTag"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hostEvents_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hostEvents_argsPage(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["page"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
	if tmp, ok := rawArgs["page"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_host_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_host_argsHostID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_host_argsHostID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["hostId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_hosts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_hosts_argsHostID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostId"] = arg0
	arg1, err := ec.field_Query_hosts_argsDistroID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["distroId"] = arg1
	arg2, err := ec.field_Query_hosts_argsCurrentTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["currentTaskId"] = arg2
	arg3, err := ec.field_Query_hosts_argsStatuses(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["statuses"] = arg3
	arg4, err := ec.field_Query_hosts_argsStartedBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["startedBy"] = arg4
	arg5, err := ec.field_Query_hosts_argsSortBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sortBy"] = arg5
	arg6, err := ec.field_Query_hosts_argsSortDir(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sortDir"] = arg6
	arg7, err := ec.field_Query_hosts_argsPage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["page"] = arg7
	arg8, err := ec.field_Query_hosts_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg8
	return args, nil
}
func (ec *executionContext) field_Query_hosts_argsHostID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["hostId"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
	if tmp, ok := rawArgs["hostId"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsDistroID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["distroId"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
	if tmp, ok := rawArgs["distroId"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsCurrentTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["currentTaskId"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("currentTaskId"))
	if tmp, ok := rawArgs["currentTaskId"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsStatuses(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["statuses"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
	if tmp, ok := rawArgs["statuses"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsStartedBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["startedBy"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("startedBy"))
	if tmp, ok := rawArgs["startedBy"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsSortBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*HostSortBy, error) {
	if _, ok := rawArgs["sortBy"]; !ok {
		var zeroVal *HostSortBy
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
	if tmp, ok := rawArgs["sortBy"]; ok {
		return ec.unmarshalOHostSortBy2githubcomevergreencievergreengraphqlHostSortBy(ctx, tmp)
	}

	var zeroVal *HostSortBy
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsSortDir(
	ctx context.Context,
	rawArgs map[string]any,
) (*SortDirection, error) {
	if _, ok := rawArgs["sortDir"]; !ok {
		var zeroVal *SortDirection
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDir"))
	if tmp, ok := rawArgs["sortDir"]; ok {
		return ec.unmarshalOSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx, tmp)
	}

	var zeroVal *SortDirection
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsPage(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["page"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
	if tmp, ok := rawArgs["page"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_image_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_image_argsImageID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["imageId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_image_argsImageID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["imageId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("imageId"))
	if tmp, ok := rawArgs["imageId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_isRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_isRepo_argsProjectOrRepoID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectOrRepoId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_isRepo_argsProjectOrRepoID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectOrRepoId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectOrRepoId"))
	if tmp, ok := rawArgs["projectOrRepoId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_logkeeperBuildMetadata_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_logkeeperBuildMetadata_argsBuildID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["buildId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_logkeeperBuildMetadata_argsBuildID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["buildId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("buildId"))
	if tmp, ok := rawArgs["buildId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_mainlineCommits_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_mainlineCommits_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	arg1, err := ec.field_Query_mainlineCommits_argsBuildVariantOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["buildVariantOptions"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_mainlineCommits_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (MainlineCommitsOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal MainlineCommitsOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNMainlineCommitsOptions2githubcomevergreencievergreengraphqlMainlineCommitsOptions(ctx, tmp)
	}

	var zeroVal MainlineCommitsOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Query_mainlineCommits_argsBuildVariantOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (*BuildVariantOptions, error) {
	if _, ok := rawArgs["buildVariantOptions"]; !ok {
		var zeroVal *BuildVariantOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantOptions"))
	if tmp, ok := rawArgs["buildVariantOptions"]; ok {
		return ec.unmarshalOBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions(ctx, tmp)
	}

	var zeroVal *BuildVariantOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Query_patch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_patch_argsPatchID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_patch_argsPatchID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["patchId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["patchId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_pod_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_pod_argsPodID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["podId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_pod_argsPodID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["podId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("podId"))
	if tmp, ok := rawArgs["podId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_projectEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_projectEvents_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	arg1, err := ec.field_Query_projectEvents_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := ec.field_Query_projectEvents_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_projectEvents_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_projectEvents_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_projectEvents_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOTime2timeTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_projectSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_projectSettings_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_projectSettings_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_project_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_project_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_project_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_repoEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_repoEvents_argsRepoID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["repoId"] = arg0
	arg1, err := ec.field_Query_repoEvents_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := ec.field_Query_repoEvents_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_repoEvents_argsRepoID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["repoId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["repoId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_repoEvents_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_repoEvents_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOTime2timeTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_repoSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_repoSettings_argsRepoID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["repoId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_repoSettings_argsRepoID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["repoId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["repoId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskAllExecutions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskAllExecutions_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_taskAllExecutions_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskHistory_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskHistory_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_taskHistory_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (TaskHistoryOpts, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal TaskHistoryOpts
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNTaskHistoryOpts2githubcomevergreencievergreengraphqlTaskHistoryOpts(ctx, tmp)
	}

	var zeroVal TaskHistoryOpts
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskNamesForBuildVariant_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskNamesForBuildVariant_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	arg1, err := ec.field_Query_taskNamesForBuildVariant_argsBuildVariant(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["buildVariant"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_taskNamesForBuildVariant_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskNamesForBuildVariant_argsBuildVariant(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["buildVariant"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariant"))
	if tmp, ok := rawArgs["buildVariant"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskTestSample_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskTestSample_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := ec.field_Query_taskTestSample_argsTaskIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskIds"] = arg1
	arg2, err := ec.field_Query_taskTestSample_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_taskTestSample_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskTestSample_argsTaskIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["taskIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskIds"))
	if tmp, ok := rawArgs["taskIds"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskTestSample_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*TestFilter, error) {
	if _, ok := rawArgs["filters"]; !ok {
		var zeroVal []*TestFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalNTestFilter2githubcomevergreencievergreengraphqlTestFilter(ctx, tmp)
	}

	var zeroVal []*TestFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_task_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_task_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Query_task_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_task_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_task_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_user_argsUserID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["userId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_user_argsUserID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["userId"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
	if tmp, ok := rawArgs["userId"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_version_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_version_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_version_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_waterfall_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_waterfall_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_waterfall_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (WaterfallOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal WaterfallOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNWaterfallOptions2githubcomevergreencievergreengraphqlWaterfallOptions(ctx, tmp)
	}

	var zeroVal WaterfallOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Task_tests_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Task_tests_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Task_tests_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (*TestFilterOptions, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal *TestFilterOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalOTestFilterOptions2githubcomevergreencievergreengraphqlTestFilterOptions(ctx, tmp)
	}

	var zeroVal *TestFilterOptions
	return zeroVal, nil
}

func (ec *executionContext) field_User_patches_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_User_patches_argsPatchesInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchesInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_User_patches_argsPatchesInput(
	ctx context.Context,
	rawArgs map[string]any,
) (PatchesInput, error) {
	if _, ok := rawArgs["patchesInput"]; !ok {
		var zeroVal PatchesInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchesInput"))
	if tmp, ok := rawArgs["patchesInput"]; ok {
		return ec.unmarshalNPatchesInput2githubcomevergreencievergreengraphqlPatchesInput(ctx, tmp)
	}

	var zeroVal PatchesInput
	return zeroVal, nil
}

func (ec *executionContext) field_Version_buildVariantStats_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Version_buildVariantStats_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Version_buildVariantStats_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (BuildVariantOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal BuildVariantOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions(ctx, tmp)
	}

	var zeroVal BuildVariantOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Version_buildVariants_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Version_buildVariants_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Version_buildVariants_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (BuildVariantOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal BuildVariantOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions(ctx, tmp)
	}

	var zeroVal BuildVariantOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Version_taskStatusStats_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Version_taskStatusStats_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Version_taskStatusStats_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (BuildVariantOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal BuildVariantOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions(ctx, tmp)
	}

	var zeroVal BuildVariantOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Version_tasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Version_tasks_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Version_tasks_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (TaskFilterOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal TaskFilterOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNTaskFilterOptions2githubcomevergreencievergreengraphqlTaskFilterOptions(ctx, tmp)
	}

	var zeroVal TaskFilterOptions
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AWSConfig_maxVolumeSizePerUser(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AWSConfig_maxVolumeSizePerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxVolumeSizePerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AWSConfig_maxVolumeSizePerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_pod(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AWSConfig_pod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAWSPodConfig)
	fc.Result = res
	return ec.marshalOAWSPodConfig2githubcomevergreencievergreenrestmodelAPIAWSPodConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AWSConfig_pod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ecs":
				return ec.fieldContext_AWSPodConfig_ecs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AWSPodConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSPodConfig_ecs(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSPodConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AWSPodConfig_ecs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ECS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIECSConfig)
	fc.Result = res
	return ec.marshalOECSConfig2githubcomevergreencievergreenrestmodelAPIECSConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AWSPodConfig_ecs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSPodConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxCPU":
				return ec.fieldContext_ECSConfig_maxCPU(ctx, field)
			case "maxMemoryMb":
				return ec.fieldContext_ECSConfig_maxMemoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ECSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_buildVariantDisplayName(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_buildVariantDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariantDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_buildVariantDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_newVersion(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_newVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_newVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_prClosed(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_prClosed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrClosed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_prClosed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_taskDisplayName(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_taskDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_taskDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_taskID(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_taskID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_taskID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_user(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_banner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_banner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_bannerTheme(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_bannerTheme(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AdminSettings().BannerTheme(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*evergreen.BannerTheme)
	fc.Result = res
	return ec.marshalOBannerTheme2githubcomevergreencievergreenBannerTheme(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_bannerTheme(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BannerTheme does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_id(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_createdIssues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_createdIssues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedIssues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIIssueLink)
	fc.Result = res
	return ec.marshalOIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_createdIssues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_issues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_issues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIIssueLink)
	fc.Result = res
	return ec.marshalOIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_issues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_note(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_note(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APINote)
	fc.Result = res
	return ec.marshalONote2githubcomevergreencievergreenrestmodelAPINote(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_note(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Note_message(ctx, field)
			case "source":
				return ec.fieldContext_Note_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Note", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_suspectedIssues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_suspectedIssues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuspectedIssues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIIssueLink)
	fc.Result = res
	return ec.marshalOIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_suspectedIssues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_metadataLinks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_metadataLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetadataLinks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIMetadataLink)
	fc.Result = res
	return ec.marshalOMetadataLink2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_metadataLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_MetadataLink_url(ctx, field)
			case "text":
				return ec.fieldContext_MetadataLink_text(ctx, field)
			case "source":
				return ec.fieldContext_MetadataLink_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetadataLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_taskId(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_taskExecution(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_webhookConfigured(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_webhookConfigured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Annotation().WebhookConfigured(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_webhookConfigured(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BetaFeatures_spruceWaterfallEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIBetaFeatures) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpruceWaterfallEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BetaFeatures_spruceWaterfallEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BetaFeatures",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_clientDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_clientDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_clientDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_communication(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_communication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BootstrapSettings().Communication(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(CommunicationMethod)
	fc.Result = res
	return ec.marshalNCommunicationMethod2githubcomevergreencievergreengraphqlCommunicationMethod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_communication(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CommunicationMethod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_env(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_env(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Env, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIEnvVar)
	fc.Result = res
	return ec.marshalNEnvVar2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_env(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_EnvVar_key(ctx, field)
			case "value":
				return ec.fieldContext_EnvVar_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EnvVar", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_jasperBinaryDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_jasperBinaryDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JasperBinaryDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_jasperBinaryDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_jasperCredentialsPath(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_jasperCredentialsPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JasperCredentialsPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_jasperCredentialsPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_method(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_method(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BootstrapSettings().Method(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(BootstrapMethod)
	fc.Result = res
	return ec.marshalNBootstrapMethod2githubcomevergreencievergreengraphqlBootstrapMethod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_method(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BootstrapMethod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_preconditionScripts(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_preconditionScripts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreconditionScripts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIPreconditionScript)
	fc.Result = res
	return ec.marshalNPreconditionScript2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_preconditionScripts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "path":
				return ec.fieldContext_PreconditionScript_path(ctx, field)
			case "script":
				return ec.fieldContext_PreconditionScript_script(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreconditionScript", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_resourceLimits(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_resourceLimits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceLimits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIResourceLimits)
	fc.Result = res
	return ec.marshalNResourceLimits2githubcomevergreencievergreenrestmodelAPIResourceLimits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_resourceLimits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lockedMemoryKb":
				return ec.fieldContext_ResourceLimits_lockedMemoryKb(ctx, field)
			case "numFiles":
				return ec.fieldContext_ResourceLimits_numFiles(ctx, field)
			case "numProcesses":
				return ec.fieldContext_ResourceLimits_numProcesses(ctx, field)
			case "numTasks":
				return ec.fieldContext_ResourceLimits_numTasks(ctx, field)
			case "virtualMemoryKb":
				return ec.fieldContext_ResourceLimits_virtualMemoryKb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceLimits", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_rootDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_rootDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_rootDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_serviceUser(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_serviceUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_serviceUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_shellPath(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_shellPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShellPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_shellPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_id(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_actualMakespan(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_actualMakespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActualMakespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_actualMakespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_predictedMakespan(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_predictedMakespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PredictedMakespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_predictedMakespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_status(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_bbTicketCreationDefined(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaron_bbTicketCreationDefined(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BbTicketCreationDefined, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaron_bbTicketCreationDefined(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_buildBaronConfigured(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaron_buildBaronConfigured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBaronConfigured, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaron_buildBaronConfigured(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_searchReturnInfo(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaron_searchReturnInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchReturnInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*thirdparty.SearchReturnInfo)
	fc.Result = res
	return ec.marshalOSearchReturnInfo2githubcomevergreencievergreenthirdpartySearchReturnInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaron_searchReturnInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featuresURL":
				return ec.fieldContext_SearchReturnInfo_featuresURL(ctx, field)
			case "issues":
				return ec.fieldContext_SearchReturnInfo_issues(ctx, field)
			case "search":
				return ec.fieldContext_SearchReturnInfo_search(ctx, field)
			case "source":
				return ec.fieldContext_SearchReturnInfo_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchReturnInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionFeaturesURL(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionFeaturesURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionPassword(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionPassword(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionServer(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionServer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionServer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionTimeoutSecs(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionTimeoutSecs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionUsername(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionUsername(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketCreateProject(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketCreateProject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketCreateProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketSearchProjects(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketSearchProjects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketSearchProjects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketCreateIssueType(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_ticketCreateIssueType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketCreateIssueType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketCreateIssueType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildVariantTuple_buildVariant(ctx context.Context, field graphql.CollectedField, obj *task.BuildVariantTuple) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildVariantTuple_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildVariantTuple_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildVariantTuple",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildVariantTuple_displayName(ctx context.Context, field graphql.CollectedField, obj *task.BuildVariantTuple) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildVariantTuple_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildVariantTuple_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildVariantTuple",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChildPatchAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIChildPatchAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChildPatchAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChildPatchAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChildPatchAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChildPatchAlias_patchId(ctx context.Context, field graphql.CollectedField, obj *model.APIChildPatchAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChildPatchAlias_patchId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChildPatchAlias_patchId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChildPatchAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_arch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Arch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_arch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_os(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_url(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientConfig_clientBinaries(ctx context.Context, field graphql.CollectedField, obj *model.APIClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientConfig_clientBinaries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientBinaries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIClientBinary)
	fc.Result = res
	return ec.marshalOClientBinary2githubcomevergreencievergreenrestmodelAPIClientBinary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientConfig_clientBinaries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arch":
				return ec.fieldContext_ClientBinary_arch(ctx, field)
			case "displayName":
				return ec.fieldContext_ClientBinary_displayName(ctx, field)
			case "os":
				return ec.fieldContext_ClientBinary_os(ctx, field)
			case "url":
				return ec.fieldContext_ClientBinary_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientBinary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientConfig_latestRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientConfig_latestRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientConfig_latestRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CloudProviderConfig_aws(ctx context.Context, field graphql.CollectedField, obj *model.APICloudProviders) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CloudProviderConfig_aws(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AWS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAWSConfig)
	fc.Result = res
	return ec.marshalOAWSConfig2githubcomevergreencievergreenrestmodelAPIAWSConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CloudProviderConfig_aws(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CloudProviderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxVolumeSizePerUser":
				return ec.fieldContext_AWSConfig_maxVolumeSizePerUser(ctx, field)
			case "pod":
				return ec.fieldContext_AWSConfig_pod(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AWSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueParams_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueParams_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_mergeMethod(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueParams_mergeMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueParams_mergeMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_message(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueParams_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueParams_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_id(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerPool_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerPool_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_distro(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerPool_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerPool_distro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_maxContainers(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerPool_maxContainers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxContainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerPool_maxContainers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_port(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerPool_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerPool().Port(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerPool_port(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPoolsConfig_pools(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPoolsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerPoolsConfig_pools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pools, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIContainerPool)
	fc.Result = res
	return ec.marshalNContainerPool2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerPoolsConfig_pools(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPoolsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerPool_id(ctx, field)
			case "distro":
				return ec.fieldContext_ContainerPool_distro(ctx, field)
			case "maxContainers":
				return ec.fieldContext_ContainerPool_maxContainers(ctx, field)
			case "port":
				return ec.fieldContext_ContainerPool_port(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerPool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_name(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerResources_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerResources_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_cpu(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerResources_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerResources_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_memoryMb(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerResources_memoryMb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemoryMB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerResources_memoryMb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteDistroPayload_deletedDistroId(ctx context.Context, field graphql.CollectedField, obj *DeleteDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteDistroPayload_deletedDistroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedDistroID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteDistroPayload_deletedDistroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteGithubAppCredentialsPayload_oldAppId(ctx context.Context, field graphql.CollectedField, obj *DeleteGithubAppCredentialsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteGithubAppCredentialsPayload_oldAppId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldAppID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteGithubAppCredentialsPayload_oldAppId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteGithubAppCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_buildVariant(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_metStatus(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_metStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(MetStatus)
	fc.Result = res
	return ec.marshalNMetStatus2githubcomevergreencievergreengraphqlMetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_metStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MetStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_name(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_requiredStatus(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_requiredStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(RequiredStatus)
	fc.Result = res
	return ec.marshalNRequiredStatus2githubcomevergreencievergreengraphqlRequiredStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_requiredStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RequiredStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_taskId(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DispatcherSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIDispatcherSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DispatcherSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DispatcherSettings().Version(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DispatcherVersion)
	fc.Result = res
	return ec.marshalNDispatcherVersion2githubcomevergreencievergreengraphqlDispatcherVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DispatcherSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DispatcherSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DispatcherVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_adminOnly(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_adminOnly(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_adminOnly(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_arch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Distro().Arch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Arch)
	fc.Result = res
	return ec.marshalNArch2githubcomevergreencievergreengraphqlArch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_arch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Arch does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_authorizedKeysFile(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizedKeysFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_authorizedKeysFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_bootstrapSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_bootstrapSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BootstrapSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBootstrapSettings)
	fc.Result = res
	return ec.marshalNBootstrapSettings2githubcomevergreencievergreenrestmodelAPIBootstrapSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_bootstrapSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientDir":
				return ec.fieldContext_BootstrapSettings_clientDir(ctx, field)
			case "communication":
				return ec.fieldContext_BootstrapSettings_communication(ctx, field)
			case "env":
				return ec.fieldContext_BootstrapSettings_env(ctx, field)
			case "jasperBinaryDir":
				return ec.fieldContext_BootstrapSettings_jasperBinaryDir(ctx, field)
			case "jasperCredentialsPath":
				return ec.fieldContext_BootstrapSettings_jasperCredentialsPath(ctx, field)
			case "method":
				return ec.fieldContext_BootstrapSettings_method(ctx, field)
			case "preconditionScripts":
				return ec.fieldContext_BootstrapSettings_preconditionScripts(ctx, field)
			case "resourceLimits":
				return ec.fieldContext_BootstrapSettings_resourceLimits(ctx, field)
			case "rootDir":
				return ec.fieldContext_BootstrapSettings_rootDir(ctx, field)
			case "serviceUser":
				return ec.fieldContext_BootstrapSettings_serviceUser(ctx, field)
			case "shellPath":
				return ec.fieldContext_BootstrapSettings_shellPath(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BootstrapSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_containerPool(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_containerPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerPool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_containerPool(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_disabled(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_disabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_disableShallowClone(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_disableShallowClone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisableShallowClone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_disableShallowClone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_dispatcherSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_dispatcherSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DispatcherSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDispatcherSettings)
	fc.Result = res
	return ec.marshalNDispatcherSettings2githubcomevergreencievergreenrestmodelAPIDispatcherSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_dispatcherSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_DispatcherSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DispatcherSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_execUser(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_execUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_execUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_expansions(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_expansions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expansions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIExpansion)
	fc.Result = res
	return ec.marshalNExpansion2githubcomevergreencievergreenrestmodelAPIExpansion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_expansions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Expansion_key(ctx, field)
			case "value":
				return ec.fieldContext_Expansion_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Expansion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_finderSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_finderSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinderSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIFinderSettings)
	fc.Result = res
	return ec.marshalNFinderSettings2githubcomevergreencievergreenrestmodelAPIFinderSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_finderSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_FinderSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FinderSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_homeVolumeSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeVolumeSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIHomeVolumeSettings)
	fc.Result = res
	return ec.marshalNHomeVolumeSettings2githubcomevergreencievergreenrestmodelAPIHomeVolumeSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_homeVolumeSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "formatCommand":
				return ec.fieldContext_HomeVolumeSettings_formatCommand(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HomeVolumeSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_hostAllocatorSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostAllocatorSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIHostAllocatorSettings)
	fc.Result = res
	return ec.marshalNHostAllocatorSettings2githubcomevergreencievergreenrestmodelAPIHostAllocatorSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_hostAllocatorSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acceptableHostIdleTime":
				return ec.fieldContext_HostAllocatorSettings_acceptableHostIdleTime(ctx, field)
			case "feedbackRule":
				return ec.fieldContext_HostAllocatorSettings_feedbackRule(ctx, field)
			case "futureHostFraction":
				return ec.fieldContext_HostAllocatorSettings_futureHostFraction(ctx, field)
			case "hostsOverallocatedRule":
				return ec.fieldContext_HostAllocatorSettings_hostsOverallocatedRule(ctx, field)
			case "maximumHosts":
				return ec.fieldContext_HostAllocatorSettings_maximumHosts(ctx, field)
			case "minimumHosts":
				return ec.fieldContext_HostAllocatorSettings_minimumHosts(ctx, field)
			case "roundingRule":
				return ec.fieldContext_HostAllocatorSettings_roundingRule(ctx, field)
			case "version":
				return ec.fieldContext_HostAllocatorSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostAllocatorSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_iceCreamSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_iceCreamSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IcecreamSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIIceCreamSettings)
	fc.Result = res
	return ec.marshalNIceCreamSettings2githubcomevergreencievergreenrestmodelAPIIceCreamSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_iceCreamSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "configPath":
				return ec.fieldContext_IceCreamSettings_configPath(ctx, field)
			case "schedulerHost":
				return ec.fieldContext_IceCreamSettings_schedulerHost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IceCreamSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_imageId(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_imageId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_imageId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_isCluster(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_isCluster(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCluster, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_isCluster(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_isVirtualWorkStation(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsVirtualWorkstation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_isVirtualWorkStation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_mountpoints(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_mountpoints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mountpoints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_mountpoints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_name(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_note(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_note(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_note(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_plannerSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_plannerSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlannerSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIPlannerSettings)
	fc.Result = res
	return ec.marshalNPlannerSettings2githubcomevergreencievergreenrestmodelAPIPlannerSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_plannerSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commitQueueFactor":
				return ec.fieldContext_PlannerSettings_commitQueueFactor(ctx, field)
			case "expectedRuntimeFactor":
				return ec.fieldContext_PlannerSettings_expectedRuntimeFactor(ctx, field)
			case "generateTaskFactor":
				return ec.fieldContext_PlannerSettings_generateTaskFactor(ctx, field)
			case "numDependentsFactor":
				return ec.fieldContext_PlannerSettings_numDependentsFactor(ctx, field)
			case "groupVersions":
				return ec.fieldContext_PlannerSettings_groupVersions(ctx, field)
			case "mainlineTimeInQueueFactor":
				return ec.fieldContext_PlannerSettings_mainlineTimeInQueueFactor(ctx, field)
			case "patchFactor":
				return ec.fieldContext_PlannerSettings_patchFactor(ctx, field)
			case "patchTimeInQueueFactor":
				return ec.fieldContext_PlannerSettings_patchTimeInQueueFactor(ctx, field)
			case "targetTime":
				return ec.fieldContext_PlannerSettings_targetTime(ctx, field)
			case "version":
				return ec.fieldContext_PlannerSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannerSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_provider(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Distro().Provider(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Provider)
	fc.Result = res
	return ec.marshalNProvider2githubcomevergreencievergreengraphqlProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Provider does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_providerSettingsList(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_providerSettingsList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Distro().ProviderSettingsList(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]map[string]any)
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_providerSettingsList(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_setup(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_setup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Setup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_setup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_setupAsSudo(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_setupAsSudo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupAsSudo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_setupAsSudo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_singleTaskDistro(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_singleTaskDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SingleTaskDistro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_singleTaskDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_sshOptions(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_sshOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHOptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_sshOptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_user(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_userSpawnAllowed(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserSpawnAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_userSpawnAllowed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_validProjects(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_validProjects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidProjects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_validProjects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_warningNote(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_warningNote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WarningNote, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_warningNote(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_workDir(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_workDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_workDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_after(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_before(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_data(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_user(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEventsPayload_count(ctx context.Context, field graphql.CollectedField, obj *DistroEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEventsPayload_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEventsPayload_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEventsPayload_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *DistroEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEventsPayload_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*DistroEvent)
	fc.Result = res
	return ec.marshalNDistroEvent2githubcomevergreencievergreengraphqlDistroEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEventsPayload_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "after":
				return ec.fieldContext_DistroEvent_after(ctx, field)
			case "before":
				return ec.fieldContext_DistroEvent_before(ctx, field)
			case "data":
				return ec.fieldContext_DistroEvent_data(ctx, field)
			case "timestamp":
				return ec.fieldContext_DistroEvent_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_DistroEvent_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_bootstrapMethod(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_bootstrapMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BootstrapMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_bootstrapMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_isVirtualWorkStation(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_isVirtualWorkStation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsVirtualWorkstation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_isVirtualWorkStation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_isWindows(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_isWindows(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsWindows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_isWindows(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_user(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_workDir(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_workDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_workDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_admin(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroPermissions_admin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroPermissions_admin(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_edit(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroPermissions_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroPermissions_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_view(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroPermissions_view(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.View, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroPermissions_view(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_maxCPU(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ECSConfig_maxCPU(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxCPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ECSConfig_maxCPU(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_maxMemoryMb(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ECSConfig_maxMemoryMb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxMemoryMB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ECSConfig_maxMemoryMb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvVar_key(ctx context.Context, field graphql.CollectedField, obj *model.APIEnvVar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvVar_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvVar_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvVar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvVar_value(ctx context.Context, field graphql.CollectedField, obj *model.APIEnvVar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvVar_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvVar_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvVar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Expansion_key(ctx context.Context, field graphql.CollectedField, obj *model.APIExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Expansion_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Expansion_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Expansion_value(ctx context.Context, field graphql.CollectedField, obj *model.APIExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Expansion_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Expansion_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLink_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLink_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_requesters(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLink_requesters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requesters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLink_requesters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_urlTemplate(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLink_urlTemplate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLinkForMetadata_url(ctx context.Context, field graphql.CollectedField, obj *ExternalLinkForMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLinkForMetadata_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLinkForMetadata_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLinkForMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLinkForMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *ExternalLinkForMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLinkForMetadata_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLinkForMetadata_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLinkForMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_link(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Link, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_link(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_name(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_urlParsley(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_urlParsley(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLParsley, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_urlParsley(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_visibility(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_visibility(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_additions(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_additions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Additions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_additions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_deletions(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_deletions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deletions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_deletions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_description(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_diffLink(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_diffLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiffLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_diffLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_fileName(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_fileName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_fileName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinderSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIFinderSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FinderSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FinderSettings().Version(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FinderVersion)
	fc.Result = res
	return ec.marshalNFinderVersion2githubcomevergreencievergreengraphqlFinderVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FinderSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinderSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FinderVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_id(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_ownerType(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OwnerType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_ownerType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_regexSelectors(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegexSelectors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APISelector)
	fc.Result = res
	return ec.marshalNSelector2githubcomevergreencievergreenrestmodelAPISelector(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_regexSelectors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_Selector_data(ctx, field)
			case "type":
				return ec.fieldContext_Selector_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Selector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_selectors(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_selectors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Selectors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APISelector)
	fc.Result = res
	return ec.marshalNSelector2githubcomevergreencievergreenrestmodelAPISelector(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_selectors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_Selector_data(ctx, field)
			case "type":
				return ec.fieldContext_Selector_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Selector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_subscriber(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APISubscriber)
	fc.Result = res
	return ec.marshalOSubscriberWrapper2githubcomevergreencievergreenrestmodelAPISubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_subscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "subscriber":
				return ec.fieldContext_SubscriberWrapper_subscriber(ctx, field)
			case "type":
				return ec.fieldContext_SubscriberWrapper_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubscriberWrapper", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_trigger(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_trigger(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Trigger, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_trigger(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_triggerData(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_triggerData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_buildVariantName(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedTaskCountResults_buildVariantName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariantName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_buildVariantName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_taskName(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedTaskCountResults_taskName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_taskName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_taskId(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedTaskCountResults_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_estimatedTasks(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedTaskCountResults_estimatedTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_estimatedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubDynamicTokenPermissionGroup_name(ctx context.Context, field graphql.CollectedField, obj *model.APIGitHubDynamicTokenPermissionGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubDynamicTokenPermissionGroup_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubDynamicTokenPermissionGroup_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubDynamicTokenPermissionGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubDynamicTokenPermissionGroup_permissions(ctx context.Context, field graphql.CollectedField, obj *model.APIGitHubDynamicTokenPermissionGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubDynamicTokenPermissionGroup_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Permissions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalNStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubDynamicTokenPermissionGroup_permissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubDynamicTokenPermissionGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitTag_tag(ctx context.Context, field graphql.CollectedField, obj *model.APIGitTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitTag_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitTag_tag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitTag_pusher(ctx context.Context, field graphql.CollectedField, obj *model.APIGitTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitTag_pusher(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pusher, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitTag_pusher(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAppAuth_appId(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAppAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAppAuth_appId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAppAuth_appId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAppAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAppAuth_privateKey(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAppAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAppAuth_privateKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAppAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubCheckSubscriber_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_ref(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubCheckSubscriber_ref(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_ref(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubCheckSubscriber_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_prNumber(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_prNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_prNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_ref(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_ref(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_ref(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_commitCheckIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubProjectConflicts_commitCheckIdentifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitCheckIdentifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_commitCheckIdentifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_commitQueueIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubProjectConflicts_commitQueueIdentifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueueIdentifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_commitQueueIdentifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_prTestingIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubProjectConflicts_prTestingIdentifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRTestingIdentifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_prTestingIdentifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_lastKnownAs(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_lastKnownAs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastKnownAs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_lastKnownAs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_uid(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_uid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_uid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedBuildVariant_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_tasks(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedBuildVariant_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_variant(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedBuildVariant_variant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_variant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_files(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedFiles_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Files, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIFile)
	fc.Result = res
	return ec.marshalOFile2githubcomevergreencievergreenrestmodelAPIFile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedFiles_files(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "link":
				return ec.fieldContext_File_link(ctx, field)
			case "name":
				return ec.fieldContext_File_name(ctx, field)
			case "urlParsley":
				return ec.fieldContext_File_urlParsley(ctx, field)
			case "visibility":
				return ec.fieldContext_File_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_taskName(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedFiles_taskName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedFiles_taskName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_taskId(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedFiles_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedFiles_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_execution(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedFiles_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedFiles_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_groupDisplayName(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedProjects_groupDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_projects(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedProjects_projects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Projects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedProjects_projects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_repo(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedProjects_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalORepoRef2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedProjects_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoRef_id(ctx, field)
			case "admins":
				return ec.fieldContext_RepoRef_admins(ctx, field)
			case "batchTime":
				return ec.fieldContext_RepoRef_batchTime(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_RepoRef_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_RepoRef_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_RepoRef_enabled(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_RepoRef_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_RepoRef_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_RepoRef_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_RepoRef_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_RepoRef_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_RepoRef_parsleyFilters(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_RepoRef_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_RepoRef_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_RepoRef_repo(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_RepoRef_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_RepoRef_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_RepoRef_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_RepoRef_workstationConfig(ctx, field)
			case "externalLinks":
				return ec.fieldContext_RepoRef_externalLinks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_displayName(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedTaskStatusCount_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_statusCounts(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedTaskStatusCount_statusCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StatusCounts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*task.StatusCount)
	fc.Result = res
	return ec.marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_statusCounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_StatusCount_count(ctx, field)
			case "status":
				return ec.fieldContext_StatusCount_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_variant(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedTaskStatusCount_variant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_variant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HomeVolumeSettings_formatCommand(ctx context.Context, field graphql.CollectedField, obj *model.APIHomeVolumeSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HomeVolumeSettings_formatCommand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormatCommand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HomeVolumeSettings_formatCommand(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HomeVolumeSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_id(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_availabilityZone(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_availabilityZone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailabilityZone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_availabilityZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_ami(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_ami(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Ami(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_ami(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_distro(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.DistroInfo)
	fc.Result = res
	return ec.marshalODistroInfo2githubcomevergreencievergreenrestmodelDistroInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_distro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DistroInfo_id(ctx, field)
			case "bootstrapMethod":
				return ec.fieldContext_DistroInfo_bootstrapMethod(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_DistroInfo_isVirtualWorkStation(ctx, field)
			case "isWindows":
				return ec.fieldContext_DistroInfo_isWindows(ctx, field)
			case "user":
				return ec.fieldContext_DistroInfo_user(ctx, field)
			case "workDir":
				return ec.fieldContext_DistroInfo_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_distroId(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_distroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().DistroID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_distroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_elapsed(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_elapsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Elapsed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_elapsed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_events(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Events(rctx, obj, fc.Args["opts"].(HostEventsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*HostEvents)
	fc.Result = res
	return ec.marshalNHostEvents2githubcomevergreencievergreengraphqlHostEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_HostEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_HostEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Host_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Host_eventTypes(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_eventTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().EventTypes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNHostEventType2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_eventTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_expiration(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_expiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_expiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_hostUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_hostUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_hostUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_homeVolume(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_homeVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().HomeVolume(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVolume)
	fc.Result = res
	return ec.marshalOVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_homeVolume(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_homeVolumeID(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_homeVolumeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeVolumeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_homeVolumeID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_instanceType(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_instanceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_instanceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_instanceTags(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_instanceTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]host.Tag)
	fc.Result = res
	return ec.marshalNInstanceTag2githubcomevergreencievergreenmodelhostTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_instanceTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canBeModified":
				return ec.fieldContext_InstanceTag_canBeModified(ctx, field)
			case "key":
				return ec.fieldContext_InstanceTag_key(ctx, field)
			case "value":
				return ec.fieldContext_InstanceTag_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InstanceTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_lastCommunicationTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_lastCommunicationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastCommunicationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_lastCommunicationTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_noExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_noExpiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoExpiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_noExpiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_persistentDnsName(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_persistentDnsName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PersistentDNSName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_persistentDnsName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_provider(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_runningTask(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_runningTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunningTask, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.TaskInfo)
	fc.Result = res
	return ec.marshalOTaskInfo2githubcomevergreencievergreenrestmodelTaskInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_runningTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_TaskInfo_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_sleepSchedule(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_sleepSchedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().SleepSchedule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*host.SleepScheduleInfo)
	fc.Result = res
	return ec.marshalOSleepSchedule2githubcomevergreencievergreenmodelhostSleepScheduleInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_sleepSchedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dailyStartTime":
				return ec.fieldContext_SleepSchedule_dailyStartTime(ctx, field)
			case "dailyStopTime":
				return ec.fieldContext_SleepSchedule_dailyStopTime(ctx, field)
			case "nextStartTime":
				return ec.fieldContext_SleepSchedule_nextStartTime(ctx, field)
			case "nextStopTime":
				return ec.fieldContext_SleepSchedule_nextStopTime(ctx, field)
			case "permanentlyExempt":
				return ec.fieldContext_SleepSchedule_permanentlyExempt(ctx, field)
			case "shouldKeepOff":
				return ec.fieldContext_SleepSchedule_shouldKeepOff(ctx, field)
			case "timeZone":
				return ec.fieldContext_SleepSchedule_timeZone(ctx, field)
			case "temporarilyExemptUntil":
				return ec.fieldContext_SleepSchedule_temporarilyExemptUntil(ctx, field)
			case "wholeWeekdaysOff":
				return ec.fieldContext_SleepSchedule_wholeWeekdaysOff(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SleepSchedule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_startedBy(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_startedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_startedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_status(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_tag(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_tag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_totalIdleTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_totalIdleTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalIdleTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_totalIdleTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_uptime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Uptime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_uptime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_user(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_volumes(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_volumes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Volumes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIVolume)
	fc.Result = res
	return ec.marshalNVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_volumes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_acceptableHostIdleTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_acceptableHostIdleTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcceptableHostIdleTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_acceptableHostIdleTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_feedbackRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_feedbackRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HostAllocatorSettings().FeedbackRule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FeedbackRule)
	fc.Result = res
	return ec.marshalNFeedbackRule2githubcomevergreencievergreengraphqlFeedbackRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_feedbackRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FeedbackRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_futureHostFraction(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_futureHostFraction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FutureHostFraction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_futureHostFraction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_hostsOverallocatedRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_hostsOverallocatedRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HostAllocatorSettings().HostsOverallocatedRule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(OverallocatedRule)
	fc.Result = res
	return ec.marshalNOverallocatedRule2githubcomevergreencievergreengraphqlOverallocatedRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_hostsOverallocatedRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OverallocatedRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_maximumHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_maximumHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaximumHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_maximumHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_minimumHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_minimumHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinimumHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_minimumHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_roundingRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_roundingRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HostAllocatorSettings().RoundingRule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(RoundingRule)
	fc.Result = res
	return ec.marshalNRoundingRule2githubcomevergreencievergreengraphqlRoundingRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_roundingRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RoundingRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HostAllocatorSettings().Version(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(HostAllocatorVersion)
	fc.Result = res
	return ec.marshalNHostAllocatorVersion2githubcomevergreencievergreengraphqlHostAllocatorVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostAllocatorVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_agentBuild(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_agentBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentBuild, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_agentBuild(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_agentRevision(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_agentRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_agentRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_duration(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_execution(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_hostname(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_hostname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_jasperRevision(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_jasperRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JasperRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_jasperRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_logs(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_monitorOp(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_monitorOp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MonitorOp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_monitorOp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_newStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_newStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_oldStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_oldStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_oldStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_provisioningMethod(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_provisioningMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_provisioningMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_successful(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_successful(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Successful, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_successful(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskId(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskPid(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_taskPid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskPid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskPid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_taskStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_user(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HostAPIEventData)
	fc.Result = res
	return ec.marshalNHostEventLogData2githubcomevergreencievergreenrestmodelHostAPIEventData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentBuild":
				return ec.fieldContext_HostEventLogData_agentBuild(ctx, field)
			case "agentRevision":
				return ec.fieldContext_HostEventLogData_agentRevision(ctx, field)
			case "duration":
				return ec.fieldContext_HostEventLogData_duration(ctx, field)
			case "execution":
				return ec.fieldContext_HostEventLogData_execution(ctx, field)
			case "hostname":
				return ec.fieldContext_HostEventLogData_hostname(ctx, field)
			case "jasperRevision":
				return ec.fieldContext_HostEventLogData_jasperRevision(ctx, field)
			case "logs":
				return ec.fieldContext_HostEventLogData_logs(ctx, field)
			case "monitorOp":
				return ec.fieldContext_HostEventLogData_monitorOp(ctx, field)
			case "newStatus":
				return ec.fieldContext_HostEventLogData_newStatus(ctx, field)
			case "oldStatus":
				return ec.fieldContext_HostEventLogData_oldStatus(ctx, field)
			case "provisioningMethod":
				return ec.fieldContext_HostEventLogData_provisioningMethod(ctx, field)
			case "successful":
				return ec.fieldContext_HostEventLogData_successful(ctx, field)
			case "taskId":
				return ec.fieldContext_HostEventLogData_taskId(ctx, field)
			case "taskPid":
				return ec.fieldContext_HostEventLogData_taskPid(ctx, field)
			case "taskStatus":
				return ec.fieldContext_HostEventLogData_taskStatus(ctx, field)
			case "user":
				return ec.fieldContext_HostEventLogData_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOHostEventType2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_eventType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_processedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_processedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_resourceId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEvents_count(ctx context.Context, field graphql.CollectedField, obj *HostEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEvents_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEvents_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *HostEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEvents_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.HostAPIEventLogEntry)
	fc.Result = res
	return ec.marshalNHostEventLogEntry2githubcomevergreencievergreenrestmodelHostAPIEventLogEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEvents_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_HostEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_HostEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_HostEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_HostEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_HostEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_HostEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_filteredHostsCount(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostsResponse_filteredHostsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredHostsCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostsResponse_filteredHostsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_hosts(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostsResponse_hosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostsResponse_hosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_totalHostsCount(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostsResponse_totalHostsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalHostsCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostsResponse_totalHostsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IceCreamSettings_configPath(ctx context.Context, field graphql.CollectedField, obj *model.APIIceCreamSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IceCreamSettings_configPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IceCreamSettings_configPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IceCreamSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IceCreamSettings_schedulerHost(ctx context.Context, field graphql.CollectedField, obj *model.APIIceCreamSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IceCreamSettings_schedulerHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SchedulerHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IceCreamSettings_schedulerHost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IceCreamSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_id(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_ami(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_ami(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AMI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_ami(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_distros(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_distros(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().Distros(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIDistro)
	fc.Result = res
	return ec.marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_distros(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_events(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().Events(rctx, obj, fc.Args["limit"].(int), fc.Args["page"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImageEventsPayload)
	fc.Result = res
	return ec.marshalNImageEventsPayload2githubcomevergreencievergreengraphqlImageEventsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ImageEventsPayload_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ImageEventsPayload_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageEventsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Image_lastDeployed(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_lastDeployed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastDeployed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_lastDeployed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_latestTask(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_latestTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().LatestTask(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_latestTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_operatingSystem(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_operatingSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().OperatingSystem(rctx, obj, fc.Args["opts"].(thirdparty.OSInfoFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImageOperatingSystemPayload)
	fc.Result = res
	return ec.marshalNImageOperatingSystemPayload2githubcomevergreencievergreengraphqlImageOperatingSystemPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_operatingSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ImageOperatingSystemPayload_data(ctx, field)
			case "filteredCount":
				return ec.fieldContext_ImageOperatingSystemPayload_filteredCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ImageOperatingSystemPayload_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageOperatingSystemPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_operatingSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Image_packages(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_packages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().Packages(rctx, obj, fc.Args["opts"].(thirdparty.PackageFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImagePackagesPayload)
	fc.Result = res
	return ec.marshalNImagePackagesPayload2githubcomevergreencievergreengraphqlImagePackagesPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_packages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ImagePackagesPayload_data(ctx, field)
			case "filteredCount":
				return ec.fieldContext_ImagePackagesPayload_filteredCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ImagePackagesPayload_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImagePackagesPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_packages_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Image_toolchains(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_toolchains(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().Toolchains(rctx, obj, fc.Args["opts"].(thirdparty.ToolchainFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImageToolchainsPayload)
	fc.Result = res
	return ec.marshalNImageToolchainsPayload2githubcomevergreencievergreengraphqlImageToolchainsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_toolchains(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ImageToolchainsPayload_data(ctx, field)
			case "filteredCount":
				return ec.fieldContext_ImageToolchainsPayload_filteredCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ImageToolchainsPayload_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageToolchainsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_toolchains_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_entries(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEvent_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIImageEventEntry)
	fc.Result = res
	return ec.marshalNImageEventEntry2githubcomevergreencievergreenrestmodelAPIImageEventEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEvent_entries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ImageEventEntry_name(ctx, field)
			case "after":
				return ec.fieldContext_ImageEventEntry_after(ctx, field)
			case "before":
				return ec.fieldContext_ImageEventEntry_before(ctx, field)
			case "type":
				return ec.fieldContext_ImageEventEntry_type(ctx, field)
			case "action":
				return ec.fieldContext_ImageEventEntry_action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageEventEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEvent_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_amiBefore(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEvent_amiBefore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AMIBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEvent_amiBefore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_amiAfter(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEvent_amiAfter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AMIAfter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEvent_amiAfter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_name(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventEntry_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventEntry_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_after(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventEntry_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventEntry_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_before(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventEntry_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventEntry_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_type(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventEntry_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(thirdparty.ImageEventType)
	fc.Result = res
	return ec.marshalNImageEventType2githubcomevergreencievergreenthirdpartyImageEventType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventEntry_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_action(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventEntry_action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(thirdparty.ImageEventEntryAction)
	fc.Result = res
	return ec.marshalNImageEventEntryAction2githubcomevergreencievergreenthirdpartyImageEventEntryAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventEntry_action(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageEventEntryAction does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventsPayload_count(ctx context.Context, field graphql.CollectedField, obj *ImageEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventsPayload_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventsPayload_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventsPayload_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *ImageEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventsPayload_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIImageEvent)
	fc.Result = res
	return ec.marshalNImageEvent2githubcomevergreencievergreenrestmodelAPIImageEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventsPayload_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "entries":
				return ec.fieldContext_ImageEvent_entries(ctx, field)
			case "timestamp":
				return ec.fieldContext_ImageEvent_timestamp(ctx, field)
			case "amiBefore":
				return ec.fieldContext_ImageEvent_amiBefore(ctx, field)
			case "amiAfter":
				return ec.fieldContext_ImageEvent_amiAfter(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageOperatingSystemPayload_data(ctx context.Context, field graphql.CollectedField, obj *ImageOperatingSystemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageOperatingSystemPayload_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIOSInfo)
	fc.Result = res
	return ec.marshalNOSInfo2githubcomevergreencievergreenrestmodelAPIOSInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageOperatingSystemPayload_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageOperatingSystemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_OSInfo_name(ctx, field)
			case "version":
				return ec.fieldContext_OSInfo_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OSInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageOperatingSystemPayload_filteredCount(ctx context.Context, field graphql.CollectedField, obj *ImageOperatingSystemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageOperatingSystemPayload_filteredCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageOperatingSystemPayload_filteredCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageOperatingSystemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageOperatingSystemPayload_totalCount(ctx context.Context, field graphql.CollectedField, obj *ImageOperatingSystemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageOperatingSystemPayload_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageOperatingSystemPayload_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageOperatingSystemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImagePackagesPayload_data(ctx context.Context, field graphql.CollectedField, obj *ImagePackagesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImagePackagesPayload_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPackage)
	fc.Result = res
	return ec.marshalNPackage2githubcomevergreencievergreenrestmodelAPIPackage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImagePackagesPayload_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImagePackagesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Package_name(ctx, field)
			case "manager":
				return ec.fieldContext_Package_manager(ctx, field)
			case "version":
				return ec.fieldContext_Package_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Package", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImagePackagesPayload_filteredCount(ctx context.Context, field graphql.CollectedField, obj *ImagePackagesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImagePackagesPayload_filteredCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImagePackagesPayload_filteredCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImagePackagesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImagePackagesPayload_totalCount(ctx context.Context, field graphql.CollectedField, obj *ImagePackagesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImagePackagesPayload_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImagePackagesPayload_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImagePackagesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageToolchainsPayload_data(ctx context.Context, field graphql.CollectedField, obj *ImageToolchainsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageToolchainsPayload_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIToolchain)
	fc.Result = res
	return ec.marshalNToolchain2githubcomevergreencievergreenrestmodelAPIToolchain(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageToolchainsPayload_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageToolchainsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Toolchain_name(ctx, field)
			case "path":
				return ec.fieldContext_Toolchain_path(ctx, field)
			case "version":
				return ec.fieldContext_Toolchain_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Toolchain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageToolchainsPayload_filteredCount(ctx context.Context, field graphql.CollectedField, obj *ImageToolchainsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageToolchainsPayload_filteredCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageToolchainsPayload_filteredCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageToolchainsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageToolchainsPayload_totalCount(ctx context.Context, field graphql.CollectedField, obj *ImageToolchainsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageToolchainsPayload_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageToolchainsPayload_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageToolchainsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_canBeModified(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstanceTag_canBeModified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanBeModified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstanceTag_canBeModified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_key(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstanceTag_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstanceTag_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_value(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstanceTag_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstanceTag_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_confidenceScore(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_confidenceScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfidenceScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_confidenceScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_issueKey(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_issueKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssueKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_issueKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_jiraTicket(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_jiraTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IssueLink().JiraTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*thirdparty.JiraTicket)
	fc.Result = res
	return ec.marshalOJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_jiraTicket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_source(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISource)
	fc.Result = res
	return ec.marshalOSource2githubcomevergreencievergreenrestmodelAPISource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_url(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraConfig_email(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraConfig_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraConfig_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraConfig_host(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraConfig_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraConfig_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraIssueSubscriber_issueType(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRAIssueSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraIssueSubscriber_issueType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssueType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraIssueSubscriber_issueType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraIssueSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraIssueSubscriber_project(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRAIssueSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraIssueSubscriber_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraIssueSubscriber_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraIssueSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraStatus_id(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraStatus_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraStatus_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraStatus_name(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraStatus_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraStatus_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraTicket_fields(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraTicket_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*thirdparty.TicketFields)
	fc.Result = res
	return ec.marshalNTicketFields2githubcomevergreencievergreenthirdpartyTicketFields(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraTicket_fields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignedTeam":
				return ec.fieldContext_TicketFields_assignedTeam(ctx, field)
			case "assigneeDisplayName":
				return ec.fieldContext_TicketFields_assigneeDisplayName(ctx, field)
			case "created":
				return ec.fieldContext_TicketFields_created(ctx, field)
			case "resolutionName":
				return ec.fieldContext_TicketFields_resolutionName(ctx, field)
			case "status":
				return ec.fieldContext_TicketFields_status(ctx, field)
			case "summary":
				return ec.fieldContext_TicketFields_summary(ctx, field)
			case "updated":
				return ec.fieldContext_TicketFields_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TicketFields", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraTicket_key(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraTicket_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraTicket_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_message(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_severity(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_timestamp(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_type(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_version(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_id(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_builder(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_builder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_builder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_buildNum(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_buildNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_buildNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_taskId(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_taskExecution(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_tests(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_tests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]plank.Test)
	fc.Result = res
	return ec.marshalNLogkeeperTest2githubcomevergreenciplankTest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_tests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LogkeeperTest_id(ctx, field)
			case "name":
				return ec.fieldContext_LogkeeperTest_name(ctx, field)
			case "buildId":
				return ec.fieldContext_LogkeeperTest_buildId(ctx, field)
			case "taskId":
				return ec.fieldContext_LogkeeperTest_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_LogkeeperTest_taskExecution(ctx, field)
			case "phase":
				return ec.fieldContext_LogkeeperTest_phase(ctx, field)
			case "command":
				return ec.fieldContext_LogkeeperTest_command(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogkeeperTest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_task(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LogkeeperBuild().Task(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_id(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_name(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_buildId(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_buildId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_buildId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_taskId(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_taskExecution(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_phase(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_phase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_phase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_command(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_command(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommitVersion_rolledUpVersions(ctx context.Context, field graphql.CollectedField, obj *MainlineCommitVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommitVersion_rolledUpVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RolledUpVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommitVersion_rolledUpVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommitVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommitVersion_version(ctx context.Context, field graphql.CollectedField, obj *MainlineCommitVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommitVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommitVersion_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommitVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_nextPageOrderNumber(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommits_nextPageOrderNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextPageOrderNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommits_nextPageOrderNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_prevPageOrderNumber(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommits_prevPageOrderNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevPageOrderNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommits_prevPageOrderNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_versions(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommits_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*MainlineCommitVersion)
	fc.Result = res
	return ec.marshalNMainlineCommitVersion2githubcomevergreencievergreengraphqlMainlineCommitVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommits_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rolledUpVersions":
				return ec.fieldContext_MainlineCommitVersion_rolledUpVersions(ctx, field)
			case "version":
				return ec.fieldContext_MainlineCommitVersion_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MainlineCommitVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_id(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_branch(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_branch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_isBase(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_isBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsBase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_isBase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_moduleOverrides(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_moduleOverrides(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModuleOverrides, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_moduleOverrides(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_modules(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_modules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Modules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_modules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_project(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_revision(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_url(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetadataLink_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetadataLink_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_text(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetadataLink_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetadataLink_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_source(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetadataLink_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISource)
	fc.Result = res
	return ec.marshalOSource2githubcomevergreencievergreenrestmodelAPISource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetadataLink_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_branchName(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_branchName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BranchName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_branchName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_fileDiffs(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_fileDiffs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDiffs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.FileDiff)
	fc.Result = res
	return ec.marshalNFileDiff2githubcomevergreencievergreenrestmodelFileDiff(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_fileDiffs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "additions":
				return ec.fieldContext_FileDiff_additions(ctx, field)
			case "deletions":
				return ec.fieldContext_FileDiff_deletions(ctx, field)
			case "description":
				return ec.fieldContext_FileDiff_description(ctx, field)
			case "diffLink":
				return ec.fieldContext_FileDiff_diffLink(ctx, field)
			case "fileName":
				return ec.fieldContext_FileDiff_fileName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDiff", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_htmlLink(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_htmlLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_htmlLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_rawLink(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_rawLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_rawLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bbCreateTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_bbCreateTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().BbCreateTicket(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_bbCreateTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bbCreateTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addAnnotationIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddAnnotationIssue(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editAnnotationNote(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editAnnotationNote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditAnnotationNote(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["originalMessage"].(string), fc.Args["newMessage"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editAnnotationNote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editAnnotationNote_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_moveAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_moveAnnotationIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MoveAnnotationIssue(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_moveAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_moveAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeAnnotationIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveAnnotationIssue(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setAnnotationMetadataLinks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setAnnotationMetadataLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetAnnotationMetadataLinks(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["metadataLinks"].([]*model.APIMetadataLink))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setAnnotationMetadataLinks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setAnnotationMetadataLinks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteDistro(rctx, fc.Args["opts"].(DeleteDistroInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DeleteDistroPayload)
	fc.Result = res
	return ec.marshalNDeleteDistroPayload2githubcomevergreencievergreengraphqlDeleteDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedDistroId":
				return ec.fieldContext_DeleteDistroPayload_deletedDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_copyDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_copyDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CopyDistro(rctx, fc.Args["opts"].(model.CopyDistroOpts))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*NewDistroPayload)
	fc.Result = res
	return ec.marshalNNewDistroPayload2githubcomevergreencievergreengraphqlNewDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_copyDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "newDistroId":
				return ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_copyDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateDistro(rctx, fc.Args["opts"].(CreateDistroInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*NewDistroPayload)
	fc.Result = res
	return ec.marshalNNewDistroPayload2githubcomevergreencievergreengraphqlNewDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "newDistroId":
				return ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveDistro(rctx, fc.Args["opts"].(SaveDistroInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SaveDistroPayload)
	fc.Result = res
	return ec.marshalNSaveDistroPayload2githubcomevergreencievergreengraphqlSaveDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distro":
				return ec.fieldContext_SaveDistroPayload_distro(ctx, field)
			case "hostCount":
				return ec.fieldContext_SaveDistroPayload_hostCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SaveDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reprovisionToNew(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_reprovisionToNew(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ReprovisionToNew(rctx, fc.Args["hostIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_reprovisionToNew(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reprovisionToNew_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartJasper(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartJasper(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartJasper(rctx, fc.Args["hostIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartJasper(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartJasper_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateHostStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateHostStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateHostStatus(rctx, fc.Args["hostIds"].([]string), fc.Args["status"].(string), fc.Args["notes"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateHostStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateHostStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setPatchVisibility(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setPatchVisibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetPatchVisibility(rctx, fc.Args["patchIds"].([]string), fc.Args["hidden"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setPatchVisibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setPatchVisibility_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_schedulePatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_schedulePatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SchedulePatch(rctx, fc.Args["patchId"].(string), fc.Args["configure"].(PatchConfigure))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_schedulePatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_schedulePatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachProjectToNewRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachProjectToNewRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AttachProjectToNewRepo(rctx, fc.Args["project"].(MoveProjectInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachProjectToNewRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachProjectToNewRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachProjectToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachProjectToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AttachProjectToRepo(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachProjectToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachProjectToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateProject(rctx, fc.Args["project"].(model.APIProjectRef), fc.Args["requestS3Creds"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_copyProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_copyProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CopyProject(rctx, fc.Args["project"].(model.CopyProjectOpts), fc.Args["requestS3Creds"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_copyProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_copyProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deactivateStepbackTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deactivateStepbackTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeactivateStepbackTask(rctx, fc.Args["opts"].(DeactivateStepbackTaskInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deactivateStepbackTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deactivateStepbackTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_defaultSectionToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_defaultSectionToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DefaultSectionToRepo(rctx, fc.Args["opts"].(DefaultSectionToRepoInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_defaultSectionToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_defaultSectionToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGithubAppCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGithubAppCredentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteGithubAppCredentials(rctx, fc.Args["opts"].(DeleteGithubAppCredentialsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteGithubAppCredentialsPayload)
	fc.Result = res
	return ec.marshalODeleteGithubAppCredentialsPayload2githubcomevergreencievergreengraphqlDeleteGithubAppCredentialsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGithubAppCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "oldAppId":
				return ec.fieldContext_DeleteGithubAppCredentialsPayload_oldAppId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteGithubAppCredentialsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGithubAppCredentials_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteProject(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_detachProjectFromRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_detachProjectFromRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DetachProjectFromRepo(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_detachProjectFromRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_detachProjectFromRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_forceRepotrackerRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_forceRepotrackerRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ForceRepotrackerRun(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_forceRepotrackerRun(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_forceRepotrackerRun_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_promoteVarsToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_promoteVarsToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PromoteVarsToRepo(rctx, fc.Args["opts"].(PromoteVarsToRepoInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_promoteVarsToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_promoteVarsToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveProjectSettingsForSection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveProjectSettingsForSection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveProjectSettingsForSection(rctx, fc.Args["projectSettings"].(*model.APIProjectSettings), fc.Args["section"].(ProjectSettingsSection))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNProjectSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveProjectSettingsForSection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveProjectSettingsForSection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveRepoSettingsForSection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveRepoSettingsForSection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveRepoSettingsForSection(rctx, fc.Args["repoSettings"].(*model.APIProjectSettings), fc.Args["section"].(ProjectSettingsSection))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNRepoSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveRepoSettingsForSection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_RepoSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_RepoSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_RepoSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_RepoSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_RepoSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveRepoSettingsForSection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setLastRevision(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setLastRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetLastRevision(rctx, fc.Args["opts"].(SetLastRevisionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SetLastRevisionPayload)
	fc.Result = res
	return ec.marshalNSetLastRevisionPayload2githubcomevergreencievergreengraphqlSetLastRevisionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setLastRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mergeBaseRevision":
				return ec.fieldContext_SetLastRevisionPayload_mergeBaseRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetLastRevisionPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setLastRevision_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachVolumeToHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachVolumeToHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AttachVolumeToHost(rctx, fc.Args["volumeAndHost"].(VolumeHost))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachVolumeToHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachVolumeToHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_detachVolumeFromHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_detachVolumeFromHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DetachVolumeFromHost(rctx, fc.Args["volumeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_detachVolumeFromHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_detachVolumeFromHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editSpawnHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editSpawnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditSpawnHost(rctx, fc.Args["spawnHost"].(*EditSpawnHostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editSpawnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editSpawnHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_migrateVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_migrateVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MigrateVolume(rctx, fc.Args["volumeId"].(string), fc.Args["spawnHostInput"].(*SpawnHostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_migrateVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_migrateVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_spawnHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_spawnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SpawnHost(rctx, fc.Args["spawnHostInput"].(*SpawnHostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_spawnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_spawnHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_spawnVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_spawnVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SpawnVolume(rctx, fc.Args["spawnVolumeInput"].(SpawnVolumeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_spawnVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_spawnVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveVolume(rctx, fc.Args["volumeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSpawnHostStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSpawnHostStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateSpawnHostStatus(rctx, fc.Args["updateSpawnHostStatusInput"].(UpdateSpawnHostStatusInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSpawnHostStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSpawnHostStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateVolume(rctx, fc.Args["updateVolumeInput"].(UpdateVolumeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_abortTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_abortTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AbortTask(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_abortTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_abortTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_overrideTaskDependencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_overrideTaskDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().OverrideTaskDependencies(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_overrideTaskDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_overrideTaskDependencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartTask(rctx, fc.Args["taskId"].(string), fc.Args["failedOnly"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_scheduleTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_scheduleTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ScheduleTasks(rctx, fc.Args["versionId"].(string), fc.Args["taskIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_scheduleTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_scheduleTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setTaskPriority(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setTaskPriority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetTaskPriority(rctx, fc.Args["taskId"].(string), fc.Args["priority"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setTaskPriority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setTaskPriority_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unscheduleTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unscheduleTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnscheduleTask(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unscheduleTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unscheduleTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addFavoriteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addFavoriteProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddFavoriteProject(rctx, fc.Args["opts"].(AddFavoriteProjectInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addFavoriteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addFavoriteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_clearMySubscriptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_clearMySubscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ClearMySubscriptions(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_clearMySubscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createPublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePublicKey(rctx, fc.Args["publicKeyInput"].(PublicKeyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createPublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSubscriptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSubscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSubscriptions(rctx, fc.Args["subscriptionIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSubscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSubscriptions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeFavoriteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeFavoriteProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveFavoriteProject(rctx, fc.Args["opts"].(RemoveFavoriteProjectInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeFavoriteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeFavoriteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removePublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removePublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemovePublicKey(rctx, fc.Args["keyName"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removePublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removePublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveSubscription(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveSubscription(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveSubscription(rctx, fc.Args["subscription"].(model.APISubscription))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveSubscription(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveSubscription_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBetaFeatures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBetaFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateBetaFeatures(rctx, fc.Args["opts"].(UpdateBetaFeaturesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpdateBetaFeaturesPayload)
	fc.Result = res
	return ec.marshalOUpdateBetaFeaturesPayload2githubcomevergreencievergreengraphqlUpdateBetaFeaturesPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBetaFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_UpdateBetaFeaturesPayload_betaFeatures(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateBetaFeaturesPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBetaFeatures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateParsleySettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateParsleySettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateParsleySettings(rctx, fc.Args["opts"].(UpdateParsleySettingsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpdateParsleySettingsPayload)
	fc.Result = res
	return ec.marshalOUpdateParsleySettingsPayload2githubcomevergreencievergreengraphqlUpdateParsleySettingsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateParsleySettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "parsleySettings":
				return ec.fieldContext_UpdateParsleySettingsPayload_parsleySettings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateParsleySettingsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateParsleySettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePublicKey(rctx, fc.Args["targetKeyName"].(string), fc.Args["updateInfo"].(PublicKeyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUserSettings(rctx, fc.Args["userSettings"].(*model.APIUserSettings))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartVersions(rctx, fc.Args["versionId"].(string), fc.Args["abort"].(bool), fc.Args["versionsToRestart"].([]*model1.VersionToRestart))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_scheduleUndispatchedBaseTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_scheduleUndispatchedBaseTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ScheduleUndispatchedBaseTasks(rctx, fc.Args["versionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_scheduleUndispatchedBaseTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_scheduleUndispatchedBaseTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setVersionPriority(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setVersionPriority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetVersionPriority(rctx, fc.Args["versionId"].(string), fc.Args["priority"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setVersionPriority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setVersionPriority_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unscheduleVersionTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unscheduleVersionTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnscheduleVersionTasks(rctx, fc.Args["versionId"].(string), fc.Args["abort"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unscheduleVersionTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unscheduleVersionTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _NewDistroPayload_newDistroId(ctx context.Context, field graphql.CollectedField, obj *NewDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewDistroID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NewDistroPayload_newDistroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NewDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Note_message(ctx context.Context, field graphql.CollectedField, obj *model.APINote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Note_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Note_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Note",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Note_source(ctx context.Context, field graphql.CollectedField, obj *model.APINote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Note_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APISource)
	fc.Result = res
	return ec.marshalNSource2githubcomevergreencievergreenrestmodelAPISource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Note_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Note",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_buildBreak(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_buildBreak(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBreak, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_buildBreak(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_buildBreakId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_buildBreakId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBreakID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_buildBreakId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFinish(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFinish(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFinish, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFinish(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFinishId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFinishId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFinishID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFinishId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFirstFailure(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFirstFailure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFirstFailure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFirstFailure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFirstFailureId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFirstFailureId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFirstFailureID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFirstFailureId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostExpiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostExpiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostExpiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostExpirationId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostExpirationId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostExpirationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostExpirationId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostOutcome(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostOutcome(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostOutcome, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostOutcome(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostOutcomeId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostOutcomeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostOutcomeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostOutcomeId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OSInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.APIOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OSInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OSInfo_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OSInfo_version(ctx context.Context, field graphql.CollectedField, obj *model.APIOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OSInfo_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OSInfo_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OomTrackerInfo_detected(ctx context.Context, field graphql.CollectedField, obj *model.APIOomTrackerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OomTrackerInfo_detected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Detected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OomTrackerInfo_detected(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OomTrackerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OomTrackerInfo_pids(ctx context.Context, field graphql.CollectedField, obj *model.APIOomTrackerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OomTrackerInfo_pids(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pids, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OomTrackerInfo_pids(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OomTrackerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Package_name(ctx context.Context, field graphql.CollectedField, obj *model.APIPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Package_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Package_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Package_manager(ctx context.Context, field graphql.CollectedField, obj *model.APIPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Package_manager(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manager, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Package_manager(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Package_version(ctx context.Context, field graphql.CollectedField, obj *model.APIPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Package_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Package_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Parameter_key(ctx context.Context, field graphql.CollectedField, obj *model.APIParameter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Parameter_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Parameter_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Parameter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Parameter_value(ctx context.Context, field graphql.CollectedField, obj *model.APIParameter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Parameter_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Parameter_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Parameter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_expression(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleyFilter_expression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleyFilter_expression(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_caseSensitive(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CaseSensitive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleyFilter_caseSensitive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_exactMatch(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExactMatch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleyFilter_exactMatch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleySettings_sectionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleySettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleySettings_sectionsEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectionsEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleySettings_sectionsEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleySettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleySettings_jumpToFailingLineEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleySettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleySettings_jumpToFailingLineEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JumpToFailingLineEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleySettings_jumpToFailingLineEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleySettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_activated(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_author(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_authorDisplayName(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_authorDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().AuthorDisplayName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_authorDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_baseTaskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().BaseTaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_baseTaskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_builds(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_builds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Builds(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIBuild)
	fc.Result = res
	return ec.marshalNBuild2githubcomevergreencievergreenrestmodelAPIBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_builds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "actualMakespan":
				return ec.fieldContext_Build_actualMakespan(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Build_buildVariant(ctx, field)
			case "predictedMakespan":
				return ec.fieldContext_Build_predictedMakespan(ctx, field)
			case "status":
				return ec.fieldContext_Build_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_childPatchAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_childPatchAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildPatchAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIChildPatchAlias)
	fc.Result = res
	return ec.marshalOChildPatchAlias2githubcomevergreencievergreenrestmodelAPIChildPatchAlias(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_childPatchAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_ChildPatchAlias_alias(ctx, field)
			case "patchId":
				return ec.fieldContext_ChildPatchAlias_patchId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChildPatchAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_childPatches(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_childPatches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildPatches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPatch)
	fc.Result = res
	return ec.marshalOPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_childPatches(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_description(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_duration(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Duration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchDuration)
	fc.Result = res
	return ec.marshalOPatchDuration2githubcomevergreencievergreengraphqlPatchDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "makespan":
				return ec.fieldContext_PatchDuration_makespan(ctx, field)
			case "time":
				return ec.fieldContext_PatchDuration_time(ctx, field)
			case "timeTaken":
				return ec.fieldContext_PatchDuration_timeTaken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchDuration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_generatedTaskCounts(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().GeneratedTaskCounts(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GeneratedTaskCountResults)
	fc.Result = res
	return ec.marshalNGeneratedTaskCountResults2githubcomevergreencievergreengraphqlGeneratedTaskCountResults(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_generatedTaskCounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariantName":
				return ec.fieldContext_GeneratedTaskCountResults_buildVariantName(ctx, field)
			case "taskName":
				return ec.fieldContext_GeneratedTaskCountResults_taskName(ctx, field)
			case "taskId":
				return ec.fieldContext_GeneratedTaskCountResults_taskId(ctx, field)
			case "estimatedTasks":
				return ec.fieldContext_GeneratedTaskCountResults_estimatedTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneratedTaskCountResults", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_githash(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_githash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Githash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_githash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_hidden(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_hidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_hidden(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_moduleCodeChanges(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModuleCodeChanges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIModulePatch)
	fc.Result = res
	return ec.marshalNModuleCodeChange2githubcomevergreencievergreenrestmodelAPIModulePatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_moduleCodeChanges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "branchName":
				return ec.fieldContext_ModuleCodeChange_branchName(ctx, field)
			case "fileDiffs":
				return ec.fieldContext_ModuleCodeChange_fileDiffs(ctx, field)
			case "htmlLink":
				return ec.fieldContext_ModuleCodeChange_htmlLink(ctx, field)
			case "rawLink":
				return ec.fieldContext_ModuleCodeChange_rawLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModuleCodeChange", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIParameter)
	fc.Result = res
	return ec.marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_parameters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_patchNumber(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_patchNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_patchNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().PatchTriggerAliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPatchTriggerDefinition)
	fc.Result = res
	return ec.marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_patchTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "downstreamRevision":
				return ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_project(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Project(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchProject)
	fc.Result = res
	return ec.marshalOPatchProject2githubcomevergreencievergreengraphqlPatchProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "variants":
				return ec.fieldContext_PatchProject_variants(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchProject", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectID(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_projectID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_projectID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().ProjectIdentifier(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_projectMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().ProjectMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_projectMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_taskCount(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_taskCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().TaskCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_taskCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_tasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_taskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_taskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().TaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_taskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_time(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Time(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchTime)
	fc.Result = res
	return ec.marshalOPatchTime2githubcomevergreencievergreengraphqlPatchTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "finished":
				return ec.fieldContext_PatchTime_finished(ctx, field)
			case "started":
				return ec.fieldContext_PatchTime_started(ctx, field)
			case "submittedAt":
				return ec.fieldContext_PatchTime_submittedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_variants(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_variants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variants, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_variants(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_variantsTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_variantsTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantsTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.VariantTask)
	fc.Result = res
	return ec.marshalNVariantTask2githubcomevergreencievergreenrestmodelVariantTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_variantsTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_VariantTask_name(ctx, field)
			case "tasks":
				return ec.fieldContext_VariantTask_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VariantTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_versionFull(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_versionFull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().VersionFull(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_versionFull(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_makespan(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchDuration_makespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Makespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchDuration_makespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_time(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchDuration_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchTime)
	fc.Result = res
	return ec.marshalOPatchTime2githubcomevergreencievergreengraphqlPatchTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchDuration_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "finished":
				return ec.fieldContext_PatchTime_finished(ctx, field)
			case "started":
				return ec.fieldContext_PatchTime_started(ctx, field)
			case "submittedAt":
				return ec.fieldContext_PatchTime_submittedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_timeTaken(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchDuration_timeTaken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeTaken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchDuration_timeTaken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchProject_variants(ctx context.Context, field graphql.CollectedField, obj *PatchProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchProject_variants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variants, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ProjectBuildVariant)
	fc.Result = res
	return ec.marshalNProjectBuildVariant2githubcomevergreencievergreengraphqlProjectBuildVariant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchProject_variants(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ProjectBuildVariant_displayName(ctx, field)
			case "name":
				return ec.fieldContext_ProjectBuildVariant_name(ctx, field)
			case "tasks":
				return ec.fieldContext_ProjectBuildVariant_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectBuildVariant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_finished(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTime_finished(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Finished, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTime_finished(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_started(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTime_started(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Started, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTime_started(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_submittedAt(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTime_submittedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubmittedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTime_submittedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_childProjectId(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_childProjectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_childProjectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildProjectIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_childProjectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_parentAsModule(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentAsModule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_parentAsModule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_downstreamRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DownstreamRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_downstreamRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_taskSpecifiers(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskSpecifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APITaskSpecifier)
	fc.Result = res
	return ec.marshalOTaskSpecifier2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_taskSpecifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "patchAlias":
				return ec.fieldContext_TaskSpecifier_patchAlias(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TaskSpecifier_taskRegex(ctx, field)
			case "variantRegex":
				return ec.fieldContext_TaskSpecifier_variantRegex(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskSpecifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_variantsTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantsTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.VariantTask)
	fc.Result = res
	return ec.marshalNVariantTask2githubcomevergreencievergreenrestmodelVariantTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_variantsTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_VariantTask_name(ctx, field)
			case "tasks":
				return ec.fieldContext_VariantTask_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VariantTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patches_filteredPatchCount(ctx context.Context, field graphql.CollectedField, obj *Patches) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patches_filteredPatchCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredPatchCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patches_filteredPatchCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patches",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patches_patches(ctx context.Context, field graphql.CollectedField, obj *Patches) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patches_patches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Patches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patches_patches(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patches",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_configFile(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_configFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_configFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_intervalHours(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntervalHours, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_intervalHours(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_cron(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_cron(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cron, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_cron(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_message(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_nextRunTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextRunTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_nextRunTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canCreateDistro(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_canCreateDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().CanCreateDistro(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_canCreateDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canCreateProject(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_canCreateProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().CanCreateProject(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_canCreateProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canEditAdminSettings(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_canEditAdminSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().CanEditAdminSettings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_canEditAdminSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_distroPermissions(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_distroPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().DistroPermissions(rctx, obj, fc.Args["options"].(DistroPermissionsOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DistroPermissions)
	fc.Result = res
	return ec.marshalNDistroPermissions2githubcomevergreencievergreengraphqlDistroPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_distroPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "admin":
				return ec.fieldContext_DistroPermissions_admin(ctx, field)
			case "edit":
				return ec.fieldContext_DistroPermissions_edit(ctx, field)
			case "view":
				return ec.fieldContext_DistroPermissions_view(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroPermissions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Permissions_distroPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_projectPermissions(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_projectPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().ProjectPermissions(rctx, obj, fc.Args["options"].(ProjectPermissionsOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ProjectPermissions)
	fc.Result = res
	return ec.marshalNProjectPermissions2githubcomevergreencievergreengraphqlProjectPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_projectPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edit":
				return ec.fieldContext_ProjectPermissions_edit(ctx, field)
			case "view":
				return ec.fieldContext_ProjectPermissions_view(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectPermissions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Permissions_projectPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_repoPermissions(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_repoPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().RepoPermissions(rctx, obj, fc.Args["options"].(RepoPermissionsOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoPermissions)
	fc.Result = res
	return ec.marshalNRepoPermissions2githubcomevergreencievergreengraphqlRepoPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_repoPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edit":
				return ec.fieldContext_RepoPermissions_edit(ctx, field)
			case "view":
				return ec.fieldContext_RepoPermissions_view(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoPermissions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Permissions_repoPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_userId(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_commitQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_commitQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_commitQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_expectedRuntimeFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_expectedRuntimeFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedRuntimeFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_expectedRuntimeFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_generateTaskFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_generateTaskFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenerateTaskFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_generateTaskFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_numDependentsFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_numDependentsFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDependentsFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_numDependentsFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_groupVersions(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_groupVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_groupVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_mainlineTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_mainlineTimeInQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainlineTimeInQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_mainlineTimeInQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_patchFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_patchFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_patchFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_patchTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_patchTimeInQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchTimeInQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_patchTimeInQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_targetTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_targetTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_targetTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PlannerSettings().Version(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PlannerVersion)
	fc.Result = res
	return ec.marshalNPlannerVersion2githubcomevergreencievergreengraphqlPlannerVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PlannerVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_events(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Events(rctx, obj, fc.Args["limit"].(*int), fc.Args["page"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PodEvents)
	fc.Result = res
	return ec.marshalNPodEvents2githubcomevergreencievergreengraphqlPodEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_PodEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_PodEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Pod_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Pod_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_task(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Task(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_taskContainerCreationOpts(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskContainerCreationOpts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIPodTaskContainerCreationOptions)
	fc.Result = res
	return ec.marshalNTaskContainerCreationOpts2githubcomevergreencievergreenrestmodelAPIPodTaskContainerCreationOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_taskContainerCreationOpts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "image":
				return ec.fieldContext_TaskContainerCreationOpts_image(ctx, field)
			case "memoryMB":
				return ec.fieldContext_TaskContainerCreationOpts_memoryMB(ctx, field)
			case "cpu":
				return ec.fieldContext_TaskContainerCreationOpts_cpu(ctx, field)
			case "os":
				return ec.fieldContext_TaskContainerCreationOpts_os(ctx, field)
			case "arch":
				return ec.fieldContext_TaskContainerCreationOpts_arch(ctx, field)
			case "workingDir":
				return ec.fieldContext_TaskContainerCreationOpts_workingDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskContainerCreationOpts", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_type(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_oldStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_oldStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_oldStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_newStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_newStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_reason(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_reason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskID(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_taskID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskExecution(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_taskStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_task(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PodEventLogData().Task(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PodAPIEventData)
	fc.Result = res
	return ec.marshalNPodEventLogData2githubcomevergreencievergreenrestmodelPodAPIEventData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "oldStatus":
				return ec.fieldContext_PodEventLogData_oldStatus(ctx, field)
			case "newStatus":
				return ec.fieldContext_PodEventLogData_newStatus(ctx, field)
			case "reason":
				return ec.fieldContext_PodEventLogData_reason(ctx, field)
			case "taskID":
				return ec.fieldContext_PodEventLogData_taskID(ctx, field)
			case "taskExecution":
				return ec.fieldContext_PodEventLogData_taskExecution(ctx, field)
			case "taskStatus":
				return ec.fieldContext_PodEventLogData_taskStatus(ctx, field)
			case "task":
				return ec.fieldContext_PodEventLogData_task(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_eventType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_processedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_processedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_resourceId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEvents_count(ctx context.Context, field graphql.CollectedField, obj *PodEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEvents_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEvents_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *PodEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEvents_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PodAPIEventLogEntry)
	fc.Result = res
	return ec.marshalNPodEventLogEntry2githubcomevergreencievergreenrestmodelPodAPIEventLogEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEvents_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PodEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_PodEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_PodEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_PodEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_PodEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_PodEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_PodEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreconditionScript_path(ctx context.Context, field graphql.CollectedField, obj *model.APIPreconditionScript) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreconditionScript_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreconditionScript_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreconditionScript",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreconditionScript_script(ctx context.Context, field graphql.CollectedField, obj *model.APIPreconditionScript) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreconditionScript_script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreconditionScript_script(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreconditionScript",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_admins(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admins, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_admins(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_banner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectBanner)
	fc.Result = res
	return ec.marshalOProjectBanner2githubcomevergreencievergreenrestmodelAPIProjectBanner(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_banner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_ProjectBanner_text(ctx, field)
			case "theme":
				return ec.fieldContext_ProjectBanner_theme(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectBanner", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_batchTime(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_batchTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_batchTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_branch(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_branch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_buildBaronSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_buildBaronSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBaronSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBuildBaronSettings)
	fc.Result = res
	return ec.marshalNBuildBaronSettings2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_buildBaronSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bfSuggestionFeaturesURL":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
			case "bfSuggestionPassword":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
			case "bfSuggestionServer":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
			case "bfSuggestionTimeoutSecs":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
			case "bfSuggestionUsername":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
			case "ticketCreateProject":
				return ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
			case "ticketSearchProjects":
				return ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
			case "ticketCreateIssueType":
				return ec.fieldContext_BuildBaronSettings_ticketCreateIssueType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaronSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_commitQueue(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_commitQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APICommitQueueParams)
	fc.Result = res
	return ec.marshalNCommitQueueParams2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_commitQueue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_CommitQueueParams_enabled(ctx, field)
			case "mergeMethod":
				return ec.fieldContext_CommitQueueParams_mergeMethod(ctx, field)
			case "message":
				return ec.fieldContext_CommitQueueParams_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CommitQueueParams", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_containerSizeDefinitions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerSizeDefinitions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIContainerResources)
	fc.Result = res
	return ec.marshalOContainerResources2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_containerSizeDefinitions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ContainerResources_name(ctx, field)
			case "cpu":
				return ec.fieldContext_ContainerResources_cpu(ctx, field)
			case "memoryMb":
				return ec.fieldContext_ContainerResources_memoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_deactivatePrevious(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_deactivatePrevious(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeactivatePrevious, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_deactivatePrevious(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_disabledStatsCache(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_disabledStatsCache(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisabledStatsCache, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_disabledStatsCache(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_dispatchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_dispatchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DispatchingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_dispatchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_externalLinks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_externalLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalLinks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIExternalLink)
	fc.Result = res
	return ec.marshalOExternalLink2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_externalLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ExternalLink_displayName(ctx, field)
			case "requesters":
				return ec.fieldContext_ExternalLink_requesters(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubChecksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubChecksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubChecksEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubChecksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubDynamicTokenPermissionGroups(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitHubDynamicTokenPermissionGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIGitHubDynamicTokenPermissionGroup)
	fc.Result = res
	return ec.marshalNGitHubDynamicTokenPermissionGroup2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubDynamicTokenPermissionGroups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_name(ctx, field)
			case "permissions":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_permissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitHubDynamicTokenPermissionGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubPermissionGroupByRequester(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitHubPermissionGroupByRequester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubPermissionGroupByRequester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubTriggerAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagAuthorizedTeams(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagAuthorizedTeams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_gitTagAuthorizedTeams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagAuthorizedUsers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagAuthorizedUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_gitTagAuthorizedUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagVersionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagVersionsEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_gitTagVersionsEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_hidden(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_hidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_hidden(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_identifier(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_identifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Identifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_identifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_isFavorite(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_isFavorite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().IsFavorite(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_isFavorite(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_manualPrTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManualPRTestingEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_manualPrTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_notifyOnBuildFailure(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotifyOnBuildFailure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_notifyOnBuildFailure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_oldestAllowedMergeBase(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldestAllowedMergeBase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_oldestAllowedMergeBase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_parsleyFilters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_parsleyFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleyFilters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIParsleyFilter)
	fc.Result = res
	return ec.marshalOParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_parsleyFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "expression":
				return ec.fieldContext_ParsleyFilter_expression(ctx, field)
			case "caseSensitive":
				return ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
			case "exactMatch":
				return ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleyFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_patches(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_patches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().Patches(rctx, obj, fc.Args["patchesInput"].(PatchesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Patches)
	fc.Result = res
	return ec.marshalNPatches2githubcomevergreencievergreengraphqlPatches(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_patches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredPatchCount":
				return ec.fieldContext_Patches_filteredPatchCount(ctx, field)
			case "patches":
				return ec.fieldContext_Patches_patches(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patches", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Project_patches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Project_patchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_patchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_patchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_patchTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchTriggerAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPatchTriggerDefinition)
	fc.Result = res
	return ec.marshalOPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_patchTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "downstreamRevision":
				return ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_perfEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_perfEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerfEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_perfEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_periodicBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_periodicBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeriodicBuilds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPeriodicBuildDefinition)
	fc.Result = res
	return ec.marshalOPeriodicBuild2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_periodicBuilds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PeriodicBuild_id(ctx, field)
			case "alias":
				return ec.fieldContext_PeriodicBuild_alias(ctx, field)
			case "configFile":
				return ec.fieldContext_PeriodicBuild_configFile(ctx, field)
			case "intervalHours":
				return ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
			case "cron":
				return ec.fieldContext_PeriodicBuild_cron(ctx, field)
			case "message":
				return ec.fieldContext_PeriodicBuild_message(ctx, field)
			case "nextRunTime":
				return ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PeriodicBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_projectHealthView(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_projectHealthView(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectHealthView, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model1.ProjectHealthView)
	fc.Result = res
	return ec.marshalNProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_projectHealthView(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectHealthView does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_prTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_prTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRTestingEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_prTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_remotePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemotePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_remotePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repoRefId(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repoRefId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoRefId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repoRefId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repotrackerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repotrackerDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepotrackerDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repotrackerDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repotrackerError(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repotrackerError(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepotrackerError, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIRepositoryErrorDetails)
	fc.Result = res
	return ec.marshalORepotrackerError2githubcomevergreencievergreenrestmodelAPIRepositoryErrorDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repotrackerError(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_RepotrackerError_exists(ctx, field)
			case "invalidRevision":
				return ec.fieldContext_RepotrackerError_invalidRevision(ctx, field)
			case "mergeBaseRevision":
				return ec.fieldContext_RepotrackerError_mergeBaseRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepotrackerError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_restricted(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_restricted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restricted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_restricted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_spawnHostScriptPath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostScriptPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_spawnHostScriptPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_stepbackDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_stepbackDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_stepbackDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_stepbackBisect(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_stepbackBisect(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackBisect, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_stepbackBisect(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_taskAnnotationSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskAnnotationSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APITaskAnnotationSettings)
	fc.Result = res
	return ec.marshalNTaskAnnotationSettings2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_taskAnnotationSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileTicketWebhook":
				return ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskAnnotationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_tracksPushEvents(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_tracksPushEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TracksPushEvents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_tracksPushEvents(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_triggers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_triggers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Triggers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APITriggerDefinition)
	fc.Result = res
	return ec.marshalOTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_triggers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_TriggerAlias_alias(ctx, field)
			case "buildVariantRegex":
				return ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
			case "configFile":
				return ec.fieldContext_TriggerAlias_configFile(ctx, field)
			case "dateCutoff":
				return ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
			case "level":
				return ec.fieldContext_TriggerAlias_level(ctx, field)
			case "project":
				return ec.fieldContext_TriggerAlias_project(ctx, field)
			case "status":
				return ec.fieldContext_TriggerAlias_status(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
			case "unscheduleDownstreamVersions":
				return ec.fieldContext_TriggerAlias_unscheduleDownstreamVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_versionControlEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_versionControlEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionControlEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_versionControlEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_workstationConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_workstationConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkstationConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIWorkstationConfig)
	fc.Result = res
	return ec.marshalNWorkstationConfig2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_workstationConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gitClone":
				return ec.fieldContext_WorkstationConfig_gitClone(ctx, field)
			case "setupCommands":
				return ec.fieldContext_WorkstationConfig_setupCommands(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_description(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_gitTag(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_gitTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_gitTag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_remotePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemotePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_remotePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_task(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Task, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_taskTags(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_taskTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_taskTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_variant(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_variant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_variant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_variantTags(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_variantTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_variantTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIParameter)
	fc.Result = res
	return ec.marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_parameters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBanner_text(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectBanner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBanner_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBanner_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBanner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBanner_theme(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectBanner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBanner_theme(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Theme, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(evergreen.BannerTheme)
	fc.Result = res
	return ec.marshalNBannerTheme2githubcomevergreencievergreenBannerTheme(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBanner_theme(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBanner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BannerTheme does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBuildVariant_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_name(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBuildVariant_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_tasks(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBuildVariant_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_after(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectEventSettings)
	fc.Result = res
	return ec.marshalOProjectEventSettings2githubcomevergreencievergreenrestmodelAPIProjectEventSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectEventSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectEventSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_before(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectEventSettings)
	fc.Result = res
	return ec.marshalOProjectEventSettings2githubcomevergreencievergreenrestmodelAPIProjectEventSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectEventSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectEventSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_user(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIProjectAlias)
	fc.Result = res
	return ec.marshalOProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_githubAppAuth(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_githubAppAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubAppAuth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIGithubAppAuth)
	fc.Result = res
	return ec.marshalOGithubAppAuth2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_githubAppAuth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GithubAppAuth_appId(ctx, field)
			case "privateKey":
				return ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAppAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubWebhooksEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_githubWebhooksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_projectRef(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subscriptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectVars)
	fc.Result = res
	return ec.marshalOProjectVars2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEvents_count(ctx context.Context, field graphql.CollectedField, obj *ProjectEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEvents_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEvents_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *ProjectEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectEvent)
	fc.Result = res
	return ec.marshalNProjectEventLogEntry2githubcomevergreencievergreenrestmodelAPIProjectEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEvents_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "after":
				return ec.fieldContext_ProjectEventLogEntry_after(ctx, field)
			case "before":
				return ec.fieldContext_ProjectEventLogEntry_before(ctx, field)
			case "timestamp":
				return ec.fieldContext_ProjectEventLogEntry_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_ProjectEventLogEntry_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectPermissions_edit(ctx context.Context, field graphql.CollectedField, obj *ProjectPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectPermissions_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectPermissions_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectPermissions_view(ctx context.Context, field graphql.CollectedField, obj *ProjectPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectPermissions_view(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.View, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectPermissions_view(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectAlias)
	fc.Result = res
	return ec.marshalOProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_githubAppAuth(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_githubAppAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().GithubAppAuth(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubAppAuth)
	fc.Result = res
	return ec.marshalOGithubAppAuth2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_githubAppAuth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GithubAppAuth_appId(ctx, field)
			case "privateKey":
				return ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAppAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().GithubWebhooksEnabled(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_githubWebhooksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_projectRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ProjectRef, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireProjectSettingsAccess == nil {
				var zeroVal model.APIProjectRef
				return zeroVal, errors.New("directive requireProjectSettingsAccess is not implemented")
			}
			return ec.directives.RequireProjectSettingsAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APIProjectRef); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectRef`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_projectRef(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().Subscriptions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectVars)
	fc.Result = res
	return ec.marshalOProjectVars2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTasksPair_projectId(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectTasksPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTasksPair_projectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTasksPair_projectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTasksPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTasksPair_allowedTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectTasksPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTasksPair_allowedTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTasksPair_allowedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTasksPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTasksPair_allowedBVs(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectTasksPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTasksPair_allowedBVs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedBVs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTasksPair_allowedBVs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTasksPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_adminOnlyVars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectVars().AdminOnlyVars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectVars_adminOnlyVars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_privateVars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectVars_privateVars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectVars().PrivateVars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectVars_privateVars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectVars_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectVars_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicKey_key(ctx context.Context, field graphql.CollectedField, obj *model.APIPubKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicKey_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicKey_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicKey_name(ctx context.Context, field graphql.CollectedField, obj *model.APIPubKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicKey_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicKey_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_bbGetCreatedTickets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bbGetCreatedTickets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BbGetCreatedTickets(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*thirdparty.JiraTicket)
	fc.Result = res
	return ec.marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bbGetCreatedTickets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bbGetCreatedTickets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_buildBaron(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_buildBaron(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BuildBaron(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BuildBaron)
	fc.Result = res
	return ec.marshalNBuildBaron2githubcomevergreencievergreengraphqlBuildBaron(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_buildBaron(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bbTicketCreationDefined":
				return ec.fieldContext_BuildBaron_bbTicketCreationDefined(ctx, field)
			case "buildBaronConfigured":
				return ec.fieldContext_BuildBaron_buildBaronConfigured(ctx, field)
			case "searchReturnInfo":
				return ec.fieldContext_BuildBaron_searchReturnInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaron", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_buildBaron_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_awsRegions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_awsRegions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AWSRegions(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_awsRegions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_clientConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_clientConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClientConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIClientConfig)
	fc.Result = res
	return ec.marshalOClientConfig2githubcomevergreencievergreenrestmodelAPIClientConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_clientConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientBinaries":
				return ec.fieldContext_ClientConfig_clientBinaries(ctx, field)
			case "latestRevision":
				return ec.fieldContext_ClientConfig_latestRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_instanceTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_instanceTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InstanceTypes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_instanceTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_spruceConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_spruceConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SpruceConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAdminSettings)
	fc.Result = res
	return ec.marshalOSpruceConfig2githubcomevergreencievergreenrestmodelAPIAdminSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_spruceConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "banner":
				return ec.fieldContext_SpruceConfig_banner(ctx, field)
			case "bannerTheme":
				return ec.fieldContext_SpruceConfig_bannerTheme(ctx, field)
			case "containerPools":
				return ec.fieldContext_SpruceConfig_containerPools(ctx, field)
			case "githubOrgs":
				return ec.fieldContext_SpruceConfig_githubOrgs(ctx, field)
			case "jira":
				return ec.fieldContext_SpruceConfig_jira(ctx, field)
			case "providers":
				return ec.fieldContext_SpruceConfig_providers(ctx, field)
			case "secretFields":
				return ec.fieldContext_SpruceConfig_secretFields(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_SpruceConfig_singleTaskDistro(ctx, field)
			case "slack":
				return ec.fieldContext_SpruceConfig_slack(ctx, field)
			case "spawnHost":
				return ec.fieldContext_SpruceConfig_spawnHost(ctx, field)
			case "ui":
				return ec.fieldContext_SpruceConfig_ui(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpruceConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_subnetAvailabilityZones(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_subnetAvailabilityZones(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SubnetAvailabilityZones(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_subnetAvailabilityZones(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_distro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Distro(rctx, fc.Args["distroId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDistro)
	fc.Result = res
	return ec.marshalODistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_distroEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distroEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DistroEvents(rctx, fc.Args["opts"].(DistroEventsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DistroEventsPayload)
	fc.Result = res
	return ec.marshalNDistroEventsPayload2githubcomevergreencievergreengraphqlDistroEventsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distroEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_DistroEventsPayload_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_DistroEventsPayload_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroEventsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distroEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_distros(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distros(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Distros(rctx, fc.Args["onlySpawnable"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIDistro)
	fc.Result = res
	return ec.marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distros(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distros_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_distroTaskQueue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distroTaskQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DistroTaskQueue(rctx, fc.Args["distroId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITaskQueueItem)
	fc.Result = res
	return ec.marshalNTaskQueueItem2githubcomevergreencievergreenrestmodelAPITaskQueueItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distroTaskQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskQueueItem_id(ctx, field)
			case "buildVariant":
				return ec.fieldContext_TaskQueueItem_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_TaskQueueItem_displayName(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_TaskQueueItem_expectedDuration(ctx, field)
			case "priority":
				return ec.fieldContext_TaskQueueItem_priority(ctx, field)
			case "project":
				return ec.fieldContext_TaskQueueItem_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_TaskQueueItem_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_TaskQueueItem_requester(ctx, field)
			case "activatedBy":
				return ec.fieldContext_TaskQueueItem_activatedBy(ctx, field)
			case "revision":
				return ec.fieldContext_TaskQueueItem_revision(ctx, field)
			case "version":
				return ec.fieldContext_TaskQueueItem_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskQueueItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distroTaskQueue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_host(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Host(rctx, fc.Args["hostId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalOHost2githubcomevergreencievergreenrestmodelAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_host_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hostEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hostEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HostEvents(rctx, fc.Args["hostId"].(string), fc.Args["hostTag"].(*string), fc.Args["limit"].(*int), fc.Args["page"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*HostEvents)
	fc.Result = res
	return ec.marshalNHostEvents2githubcomevergreencievergreengraphqlHostEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hostEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_HostEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_HostEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hostEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hosts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Hosts(rctx, fc.Args["hostId"].(*string), fc.Args["distroId"].(*string), fc.Args["currentTaskId"].(*string), fc.Args["statuses"].([]string), fc.Args["startedBy"].(*string), fc.Args["sortBy"].(*HostSortBy), fc.Args["sortDir"].(*SortDirection), fc.Args["page"].(*int), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*HostsResponse)
	fc.Result = res
	return ec.marshalNHostsResponse2githubcomevergreencievergreengraphqlHostsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredHostsCount":
				return ec.fieldContext_HostsResponse_filteredHostsCount(ctx, field)
			case "hosts":
				return ec.fieldContext_HostsResponse_hosts(ctx, field)
			case "totalHostsCount":
				return ec.fieldContext_HostsResponse_totalHostsCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hosts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskQueueDistros(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskQueueDistros(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskQueueDistros(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TaskQueueDistro)
	fc.Result = res
	return ec.marshalNTaskQueueDistro2githubcomevergreencievergreengraphqlTaskQueueDistro(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskQueueDistros(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskQueueDistro_id(ctx, field)
			case "hostCount":
				return ec.fieldContext_TaskQueueDistro_hostCount(ctx, field)
			case "taskCount":
				return ec.fieldContext_TaskQueueDistro_taskCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskQueueDistro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_pod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_pod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Pod(rctx, fc.Args["podId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIPod)
	fc.Result = res
	return ec.marshalNPod2githubcomevergreencievergreenrestmodelAPIPod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_pod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "events":
				return ec.fieldContext_Pod_events(ctx, field)
			case "id":
				return ec.fieldContext_Pod_id(ctx, field)
			case "status":
				return ec.fieldContext_Pod_status(ctx, field)
			case "task":
				return ec.fieldContext_Pod_task(ctx, field)
			case "taskContainerCreationOpts":
				return ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
			case "type":
				return ec.fieldContext_Pod_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_pod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_patch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Patch(rctx, fc.Args["patchId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_patch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_patch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubProjectConflicts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubProjectConflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubProjectConflicts(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model1.GithubProjectConflicts)
	fc.Result = res
	return ec.marshalNGithubProjectConflicts2githubcomevergreencievergreenmodelGithubProjectConflicts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubProjectConflicts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commitCheckIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_commitCheckIdentifiers(ctx, field)
			case "commitQueueIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_commitQueueIdentifiers(ctx, field)
			case "prTestingIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_prTestingIdentifiers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubProjectConflicts", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubProjectConflicts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_project(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Project(rctx, fc.Args["projectIdentifier"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_project_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_projects(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Projects(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GroupedProjects)
	fc.Result = res
	return ec.marshalNGroupedProjects2githubcomevergreencievergreengraphqlGroupedProjects(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupDisplayName":
				return ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
			case "projects":
				return ec.fieldContext_GroupedProjects_projects(ctx, field)
			case "repo":
				return ec.fieldContext_GroupedProjects_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedProjects", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projectEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ProjectEvents(rctx, fc.Args["projectIdentifier"].(string), fc.Args["limit"].(*int), fc.Args["before"].(*time.Time))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ProjectEvents)
	fc.Result = res
	return ec.marshalNProjectEvents2githubcomevergreencievergreengraphqlProjectEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projectEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ProjectEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projectSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ProjectSettings(rctx, fc.Args["projectIdentifier"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNProjectSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projectSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_repoEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_repoEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RepoEvents(rctx, fc.Args["repoId"].(string), fc.Args["limit"].(*int), fc.Args["before"].(*time.Time))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ProjectEvents)
	fc.Result = res
	return ec.marshalNProjectEvents2githubcomevergreencievergreengraphqlProjectEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_repoEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ProjectEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_repoEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_repoSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_repoSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RepoSettings(rctx, fc.Args["repoId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNRepoSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_repoSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_RepoSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_RepoSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_RepoSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_RepoSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_RepoSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_repoSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewableProjectRefs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewableProjectRefs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ViewableProjectRefs(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GroupedProjects)
	fc.Result = res
	return ec.marshalNGroupedProjects2githubcomevergreencievergreengraphqlGroupedProjects(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewableProjectRefs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupDisplayName":
				return ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
			case "projects":
				return ec.fieldContext_GroupedProjects_projects(ctx, field)
			case "repo":
				return ec.fieldContext_GroupedProjects_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedProjects", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_isRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_isRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().IsRepo(rctx, fc.Args["projectOrRepoId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_isRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_isRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_myHosts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyHosts(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_myVolumes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myVolumes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyVolumes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIVolume)
	fc.Result = res
	return ec.marshalNVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myVolumes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_logkeeperBuildMetadata(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_logkeeperBuildMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LogkeeperBuildMetadata(rctx, fc.Args["buildId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*plank.Build)
	fc.Result = res
	return ec.marshalNLogkeeperBuild2githubcomevergreenciplankBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_logkeeperBuildMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LogkeeperBuild_id(ctx, field)
			case "builder":
				return ec.fieldContext_LogkeeperBuild_builder(ctx, field)
			case "buildNum":
				return ec.fieldContext_LogkeeperBuild_buildNum(ctx, field)
			case "taskId":
				return ec.fieldContext_LogkeeperBuild_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_LogkeeperBuild_taskExecution(ctx, field)
			case "tests":
				return ec.fieldContext_LogkeeperBuild_tests(ctx, field)
			case "task":
				return ec.fieldContext_LogkeeperBuild_task(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogkeeperBuild", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_logkeeperBuildMetadata_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_task(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Task(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_task_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskAllExecutions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskAllExecutions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskAllExecutions(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskAllExecutions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskAllExecutions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskTestSample(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskTestSample(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskTestSample(rctx, fc.Args["versionId"].(string), fc.Args["taskIds"].([]string), fc.Args["filters"].([]*TestFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*TaskTestResultSample)
	fc.Result = res
	return ec.marshalOTaskTestResultSample2githubcomevergreencievergreengraphqlTaskTestResultSample(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskTestSample(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "execution":
				return ec.fieldContext_TaskTestResultSample_execution(ctx, field)
			case "matchingFailedTestNames":
				return ec.fieldContext_TaskTestResultSample_matchingFailedTestNames(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskTestResultSample_taskId(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_TaskTestResultSample_totalTestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskTestResultSample", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskTestSample_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_myPublicKeys(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myPublicKeys(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyPublicKeys(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myPublicKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIDBUser)
	fc.Result = res
	return ec.marshalNUser2githubcomevergreencievergreenrestmodelAPIDBUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_User_betaFeatures(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "emailAddress":
				return ec.fieldContext_User_emailAddress(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_User_parsleyFilters(ctx, field)
			case "parsleySettings":
				return ec.fieldContext_User_parsleySettings(ctx, field)
			case "patches":
				return ec.fieldContext_User_patches(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "subscriptions":
				return ec.fieldContext_User_subscriptions(ctx, field)
			case "userId":
				return ec.fieldContext_User_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserConfig)
	fc.Result = res
	return ec.marshalOUserConfig2githubcomevergreencievergreengraphqlUserConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "api_key":
				return ec.fieldContext_UserConfig_api_key(ctx, field)
			case "api_server_host":
				return ec.fieldContext_UserConfig_api_server_host(ctx, field)
			case "ui_server_host":
				return ec.fieldContext_UserConfig_ui_server_host(ctx, field)
			case "user":
				return ec.fieldContext_UserConfig_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_buildVariantsForTaskName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_buildVariantsForTaskName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BuildVariantsForTaskName(rctx, fc.Args["projectIdentifier"].(string), fc.Args["taskName"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*task.BuildVariantTuple)
	fc.Result = res
	return ec.marshalOBuildVariantTuple2githubcomevergreencievergreenmodeltaskBuildVariantTuple(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_buildVariantsForTaskName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariant":
				return ec.fieldContext_BuildVariantTuple_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_BuildVariantTuple_displayName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildVariantTuple", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_buildVariantsForTaskName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_mainlineCommits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_mainlineCommits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MainlineCommits(rctx, fc.Args["options"].(MainlineCommitsOptions), fc.Args["buildVariantOptions"].(*BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*MainlineCommits)
	fc.Result = res
	return ec.marshalOMainlineCommits2githubcomevergreencievergreengraphqlMainlineCommits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_mainlineCommits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nextPageOrderNumber":
				return ec.fieldContext_MainlineCommits_nextPageOrderNumber(ctx, field)
			case "prevPageOrderNumber":
				return ec.fieldContext_MainlineCommits_prevPageOrderNumber(ctx, field)
			case "versions":
				return ec.fieldContext_MainlineCommits_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MainlineCommits", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_mainlineCommits_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskNamesForBuildVariant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskNamesForBuildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskNamesForBuildVariant(rctx, fc.Args["projectIdentifier"].(string), fc.Args["buildVariant"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskNamesForBuildVariant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskNamesForBuildVariant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_waterfall(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_waterfall(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Waterfall(rctx, fc.Args["options"].(WaterfallOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Waterfall)
	fc.Result = res
	return ec.marshalNWaterfall2githubcomevergreencievergreengraphqlWaterfall(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_waterfall(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "flattenedVersions":
				return ec.fieldContext_Waterfall_flattenedVersions(ctx, field)
			case "pagination":
				return ec.fieldContext_Waterfall_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waterfall", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_waterfall_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskHistory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskHistory(rctx, fc.Args["options"].(TaskHistoryOpts))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskHistory)
	fc.Result = res
	return ec.marshalNTaskHistory2githubcomevergreencievergreengraphqlTaskHistory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tasks":
				return ec.fieldContext_TaskHistory_tasks(ctx, field)
			case "pagination":
				return ec.fieldContext_TaskHistory_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hasVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hasVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HasVersion(rctx, fc.Args["patchId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hasVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hasVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx, fc.Args["versionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_version_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_image(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Image(rctx, fc.Args["imageId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIImage)
	fc.Result = res
	return ec.marshalOImage2githubcomevergreencievergreenrestmodelAPIImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_image(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "ami":
				return ec.fieldContext_Image_ami(ctx, field)
			case "distros":
				return ec.fieldContext_Image_distros(ctx, field)
			case "events":
				return ec.fieldContext_Image_events(ctx, field)
			case "lastDeployed":
				return ec.fieldContext_Image_lastDeployed(ctx, field)
			case "latestTask":
				return ec.fieldContext_Image_latestTask(ctx, field)
			case "operatingSystem":
				return ec.fieldContext_Image_operatingSystem(ctx, field)
			case "packages":
				return ec.fieldContext_Image_packages(ctx, field)
			case "toolchains":
				return ec.fieldContext_Image_toolchains(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_image_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_images(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Images(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommitQueueParams_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_mergeMethod(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommitQueueParams_mergeMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_mergeMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_message(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommitQueueParams_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoPermissions_edit(ctx context.Context, field graphql.CollectedField, obj *RepoPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoPermissions_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoPermissions_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoPermissions_view(ctx context.Context, field graphql.CollectedField, obj *RepoPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoPermissions_view(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.View, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoPermissions_view(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_admins(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admins, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_admins(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_batchTime(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_batchTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_batchTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_buildBaronSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBaronSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBuildBaronSettings)
	fc.Result = res
	return ec.marshalNBuildBaronSettings2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_buildBaronSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bfSuggestionFeaturesURL":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
			case "bfSuggestionPassword":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
			case "bfSuggestionServer":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
			case "bfSuggestionTimeoutSecs":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
			case "bfSuggestionUsername":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
			case "ticketCreateProject":
				return ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
			case "ticketSearchProjects":
				return ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
			case "ticketCreateIssueType":
				return ec.fieldContext_BuildBaronSettings_ticketCreateIssueType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaronSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_commitQueue(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_commitQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APICommitQueueParams)
	fc.Result = res
	return ec.marshalNRepoCommitQueueParams2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_commitQueue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_RepoCommitQueueParams_enabled(ctx, field)
			case "mergeMethod":
				return ec.fieldContext_RepoCommitQueueParams_mergeMethod(ctx, field)
			case "message":
				return ec.fieldContext_RepoCommitQueueParams_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoCommitQueueParams", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_containerSizeDefinitions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerSizeDefinitions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIContainerResources)
	fc.Result = res
	return ec.marshalOContainerResources2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_containerSizeDefinitions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ContainerResources_name(ctx, field)
			case "cpu":
				return ec.fieldContext_ContainerResources_cpu(ctx, field)
			case "memoryMb":
				return ec.fieldContext_ContainerResources_memoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_deactivatePrevious(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeactivatePrevious, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_deactivatePrevious(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_disabledStatsCache(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisabledStatsCache, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_disabledStatsCache(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_dispatchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DispatchingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_dispatchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubChecksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubChecksEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubChecksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubDynamicTokenPermissionGroups(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubDynamicTokenPermissionGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitHubDynamicTokenPermissionGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIGitHubDynamicTokenPermissionGroup)
	fc.Result = res
	return ec.marshalNGitHubDynamicTokenPermissionGroup2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubDynamicTokenPermissionGroups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_name(ctx, field)
			case "permissions":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_permissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitHubDynamicTokenPermissionGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubPermissionGroupByRequester(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubPermissionGroupByRequester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitHubPermissionGroupByRequester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubPermissionGroupByRequester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubTriggerAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagAuthorizedTeams(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagAuthorizedTeams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagAuthorizedTeams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagAuthorizedUsers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagAuthorizedUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagAuthorizedUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagVersionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagVersionsEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagVersionsEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_manualPrTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManualPRTestingEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_manualPrTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_notifyOnBuildFailure(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotifyOnBuildFailure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_notifyOnBuildFailure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_oldestAllowedMergeBase(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_oldestAllowedMergeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldestAllowedMergeBase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_oldestAllowedMergeBase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_parsleyFilters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_parsleyFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleyFilters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIParsleyFilter)
	fc.Result = res
	return ec.marshalOParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_parsleyFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "expression":
				return ec.fieldContext_ParsleyFilter_expression(ctx, field)
			case "caseSensitive":
				return ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
			case "exactMatch":
				return ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleyFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_patchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_patchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchTriggerAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPatchTriggerDefinition)
	fc.Result = res
	return ec.marshalOPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_patchTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "downstreamRevision":
				return ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_perfEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_perfEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerfEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_perfEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_periodicBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeriodicBuilds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPeriodicBuildDefinition)
	fc.Result = res
	return ec.marshalOPeriodicBuild2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_periodicBuilds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PeriodicBuild_id(ctx, field)
			case "alias":
				return ec.fieldContext_PeriodicBuild_alias(ctx, field)
			case "configFile":
				return ec.fieldContext_PeriodicBuild_configFile(ctx, field)
			case "intervalHours":
				return ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
			case "cron":
				return ec.fieldContext_PeriodicBuild_cron(ctx, field)
			case "message":
				return ec.fieldContext_PeriodicBuild_message(ctx, field)
			case "nextRunTime":
				return ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PeriodicBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_prTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRTestingEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_prTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_remotePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemotePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_remotePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_repotrackerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepotrackerDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_repotrackerDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_restricted(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_restricted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restricted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_restricted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_spawnHostScriptPath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostScriptPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_spawnHostScriptPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_stepbackDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_stepbackDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_stepbackBisect(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_stepbackBisect(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackBisect, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_stepbackBisect(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_taskAnnotationSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskAnnotationSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APITaskAnnotationSettings)
	fc.Result = res
	return ec.marshalNTaskAnnotationSettings2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_taskAnnotationSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileTicketWebhook":
				return ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskAnnotationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_tracksPushEvents(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TracksPushEvents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_tracksPushEvents(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_triggers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_triggers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Triggers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APITriggerDefinition)
	fc.Result = res
	return ec.marshalNTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_triggers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_TriggerAlias_alias(ctx, field)
			case "buildVariantRegex":
				return ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
			case "configFile":
				return ec.fieldContext_TriggerAlias_configFile(ctx, field)
			case "dateCutoff":
				return ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
			case "level":
				return ec.fieldContext_TriggerAlias_level(ctx, field)
			case "project":
				return ec.fieldContext_TriggerAlias_project(ctx, field)
			case "status":
				return ec.fieldContext_TriggerAlias_status(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
			case "unscheduleDownstreamVersions":
				return ec.fieldContext_TriggerAlias_unscheduleDownstreamVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_versionControlEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionControlEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_versionControlEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_workstationConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_workstationConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkstationConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIWorkstationConfig)
	fc.Result = res
	return ec.marshalNRepoWorkstationConfig2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_workstationConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gitClone":
				return ec.fieldContext_RepoWorkstationConfig_gitClone(ctx, field)
			case "setupCommands":
				return ec.fieldContext_RepoWorkstationConfig_setupCommands(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoWorkstationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_externalLinks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_externalLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalLinks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIExternalLink)
	fc.Result = res
	return ec.marshalOExternalLink2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_externalLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ExternalLink_displayName(ctx, field)
			case "requesters":
				return ec.fieldContext_ExternalLink_requesters(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectAlias)
	fc.Result = res
	return ec.marshalOProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_githubAppAuth(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_githubAppAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().GithubAppAuth(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubAppAuth)
	fc.Result = res
	return ec.marshalOGithubAppAuth2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_githubAppAuth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GithubAppAuth_appId(ctx, field)
			case "privateKey":
				return ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAppAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().GithubWebhooksEnabled(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_githubWebhooksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_projectRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ProjectRef, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireProjectSettingsAccess == nil {
				var zeroVal model.APIProjectRef
				return zeroVal, errors.New("directive requireProjectSettingsAccess is not implemented")
			}
			return ec.directives.RequireProjectSettingsAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APIProjectRef); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectRef`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectRef)
	fc.Result = res
	return ec.marshalORepoRef2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_projectRef(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoRef_id(ctx, field)
			case "admins":
				return ec.fieldContext_RepoRef_admins(ctx, field)
			case "batchTime":
				return ec.fieldContext_RepoRef_batchTime(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_RepoRef_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_RepoRef_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_RepoRef_enabled(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_RepoRef_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_RepoRef_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_RepoRef_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_RepoRef_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_RepoRef_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_RepoRef_parsleyFilters(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_RepoRef_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_RepoRef_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_RepoRef_repo(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_RepoRef_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_RepoRef_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_RepoRef_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_RepoRef_workstationConfig(ctx, field)
			case "externalLinks":
				return ec.fieldContext_RepoRef_externalLinks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().Subscriptions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectVars)
	fc.Result = res
	return ec.marshalOProjectVars2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoWorkstationConfig_gitClone(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoWorkstationConfig_gitClone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitClone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoWorkstationConfig_gitClone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoWorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoWorkstationConfig_setupCommands(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoWorkstationConfig_setupCommands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupCommands, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIWorkstationSetupCommand)
	fc.Result = res
	return ec.marshalOWorkstationSetupCommand2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoWorkstationConfig_setupCommands(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoWorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "command":
				return ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
			case "directory":
				return ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationSetupCommand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerError_exists(ctx context.Context, field graphql.CollectedField, obj *model.APIRepositoryErrorDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepotrackerError_exists(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepotrackerError_exists(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerError_invalidRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIRepositoryErrorDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepotrackerError_invalidRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvalidRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepotrackerError_invalidRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerError_mergeBaseRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIRepositoryErrorDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepotrackerError_mergeBaseRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeBaseRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepotrackerError_mergeBaseRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_lockedMemoryKb(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_lockedMemoryKb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LockedMemoryKB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_lockedMemoryKb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numFiles(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_numFiles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumFiles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_numFiles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numProcesses(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_numProcesses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumProcesses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_numProcesses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_numTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_numTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_virtualMemoryKb(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_virtualMemoryKb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualMemoryKB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_virtualMemoryKb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SaveDistroPayload_distro(ctx context.Context, field graphql.CollectedField, obj *SaveDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SaveDistroPayload_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIDistro)
	fc.Result = res
	return ec.marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SaveDistroPayload_distro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SaveDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SaveDistroPayload_hostCount(ctx context.Context, field graphql.CollectedField, obj *SaveDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SaveDistroPayload_hostCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SaveDistroPayload_hostCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SaveDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_featuresURL(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_featuresURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeaturesURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_featuresURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_issues(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_issues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]thirdparty.JiraTicket)
	fc.Result = res
	return ec.marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_issues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_search(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_search(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Search, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_search(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_source(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Selector_data(ctx context.Context, field graphql.CollectedField, obj *model.APISelector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Selector_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Selector_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Selector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Selector_type(ctx context.Context, field graphql.CollectedField, obj *model.APISelector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Selector_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Selector_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Selector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetLastRevisionPayload_mergeBaseRevision(ctx context.Context, field graphql.CollectedField, obj *SetLastRevisionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetLastRevisionPayload_mergeBaseRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeBaseRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetLastRevisionPayload_mergeBaseRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetLastRevisionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SingleTaskDistroConfig_projectTasksPairs(ctx context.Context, field graphql.CollectedField, obj *model.APISingleTaskDistroConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SingleTaskDistroConfig_projectTasksPairs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectTasksPairs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIProjectTasksPair)
	fc.Result = res
	return ec.marshalNProjectTasksPair2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SingleTaskDistroConfig_projectTasksPairs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SingleTaskDistroConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectId":
				return ec.fieldContext_ProjectTasksPair_projectId(ctx, field)
			case "allowedTasks":
				return ec.fieldContext_ProjectTasksPair_allowedTasks(ctx, field)
			case "allowedBVs":
				return ec.fieldContext_ProjectTasksPair_allowedBVs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTasksPair", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.APISlackConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackConfig_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_dailyStartTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_dailyStartTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DailyStartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_dailyStartTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_dailyStopTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_dailyStopTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DailyStopTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_dailyStopTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_nextStartTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_nextStartTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextStartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_nextStartTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_nextStopTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_nextStopTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextStopTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_nextStopTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_permanentlyExempt(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_permanentlyExempt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PermanentlyExempt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_permanentlyExempt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_shouldKeepOff(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_shouldKeepOff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShouldKeepOff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_shouldKeepOff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_timeZone(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_timeZone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeZone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_timeZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_temporarilyExemptUntil(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_temporarilyExemptUntil(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TemporarilyExemptUntil, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_temporarilyExemptUntil(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_wholeWeekdaysOff(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_wholeWeekdaysOff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SleepSchedule().WholeWeekdaysOff(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_wholeWeekdaysOff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_author(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_requester(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_time(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_spawnHostsPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpawnHostConfig_spawnHostsPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostsPerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_spawnHostsPerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_unexpirableHostsPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpawnHostConfig_unexpirableHostsPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnexpirableHostsPerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_unexpirableHostsPerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_unexpirableVolumesPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnexpirableVolumesPerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_banner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_banner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_bannerTheme(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_bannerTheme(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BannerTheme, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_bannerTheme(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_containerPools(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_containerPools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerPools, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIContainerPoolsConfig)
	fc.Result = res
	return ec.marshalOContainerPoolsConfig2githubcomevergreencievergreenrestmodelAPIContainerPoolsConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_containerPools(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pools":
				return ec.fieldContext_ContainerPoolsConfig_pools(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerPoolsConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_githubOrgs(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_githubOrgs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubOrgs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_githubOrgs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_jira(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_jira(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jira, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIJiraConfig)
	fc.Result = res
	return ec.marshalOJiraConfig2githubcomevergreencievergreenrestmodelAPIJiraConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_jira(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "email":
				return ec.fieldContext_JiraConfig_email(ctx, field)
			case "host":
				return ec.fieldContext_JiraConfig_host(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_providers(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_providers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Providers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APICloudProviders)
	fc.Result = res
	return ec.marshalOCloudProviderConfig2githubcomevergreencievergreenrestmodelAPICloudProviders(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_providers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aws":
				return ec.fieldContext_CloudProviderConfig_aws(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CloudProviderConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_secretFields(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_secretFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SpruceConfig().SecretFields(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_secretFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_singleTaskDistro(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_singleTaskDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SingleTaskDistro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISingleTaskDistroConfig)
	fc.Result = res
	return ec.marshalOSingleTaskDistroConfig2githubcomevergreencievergreenrestmodelAPISingleTaskDistroConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_singleTaskDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectTasksPairs":
				return ec.fieldContext_SingleTaskDistroConfig_projectTasksPairs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SingleTaskDistroConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_slack(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_slack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISlackConfig)
	fc.Result = res
	return ec.marshalOSlackConfig2githubcomevergreencievergreenrestmodelAPISlackConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_slack(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SlackConfig_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlackConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_spawnHost(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_spawnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spawnhost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APISpawnHostConfig)
	fc.Result = res
	return ec.marshalNSpawnHostConfig2githubcomevergreencievergreenrestmodelAPISpawnHostConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_spawnHost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spawnHostsPerUser":
				return ec.fieldContext_SpawnHostConfig_spawnHostsPerUser(ctx, field)
			case "unexpirableHostsPerUser":
				return ec.fieldContext_SpawnHostConfig_unexpirableHostsPerUser(ctx, field)
			case "unexpirableVolumesPerUser":
				return ec.fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpawnHostConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_ui(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_ui(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ui, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIUIConfig)
	fc.Result = res
	return ec.marshalNUIConfig2githubcomevergreencievergreenrestmodelAPIUIConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_ui(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_UIConfig_betaFeatures(ctx, field)
			case "defaultProject":
				return ec.fieldContext_UIConfig_defaultProject(ctx, field)
			case "userVoice":
				return ec.fieldContext_UIConfig_userVoice(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UIConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusCount_count(ctx context.Context, field graphql.CollectedField, obj *task.StatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusCount_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusCount_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusCount_status(ctx context.Context, field graphql.CollectedField, obj *task.StatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusCount_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusCount_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_lastFailingStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepbackInfo_lastFailingStepbackTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastFailingStepbackTaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepbackInfo_lastFailingStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_lastPassingStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepbackInfo_lastPassingStepbackTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastPassingStepbackTaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepbackInfo_lastPassingStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_nextStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepbackInfo_nextStepbackTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextStepbackTaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepbackInfo_nextStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_previousStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepbackInfo_previousStepbackTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousStepbackTaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepbackInfo_previousStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_emailSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_emailSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_emailSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_githubCheckSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_githubCheckSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubCheckSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubCheckSubscriber)
	fc.Result = res
	return ec.marshalOGithubCheckSubscriber2githubcomevergreencievergreenrestmodelAPIGithubCheckSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_githubCheckSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_GithubCheckSubscriber_owner(ctx, field)
			case "ref":
				return ec.fieldContext_GithubCheckSubscriber_ref(ctx, field)
			case "repo":
				return ec.fieldContext_GithubCheckSubscriber_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubCheckSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_githubPRSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_githubPRSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubPRSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubPRSubscriber)
	fc.Result = res
	return ec.marshalOGithubPRSubscriber2githubcomevergreencievergreenrestmodelAPIGithubPRSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_githubPRSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_GithubPRSubscriber_owner(ctx, field)
			case "prNumber":
				return ec.fieldContext_GithubPRSubscriber_prNumber(ctx, field)
			case "ref":
				return ec.fieldContext_GithubPRSubscriber_ref(ctx, field)
			case "repo":
				return ec.fieldContext_GithubPRSubscriber_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubPRSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_jiraCommentSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_jiraCommentSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraCommentSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_jiraCommentSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_jiraIssueSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_jiraIssueSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraIssueSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIJIRAIssueSubscriber)
	fc.Result = res
	return ec.marshalOJiraIssueSubscriber2githubcomevergreencievergreenrestmodelAPIJIRAIssueSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_jiraIssueSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "issueType":
				return ec.fieldContext_JiraIssueSubscriber_issueType(ctx, field)
			case "project":
				return ec.fieldContext_JiraIssueSubscriber_project(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraIssueSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_slackSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_slackSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_slackSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_webhookSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_webhookSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WebhookSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIWebhookSubscriber)
	fc.Result = res
	return ec.marshalOWebhookSubscriber2githubcomevergreencievergreenrestmodelAPIWebhookSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_webhookSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "headers":
				return ec.fieldContext_WebhookSubscriber_headers(ctx, field)
			case "secret":
				return ec.fieldContext_WebhookSubscriber_secret(ctx, field)
			case "url":
				return ec.fieldContext_WebhookSubscriber_url(ctx, field)
			case "retries":
				return ec.fieldContext_WebhookSubscriber_retries(ctx, field)
			case "minDelayMs":
				return ec.fieldContext_WebhookSubscriber_minDelayMs(ctx, field)
			case "timeoutMs":
				return ec.fieldContext_WebhookSubscriber_timeoutMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubscriberWrapper_subscriber(ctx context.Context, field graphql.CollectedField, obj *model.APISubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubscriberWrapper_subscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SubscriberWrapper().Subscriber(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Subscriber)
	fc.Result = res
	return ec.marshalNSubscriber2githubcomevergreencievergreengraphqlSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubscriberWrapper_subscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubscriberWrapper",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "emailSubscriber":
				return ec.fieldContext_Subscriber_emailSubscriber(ctx, field)
			case "githubCheckSubscriber":
				return ec.fieldContext_Subscriber_githubCheckSubscriber(ctx, field)
			case "githubPRSubscriber":
				return ec.fieldContext_Subscriber_githubPRSubscriber(ctx, field)
			case "jiraCommentSubscriber":
				return ec.fieldContext_Subscriber_jiraCommentSubscriber(ctx, field)
			case "jiraIssueSubscriber":
				return ec.fieldContext_Subscriber_jiraIssueSubscriber(ctx, field)
			case "slackSubscriber":
				return ec.fieldContext_Subscriber_slackSubscriber(ctx, field)
			case "webhookSubscriber":
				return ec.fieldContext_Subscriber_webhookSubscriber(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Subscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubscriberWrapper_type(ctx context.Context, field graphql.CollectedField, obj *model.APISubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubscriberWrapper_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubscriberWrapper_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubscriberWrapper",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_aborted(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_aborted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aborted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_aborted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_abortInfo(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_abortInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().AbortInfo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AbortInfo)
	fc.Result = res
	return ec.marshalOAbortInfo2githubcomevergreencievergreengraphqlAbortInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_abortInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariantDisplayName":
				return ec.fieldContext_AbortInfo_buildVariantDisplayName(ctx, field)
			case "newVersion":
				return ec.fieldContext_AbortInfo_newVersion(ctx, field)
			case "prClosed":
				return ec.fieldContext_AbortInfo_prClosed(ctx, field)
			case "taskDisplayName":
				return ec.fieldContext_AbortInfo_taskDisplayName(ctx, field)
			case "taskID":
				return ec.fieldContext_AbortInfo_taskID(ctx, field)
			case "user":
				return ec.fieldContext_AbortInfo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbortInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activated(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_activatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_activatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activatedTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_activatedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_activatedTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_ami(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_ami(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Ami(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_ami(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_annotation(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_annotation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Annotation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITaskAnnotation)
	fc.Result = res
	return ec.marshalOAnnotation2githubcomevergreencievergreenrestmodelAPITaskAnnotation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_annotation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Annotation_id(ctx, field)
			case "createdIssues":
				return ec.fieldContext_Annotation_createdIssues(ctx, field)
			case "issues":
				return ec.fieldContext_Annotation_issues(ctx, field)
			case "note":
				return ec.fieldContext_Annotation_note(ctx, field)
			case "suspectedIssues":
				return ec.fieldContext_Annotation_suspectedIssues(ctx, field)
			case "metadataLinks":
				return ec.fieldContext_Annotation_metadataLinks(ctx, field)
			case "taskId":
				return ec.fieldContext_Annotation_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_Annotation_taskExecution(ctx, field)
			case "webhookConfigured":
				return ec.fieldContext_Annotation_webhookConfigured(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Annotation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_id(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_baseStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_baseStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().BaseStatus(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_baseStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_baseTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_baseTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().BaseTask(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_baseTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_blocked(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_blocked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Blocked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_blocked(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_buildId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_buildId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildVariantDisplayName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().BuildVariantDisplayName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_buildVariantDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canAbort(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canAbort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanAbort(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canAbort(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canDisable(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canDisable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanDisable(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canDisable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canModifyAnnotation(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canModifyAnnotation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanModifyAnnotation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canModifyAnnotation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canOverrideDependencies(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canOverrideDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanOverrideDependencies(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canOverrideDependencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canRestart(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canRestart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanRestart(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canRestart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canSchedule(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canSchedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanSchedule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canSchedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canSetPriority(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canSetPriority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanSetPriority(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canSetPriority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canUnschedule(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canUnschedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanUnschedule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canUnschedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_containerAllocatedTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_containerAllocatedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerAllocatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_containerAllocatedTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_dependsOn(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_dependsOn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().DependsOn(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Dependency)
	fc.Result = res
	return ec.marshalODependency2githubcomevergreencievergreengraphqlDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_dependsOn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariant":
				return ec.fieldContext_Dependency_buildVariant(ctx, field)
			case "metStatus":
				return ec.fieldContext_Dependency_metStatus(ctx, field)
			case "name":
				return ec.fieldContext_Dependency_name(ctx, field)
			case "requiredStatus":
				return ec.fieldContext_Dependency_requiredStatus(ctx, field)
			case "taskId":
				return ec.fieldContext_Dependency_taskId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_details(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ApiTaskEndDetail)
	fc.Result = res
	return ec.marshalOTaskEndDetail2githubcomevergreencievergreenrestmodelApiTaskEndDetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext_TaskEndDetail_description(ctx, field)
			case "diskDevices":
				return ec.fieldContext_TaskEndDetail_diskDevices(ctx, field)
			case "failingCommand":
				return ec.fieldContext_TaskEndDetail_failingCommand(ctx, field)
			case "failureMetadataTags":
				return ec.fieldContext_TaskEndDetail_failureMetadataTags(ctx, field)
			case "oomTracker":
				return ec.fieldContext_TaskEndDetail_oomTracker(ctx, field)
			case "status":
				return ec.fieldContext_TaskEndDetail_status(ctx, field)
			case "timedOut":
				return ec.fieldContext_TaskEndDetail_timedOut(ctx, field)
			case "timeoutType":
				return ec.fieldContext_TaskEndDetail_timeoutType(ctx, field)
			case "traceID":
				return ec.fieldContext_TaskEndDetail_traceID(ctx, field)
			case "type":
				return ec.fieldContext_TaskEndDetail_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEndDetail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_dispatchTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_dispatchTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DispatchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_dispatchTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayOnly(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayOnly(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayOnly(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().DisplayTask(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_distroId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_distroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistroId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_distroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_estimatedStart(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_estimatedStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().EstimatedStart(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_estimatedStart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_execution(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_executionTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_executionTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutionTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_executionTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_executionTasksFull(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_executionTasksFull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().ExecutionTasksFull(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_executionTasksFull(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_expectedDuration(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_expectedDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_expectedDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_failedTestCount(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_failedTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().FailedTestCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_failedTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_files(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Files(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskFiles)
	fc.Result = res
	return ec.marshalNTaskFiles2githubcomevergreencievergreengraphqlTaskFiles(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_files(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileCount":
				return ec.fieldContext_TaskFiles_fileCount(ctx, field)
			case "groupedFiles":
				return ec.fieldContext_TaskFiles_groupedFiles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskFiles", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_finishTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_finishTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_finishTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_generatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GeneratedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_generatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generatedByName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_generatedByName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().GeneratedByName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_generatedByName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generateTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_generateTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenerateTask, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_generateTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_hasCedarResults(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_hasCedarResults(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasCedarResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_hasCedarResults(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_hostId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_hostId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_hostId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_imageId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_imageId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().ImageID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_imageId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_ingestTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_ingestTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_ingestTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_isPerfPluginEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().IsPerfPluginEnabled(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_isPerfPluginEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_latestExecution(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_latestExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().LatestExecution(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_latestExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_logs(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LogLinks)
	fc.Result = res
	return ec.marshalNTaskLogLinks2githubcomevergreencievergreenrestmodelLogLinks(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentLogLink":
				return ec.fieldContext_TaskLogLinks_agentLogLink(ctx, field)
			case "allLogLink":
				return ec.fieldContext_TaskLogLinks_allLogLink(ctx, field)
			case "eventLogLink":
				return ec.fieldContext_TaskLogLinks_eventLogLink(ctx, field)
			case "systemLogLink":
				return ec.fieldContext_TaskLogLinks_systemLogLink(ctx, field)
			case "taskLogLink":
				return ec.fieldContext_TaskLogLinks_taskLogLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskLogLinks", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_minQueuePosition(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_minQueuePosition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().MinQueuePosition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_minQueuePosition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_order(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_patch(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Patch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalOPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_patch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_patchNumber(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_patchNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().PatchNumber(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_patchNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_pod(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_pod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Pod(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPod)
	fc.Result = res
	return ec.marshalOPod2githubcomevergreencievergreenrestmodelAPIPod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_pod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "events":
				return ec.fieldContext_Pod_events(ctx, field)
			case "id":
				return ec.fieldContext_Pod_id(ctx, field)
			case "status":
				return ec.fieldContext_Pod_status(ctx, field)
			case "task":
				return ec.fieldContext_Pod_task(ctx, field)
			case "taskContainerCreationOpts":
				return ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
			case "type":
				return ec.fieldContext_Pod_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_priority(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_priority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_project(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Project(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_projectId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_projectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_projectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().ProjectIdentifier(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_requester(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_resetWhenFinished(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_resetWhenFinished(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResetWhenFinished, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_resetWhenFinished(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_revision(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_scheduledTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_scheduledTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_scheduledTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_spawnHostLink(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_spawnHostLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().SpawnHostLink(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_spawnHostLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_status(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_tags(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskGroup(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskGroupMaxHosts(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskGroupMaxHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskGroupMaxHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_stepbackInfo(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_stepbackInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIStepbackInfo)
	fc.Result = res
	return ec.marshalOStepbackInfo2githubcomevergreencievergreenrestmodelAPIStepbackInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_stepbackInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastFailingStepbackTaskId":
				return ec.fieldContext_StepbackInfo_lastFailingStepbackTaskId(ctx, field)
			case "lastPassingStepbackTaskId":
				return ec.fieldContext_StepbackInfo_lastPassingStepbackTaskId(ctx, field)
			case "nextStepbackTaskId":
				return ec.fieldContext_StepbackInfo_nextStepbackTaskId(ctx, field)
			case "previousStepbackTaskId":
				return ec.fieldContext_StepbackInfo_previousStepbackTaskId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StepbackInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskLogs(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().TaskLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskLogs)
	fc.Result = res
	return ec.marshalNTaskLogs2githubcomevergreencievergreengraphqlTaskLogs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentLogs":
				return ec.fieldContext_TaskLogs_agentLogs(ctx, field)
			case "allLogs":
				return ec.fieldContext_TaskLogs_allLogs(ctx, field)
			case "eventLogs":
				return ec.fieldContext_TaskLogs_eventLogs(ctx, field)
			case "execution":
				return ec.fieldContext_TaskLogs_execution(ctx, field)
			case "systemLogs":
				return ec.fieldContext_TaskLogs_systemLogs(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskLogs_taskId(ctx, field)
			case "taskLogs":
				return ec.fieldContext_TaskLogs_taskLogs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskLogs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskOwnerTeam(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskOwnerTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().TaskOwnerTeam(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TaskOwnerTeam)
	fc.Result = res
	return ec.marshalOTaskOwnerTeam2githubcomevergreencievergreengraphqlTaskOwnerTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskOwnerTeam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignmentType":
				return ec.fieldContext_TaskOwnerTeam_assignmentType(ctx, field)
			case "messages":
				return ec.fieldContext_TaskOwnerTeam_messages(ctx, field)
			case "teamName":
				return ec.fieldContext_TaskOwnerTeam_teamName(ctx, field)
			case "jiraProject":
				return ec.fieldContext_TaskOwnerTeam_jiraProject(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskOwnerTeam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_tests(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_tests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Tests(rctx, obj, fc.Args["opts"].(*TestFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskTestResult)
	fc.Result = res
	return ec.marshalNTaskTestResult2githubcomevergreencievergreengraphqlTaskTestResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_tests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "testResults":
				return ec.fieldContext_TaskTestResult_testResults(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_TaskTestResult_totalTestCount(ctx, field)
			case "filteredTestCount":
				return ec.fieldContext_TaskTestResult_filteredTestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskTestResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Task_tests_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Task_timeTaken(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_timeTaken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeTaken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_timeTaken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_totalTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().TotalTestCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_totalTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_versionMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_versionMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().VersionMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_versionMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskAnnotationSettings_fileTicketWebhook(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileTicketWebhook, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIWebHook)
	fc.Result = res
	return ec.marshalNWebhook2githubcomevergreencievergreenrestmodelAPIWebHook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskAnnotationSettings_fileTicketWebhook(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskAnnotationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endpoint":
				return ec.fieldContext_Webhook_endpoint(ctx, field)
			case "secret":
				return ec.fieldContext_Webhook_secret(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_image(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_memoryMB(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_memoryMB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemoryMB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_memoryMB(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_cpu(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_os(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskContainerCreationOpts().Os(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_arch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskContainerCreationOpts().Arch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_arch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_workingDir(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_workingDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkingDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_workingDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_description(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_diskDevices(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_diskDevices(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiskDevices, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_diskDevices(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_failingCommand(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_failingCommand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailingCommand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_failingCommand(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_failureMetadataTags(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_failureMetadataTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureMetadataTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_failureMetadataTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_oomTracker(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_oomTracker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OOMTracker, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIOomTrackerInfo)
	fc.Result = res
	return ec.marshalNOomTrackerInfo2githubcomevergreencievergreenrestmodelAPIOomTrackerInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_oomTracker(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "detected":
				return ec.fieldContext_OomTrackerInfo_detected(ctx, field)
			case "pids":
				return ec.fieldContext_OomTrackerInfo_pids(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OomTrackerInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_status(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_timedOut(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_timedOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimedOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_timedOut(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_timeoutType(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_timeoutType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeoutType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_timeoutType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_traceID(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_traceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TraceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_traceID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_type(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_hostId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_hostId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_hostId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_podId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_podId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_podId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_jiraIssue(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_jiraIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraIssue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_jiraIssue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_jiraLink(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_jiraLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_jiraLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_priority(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_priority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_status(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_userId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_blockedOn(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_blockedOn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockedOn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_blockedOn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TaskEventData)
	fc.Result = res
	return ec.marshalNTaskEventLogData2githubcomevergreencievergreenrestmodelTaskEventData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hostId":
				return ec.fieldContext_TaskEventLogData_hostId(ctx, field)
			case "podId":
				return ec.fieldContext_TaskEventLogData_podId(ctx, field)
			case "jiraIssue":
				return ec.fieldContext_TaskEventLogData_jiraIssue(ctx, field)
			case "jiraLink":
				return ec.fieldContext_TaskEventLogData_jiraLink(ctx, field)
			case "priority":
				return ec.fieldContext_TaskEventLogData_priority(ctx, field)
			case "status":
				return ec.fieldContext_TaskEventLogData_status(ctx, field)
			case "timestamp":
				return ec.fieldContext_TaskEventLogData_timestamp(ctx, field)
			case "userId":
				return ec.fieldContext_TaskEventLogData_userId(ctx, field)
			case "blockedOn":
				return ec.fieldContext_TaskEventLogData_blockedOn(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_eventType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_processedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_processedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_resourceId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskFiles_fileCount(ctx context.Context, field graphql.CollectedField, obj *TaskFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskFiles_fileCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskFiles_fileCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskFiles_groupedFiles(ctx context.Context, field graphql.CollectedField, obj *TaskFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskFiles_groupedFiles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupedFiles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GroupedFiles)
	fc.Result = res
	return ec.marshalNGroupedFiles2githubcomevergreencievergreengraphqlGroupedFiles(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskFiles_groupedFiles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "files":
				return ec.fieldContext_GroupedFiles_files(ctx, field)
			case "taskName":
				return ec.fieldContext_GroupedFiles_taskName(ctx, field)
			case "taskId":
				return ec.fieldContext_GroupedFiles_taskId(ctx, field)
			case "execution":
				return ec.fieldContext_GroupedFiles_execution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedFiles", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_tasks(ctx context.Context, field graphql.CollectedField, obj *TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_pagination(ctx context.Context, field graphql.CollectedField, obj *TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskHistoryPagination)
	fc.Result = res
	return ec.marshalNTaskHistoryPagination2githubcomevergreencievergreengraphqlTaskHistoryPagination(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_pagination(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mostRecentTaskOrder":
				return ec.fieldContext_TaskHistoryPagination_mostRecentTaskOrder(ctx, field)
			case "oldestTaskOrder":
				return ec.fieldContext_TaskHistoryPagination_oldestTaskOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistoryPagination", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistoryPagination_mostRecentTaskOrder(ctx context.Context, field graphql.CollectedField, obj *TaskHistoryPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistoryPagination_mostRecentTaskOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MostRecentTaskOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistoryPagination_mostRecentTaskOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistoryPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistoryPagination_oldestTaskOrder(ctx context.Context, field graphql.CollectedField, obj *TaskHistoryPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistoryPagination_oldestTaskOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldestTaskOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistoryPagination_oldestTaskOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistoryPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.TaskInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskInfo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.TaskInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskInfo_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_agentLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_agentLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_agentLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_allLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_allLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_allLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_eventLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_eventLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_eventLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_systemLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_systemLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_systemLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_taskLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_taskLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_taskLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_agentLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_agentLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().AgentLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_agentLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_allLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_allLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().AllLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_allLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_eventLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_eventLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().EventLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TaskAPIEventLogEntry)
	fc.Result = res
	return ec.marshalNTaskEventLogEntry2githubcomevergreencievergreenrestmodelTaskAPIEventLogEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_eventLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_TaskEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_TaskEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_TaskEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_TaskEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_TaskEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_TaskEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_execution(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_systemLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_systemLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().SystemLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_systemLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_taskId(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_taskLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_taskLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().TaskLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_taskLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_assignmentType(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskOwnerTeam_assignmentType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_assignmentType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_messages(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskOwnerTeam_messages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Messages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_messages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_teamName(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskOwnerTeam_teamName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_teamName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_jiraProject(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskOwnerTeam_jiraProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraProject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_jiraProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_id(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueDistro_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_hostCount(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueDistro_hostCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_hostCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_taskCount(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueDistro_taskCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_taskCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_id(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_expectedDuration(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_expectedDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_expectedDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_priority(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_priority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_project(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_requester(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskQueueItem().Requester(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TaskQueueItemType)
	fc.Result = res
	return ec.marshalNTaskQueueItemType2githubcomevergreencievergreengraphqlTaskQueueItemType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TaskQueueItemType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_activatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_activatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_activatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_revision(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_version(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_patchAlias(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSpecifier_patchAlias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchAlias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSpecifier_patchAlias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_taskRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSpecifier_taskRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSpecifier_taskRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_variantRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSpecifier_variantRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSpecifier_variantRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_counts(ctx context.Context, field graphql.CollectedField, obj *task.TaskStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskStats_counts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Counts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]task.StatusCount)
	fc.Result = res
	return ec.marshalOStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskStats_counts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_StatusCount_count(ctx, field)
			case "status":
				return ec.fieldContext_StatusCount_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_eta(ctx context.Context, field graphql.CollectedField, obj *task.TaskStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskStats_eta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ETA, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskStats_eta(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_testResults(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResult_testResults(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TestResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITest)
	fc.Result = res
	return ec.marshalNTestResult2githubcomevergreencievergreenrestmodelAPITest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResult_testResults(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TestResult_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_TestResult_baseStatus(ctx, field)
			case "duration":
				return ec.fieldContext_TestResult_duration(ctx, field)
			case "endTime":
				return ec.fieldContext_TestResult_endTime(ctx, field)
			case "execution":
				return ec.fieldContext_TestResult_execution(ctx, field)
			case "exitCode":
				return ec.fieldContext_TestResult_exitCode(ctx, field)
			case "groupID":
				return ec.fieldContext_TestResult_groupID(ctx, field)
			case "logs":
				return ec.fieldContext_TestResult_logs(ctx, field)
			case "startTime":
				return ec.fieldContext_TestResult_startTime(ctx, field)
			case "status":
				return ec.fieldContext_TestResult_status(ctx, field)
			case "taskId":
				return ec.fieldContext_TestResult_taskId(ctx, field)
			case "testFile":
				return ec.fieldContext_TestResult_testFile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResult_totalTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTestCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResult_totalTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_filteredTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResult_filteredTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredTestCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResult_filteredTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_execution(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_matchingFailedTestNames(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_matchingFailedTestNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingFailedTestNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_matchingFailedTestNames(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_taskId(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_totalTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTestCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_totalTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_lineNum(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_lineNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LineNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_lineNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_url(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_urlParsley(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_urlParsley(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLParsley, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_urlParsley(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_urlRaw(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_urlRaw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLRaw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_urlRaw(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_renderingType(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_renderingType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RenderingType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_renderingType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_version(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalOInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_id(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_baseStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_baseStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_baseStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_duration(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_endTime(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_endTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_endTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_execution(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_exitCode(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_exitCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExitCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_exitCode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_groupID(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_groupID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_groupID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_logs(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TestLogs)
	fc.Result = res
	return ec.marshalNTestLog2githubcomevergreencievergreenrestmodelTestLogs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lineNum":
				return ec.fieldContext_TestLog_lineNum(ctx, field)
			case "url":
				return ec.fieldContext_TestLog_url(ctx, field)
			case "urlParsley":
				return ec.fieldContext_TestLog_urlParsley(ctx, field)
			case "urlRaw":
				return ec.fieldContext_TestLog_urlRaw(ctx, field)
			case "renderingType":
				return ec.fieldContext_TestLog_renderingType(ctx, field)
			case "version":
				return ec.fieldContext_TestLog_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestLog", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_status(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_taskId(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_testFile(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_testFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TestFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_testFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_assignedTeam(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_assignedTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TicketFields().AssignedTeam(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_assignedTeam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_assigneeDisplayName(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_assigneeDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TicketFields().AssigneeDisplayName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_assigneeDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_created(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_resolutionName(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_resolutionName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TicketFields().ResolutionName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_resolutionName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_status(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*thirdparty.JiraStatus)
	fc.Result = res
	return ec.marshalNJiraStatus2githubcomevergreencievergreenthirdpartyJiraStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JiraStatus_id(ctx, field)
			case "name":
				return ec.fieldContext_JiraStatus_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_summary(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_summary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_summary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_updated(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Toolchain_name(ctx context.Context, field graphql.CollectedField, obj *model.APIToolchain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Toolchain_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Toolchain_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Toolchain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Toolchain_path(ctx context.Context, field graphql.CollectedField, obj *model.APIToolchain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Toolchain_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Toolchain_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Toolchain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Toolchain_version(ctx context.Context, field graphql.CollectedField, obj *model.APIToolchain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Toolchain_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Toolchain_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Toolchain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_buildVariantRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariantRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_buildVariantRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_configFile(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_configFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_configFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_dateCutoff(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DateCutoff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_dateCutoff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_level(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_project(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_status(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_taskRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_taskRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_unscheduleDownstreamVersions(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_unscheduleDownstreamVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnscheduleDownstreamVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_unscheduleDownstreamVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_betaFeatures(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_betaFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BetaFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBetaFeatures)
	fc.Result = res
	return ec.marshalNBetaFeatures2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_betaFeatures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceWaterfallEnabled":
				return ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BetaFeatures", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_defaultProject(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_defaultProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultProject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_defaultProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_userVoice(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_userVoice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserVoice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_userVoice(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateBetaFeaturesPayload_betaFeatures(ctx context.Context, field graphql.CollectedField, obj *UpdateBetaFeaturesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateBetaFeaturesPayload_betaFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BetaFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIBetaFeatures)
	fc.Result = res
	return ec.marshalOBetaFeatures2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateBetaFeaturesPayload_betaFeatures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateBetaFeaturesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceWaterfallEnabled":
				return ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BetaFeatures", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateParsleySettingsPayload_parsleySettings(ctx context.Context, field graphql.CollectedField, obj *UpdateParsleySettingsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateParsleySettingsPayload_parsleySettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleySettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIParsleySettings)
	fc.Result = res
	return ec.marshalOParsleySettings2githubcomevergreencievergreenrestmodelAPIParsleySettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateParsleySettingsPayload_parsleySettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateParsleySettingsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sectionsEnabled":
				return ec.fieldContext_ParsleySettings_sectionsEnabled(ctx, field)
			case "jumpToFailingLineEnabled":
				return ec.fieldContext_ParsleySettings_jumpToFailingLineEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleySettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_owner(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_project(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_repo(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_resourceID(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_resourceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_resourceID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_revision(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_task(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Task, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_triggerID(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_triggerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_triggerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_triggerType(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_triggerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_triggerType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_version(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UseSpruceOptions_hasUsedMainlineCommitsBefore(ctx context.Context, field graphql.CollectedField, obj *model.APIUseSpruceOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UseSpruceOptions_hasUsedMainlineCommitsBefore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasUsedMainlineCommitsBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UseSpruceOptions_hasUsedMainlineCommitsBefore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UseSpruceOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UseSpruceOptions_hasUsedSpruceBefore(ctx context.Context, field graphql.CollectedField, obj *model.APIUseSpruceOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UseSpruceOptions_hasUsedSpruceBefore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasUsedSpruceBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UseSpruceOptions_hasUsedSpruceBefore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UseSpruceOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UseSpruceOptions_spruceV1(ctx context.Context, field graphql.CollectedField, obj *model.APIUseSpruceOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UseSpruceOptions_spruceV1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpruceV1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UseSpruceOptions_spruceV1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UseSpruceOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_betaFeatures(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_betaFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BetaFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBetaFeatures)
	fc.Result = res
	return ec.marshalNBetaFeatures2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_betaFeatures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceWaterfallEnabled":
				return ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BetaFeatures", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_emailAddress(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_emailAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_emailAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_parsleyFilters(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_parsleyFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleyFilters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIParsleyFilter)
	fc.Result = res
	return ec.marshalNParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_parsleyFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "expression":
				return ec.fieldContext_ParsleyFilter_expression(ctx, field)
			case "caseSensitive":
				return ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
			case "exactMatch":
				return ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleyFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_parsleySettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_parsleySettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleySettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIParsleySettings)
	fc.Result = res
	return ec.marshalNParsleySettings2githubcomevergreencievergreenrestmodelAPIParsleySettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_parsleySettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sectionsEnabled":
				return ec.fieldContext_ParsleySettings_sectionsEnabled(ctx, field)
			case "jumpToFailingLineEnabled":
				return ec.fieldContext_ParsleySettings_jumpToFailingLineEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleySettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_patches(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_patches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Patches(rctx, obj, fc.Args["patchesInput"].(PatchesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Patches)
	fc.Result = res
	return ec.marshalNPatches2githubcomevergreencievergreengraphqlPatches(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_patches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredPatchCount":
				return ec.fieldContext_Patches_filteredPatchCount(ctx, field)
			case "patches":
				return ec.fieldContext_Patches_patches(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patches", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_patches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_permissions(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Permissions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Permissions)
	fc.Result = res
	return ec.marshalNPermissions2githubcomevergreencievergreengraphqlPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_permissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canCreateDistro":
				return ec.fieldContext_Permissions_canCreateDistro(ctx, field)
			case "canCreateProject":
				return ec.fieldContext_Permissions_canCreateProject(ctx, field)
			case "canEditAdminSettings":
				return ec.fieldContext_Permissions_canEditAdminSettings(ctx, field)
			case "distroPermissions":
				return ec.fieldContext_Permissions_distroPermissions(ctx, field)
			case "projectPermissions":
				return ec.fieldContext_Permissions_projectPermissions(ctx, field)
			case "repoPermissions":
				return ec.fieldContext_Permissions_repoPermissions(ctx, field)
			case "userId":
				return ec.fieldContext_Permissions_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Permissions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_settings(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_settings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Settings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIUserSettings)
	fc.Result = res
	return ec.marshalNUserSettings2githubcomevergreencievergreenrestmodelAPIUserSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_settings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "githubUser":
				return ec.fieldContext_UserSettings_githubUser(ctx, field)
			case "notifications":
				return ec.fieldContext_UserSettings_notifications(ctx, field)
			case "region":
				return ec.fieldContext_UserSettings_region(ctx, field)
			case "slackUsername":
				return ec.fieldContext_UserSettings_slackUsername(ctx, field)
			case "slackMemberId":
				return ec.fieldContext_UserSettings_slackMemberId(ctx, field)
			case "timezone":
				return ec.fieldContext_UserSettings_timezone(ctx, field)
			case "useSpruceOptions":
				return ec.fieldContext_UserSettings_useSpruceOptions(ctx, field)
			case "dateFormat":
				return ec.fieldContext_UserSettings_dateFormat(ctx, field)
			case "timeFormat":
				return ec.fieldContext_UserSettings_timeFormat(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Subscriptions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userId(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_api_key(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_api_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_api_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_api_server_host(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_api_server_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIServerHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_api_server_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_ui_server_host(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_ui_server_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UIServerHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_ui_server_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_user(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_githubUser(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_githubUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubUser)
	fc.Result = res
	return ec.marshalOGithubUser2githubcomevergreencievergreenrestmodelAPIGithubUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_githubUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastKnownAs":
				return ec.fieldContext_GithubUser_lastKnownAs(ctx, field)
			case "uid":
				return ec.fieldContext_GithubUser_uid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_notifications(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APINotificationPreferences)
	fc.Result = res
	return ec.marshalONotifications2githubcomevergreencievergreenrestmodelAPINotificationPreferences(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_notifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildBreak":
				return ec.fieldContext_Notifications_buildBreak(ctx, field)
			case "buildBreakId":
				return ec.fieldContext_Notifications_buildBreakId(ctx, field)
			case "patchFinish":
				return ec.fieldContext_Notifications_patchFinish(ctx, field)
			case "patchFinishId":
				return ec.fieldContext_Notifications_patchFinishId(ctx, field)
			case "patchFirstFailure":
				return ec.fieldContext_Notifications_patchFirstFailure(ctx, field)
			case "patchFirstFailureId":
				return ec.fieldContext_Notifications_patchFirstFailureId(ctx, field)
			case "spawnHostExpiration":
				return ec.fieldContext_Notifications_spawnHostExpiration(ctx, field)
			case "spawnHostExpirationId":
				return ec.fieldContext_Notifications_spawnHostExpirationId(ctx, field)
			case "spawnHostOutcome":
				return ec.fieldContext_Notifications_spawnHostOutcome(ctx, field)
			case "spawnHostOutcomeId":
				return ec.fieldContext_Notifications_spawnHostOutcomeId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notifications", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_region(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_region(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Region, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_region(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_slackUsername(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_slackUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_slackUsername(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_slackMemberId(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_slackMemberId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackMemberId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_slackMemberId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_timezone(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_useSpruceOptions(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_useSpruceOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseSpruceOptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIUseSpruceOptions)
	fc.Result = res
	return ec.marshalOUseSpruceOptions2githubcomevergreencievergreenrestmodelAPIUseSpruceOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_useSpruceOptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasUsedMainlineCommitsBefore":
				return ec.fieldContext_UseSpruceOptions_hasUsedMainlineCommitsBefore(ctx, field)
			case "hasUsedSpruceBefore":
				return ec.fieldContext_UseSpruceOptions_hasUsedSpruceBefore(ctx, field)
			case "spruceV1":
				return ec.fieldContext_UseSpruceOptions_spruceV1(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UseSpruceOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_dateFormat(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_dateFormat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DateFormat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_dateFormat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_timeFormat(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_timeFormat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeFormat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_timeFormat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VariantTask_name(ctx context.Context, field graphql.CollectedField, obj *model.VariantTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VariantTask_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VariantTask_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VariantTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VariantTask_tasks(ctx context.Context, field graphql.CollectedField, obj *model.VariantTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VariantTask_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VariantTask_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VariantTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_id(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_activated(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_author(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_authorEmail(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_authorEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_authorEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_baseTaskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_baseTaskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BaseTaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_baseTaskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_baseVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_baseVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BaseVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_baseVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_branch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_branch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_buildVariants(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_buildVariants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BuildVariants(rctx, obj, fc.Args["options"].(BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*GroupedBuildVariant)
	fc.Result = res
	return ec.marshalOGroupedBuildVariant2githubcomevergreencievergreengraphqlGroupedBuildVariant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_buildVariants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_GroupedBuildVariant_displayName(ctx, field)
			case "tasks":
				return ec.fieldContext_GroupedBuildVariant_tasks(ctx, field)
			case "variant":
				return ec.fieldContext_GroupedBuildVariant_variant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedBuildVariant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_buildVariants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_buildVariantStats(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_buildVariantStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BuildVariantStats(rctx, obj, fc.Args["options"].(BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*task.GroupedTaskStatusCount)
	fc.Result = res
	return ec.marshalOGroupedTaskStatusCount2githubcomevergreencievergreenmodeltaskGroupedTaskStatusCount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_buildVariantStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_GroupedTaskStatusCount_displayName(ctx, field)
			case "statusCounts":
				return ec.fieldContext_GroupedTaskStatusCount_statusCounts(ctx, field)
			case "variant":
				return ec.fieldContext_GroupedTaskStatusCount_variant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedTaskStatusCount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_buildVariantStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_childVersions(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_childVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().ChildVersions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_childVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_errors(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_errors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_externalLinksForMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().ExternalLinksForMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ExternalLinkForMetadata)
	fc.Result = res
	return ec.marshalNExternalLinkForMetadata2githubcomevergreencievergreengraphqlExternalLinkForMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_externalLinksForMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_ExternalLinkForMetadata_url(ctx, field)
			case "displayName":
				return ec.fieldContext_ExternalLinkForMetadata_displayName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLinkForMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_finishTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_finishTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_finishTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_generatedTaskCounts(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_generatedTaskCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().GeneratedTaskCounts(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GeneratedTaskCountResults)
	fc.Result = res
	return ec.marshalNGeneratedTaskCountResults2githubcomevergreencievergreengraphqlGeneratedTaskCountResults(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_generatedTaskCounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariantName":
				return ec.fieldContext_GeneratedTaskCountResults_buildVariantName(ctx, field)
			case "taskName":
				return ec.fieldContext_GeneratedTaskCountResults_taskName(ctx, field)
			case "taskId":
				return ec.fieldContext_GeneratedTaskCountResults_taskId(ctx, field)
			case "estimatedTasks":
				return ec.fieldContext_GeneratedTaskCountResults_estimatedTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneratedTaskCountResults", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_gitTags(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_gitTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIGitTag)
	fc.Result = res
	return ec.marshalOGitTag2githubcomevergreencievergreenrestmodelAPIGitTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_gitTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tag":
				return ec.fieldContext_GitTag_tag(ctx, field)
			case "pusher":
				return ec.fieldContext_GitTag_pusher(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_ignored(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_ignored(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ignored, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_ignored(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_isPatch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_isPatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().IsPatch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_isPatch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_manifest(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_manifest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Manifest(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Manifest)
	fc.Result = res
	return ec.marshalOManifest2githubcomevergreencievergreengraphqlManifest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_manifest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Manifest_id(ctx, field)
			case "branch":
				return ec.fieldContext_Manifest_branch(ctx, field)
			case "isBase":
				return ec.fieldContext_Manifest_isBase(ctx, field)
			case "moduleOverrides":
				return ec.fieldContext_Manifest_moduleOverrides(ctx, field)
			case "modules":
				return ec.fieldContext_Manifest_modules(ctx, field)
			case "project":
				return ec.fieldContext_Manifest_project(ctx, field)
			case "revision":
				return ec.fieldContext_Manifest_revision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Manifest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_message(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_order(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIParameter)
	fc.Result = res
	return ec.marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_parameters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_patch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Patch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalOPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_patch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_previousVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_previousVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().PreviousVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_previousVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_project(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_projectMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_projectMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().ProjectMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_projectMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_requester(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_revision(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_status(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskCount(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_taskCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().TaskCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_taskCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_tasks(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Tasks(rctx, obj, fc.Args["options"].(TaskFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*VersionTasks)
	fc.Result = res
	return ec.marshalNVersionTasks2githubcomevergreencievergreengraphqlVersionTasks(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_VersionTasks_count(ctx, field)
			case "data":
				return ec.fieldContext_VersionTasks_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionTasks", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_tasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_taskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().TaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_taskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskStatusStats(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_taskStatusStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().TaskStatusStats(rctx, obj, fc.Args["options"].(BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*task.TaskStats)
	fc.Result = res
	return ec.marshalOTaskStats2githubcomevergreencievergreenmodeltaskTaskStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_taskStatusStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "counts":
				return ec.fieldContext_TaskStats_counts(ctx, field)
			case "eta":
				return ec.fieldContext_TaskStats_eta(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_taskStatusStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_upstreamProject(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_upstreamProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().UpstreamProject(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpstreamProject)
	fc.Result = res
	return ec.marshalOUpstreamProject2githubcomevergreencievergreengraphqlUpstreamProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_upstreamProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_UpstreamProject_owner(ctx, field)
			case "project":
				return ec.fieldContext_UpstreamProject_project(ctx, field)
			case "repo":
				return ec.fieldContext_UpstreamProject_repo(ctx, field)
			case "resourceID":
				return ec.fieldContext_UpstreamProject_resourceID(ctx, field)
			case "revision":
				return ec.fieldContext_UpstreamProject_revision(ctx, field)
			case "task":
				return ec.fieldContext_UpstreamProject_task(ctx, field)
			case "triggerID":
				return ec.fieldContext_UpstreamProject_triggerID(ctx, field)
			case "triggerType":
				return ec.fieldContext_UpstreamProject_triggerType(ctx, field)
			case "version":
				return ec.fieldContext_UpstreamProject_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpstreamProject", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_versionTiming(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_versionTiming(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().VersionTiming(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*VersionTiming)
	fc.Result = res
	return ec.marshalOVersionTiming2githubcomevergreencievergreengraphqlVersionTiming(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_versionTiming(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "makespan":
				return ec.fieldContext_VersionTiming_makespan(ctx, field)
			case "timeTaken":
				return ec.fieldContext_VersionTiming_timeTaken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionTiming", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_warnings(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_warnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Warnings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_warnings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_waterfallBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_waterfallBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().WaterfallBuilds(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model1.WaterfallBuild)
	fc.Result = res
	return ec.marshalOWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_waterfallBuilds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WaterfallBuild_id(ctx, field)
			case "activated":
				return ec.fieldContext_WaterfallBuild_activated(ctx, field)
			case "buildVariant":
				return ec.fieldContext_WaterfallBuild_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_WaterfallBuild_displayName(ctx, field)
			case "version":
				return ec.fieldContext_WaterfallBuild_version(ctx, field)
			case "tasks":
				return ec.fieldContext_WaterfallBuild_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTasks_count(ctx context.Context, field graphql.CollectedField, obj *VersionTasks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTasks_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTasks_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTasks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTasks_data(ctx context.Context, field graphql.CollectedField, obj *VersionTasks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTasks_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTasks_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTasks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasCedarResults":
				return ec.fieldContext_Task_hasCedarResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTiming_makespan(ctx context.Context, field graphql.CollectedField, obj *VersionTiming) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTiming_makespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Makespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTiming_makespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTiming",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTiming_timeTaken(ctx context.Context, field graphql.CollectedField, obj *VersionTiming) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTiming_timeTaken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeTaken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTiming_timeTaken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTiming",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_id(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_availabilityZone(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_availabilityZone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailabilityZone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_availabilityZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_createdBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_creationTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_deviceName(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_deviceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_deviceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_expiration(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_expiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_expiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_homeVolume(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_homeVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeVolume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_homeVolume(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_host(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Volume().Host(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalOHost2githubcomevergreencievergreenrestmodelAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_hostID(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_hostID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_hostID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_migrating(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_migrating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Migrating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_migrating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_noExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_noExpiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoExpiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_noExpiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_size(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_type(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waterfall_flattenedVersions(ctx context.Context, field graphql.CollectedField, obj *Waterfall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waterfall_flattenedVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlattenedVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waterfall_flattenedVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waterfall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waterfall_pagination(ctx context.Context, field graphql.CollectedField, obj *Waterfall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waterfall_pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*WaterfallPagination)
	fc.Result = res
	return ec.marshalNWaterfallPagination2githubcomevergreencievergreengraphqlWaterfallPagination(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waterfall_pagination(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waterfall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "activeVersionIds":
				return ec.fieldContext_WaterfallPagination_activeVersionIds(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_WaterfallPagination_hasNextPage(ctx, field)
			case "hasPrevPage":
				return ec.fieldContext_WaterfallPagination_hasPrevPage(ctx, field)
			case "mostRecentVersionOrder":
				return ec.fieldContext_WaterfallPagination_mostRecentVersionOrder(ctx, field)
			case "nextPageOrder":
				return ec.fieldContext_WaterfallPagination_nextPageOrder(ctx, field)
			case "prevPageOrder":
				return ec.fieldContext_WaterfallPagination_prevPageOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallPagination", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_id(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_activated(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_displayName(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_version(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_tasks(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model1.WaterfallTask)
	fc.Result = res
	return ec.marshalNWaterfallTask2githubcomevergreencievergreenmodelWaterfallTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WaterfallTask_id(ctx, field)
			case "displayName":
				return ec.fieldContext_WaterfallTask_displayName(ctx, field)
			case "displayStatusCache":
				return ec.fieldContext_WaterfallTask_displayStatusCache(ctx, field)
			case "execution":
				return ec.fieldContext_WaterfallTask_execution(ctx, field)
			case "status":
				return ec.fieldContext_WaterfallTask_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_id(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuildVariant_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_builds(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuildVariant_builds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model1.WaterfallBuild)
	fc.Result = res
	return ec.marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_builds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WaterfallBuild_id(ctx, field)
			case "activated":
				return ec.fieldContext_WaterfallBuild_activated(ctx, field)
			case "buildVariant":
				return ec.fieldContext_WaterfallBuild_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_WaterfallBuild_displayName(ctx, field)
			case "version":
				return ec.fieldContext_WaterfallBuild_version(ctx, field)
			case "tasks":
				return ec.fieldContext_WaterfallBuild_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuildVariant_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_version(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuildVariant_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_activeVersionIds(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_activeVersionIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveVersionIds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_activeVersionIds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_hasPrevPage(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_hasPrevPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPrevPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_hasPrevPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_mostRecentVersionOrder(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_mostRecentVersionOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MostRecentVersionOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_mostRecentVersionOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_nextPageOrder(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_nextPageOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextPageOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_nextPageOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_prevPageOrder(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_prevPageOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevPageOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_prevPageOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_id(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallTask_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallTask_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_displayName(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallTask_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallTask_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_displayStatusCache(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallTask_displayStatusCache(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayStatusCache, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallTask_displayStatusCache(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_execution(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallTask_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallTask_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_status(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallTask_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallTask_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallVersion_inactiveVersions(ctx context.Context, field graphql.CollectedField, obj *WaterfallVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallVersion_inactiveVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InactiveVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallVersion_inactiveVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallVersion_version(ctx context.Context, field graphql.CollectedField, obj *WaterfallVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallVersion_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_endpoint(ctx context.Context, field graphql.CollectedField, obj *model.APIWebHook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_endpoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Endpoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_endpoint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIWebHook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookHeader_key(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookHeader) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookHeader_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookHeader_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookHeader",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookHeader_value(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookHeader) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookHeader_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookHeader_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookHeader",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_headers(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_headers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIWebhookHeader)
	fc.Result = res
	return ec.marshalNWebhookHeader2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_headers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_WebhookHeader_key(ctx, field)
			case "value":
				return ec.fieldContext_WebhookHeader_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookHeader", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_url(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_retries(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_retries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Retries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_retries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_minDelayMs(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_minDelayMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinDelayMS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_minDelayMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_timeoutMs(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_timeoutMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeoutMS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_timeoutMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationConfig_gitClone(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationConfig_gitClone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitClone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationConfig_gitClone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationConfig_setupCommands(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationConfig_setupCommands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupCommands, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIWorkstationSetupCommand)
	fc.Result = res
	return ec.marshalOWorkstationSetupCommand2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationConfig_setupCommands(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "command":
				return ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
			case "directory":
				return ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationSetupCommand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationSetupCommand_command(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationSetupCommand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationSetupCommand_command(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationSetupCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationSetupCommand_directory(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationSetupCommand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationSetupCommand_directory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationSetupCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddFavoriteProjectInput(ctx context.Context, obj any) (AddFavoriteProjectInput, error) {
	var it AddFavoriteProjectInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBetaFeaturesInput(ctx context.Context, obj any) (model.APIBetaFeatures, error) {
	var it model.APIBetaFeatures
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"spruceWaterfallEnabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "spruceWaterfallEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spruceWaterfallEnabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpruceWaterfallEnabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBootstrapSettingsInput(ctx context.Context, obj any) (model.APIBootstrapSettings, error) {
	var it model.APIBootstrapSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientDir", "communication", "env", "jasperBinaryDir", "jasperCredentialsPath", "method", "preconditionScripts", "resourceLimits", "rootDir", "serviceUser", "shellPath"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientDir"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientDir = data
		case "communication":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("communication"))
			data, err := ec.unmarshalNCommunicationMethod2githubcomevergreencievergreengraphqlCommunicationMethod(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.BootstrapSettingsInput().Communication(ctx, &it, data); err != nil {
				return it, err
			}
		case "env":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("env"))
			data, err := ec.unmarshalNEnvVarInput2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx, v)
			if err != nil {
				return it, err
			}
			it.Env = data
		case "jasperBinaryDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jasperBinaryDir"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.JasperBinaryDir = data
		case "jasperCredentialsPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jasperCredentialsPath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.JasperCredentialsPath = data
		case "method":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			data, err := ec.unmarshalNBootstrapMethod2githubcomevergreencievergreengraphqlBootstrapMethod(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.BootstrapSettingsInput().Method(ctx, &it, data); err != nil {
				return it, err
			}
		case "preconditionScripts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preconditionScripts"))
			data, err := ec.unmarshalNPreconditionScriptInput2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreconditionScripts = data
		case "resourceLimits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceLimits"))
			data, err := ec.unmarshalNResourceLimitsInput2githubcomevergreencievergreenrestmodelAPIResourceLimits(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceLimits = data
		case "rootDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootDir"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RootDir = data
		case "serviceUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceUser"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceUser = data
		case "shellPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shellPath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShellPath = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildBaronSettingsInput(ctx context.Context, obj any) (model.APIBuildBaronSettings, error) {
	var it model.APIBuildBaronSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"bfSuggestionFeaturesURL", "bfSuggestionPassword", "bfSuggestionServer", "bfSuggestionTimeoutSecs", "bfSuggestionUsername", "ticketCreateProject", "ticketSearchProjects", "ticketCreateIssueType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "bfSuggestionFeaturesURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionFeaturesURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionFeaturesURL = data
		case "bfSuggestionPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionPassword"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionPassword = data
		case "bfSuggestionServer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionServer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionServer = data
		case "bfSuggestionTimeoutSecs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionTimeoutSecs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionTimeoutSecs = data
		case "bfSuggestionUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionUsername"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionUsername = data
		case "ticketCreateProject":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketCreateProject"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketCreateProject = data
		case "ticketSearchProjects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketSearchProjects"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketSearchProjects = data
		case "ticketCreateIssueType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketCreateIssueType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketCreateIssueType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildVariantOptions(ctx context.Context, obj any) (BuildVariantOptions, error) {
	var it BuildVariantOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"includeBaseTasks", "statuses", "tasks", "variants"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "includeBaseTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeBaseTasks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeBaseTasks = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "tasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "variants":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variants"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variants = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCommitQueueParamsInput(ctx context.Context, obj any) (model.APICommitQueueParams, error) {
	var it model.APICommitQueueParams
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"enabled", "mergeMethod", "message"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "mergeMethod":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mergeMethod"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MergeMethod = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContainerResourcesInput(ctx context.Context, obj any) (model.APIContainerResources, error) {
	var it model.APIContainerResources
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "cpu", "memoryMb"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cpu":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cpu"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CPU = data
		case "memoryMb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memoryMb"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MemoryMB = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCopyDistroInput(ctx context.Context, obj any) (model.CopyDistroOpts, error) {
	var it model.CopyDistroOpts
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newDistroId", "distroIdToCopy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newDistroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newDistroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewDistroId = data
		case "distroIdToCopy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroIdToCopy"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroIdToCopy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCopyProjectInput(ctx context.Context, obj any) (model.CopyProjectOpts, error) {
	var it model.CopyProjectOpts
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newProjectId", "newProjectIdentifier", "projectIdToCopy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newProjectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newProjectId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewProjectId = data
		case "newProjectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newProjectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewProjectIdentifier = data
		case "projectIdToCopy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdToCopy"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdToCopy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDistroInput(ctx context.Context, obj any) (CreateDistroInput, error) {
	var it CreateDistroInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newDistroId", "singleTaskDistro"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newDistroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newDistroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewDistroID = data
		case "singleTaskDistro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("singleTaskDistro"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SingleTaskDistro = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateProjectInput(ctx context.Context, obj any) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "identifier", "owner", "repo", "repoRefId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "identifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Identifier = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "repo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repoRefId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoRefId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoRefId = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCursorParams(ctx context.Context, obj any) (CursorParams, error) {
	var it CursorParams
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cursorId", "direction", "includeCursor"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cursorId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CursorID = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNTaskHistoryDirection2githubcomevergreencievergreengraphqlTaskHistoryDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "includeCursor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeCursor"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeCursor = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeactivateStepbackTaskInput(ctx context.Context, obj any) (DeactivateStepbackTaskInput, error) {
	var it DeactivateStepbackTaskInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "buildVariantName", "taskName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "buildVariantName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildVariantName = data
		case "taskName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDefaultSectionToRepoInput(ctx context.Context, obj any) (DefaultSectionToRepoInput, error) {
	var it DefaultSectionToRepoInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "section"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "section":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("section"))
			data, err := ec.unmarshalNProjectSettingsSection2githubcomevergreencievergreengraphqlProjectSettingsSection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Section = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteDistroInput(ctx context.Context, obj any) (DeleteDistroInput, error) {
	var it DeleteDistroInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "ADMIN")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireDistroAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.DistroID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteGithubAppCredentialsInput(ctx context.Context, obj any) (DeleteGithubAppCredentialsInput, error) {
	var it DeleteGithubAppCredentialsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDispatcherSettingsInput(ctx context.Context, obj any) (model.APIDispatcherSettings, error) {
	var it model.APIDispatcherSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNDispatcherVersion2githubcomevergreencievergreengraphqlDispatcherVersion(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.DispatcherSettingsInput().Version(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDisplayTask(ctx context.Context, obj any) (DisplayTask, error) {
	var it DisplayTask
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ExecTasks", "Name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ExecTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ExecTasks"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExecTasks = data
		case "Name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroEventsInput(ctx context.Context, obj any) (DistroEventsInput, error) {
	var it DistroEventsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"before", "distroId", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "before":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireDistroAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.DistroID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroInput(ctx context.Context, obj any) (model.APIDistro, error) {
	var it model.APIDistro
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"adminOnly", "aliases", "arch", "authorizedKeysFile", "bootstrapSettings", "containerPool", "disabled", "disableShallowClone", "dispatcherSettings", "execUser", "expansions", "finderSettings", "homeVolumeSettings", "hostAllocatorSettings", "iceCreamSettings", "imageId", "isCluster", "isVirtualWorkStation", "mountpoints", "name", "note", "plannerSettings", "provider", "providerSettingsList", "setup", "setupAsSudo", "singleTaskDistro", "sshOptions", "user", "userSpawnAllowed", "validProjects", "warningNote", "workDir"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "adminOnly":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminOnly"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminOnly = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "arch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arch"))
			data, err := ec.unmarshalNArch2githubcomevergreencievergreengraphqlArch(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.DistroInput().Arch(ctx, &it, data); err != nil {
				return it, err
			}
		case "authorizedKeysFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedKeysFile"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthorizedKeysFile = data
		case "bootstrapSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bootstrapSettings"))
			data, err := ec.unmarshalNBootstrapSettingsInput2githubcomevergreencievergreenrestmodelAPIBootstrapSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BootstrapSettings = data
		case "containerPool":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerPool"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerPool = data
		case "disabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disabled = data
		case "disableShallowClone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disableShallowClone"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisableShallowClone = data
		case "dispatcherSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatcherSettings"))
			data, err := ec.unmarshalNDispatcherSettingsInput2githubcomevergreencievergreenrestmodelAPIDispatcherSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatcherSettings = data
		case "execUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execUser"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExecUser = data
		case "expansions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expansions"))
			data, err := ec.unmarshalNExpansionInput2githubcomevergreencievergreenrestmodelAPIExpansion(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expansions = data
		case "finderSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finderSettings"))
			data, err := ec.unmarshalNFinderSettingsInput2githubcomevergreencievergreenrestmodelAPIFinderSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinderSettings = data
		case "homeVolumeSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeVolumeSettings"))
			data, err := ec.unmarshalNHomeVolumeSettingsInput2githubcomevergreencievergreenrestmodelAPIHomeVolumeSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.HomeVolumeSettings = data
		case "hostAllocatorSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocatorSettings"))
			data, err := ec.unmarshalNHostAllocatorSettingsInput2githubcomevergreencievergreenrestmodelAPIHostAllocatorSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocatorSettings = data
		case "iceCreamSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iceCreamSettings"))
			data, err := ec.unmarshalNIceCreamSettingsInput2githubcomevergreencievergreenrestmodelAPIIceCreamSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.IcecreamSettings = data
		case "imageId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageID = data
		case "isCluster":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isCluster"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsCluster = data
		case "isVirtualWorkStation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isVirtualWorkStation"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsVirtualWorkstation = data
		case "mountpoints":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mountpoints"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mountpoints = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx, "EDIT")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.RequireDistroAccess == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "note":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Note = data
		case "plannerSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("plannerSettings"))
			data, err := ec.unmarshalNPlannerSettingsInput2githubcomevergreencievergreenrestmodelAPIPlannerSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.PlannerSettings = data
		case "provider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalNProvider2githubcomevergreencievergreengraphqlProvider(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.DistroInput().Provider(ctx, &it, data); err != nil {
				return it, err
			}
		case "providerSettingsList":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerSettingsList"))
			data, err := ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.DistroInput().ProviderSettingsList(ctx, &it, data); err != nil {
				return it, err
			}
		case "setup":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setup"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Setup = data
		case "setupAsSudo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setupAsSudo"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetupAsSudo = data
		case "singleTaskDistro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("singleTaskDistro"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SingleTaskDistro = data
		case "sshOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sshOptions"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSHOptions = data
		case "user":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.User = data
		case "userSpawnAllowed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userSpawnAllowed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserSpawnAllowed = data
		case "validProjects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validProjects"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValidProjects = data
		case "warningNote":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("warningNote"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WarningNote = data
		case "workDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workDir"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkDir = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroPermissionsOptions(ctx context.Context, obj any) (DistroPermissionsOptions, error) {
	var it DistroPermissionsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEditSpawnHostInput(ctx context.Context, obj any) (EditSpawnHostInput, error) {
	var it EditSpawnHostInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"addedInstanceTags", "deletedInstanceTags", "displayName", "expiration", "hostId", "instanceType", "noExpiration", "publicKey", "savePublicKey", "servicePassword", "sleepSchedule", "volume"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "addedInstanceTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addedInstanceTags"))
			data, err := ec.unmarshalOInstanceTagInput2githubcomevergreencievergreenmodelhostTag(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddedInstanceTags = data
		case "deletedInstanceTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedInstanceTags"))
			data, err := ec.unmarshalOInstanceTagInput2githubcomevergreencievergreenmodelhostTag(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedInstanceTags = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "hostId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireHostAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireHostAccess is not implemented")
				}
				return ec.directives.RequireHostAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.HostID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "instanceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("instanceType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.InstanceType = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "publicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKey"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *PublicKeyInput
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*PublicKeyInput); ok {
				it.PublicKey = data
			} else if tmp == nil {
				it.PublicKey = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/graphql.PublicKeyInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "savePublicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("savePublicKey"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SavePublicKey = data
		case "servicePassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("servicePassword"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ServicePassword = data
			} else if tmp == nil {
				it.ServicePassword = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "sleepSchedule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sleepSchedule"))
			data, err := ec.unmarshalOSleepScheduleInput2githubcomevergreencievergreenmodelhostSleepScheduleInfo(ctx, v)
			if err != nil {
				return it, err
			}
			it.SleepSchedule = data
		case "volume":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volume"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Volume = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnvVarInput(ctx context.Context, obj any) (model.APIEnvVar, error) {
	var it model.APIEnvVar
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExpansionInput(ctx context.Context, obj any) (model.APIExpansion, error) {
	var it model.APIExpansion
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExternalLinkInput(ctx context.Context, obj any) (model.APIExternalLink, error) {
	var it model.APIExternalLink
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"displayName", "requesters", "urlTemplate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "urlTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlTemplate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URLTemplate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFinderSettingsInput(ctx context.Context, obj any) (model.APIFinderSettings, error) {
	var it model.APIFinderSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNFinderVersion2githubcomevergreencievergreengraphqlFinderVersion(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.FinderSettingsInput().Version(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGitHubDynamicTokenPermissionGroupInput(ctx context.Context, obj any) (model.APIGitHubDynamicTokenPermissionGroup, error) {
	var it model.APIGitHubDynamicTokenPermissionGroup
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "permissions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "permissions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissions"))
			data, err := ec.unmarshalNStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Permissions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubAppAuthInput(ctx context.Context, obj any) (model.APIGithubAppAuth, error) {
	var it model.APIGithubAppAuth
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"appId", "privateKey"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "appId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appId"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppID = data
		case "privateKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("privateKey"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrivateKey = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubUserInput(ctx context.Context, obj any) (model.APIGithubUser, error) {
	var it model.APIGithubUser
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lastKnownAs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lastKnownAs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastKnownAs"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastKnownAs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHomeVolumeSettingsInput(ctx context.Context, obj any) (model.APIHomeVolumeSettings, error) {
	var it model.APIHomeVolumeSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"formatCommand"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "formatCommand":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formatCommand"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FormatCommand = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHostAllocatorSettingsInput(ctx context.Context, obj any) (model.APIHostAllocatorSettings, error) {
	var it model.APIHostAllocatorSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"acceptableHostIdleTime", "feedbackRule", "futureHostFraction", "hostsOverallocatedRule", "maximumHosts", "minimumHosts", "roundingRule", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "acceptableHostIdleTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acceptableHostIdleTime"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.HostAllocatorSettingsInput().AcceptableHostIdleTime(ctx, &it, data); err != nil {
				return it, err
			}
		case "feedbackRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedbackRule"))
			data, err := ec.unmarshalNFeedbackRule2githubcomevergreencievergreengraphqlFeedbackRule(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.HostAllocatorSettingsInput().FeedbackRule(ctx, &it, data); err != nil {
				return it, err
			}
		case "futureHostFraction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("futureHostFraction"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FutureHostFraction = data
		case "hostsOverallocatedRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostsOverallocatedRule"))
			data, err := ec.unmarshalNOverallocatedRule2githubcomevergreencievergreengraphqlOverallocatedRule(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.HostAllocatorSettingsInput().HostsOverallocatedRule(ctx, &it, data); err != nil {
				return it, err
			}
		case "maximumHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maximumHosts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaximumHosts = data
		case "minimumHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumHosts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinimumHosts = data
		case "roundingRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roundingRule"))
			data, err := ec.unmarshalNRoundingRule2githubcomevergreencievergreengraphqlRoundingRule(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.HostAllocatorSettingsInput().RoundingRule(ctx, &it, data); err != nil {
				return it, err
			}
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNHostAllocatorVersion2githubcomevergreencievergreengraphqlHostAllocatorVersion(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.HostAllocatorSettingsInput().Version(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHostEventsInput(ctx context.Context, obj any) (HostEventsInput, error) {
	var it HostEventsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["sortDir"]; !present {
		asMap["sortDir"] = "DESC"
	}

	fieldsInOrder := [...]string{"limit", "page", "sortDir", "eventTypes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "sortDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDir"))
			data, err := ec.unmarshalOSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortDir = data
		case "eventTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypes"))
			data, err := ec.unmarshalOHostEventType2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventTypes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIceCreamSettingsInput(ctx context.Context, obj any) (model.APIIceCreamSettings, error) {
	var it model.APIIceCreamSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"configPath", "schedulerHost"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "configPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configPath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigPath = data
		case "schedulerHost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schedulerHost"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SchedulerHost = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInstanceTagInput(ctx context.Context, obj any) (host.Tag, error) {
	var it host.Tag
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIssueLinkInput(ctx context.Context, obj any) (model.APIIssueLink, error) {
	var it model.APIIssueLink
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"confidenceScore", "issueKey", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "confidenceScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confidenceScore"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfidenceScore = data
		case "issueKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueKey"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssueKey = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJiraIssueSubscriberInput(ctx context.Context, obj any) (model.APIJIRAIssueSubscriber, error) {
	var it model.APIJIRAIssueSubscriber
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"issueType", "project"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "issueType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssueType = data
		case "project":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Project = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMainlineCommitsOptions(ctx context.Context, obj any) (MainlineCommitsOptions, error) {
	var it MainlineCommitsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 7
	}
	if _, present := asMap["shouldCollapse"]; !present {
		asMap["shouldCollapse"] = false
	}

	fieldsInOrder := [...]string{"limit", "projectIdentifier", "requesters", "revision", "shouldCollapse", "skipOrderNumber"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectIdentifier = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		case "shouldCollapse":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shouldCollapse"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShouldCollapse = data
		case "skipOrderNumber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skipOrderNumber"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SkipOrderNumber = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMetadataLinkInput(ctx context.Context, obj any) (model.APIMetadataLink, error) {
	var it model.APIMetadataLink
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMoveProjectInput(ctx context.Context, obj any) (MoveProjectInput, error) {
	var it MoveProjectInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newOwner", "newRepo", "projectId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newOwner"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewOwner = data
		case "newRepo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newRepo"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewRepo = data
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationsInput(ctx context.Context, obj any) (model.APINotificationPreferences, error) {
	var it model.APINotificationPreferences
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buildBreak", "patchFinish", "patchFirstFailure", "spawnHostExpiration", "spawnHostOutcome"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buildBreak":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBreak"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBreak = data
		case "patchFinish":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFinish"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFinish = data
		case "patchFirstFailure":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFirstFailure"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFirstFailure = data
		case "spawnHostExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostExpiration"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostExpiration = data
		case "spawnHostOutcome":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostOutcome"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostOutcome = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOperatingSystemOpts(ctx context.Context, obj any) (thirdparty.OSInfoFilterOptions, error) {
	var it thirdparty.OSInfoFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageOpts(ctx context.Context, obj any) (thirdparty.PackageFilterOptions, error) {
	var it thirdparty.PackageFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "manager", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "manager":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manager"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manager = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParameterInput(ctx context.Context, obj any) (model.APIParameter, error) {
	var it model.APIParameter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParsleyFilterInput(ctx context.Context, obj any) (model.APIParsleyFilter, error) {
	var it model.APIParsleyFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"expression", "caseSensitive", "exactMatch"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "expression":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expression = data
		case "caseSensitive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caseSensitive"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CaseSensitive = data
		case "exactMatch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exactMatch"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExactMatch = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParsleySettingsInput(ctx context.Context, obj any) (model.APIParsleySettings, error) {
	var it model.APIParsleySettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sectionsEnabled", "jumpToFailingLineEnabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sectionsEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sectionsEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SectionsEnabled = data
		case "jumpToFailingLineEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jumpToFailingLineEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.JumpToFailingLineEnabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchConfigure(ctx context.Context, obj any) (PatchConfigure, error) {
	var it PatchConfigure
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "parameters", "patchTriggerAliases", "variantsTasks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "parameters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOParameterInput2githubcomevergreencievergreenrestmodelAPIParameter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		case "patchTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "variantsTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantsTasks"))
			data, err := ec.unmarshalNVariantTasks2githubcomevergreencievergreengraphqlVariantTasks(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantsTasks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchTriggerAliasInput(ctx context.Context, obj any) (model.APIPatchTriggerDefinition, error) {
	var it model.APIPatchTriggerDefinition
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"alias", "childProjectIdentifier", "parentAsModule", "status", "downstreamRevision", "taskSpecifiers"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "childProjectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("childProjectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChildProjectIdentifier = data
		case "parentAsModule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentAsModule"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentAsModule = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "downstreamRevision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downstreamRevision"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownstreamRevision = data
		case "taskSpecifiers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskSpecifiers"))
			data, err := ec.unmarshalNTaskSpecifierInput2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskSpecifiers = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchesInput(ctx context.Context, obj any) (PatchesInput, error) {
	var it PatchesInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["includeHidden"]; !present {
		asMap["includeHidden"] = false
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["patchName"]; !present {
		asMap["patchName"] = ""
	}
	if _, present := asMap["statuses"]; !present {
		asMap["statuses"] = []any{}
	}

	fieldsInOrder := [...]string{"limit", "onlyMergeQueue", "includeHidden", "page", "patchName", "statuses", "requesters"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "onlyMergeQueue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onlyMergeQueue"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnlyMergeQueue = data
		case "includeHidden":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeHidden"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeHidden = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "patchName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchName = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPeriodicBuildInput(ctx context.Context, obj any) (model.APIPeriodicBuildDefinition, error) {
	var it model.APIPeriodicBuildDefinition
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "alias", "configFile", "cron", "intervalHours", "message", "nextRunTime"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "configFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configFile"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigFile = data
		case "cron":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cron"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cron = data
		case "intervalHours":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intervalHours"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntervalHours = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "nextRunTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nextRunTime"))
			data, err := ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.NextRunTime = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlannerSettingsInput(ctx context.Context, obj any) (model.APIPlannerSettings, error) {
	var it model.APIPlannerSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"commitQueueFactor", "expectedRuntimeFactor", "generateTaskFactor", "groupVersions", "mainlineTimeInQueueFactor", "numDependentsFactor", "patchFactor", "patchTimeInQueueFactor", "targetTime", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "commitQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueueFactor = data
		case "expectedRuntimeFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expectedRuntimeFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpectedRuntimeFactor = data
		case "generateTaskFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("generateTaskFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GenerateTaskFactor = data
		case "groupVersions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupVersions"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupVersions = data
		case "mainlineTimeInQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainlineTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainlineTimeInQueueFactor = data
		case "numDependentsFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numDependentsFactor"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumDependentsFactor = data
		case "patchFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFactor = data
		case "patchTimeInQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTimeInQueueFactor = data
		case "targetTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetTime"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.PlannerSettingsInput().TargetTime(ctx, &it, data); err != nil {
				return it, err
			}
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNPlannerVersion2githubcomevergreencievergreengraphqlPlannerVersion(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.PlannerSettingsInput().Version(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPreconditionScriptInput(ctx context.Context, obj any) (model.APIPreconditionScript, error) {
	var it model.APIPreconditionScript
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"path", "script"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "script":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("script"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Script = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectAliasInput(ctx context.Context, obj any) (model.APIProjectAlias, error) {
	var it model.APIProjectAlias
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "alias", "description", "gitTag", "remotePath", "task", "taskTags", "variant", "variantTags", "parameters"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "gitTag":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTag"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTag = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "task":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("task"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Task = data
		case "taskTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskTags"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskTags = data
		case "variant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		case "variantTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantTags"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantTags = data
		case "parameters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOParameterInput2githubcomevergreencievergreenrestmodelAPIParameter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectBannerInput(ctx context.Context, obj any) (model.APIProjectBanner, error) {
	var it model.APIProjectBanner
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "theme"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "theme":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("theme"))
			data, err := ec.unmarshalNBannerTheme2githubcomevergreencievergreenBannerTheme(ctx, v)
			if err != nil {
				return it, err
			}
			it.Theme = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectInput(ctx context.Context, obj any) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "admins", "banner", "batchTime", "branch", "buildBaronSettings", "commitQueue", "containerSizeDefinitions", "deactivatePrevious", "disabledStatsCache", "dispatchingDisabled", "displayName", "enabled", "externalLinks", "githubChecksEnabled", "githubDynamicTokenPermissionGroups", "githubPermissionGroupByRequester", "githubTriggerAliases", "gitTagAuthorizedTeams", "gitTagAuthorizedUsers", "gitTagVersionsEnabled", "identifier", "manualPrTestingEnabled", "notifyOnBuildFailure", "oldestAllowedMergeBase", "owner", "parsleyFilters", "patchingDisabled", "patchTriggerAliases", "perfEnabled", "periodicBuilds", "projectHealthView", "prTestingEnabled", "remotePath", "repo", "repotrackerDisabled", "restricted", "spawnHostScriptPath", "stepbackDisabled", "stepbackBisect", "taskAnnotationSettings", "tracksPushEvents", "triggers", "versionControlEnabled", "workstationConfig"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "admins":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Admins = data
		case "banner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("banner"))
			data, err := ec.unmarshalOProjectBannerInput2githubcomevergreencievergreenrestmodelAPIProjectBanner(ctx, v)
			if err != nil {
				return it, err
			}
			it.Banner = data
		case "batchTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchTime"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BatchTime = data
		case "branch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("branch"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Branch = data
		case "buildBaronSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBaronSettings"))
			data, err := ec.unmarshalOBuildBaronSettingsInput2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBaronSettings = data
		case "commitQueue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueue"))
			data, err := ec.unmarshalOCommitQueueParamsInput2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueue = data
		case "containerSizeDefinitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerSizeDefinitions"))
			data, err := ec.unmarshalOContainerResourcesInput2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerSizeDefinitions = data
		case "deactivatePrevious":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deactivatePrevious"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeactivatePrevious = data
		case "disabledStatsCache":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabledStatsCache"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisabledStatsCache = data
		case "dispatchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatchingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatchingDisabled = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "externalLinks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalLinks"))
			data, err := ec.unmarshalOExternalLinkInput2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalLinks = data
		case "githubChecksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubChecksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubChecksEnabled = data
		case "githubDynamicTokenPermissionGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubDynamicTokenPermissionGroups"))
			data, err := ec.unmarshalOGitHubDynamicTokenPermissionGroupInput2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubDynamicTokenPermissionGroups = data
		case "githubPermissionGroupByRequester":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPermissionGroupByRequester"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubPermissionGroupByRequester = data
		case "githubTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubTriggerAliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubTriggerAliases = data
		case "gitTagAuthorizedTeams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedTeams"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedTeams = data
		case "gitTagAuthorizedUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedUsers"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedUsers = data
		case "gitTagVersionsEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagVersionsEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagVersionsEnabled = data
		case "identifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Identifier = data
		case "manualPrTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manualPrTestingEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManualPRTestingEnabled = data
		case "notifyOnBuildFailure":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifyOnBuildFailure"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotifyOnBuildFailure = data
		case "oldestAllowedMergeBase":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oldestAllowedMergeBase"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OldestAllowedMergeBase = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "parsleyFilters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleyFilters"))
			data, err := ec.unmarshalOParsleyFilterInput2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleyFilters = data
		case "patchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchingDisabled = data
		case "patchTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOPatchTriggerAliasInput2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "perfEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perfEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerfEnabled = data
		case "periodicBuilds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("periodicBuilds"))
			data, err := ec.unmarshalOPeriodicBuildInput2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.PeriodicBuilds = data
		case "projectHealthView":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectHealthView"))
			data, err := ec.unmarshalOProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectHealthView = data
		case "prTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prTestingEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PRTestingEnabled = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "repo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repotrackerDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotrackerDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepotrackerDisabled = data
		case "restricted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("restricted"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Restricted = data
		case "spawnHostScriptPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostScriptPath"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostScriptPath = data
		case "stepbackDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackDisabled = data
		case "stepbackBisect":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackBisect"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackBisect = data
		case "taskAnnotationSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskAnnotationSettings"))
			data, err := ec.unmarshalOTaskAnnotationSettingsInput2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskAnnotationSettings = data
		case "tracksPushEvents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracksPushEvents"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TracksPushEvents = data
		case "triggers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			data, err := ec.unmarshalOTriggerAliasInput2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.Triggers = data
		case "versionControlEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionControlEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionControlEnabled = data
		case "workstationConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workstationConfig"))
			data, err := ec.unmarshalOWorkstationConfigInput2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkstationConfig = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectPermissionsOptions(ctx context.Context, obj any) (ProjectPermissionsOptions, error) {
	var it ProjectPermissionsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectSettingsInput(ctx context.Context, obj any) (model.APIProjectSettings, error) {
	var it model.APIProjectSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "aliases", "githubAppAuth", "githubWebhooksEnabled", "projectRef", "subscriptions", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				if err = ec.resolvers.ProjectSettingsInput().ProjectID(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOProjectAliasInput2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "githubAppAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubAppAuth"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOGithubAppAuthInput2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIGithubAppAuth
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIGithubAppAuth); ok {
				it.GithubAppAuth = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIGithubAppAuth`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "githubWebhooksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubWebhooksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubWebhooksEnabled = data
		case "projectRef":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectRef"))
			data, err := ec.unmarshalOProjectInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectRef = data
		case "subscriptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptions"))
			data, err := ec.unmarshalOSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriptions = data
		case "vars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOProjectVarsInput2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIProjectVars
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIProjectVars); ok {
				it.Vars = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectVars`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectVarsInput(ctx context.Context, obj any) (model.APIProjectVars, error) {
	var it model.APIProjectVars
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"adminOnlyVarsList", "privateVarsList", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "adminOnlyVarsList":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminOnlyVarsList"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminOnlyVarsList = data
		case "privateVarsList":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("privateVarsList"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrivateVarsList = data
		case "vars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Vars = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPromoteVarsToRepoInput(ctx context.Context, obj any) (PromoteVarsToRepoInput, error) {
	var it PromoteVarsToRepoInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "varNames"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "varNames":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("varNames"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VarNames = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPublicKeyInput(ctx context.Context, obj any) (PublicKeyInput, error) {
	var it PublicKeyInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveFavoriteProjectInput(ctx context.Context, obj any) (RemoveFavoriteProjectInput, error) {
	var it RemoveFavoriteProjectInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoPermissionsOptions(ctx context.Context, obj any) (RepoPermissionsOptions, error) {
	var it RepoPermissionsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"repoId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "repoId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoRefInput(ctx context.Context, obj any) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "admins", "batchTime", "buildBaronSettings", "commitQueue", "deactivatePrevious", "disabledStatsCache", "dispatchingDisabled", "displayName", "enabled", "externalLinks", "githubChecksEnabled", "githubDynamicTokenPermissionGroups", "githubPermissionGroupByRequester", "githubTriggerAliases", "gitTagAuthorizedTeams", "gitTagAuthorizedUsers", "gitTagVersionsEnabled", "manualPrTestingEnabled", "notifyOnBuildFailure", "oldestAllowedMergeBase", "owner", "parsleyFilters", "patchingDisabled", "patchTriggerAliases", "perfEnabled", "periodicBuilds", "prTestingEnabled", "remotePath", "repo", "repotrackerDisabled", "restricted", "spawnHostScriptPath", "stepbackDisabled", "stepbackBisect", "taskAnnotationSettings", "tracksPushEvents", "triggers", "versionControlEnabled", "workstationConfig", "containerSizeDefinitions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "admins":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Admins = data
		case "batchTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchTime"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BatchTime = data
		case "buildBaronSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBaronSettings"))
			data, err := ec.unmarshalOBuildBaronSettingsInput2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBaronSettings = data
		case "commitQueue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueue"))
			data, err := ec.unmarshalOCommitQueueParamsInput2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueue = data
		case "deactivatePrevious":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deactivatePrevious"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeactivatePrevious = data
		case "disabledStatsCache":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabledStatsCache"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisabledStatsCache = data
		case "dispatchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatchingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatchingDisabled = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "externalLinks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalLinks"))
			data, err := ec.unmarshalOExternalLinkInput2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalLinks = data
		case "githubChecksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubChecksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubChecksEnabled = data
		case "githubDynamicTokenPermissionGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubDynamicTokenPermissionGroups"))
			data, err := ec.unmarshalOGitHubDynamicTokenPermissionGroupInput2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubDynamicTokenPermissionGroups = data
		case "githubPermissionGroupByRequester":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPermissionGroupByRequester"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubPermissionGroupByRequester = data
		case "githubTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubTriggerAliases"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubTriggerAliases = data
		case "gitTagAuthorizedTeams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedTeams"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedTeams = data
		case "gitTagAuthorizedUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedUsers"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedUsers = data
		case "gitTagVersionsEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagVersionsEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagVersionsEnabled = data
		case "manualPrTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manualPrTestingEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManualPRTestingEnabled = data
		case "notifyOnBuildFailure":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifyOnBuildFailure"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotifyOnBuildFailure = data
		case "oldestAllowedMergeBase":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oldestAllowedMergeBase"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OldestAllowedMergeBase = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "parsleyFilters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleyFilters"))
			data, err := ec.unmarshalOParsleyFilterInput2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleyFilters = data
		case "patchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchingDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchingDisabled = data
		case "patchTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOPatchTriggerAliasInput2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "perfEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perfEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerfEnabled = data
		case "periodicBuilds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("periodicBuilds"))
			data, err := ec.unmarshalOPeriodicBuildInput2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.PeriodicBuilds = data
		case "prTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prTestingEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PRTestingEnabled = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "repo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repotrackerDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotrackerDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepotrackerDisabled = data
		case "restricted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("restricted"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Restricted = data
		case "spawnHostScriptPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostScriptPath"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostScriptPath = data
		case "stepbackDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackDisabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackDisabled = data
		case "stepbackBisect":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackBisect"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackBisect = data
		case "taskAnnotationSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskAnnotationSettings"))
			data, err := ec.unmarshalOTaskAnnotationSettingsInput2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskAnnotationSettings = data
		case "tracksPushEvents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracksPushEvents"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TracksPushEvents = data
		case "triggers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			data, err := ec.unmarshalOTriggerAliasInput2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, v)
			if err != nil {
				return it, err
			}
			it.Triggers = data
		case "versionControlEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionControlEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionControlEnabled = data
		case "workstationConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workstationConfig"))
			data, err := ec.unmarshalOWorkstationConfigInput2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkstationConfig = data
		case "containerSizeDefinitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerSizeDefinitions"))
			data, err := ec.unmarshalOContainerResourcesInput2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerSizeDefinitions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoSettingsInput(ctx context.Context, obj any) (model.APIProjectSettings, error) {
	var it model.APIProjectSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"repoId", "aliases", "githubAppAuth", "githubWebhooksEnabled", "projectRef", "subscriptions", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "repoId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				if err = ec.resolvers.RepoSettingsInput().RepoID(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOProjectAliasInput2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "githubAppAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubAppAuth"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOGithubAppAuthInput2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIGithubAppAuth
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIGithubAppAuth); ok {
				it.GithubAppAuth = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIGithubAppAuth`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "githubWebhooksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubWebhooksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubWebhooksEnabled = data
		case "projectRef":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectRef"))
			data, err := ec.unmarshalORepoRefInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectRef = data
		case "subscriptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptions"))
			data, err := ec.unmarshalOSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriptions = data
		case "vars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOProjectVarsInput2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIProjectVars
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIProjectVars); ok {
				it.Vars = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectVars`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourceLimitsInput(ctx context.Context, obj any) (model.APIResourceLimits, error) {
	var it model.APIResourceLimits
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lockedMemoryKb", "numFiles", "numProcesses", "numTasks", "virtualMemoryKb"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lockedMemoryKb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lockedMemoryKb"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LockedMemoryKB = data
		case "numFiles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numFiles"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumFiles = data
		case "numProcesses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numProcesses"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumProcesses = data
		case "numTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numTasks"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumTasks = data
		case "virtualMemoryKb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("virtualMemoryKb"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.VirtualMemoryKB = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSaveDistroInput(ctx context.Context, obj any) (SaveDistroInput, error) {
	var it SaveDistroInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distro", "onSave"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distro"))
			data, err := ec.unmarshalNDistroInput2githubcomevergreencievergreenrestmodelAPIDistro(ctx, v)
			if err != nil {
				return it, err
			}
			it.Distro = data
		case "onSave":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onSave"))
			data, err := ec.unmarshalNDistroOnSaveOperation2githubcomevergreencievergreengraphqlDistroOnSaveOperation(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnSave = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSelectorInput(ctx context.Context, obj any) (model.APISelector, error) {
	var it model.APISelector
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"data", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetLastRevisionInput(ctx context.Context, obj any) (SetLastRevisionInput, error) {
	var it SetLastRevisionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier", "revision"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSleepScheduleInput(ctx context.Context, obj any) (host.SleepScheduleInfo, error) {
	var it host.SleepScheduleInfo
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dailyStartTime", "dailyStopTime", "permanentlyExempt", "shouldKeepOff", "timeZone", "temporarilyExemptUntil", "wholeWeekdaysOff"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dailyStartTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dailyStartTime"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DailyStartTime = data
		case "dailyStopTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dailyStopTime"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DailyStopTime = data
		case "permanentlyExempt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permanentlyExempt"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermanentlyExempt = data
		case "shouldKeepOff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shouldKeepOff"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShouldKeepOff = data
		case "timeZone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeZone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeZone = data
		case "temporarilyExemptUntil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("temporarilyExemptUntil"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TemporarilyExemptUntil = data
		case "wholeWeekdaysOff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wholeWeekdaysOff"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.SleepScheduleInput().WholeWeekdaysOff(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSortOrder(ctx context.Context, obj any) (SortOrder, error) {
	var it SortOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Direction", "Key"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Direction"))
			data, err := ec.unmarshalNSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "Key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Key"))
			data, err := ec.unmarshalNTaskSortCategory2githubcomevergreencievergreengraphqlTaskSortCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpawnHostInput(ctx context.Context, obj any) (SpawnHostInput, error) {
	var it SpawnHostInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId", "expiration", "homeVolumeSize", "isVirtualWorkStation", "noExpiration", "publicKey", "region", "savePublicKey", "setUpScript", "sleepSchedule", "spawnHostsStartedByTask", "taskId", "useProjectSetupScript", "userDataScript", "useTaskConfig", "volumeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroID = data
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "homeVolumeSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeVolumeSize"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HomeVolumeSize = data
		case "isVirtualWorkStation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isVirtualWorkStation"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsVirtualWorkStation = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "publicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKey"))
			data, err := ec.unmarshalNPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublicKey = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "savePublicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("savePublicKey"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SavePublicKey = data
		case "setUpScript":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setUpScript"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetUpScript = data
		case "sleepSchedule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sleepSchedule"))
			data, err := ec.unmarshalOSleepScheduleInput2githubcomevergreencievergreenmodelhostSleepScheduleInfo(ctx, v)
			if err != nil {
				return it, err
			}
			it.SleepSchedule = data
		case "spawnHostsStartedByTask":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostsStartedByTask"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostsStartedByTask = data
		case "taskId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskID = data
		case "useProjectSetupScript":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useProjectSetupScript"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseProjectSetupScript = data
		case "userDataScript":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userDataScript"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserDataScript = data
		case "useTaskConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useTaskConfig"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseTaskConfig = data
		case "volumeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpawnVolumeInput(ctx context.Context, obj any) (SpawnVolumeInput, error) {
	var it SpawnVolumeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"availabilityZone", "expiration", "host", "noExpiration", "size", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "availabilityZone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("availabilityZone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvailabilityZone = data
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Host = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubscriberInput(ctx context.Context, obj any) (model.APISubscriber, error) {
	var it model.APISubscriber
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"target", "type", "webhookSubscriber", "jiraIssueSubscriber"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "target":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.SubscriberInput().Target(ctx, &it, data); err != nil {
				return it, err
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "webhookSubscriber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookSubscriber"))
			data, err := ec.unmarshalOWebhookSubscriberInput2githubcomevergreencievergreenrestmodelAPIWebhookSubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.WebhookSubscriber = data
		case "jiraIssueSubscriber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jiraIssueSubscriber"))
			data, err := ec.unmarshalOJiraIssueSubscriberInput2githubcomevergreencievergreenrestmodelAPIJIRAIssueSubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.JiraIssueSubscriber = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubscriptionInput(ctx context.Context, obj any) (model.APISubscription, error) {
	var it model.APISubscription
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "owner_type", "owner", "regex_selectors", "resource_type", "selectors", "subscriber", "trigger_data", "trigger"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "owner_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner_type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerType = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "regex_selectors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regex_selectors"))
			data, err := ec.unmarshalNSelectorInput2githubcomevergreencievergreenrestmodelAPISelector(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegexSelectors = data
		case "resource_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resource_type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		case "selectors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectors"))
			data, err := ec.unmarshalNSelectorInput2githubcomevergreencievergreenrestmodelAPISelector(ctx, v)
			if err != nil {
				return it, err
			}
			it.Selectors = data
		case "subscriber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriber"))
			data, err := ec.unmarshalNSubscriberInput2githubcomevergreencievergreenrestmodelAPISubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriber = data
		case "trigger_data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trigger_data"))
			data, err := ec.unmarshalNStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.TriggerData = data
		case "trigger":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trigger"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Trigger = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskAnnotationSettingsInput(ctx context.Context, obj any) (model.APITaskAnnotationSettings, error) {
	var it model.APITaskAnnotationSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fileTicketWebhook"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fileTicketWebhook":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileTicketWebhook"))
			data, err := ec.unmarshalOWebhookInput2githubcomevergreencievergreenrestmodelAPIWebHook(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileTicketWebhook = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskFilterOptions(ctx context.Context, obj any) (TaskFilterOptions, error) {
	var it TaskFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["baseStatuses"]; !present {
		asMap["baseStatuses"] = []any{}
	}
	if _, present := asMap["includeNeverActivatedTasks"]; !present {
		asMap["includeNeverActivatedTasks"] = false
	}
	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["statuses"]; !present {
		asMap["statuses"] = []any{}
	}

	fieldsInOrder := [...]string{"baseStatuses", "includeNeverActivatedTasks", "limit", "page", "sorts", "statuses", "taskName", "variant"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "baseStatuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseStatuses"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseStatuses = data
		case "includeNeverActivatedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeNeverActivatedTasks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeNeverActivatedTasks = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "sorts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sorts"))
			data, err := ec.unmarshalOSortOrder2githubcomevergreencievergreengraphqlSortOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sorts = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "taskName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskName = data
		case "variant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskHistoryOpts(ctx context.Context, obj any) (TaskHistoryOpts, error) {
	var it TaskHistoryOpts
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 50
	}

	fieldsInOrder := [...]string{"projectIdentifier", "taskName", "buildVariant", "cursorParams", "limit", "date"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectIdentifier = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "taskName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskName = data
		case "buildVariant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildVariant = data
		case "cursorParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorParams"))
			data, err := ec.unmarshalNCursorParams2githubcomevergreencievergreengraphqlCursorParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CursorParams = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskSpecifierInput(ctx context.Context, obj any) (model.APITaskSpecifier, error) {
	var it model.APITaskSpecifier
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"patchAlias", "taskRegex", "variantRegex"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "patchAlias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchAlias"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchAlias = data
		case "taskRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskRegex"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskRegex = data
		case "variantRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantRegex"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantRegex = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestFilter(ctx context.Context, obj any) (TestFilter, error) {
	var it TestFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"testName", "testStatus"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "testName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestName = data
		case "testStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testStatus"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestStatus = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestFilterOptions(ctx context.Context, obj any) (TestFilterOptions, error) {
	var it TestFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"testName", "excludeDisplayNames", "statuses", "groupID", "sort", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "testName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestName = data
		case "excludeDisplayNames":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeDisplayNames"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExcludeDisplayNames = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "groupID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupID = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOTestSortOptions2githubcomevergreencievergreengraphqlTestSortOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestSortOptions(ctx context.Context, obj any) (TestSortOptions, error) {
	var it TestSortOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sortBy", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sortBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalNTestSortCategory2githubcomevergreencievergreengraphqlTestSortCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputToolchainOpts(ctx context.Context, obj any) (thirdparty.ToolchainFilterOptions, error) {
	var it thirdparty.ToolchainFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTriggerAliasInput(ctx context.Context, obj any) (model.APITriggerDefinition, error) {
	var it model.APITriggerDefinition
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"alias", "buildVariantRegex", "configFile", "dateCutoff", "level", "project", "status", "taskRegex", "unscheduleDownstreamVersions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "buildVariantRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantRegex"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildVariantRegex = data
		case "configFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configFile"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigFile = data
		case "dateCutoff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateCutoff"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateCutoff = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "project":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Project = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "taskRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskRegex"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskRegex = data
		case "unscheduleDownstreamVersions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unscheduleDownstreamVersions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnscheduleDownstreamVersions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateBetaFeaturesInput(ctx context.Context, obj any) (UpdateBetaFeaturesInput, error) {
	var it UpdateBetaFeaturesInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"betaFeatures"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "betaFeatures":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("betaFeatures"))
			data, err := ec.unmarshalNBetaFeaturesInput2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx, v)
			if err != nil {
				return it, err
			}
			it.BetaFeatures = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateParsleySettingsInput(ctx context.Context, obj any) (UpdateParsleySettingsInput, error) {
	var it UpdateParsleySettingsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"parsleySettings"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "parsleySettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleySettings"))
			data, err := ec.unmarshalNParsleySettingsInput2githubcomevergreencievergreenrestmodelAPIParsleySettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleySettings = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSpawnHostStatusInput(ctx context.Context, obj any) (UpdateSpawnHostStatusInput, error) {
	var it UpdateSpawnHostStatusInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"action", "hostId", "shouldKeepOff"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "action":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("action"))
			data, err := ec.unmarshalNSpawnHostStatusActions2githubcomevergreencievergreengraphqlSpawnHostStatusActions(ctx, v)
			if err != nil {
				return it, err
			}
			it.Action = data
		case "hostId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireHostAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireHostAccess is not implemented")
				}
				return ec.directives.RequireHostAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.HostID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "shouldKeepOff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shouldKeepOff"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShouldKeepOff = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateVolumeInput(ctx context.Context, obj any) (UpdateVolumeInput, error) {
	var it UpdateVolumeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"expiration", "name", "noExpiration", "size", "volumeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "volumeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUseSpruceOptionsInput(ctx context.Context, obj any) (model.APIUseSpruceOptions, error) {
	var it model.APIUseSpruceOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"hasUsedMainlineCommitsBefore", "hasUsedSpruceBefore", "spruceV1"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "hasUsedMainlineCommitsBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsedMainlineCommitsBefore"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsedMainlineCommitsBefore = data
		case "hasUsedSpruceBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsedSpruceBefore"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsedSpruceBefore = data
		case "spruceV1":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spruceV1"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpruceV1 = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserSettingsInput(ctx context.Context, obj any) (model.APIUserSettings, error) {
	var it model.APIUserSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"githubUser", "notifications", "region", "slackUsername", "slackMemberId", "timezone", "useSpruceOptions", "dateFormat", "timeFormat"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "githubUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubUser"))
			data, err := ec.unmarshalOGithubUserInput2githubcomevergreencievergreenrestmodelAPIGithubUser(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubUser = data
		case "notifications":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifications"))
			data, err := ec.unmarshalONotificationsInput2githubcomevergreencievergreenrestmodelAPINotificationPreferences(ctx, v)
			if err != nil {
				return it, err
			}
			it.Notifications = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "slackUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackUsername"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackUsername = data
		case "slackMemberId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackMemberId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackMemberId = data
		case "timezone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timezone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timezone = data
		case "useSpruceOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useSpruceOptions"))
			data, err := ec.unmarshalOUseSpruceOptionsInput2githubcomevergreencievergreenrestmodelAPIUseSpruceOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseSpruceOptions = data
		case "dateFormat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateFormat"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateFormat = data
		case "timeFormat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeFormat"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeFormat = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVariantTasks(ctx context.Context, obj any) (VariantTasks, error) {
	var it VariantTasks
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"displayTasks", "tasks", "variant"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "displayTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayTasks"))
			data, err := ec.unmarshalNDisplayTask2githubcomevergreencievergreengraphqlDisplayTask(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayTasks = data
		case "tasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "variant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVersionToRestart(ctx context.Context, obj any) (model1.VersionToRestart, error) {
	var it model1.VersionToRestart
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"versionId", "taskIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "versionId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionId = data
		case "taskIds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskIds"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVolumeHost(ctx context.Context, obj any) (VolumeHost, error) {
	var it VolumeHost
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"volumeId", "hostId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "volumeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		case "hostId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWaterfallOptions(ctx context.Context, obj any) (WaterfallOptions, error) {
	var it WaterfallOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 5
	}

	fieldsInOrder := [...]string{"date", "limit", "minOrder", "maxOrder", "projectIdentifier", "requesters", "revision", "statuses", "tasks", "taskCaseSensitive", "variants", "variantCaseSensitive"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "minOrder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minOrder"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinOrder = data
		case "maxOrder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxOrder"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxOrder = data
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectIdentifier = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "tasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "taskCaseSensitive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskCaseSensitive"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskCaseSensitive = data
		case "variants":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variants"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variants = data
		case "variantCaseSensitive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantCaseSensitive"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantCaseSensitive = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookHeaderInput(ctx context.Context, obj any) (model.APIWebhookHeader, error) {
	var it model.APIWebhookHeader
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookInput(ctx context.Context, obj any) (model.APIWebHook, error) {
	var it model.APIWebHook
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"endpoint", "secret"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "endpoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpoint"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpoint = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookSubscriberInput(ctx context.Context, obj any) (model.APIWebhookSubscriber, error) {
	var it model.APIWebhookSubscriber
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["retries"]; !present {
		asMap["retries"] = 0
	}
	if _, present := asMap["minDelayMs"]; !present {
		asMap["minDelayMs"] = 0
	}
	if _, present := asMap["timeoutMs"]; !present {
		asMap["timeoutMs"] = 0
	}

	fieldsInOrder := [...]string{"headers", "secret", "url", "retries", "minDelayMs", "timeoutMs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "headers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headers"))
			data, err := ec.unmarshalNWebhookHeaderInput2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx, v)
			if err != nil {
				return it, err
			}
			it.Headers = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "retries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retries"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Retries = data
		case "minDelayMs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minDelayMs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinDelayMS = data
		case "timeoutMs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeoutMs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeoutMS = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkstationConfigInput(ctx context.Context, obj any) (model.APIWorkstationConfig, error) {
	var it model.APIWorkstationConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"gitClone", "setupCommands"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "gitClone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitClone"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitClone = data
		case "setupCommands":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setupCommands"))
			data, err := ec.unmarshalOWorkstationSetupCommandInput2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetupCommands = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkstationSetupCommandInput(ctx context.Context, obj any) (model.APIWorkstationSetupCommand, error) {
	var it model.APIWorkstationSetupCommand
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"command", "directory"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "command":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("command"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Command = data
		case "directory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("directory"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Directory = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var aWSConfigImplementors = []string{"AWSConfig"}

func (ec *executionContext) _AWSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAWSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aWSConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AWSConfig")
		case "maxVolumeSizePerUser":
			out.Values[i] = ec._AWSConfig_maxVolumeSizePerUser(ctx, field, obj)
		case "pod":
			out.Values[i] = ec._AWSConfig_pod(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aWSPodConfigImplementors = []string{"AWSPodConfig"}

func (ec *executionContext) _AWSPodConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAWSPodConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aWSPodConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AWSPodConfig")
		case "ecs":
			out.Values[i] = ec._AWSPodConfig_ecs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var abortInfoImplementors = []string{"AbortInfo"}

func (ec *executionContext) _AbortInfo(ctx context.Context, sel ast.SelectionSet, obj *AbortInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, abortInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AbortInfo")
		case "buildVariantDisplayName":
			out.Values[i] = ec._AbortInfo_buildVariantDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newVersion":
			out.Values[i] = ec._AbortInfo_newVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prClosed":
			out.Values[i] = ec._AbortInfo_prClosed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskDisplayName":
			out.Values[i] = ec._AbortInfo_taskDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskID":
			out.Values[i] = ec._AbortInfo_taskID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._AbortInfo_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminSettingsImplementors = []string{"AdminSettings"}

func (ec *executionContext) _AdminSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIAdminSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminSettings")
		case "banner":
			out.Values[i] = ec._AdminSettings_banner(ctx, field, obj)
		case "bannerTheme":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdminSettings_bannerTheme(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var annotationImplementors = []string{"Annotation"}

func (ec *executionContext) _Annotation(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskAnnotation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Annotation")
		case "id":
			out.Values[i] = ec._Annotation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdIssues":
			out.Values[i] = ec._Annotation_createdIssues(ctx, field, obj)
		case "issues":
			out.Values[i] = ec._Annotation_issues(ctx, field, obj)
		case "note":
			out.Values[i] = ec._Annotation_note(ctx, field, obj)
		case "suspectedIssues":
			out.Values[i] = ec._Annotation_suspectedIssues(ctx, field, obj)
		case "metadataLinks":
			out.Values[i] = ec._Annotation_metadataLinks(ctx, field, obj)
		case "taskId":
			out.Values[i] = ec._Annotation_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskExecution":
			out.Values[i] = ec._Annotation_taskExecution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "webhookConfigured":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Annotation_webhookConfigured(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var betaFeaturesImplementors = []string{"BetaFeatures"}

func (ec *executionContext) _BetaFeatures(ctx context.Context, sel ast.SelectionSet, obj *model.APIBetaFeatures) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, betaFeaturesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BetaFeatures")
		case "spruceWaterfallEnabled":
			out.Values[i] = ec._BetaFeatures_spruceWaterfallEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bootstrapSettingsImplementors = []string{"BootstrapSettings"}

func (ec *executionContext) _BootstrapSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIBootstrapSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bootstrapSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BootstrapSettings")
		case "clientDir":
			out.Values[i] = ec._BootstrapSettings_clientDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "communication":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BootstrapSettings_communication(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "env":
			out.Values[i] = ec._BootstrapSettings_env(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "jasperBinaryDir":
			out.Values[i] = ec._BootstrapSettings_jasperBinaryDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "jasperCredentialsPath":
			out.Values[i] = ec._BootstrapSettings_jasperCredentialsPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "method":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BootstrapSettings_method(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "preconditionScripts":
			out.Values[i] = ec._BootstrapSettings_preconditionScripts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resourceLimits":
			out.Values[i] = ec._BootstrapSettings_resourceLimits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "rootDir":
			out.Values[i] = ec._BootstrapSettings_rootDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "serviceUser":
			out.Values[i] = ec._BootstrapSettings_serviceUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "shellPath":
			out.Values[i] = ec._BootstrapSettings_shellPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildImplementors = []string{"Build"}

func (ec *executionContext) _Build(ctx context.Context, sel ast.SelectionSet, obj *model.APIBuild) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Build")
		case "id":
			out.Values[i] = ec._Build_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actualMakespan":
			out.Values[i] = ec._Build_actualMakespan(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildVariant":
			out.Values[i] = ec._Build_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "predictedMakespan":
			out.Values[i] = ec._Build_predictedMakespan(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Build_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildBaronImplementors = []string{"BuildBaron"}

func (ec *executionContext) _BuildBaron(ctx context.Context, sel ast.SelectionSet, obj *BuildBaron) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildBaronImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildBaron")
		case "bbTicketCreationDefined":
			out.Values[i] = ec._BuildBaron_bbTicketCreationDefined(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildBaronConfigured":
			out.Values[i] = ec._BuildBaron_buildBaronConfigured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "searchReturnInfo":
			out.Values[i] = ec._BuildBaron_searchReturnInfo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildBaronSettingsImplementors = []string{"BuildBaronSettings"}

func (ec *executionContext) _BuildBaronSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIBuildBaronSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildBaronSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildBaronSettings")
		case "bfSuggestionFeaturesURL":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field, obj)
		case "bfSuggestionPassword":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionPassword(ctx, field, obj)
		case "bfSuggestionServer":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionServer(ctx, field, obj)
		case "bfSuggestionTimeoutSecs":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field, obj)
		case "bfSuggestionUsername":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionUsername(ctx, field, obj)
		case "ticketCreateProject":
			out.Values[i] = ec._BuildBaronSettings_ticketCreateProject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ticketSearchProjects":
			out.Values[i] = ec._BuildBaronSettings_ticketSearchProjects(ctx, field, obj)
		case "ticketCreateIssueType":
			out.Values[i] = ec._BuildBaronSettings_ticketCreateIssueType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildVariantTupleImplementors = []string{"BuildVariantTuple"}

func (ec *executionContext) _BuildVariantTuple(ctx context.Context, sel ast.SelectionSet, obj *task.BuildVariantTuple) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildVariantTupleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildVariantTuple")
		case "buildVariant":
			out.Values[i] = ec._BuildVariantTuple_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._BuildVariantTuple_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var childPatchAliasImplementors = []string{"ChildPatchAlias"}

func (ec *executionContext) _ChildPatchAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIChildPatchAlias) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, childPatchAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChildPatchAlias")
		case "alias":
			out.Values[i] = ec._ChildPatchAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchId":
			out.Values[i] = ec._ChildPatchAlias_patchId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var clientBinaryImplementors = []string{"ClientBinary"}

func (ec *executionContext) _ClientBinary(ctx context.Context, sel ast.SelectionSet, obj *model.APIClientBinary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clientBinaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClientBinary")
		case "arch":
			out.Values[i] = ec._ClientBinary_arch(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._ClientBinary_displayName(ctx, field, obj)
		case "os":
			out.Values[i] = ec._ClientBinary_os(ctx, field, obj)
		case "url":
			out.Values[i] = ec._ClientBinary_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var clientConfigImplementors = []string{"ClientConfig"}

func (ec *executionContext) _ClientConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIClientConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clientConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClientConfig")
		case "clientBinaries":
			out.Values[i] = ec._ClientConfig_clientBinaries(ctx, field, obj)
		case "latestRevision":
			out.Values[i] = ec._ClientConfig_latestRevision(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cloudProviderConfigImplementors = []string{"CloudProviderConfig"}

func (ec *executionContext) _CloudProviderConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APICloudProviders) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cloudProviderConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CloudProviderConfig")
		case "aws":
			out.Values[i] = ec._CloudProviderConfig_aws(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var commitQueueParamsImplementors = []string{"CommitQueueParams"}

func (ec *executionContext) _CommitQueueParams(ctx context.Context, sel ast.SelectionSet, obj *model.APICommitQueueParams) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commitQueueParamsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommitQueueParams")
		case "enabled":
			out.Values[i] = ec._CommitQueueParams_enabled(ctx, field, obj)
		case "mergeMethod":
			out.Values[i] = ec._CommitQueueParams_mergeMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._CommitQueueParams_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerPoolImplementors = []string{"ContainerPool"}

func (ec *executionContext) _ContainerPool(ctx context.Context, sel ast.SelectionSet, obj *model.APIContainerPool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerPoolImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerPool")
		case "id":
			out.Values[i] = ec._ContainerPool_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "distro":
			out.Values[i] = ec._ContainerPool_distro(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "maxContainers":
			out.Values[i] = ec._ContainerPool_maxContainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "port":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerPool_port(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerPoolsConfigImplementors = []string{"ContainerPoolsConfig"}

func (ec *executionContext) _ContainerPoolsConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIContainerPoolsConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerPoolsConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerPoolsConfig")
		case "pools":
			out.Values[i] = ec._ContainerPoolsConfig_pools(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerResourcesImplementors = []string{"ContainerResources"}

func (ec *executionContext) _ContainerResources(ctx context.Context, sel ast.SelectionSet, obj *model.APIContainerResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerResourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerResources")
		case "name":
			out.Values[i] = ec._ContainerResources_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cpu":
			out.Values[i] = ec._ContainerResources_cpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "memoryMb":
			out.Values[i] = ec._ContainerResources_memoryMb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteDistroPayloadImplementors = []string{"DeleteDistroPayload"}

func (ec *executionContext) _DeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *DeleteDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteDistroPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteDistroPayload")
		case "deletedDistroId":
			out.Values[i] = ec._DeleteDistroPayload_deletedDistroId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteGithubAppCredentialsPayloadImplementors = []string{"DeleteGithubAppCredentialsPayload"}

func (ec *executionContext) _DeleteGithubAppCredentialsPayload(ctx context.Context, sel ast.SelectionSet, obj *DeleteGithubAppCredentialsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteGithubAppCredentialsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteGithubAppCredentialsPayload")
		case "oldAppId":
			out.Values[i] = ec._DeleteGithubAppCredentialsPayload_oldAppId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dependencyImplementors = []string{"Dependency"}

func (ec *executionContext) _Dependency(ctx context.Context, sel ast.SelectionSet, obj *Dependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dependencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dependency")
		case "buildVariant":
			out.Values[i] = ec._Dependency_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "metStatus":
			out.Values[i] = ec._Dependency_metStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Dependency_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requiredStatus":
			out.Values[i] = ec._Dependency_requiredStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._Dependency_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dispatcherSettingsImplementors = []string{"DispatcherSettings"}

func (ec *executionContext) _DispatcherSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIDispatcherSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dispatcherSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DispatcherSettings")
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DispatcherSettings_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroImplementors = []string{"Distro"}

func (ec *executionContext) _Distro(ctx context.Context, sel ast.SelectionSet, obj *model.APIDistro) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Distro")
		case "adminOnly":
			out.Values[i] = ec._Distro_adminOnly(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "aliases":
			out.Values[i] = ec._Distro_aliases(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "arch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Distro_arch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "authorizedKeysFile":
			out.Values[i] = ec._Distro_authorizedKeysFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "bootstrapSettings":
			out.Values[i] = ec._Distro_bootstrapSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "containerPool":
			out.Values[i] = ec._Distro_containerPool(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "disabled":
			out.Values[i] = ec._Distro_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "disableShallowClone":
			out.Values[i] = ec._Distro_disableShallowClone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dispatcherSettings":
			out.Values[i] = ec._Distro_dispatcherSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "execUser":
			out.Values[i] = ec._Distro_execUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expansions":
			out.Values[i] = ec._Distro_expansions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "finderSettings":
			out.Values[i] = ec._Distro_finderSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "homeVolumeSettings":
			out.Values[i] = ec._Distro_homeVolumeSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hostAllocatorSettings":
			out.Values[i] = ec._Distro_hostAllocatorSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "iceCreamSettings":
			out.Values[i] = ec._Distro_iceCreamSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "imageId":
			out.Values[i] = ec._Distro_imageId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isCluster":
			out.Values[i] = ec._Distro_isCluster(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isVirtualWorkStation":
			out.Values[i] = ec._Distro_isVirtualWorkStation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mountpoints":
			out.Values[i] = ec._Distro_mountpoints(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Distro_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "note":
			out.Values[i] = ec._Distro_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "plannerSettings":
			out.Values[i] = ec._Distro_plannerSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "provider":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Distro_provider(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "providerSettingsList":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Distro_providerSettingsList(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "setup":
			out.Values[i] = ec._Distro_setup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "setupAsSudo":
			out.Values[i] = ec._Distro_setupAsSudo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "singleTaskDistro":
			out.Values[i] = ec._Distro_singleTaskDistro(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sshOptions":
			out.Values[i] = ec._Distro_sshOptions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			out.Values[i] = ec._Distro_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userSpawnAllowed":
			out.Values[i] = ec._Distro_userSpawnAllowed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "validProjects":
			out.Values[i] = ec._Distro_validProjects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "warningNote":
			out.Values[i] = ec._Distro_warningNote(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workDir":
			out.Values[i] = ec._Distro_workDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroEventImplementors = []string{"DistroEvent"}

func (ec *executionContext) _DistroEvent(ctx context.Context, sel ast.SelectionSet, obj *DistroEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroEvent")
		case "after":
			out.Values[i] = ec._DistroEvent_after(ctx, field, obj)
		case "before":
			out.Values[i] = ec._DistroEvent_before(ctx, field, obj)
		case "data":
			out.Values[i] = ec._DistroEvent_data(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._DistroEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._DistroEvent_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroEventsPayloadImplementors = []string{"DistroEventsPayload"}

func (ec *executionContext) _DistroEventsPayload(ctx context.Context, sel ast.SelectionSet, obj *DistroEventsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroEventsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroEventsPayload")
		case "count":
			out.Values[i] = ec._DistroEventsPayload_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._DistroEventsPayload_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroInfoImplementors = []string{"DistroInfo"}

func (ec *executionContext) _DistroInfo(ctx context.Context, sel ast.SelectionSet, obj *model.DistroInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroInfo")
		case "id":
			out.Values[i] = ec._DistroInfo_id(ctx, field, obj)
		case "bootstrapMethod":
			out.Values[i] = ec._DistroInfo_bootstrapMethod(ctx, field, obj)
		case "isVirtualWorkStation":
			out.Values[i] = ec._DistroInfo_isVirtualWorkStation(ctx, field, obj)
		case "isWindows":
			out.Values[i] = ec._DistroInfo_isWindows(ctx, field, obj)
		case "user":
			out.Values[i] = ec._DistroInfo_user(ctx, field, obj)
		case "workDir":
			out.Values[i] = ec._DistroInfo_workDir(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroPermissionsImplementors = []string{"DistroPermissions"}

func (ec *executionContext) _DistroPermissions(ctx context.Context, sel ast.SelectionSet, obj *DistroPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroPermissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroPermissions")
		case "admin":
			out.Values[i] = ec._DistroPermissions_admin(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edit":
			out.Values[i] = ec._DistroPermissions_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "view":
			out.Values[i] = ec._DistroPermissions_view(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eCSConfigImplementors = []string{"ECSConfig"}

func (ec *executionContext) _ECSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIECSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eCSConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ECSConfig")
		case "maxCPU":
			out.Values[i] = ec._ECSConfig_maxCPU(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxMemoryMb":
			out.Values[i] = ec._ECSConfig_maxMemoryMb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var envVarImplementors = []string{"EnvVar"}

func (ec *executionContext) _EnvVar(ctx context.Context, sel ast.SelectionSet, obj *model.APIEnvVar) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, envVarImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EnvVar")
		case "key":
			out.Values[i] = ec._EnvVar_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._EnvVar_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var expansionImplementors = []string{"Expansion"}

func (ec *executionContext) _Expansion(ctx context.Context, sel ast.SelectionSet, obj *model.APIExpansion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, expansionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Expansion")
		case "key":
			out.Values[i] = ec._Expansion_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._Expansion_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var externalLinkImplementors = []string{"ExternalLink"}

func (ec *executionContext) _ExternalLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIExternalLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalLinkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalLink")
		case "displayName":
			out.Values[i] = ec._ExternalLink_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requesters":
			out.Values[i] = ec._ExternalLink_requesters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "urlTemplate":
			out.Values[i] = ec._ExternalLink_urlTemplate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var externalLinkForMetadataImplementors = []string{"ExternalLinkForMetadata"}

func (ec *executionContext) _ExternalLinkForMetadata(ctx context.Context, sel ast.SelectionSet, obj *ExternalLinkForMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalLinkForMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalLinkForMetadata")
		case "url":
			out.Values[i] = ec._ExternalLinkForMetadata_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._ExternalLinkForMetadata_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileImplementors = []string{"File"}

func (ec *executionContext) _File(ctx context.Context, sel ast.SelectionSet, obj *model.APIFile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("File")
		case "link":
			out.Values[i] = ec._File_link(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._File_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "urlParsley":
			out.Values[i] = ec._File_urlParsley(ctx, field, obj)
		case "visibility":
			out.Values[i] = ec._File_visibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileDiffImplementors = []string{"FileDiff"}

func (ec *executionContext) _FileDiff(ctx context.Context, sel ast.SelectionSet, obj *model.FileDiff) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileDiffImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileDiff")
		case "additions":
			out.Values[i] = ec._FileDiff_additions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletions":
			out.Values[i] = ec._FileDiff_deletions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._FileDiff_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "diffLink":
			out.Values[i] = ec._FileDiff_diffLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileName":
			out.Values[i] = ec._FileDiff_fileName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var finderSettingsImplementors = []string{"FinderSettings"}

func (ec *executionContext) _FinderSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIFinderSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, finderSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FinderSettings")
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FinderSettings_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var generalSubscriptionImplementors = []string{"GeneralSubscription"}

func (ec *executionContext) _GeneralSubscription(ctx context.Context, sel ast.SelectionSet, obj *model.APISubscription) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, generalSubscriptionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GeneralSubscription")
		case "id":
			out.Values[i] = ec._GeneralSubscription_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ownerType":
			out.Values[i] = ec._GeneralSubscription_ownerType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "regexSelectors":
			out.Values[i] = ec._GeneralSubscription_regexSelectors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._GeneralSubscription_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectors":
			out.Values[i] = ec._GeneralSubscription_selectors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subscriber":
			out.Values[i] = ec._GeneralSubscription_subscriber(ctx, field, obj)
		case "trigger":
			out.Values[i] = ec._GeneralSubscription_trigger(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerData":
			out.Values[i] = ec._GeneralSubscription_triggerData(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var generatedTaskCountResultsImplementors = []string{"GeneratedTaskCountResults"}

func (ec *executionContext) _GeneratedTaskCountResults(ctx context.Context, sel ast.SelectionSet, obj *GeneratedTaskCountResults) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, generatedTaskCountResultsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GeneratedTaskCountResults")
		case "buildVariantName":
			out.Values[i] = ec._GeneratedTaskCountResults_buildVariantName(ctx, field, obj)
		case "taskName":
			out.Values[i] = ec._GeneratedTaskCountResults_taskName(ctx, field, obj)
		case "taskId":
			out.Values[i] = ec._GeneratedTaskCountResults_taskId(ctx, field, obj)
		case "estimatedTasks":
			out.Values[i] = ec._GeneratedTaskCountResults_estimatedTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gitHubDynamicTokenPermissionGroupImplementors = []string{"GitHubDynamicTokenPermissionGroup"}

func (ec *executionContext) _GitHubDynamicTokenPermissionGroup(ctx context.Context, sel ast.SelectionSet, obj *model.APIGitHubDynamicTokenPermissionGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitHubDynamicTokenPermissionGroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitHubDynamicTokenPermissionGroup")
		case "name":
			out.Values[i] = ec._GitHubDynamicTokenPermissionGroup_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "permissions":
			out.Values[i] = ec._GitHubDynamicTokenPermissionGroup_permissions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gitTagImplementors = []string{"GitTag"}

func (ec *executionContext) _GitTag(ctx context.Context, sel ast.SelectionSet, obj *model.APIGitTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitTag")
		case "tag":
			out.Values[i] = ec._GitTag_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pusher":
			out.Values[i] = ec._GitTag_pusher(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubAppAuthImplementors = []string{"GithubAppAuth"}

func (ec *executionContext) _GithubAppAuth(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubAppAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubAppAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubAppAuth")
		case "appId":
			out.Values[i] = ec._GithubAppAuth_appId(ctx, field, obj)
		case "privateKey":
			out.Values[i] = ec._GithubAppAuth_privateKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubCheckSubscriberImplementors = []string{"GithubCheckSubscriber"}

func (ec *executionContext) _GithubCheckSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubCheckSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubCheckSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubCheckSubscriber")
		case "owner":
			out.Values[i] = ec._GithubCheckSubscriber_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ref":
			out.Values[i] = ec._GithubCheckSubscriber_ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._GithubCheckSubscriber_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubPRSubscriberImplementors = []string{"GithubPRSubscriber"}

func (ec *executionContext) _GithubPRSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubPRSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubPRSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubPRSubscriber")
		case "owner":
			out.Values[i] = ec._GithubPRSubscriber_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prNumber":
			out.Values[i] = ec._GithubPRSubscriber_prNumber(ctx, field, obj)
		case "ref":
			out.Values[i] = ec._GithubPRSubscriber_ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._GithubPRSubscriber_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubProjectConflictsImplementors = []string{"GithubProjectConflicts"}

func (ec *executionContext) _GithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, obj *model1.GithubProjectConflicts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubProjectConflictsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubProjectConflicts")
		case "commitCheckIdentifiers":
			out.Values[i] = ec._GithubProjectConflicts_commitCheckIdentifiers(ctx, field, obj)
		case "commitQueueIdentifiers":
			out.Values[i] = ec._GithubProjectConflicts_commitQueueIdentifiers(ctx, field, obj)
		case "prTestingIdentifiers":
			out.Values[i] = ec._GithubProjectConflicts_prTestingIdentifiers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubUserImplementors = []string{"GithubUser"}

func (ec *executionContext) _GithubUser(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubUser")
		case "lastKnownAs":
			out.Values[i] = ec._GithubUser_lastKnownAs(ctx, field, obj)
		case "uid":
			out.Values[i] = ec._GithubUser_uid(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedBuildVariantImplementors = []string{"GroupedBuildVariant"}

func (ec *executionContext) _GroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *GroupedBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedBuildVariantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedBuildVariant")
		case "displayName":
			out.Values[i] = ec._GroupedBuildVariant_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._GroupedBuildVariant_tasks(ctx, field, obj)
		case "variant":
			out.Values[i] = ec._GroupedBuildVariant_variant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedFilesImplementors = []string{"GroupedFiles"}

func (ec *executionContext) _GroupedFiles(ctx context.Context, sel ast.SelectionSet, obj *GroupedFiles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedFilesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedFiles")
		case "files":
			out.Values[i] = ec._GroupedFiles_files(ctx, field, obj)
		case "taskName":
			out.Values[i] = ec._GroupedFiles_taskName(ctx, field, obj)
		case "taskId":
			out.Values[i] = ec._GroupedFiles_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "execution":
			out.Values[i] = ec._GroupedFiles_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedProjectsImplementors = []string{"GroupedProjects"}

func (ec *executionContext) _GroupedProjects(ctx context.Context, sel ast.SelectionSet, obj *GroupedProjects) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedProjectsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedProjects")
		case "groupDisplayName":
			out.Values[i] = ec._GroupedProjects_groupDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "projects":
			out.Values[i] = ec._GroupedProjects_projects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._GroupedProjects_repo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedTaskStatusCountImplementors = []string{"GroupedTaskStatusCount"}

func (ec *executionContext) _GroupedTaskStatusCount(ctx context.Context, sel ast.SelectionSet, obj *task.GroupedTaskStatusCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedTaskStatusCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedTaskStatusCount")
		case "displayName":
			out.Values[i] = ec._GroupedTaskStatusCount_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "statusCounts":
			out.Values[i] = ec._GroupedTaskStatusCount_statusCounts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variant":
			out.Values[i] = ec._GroupedTaskStatusCount_variant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var homeVolumeSettingsImplementors = []string{"HomeVolumeSettings"}

func (ec *executionContext) _HomeVolumeSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIHomeVolumeSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, homeVolumeSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HomeVolumeSettings")
		case "formatCommand":
			out.Values[i] = ec._HomeVolumeSettings_formatCommand(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostImplementors = []string{"Host"}

func (ec *executionContext) _Host(ctx context.Context, sel ast.SelectionSet, obj *model.APIHost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Host")
		case "id":
			out.Values[i] = ec._Host_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "availabilityZone":
			out.Values[i] = ec._Host_availabilityZone(ctx, field, obj)
		case "ami":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_ami(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "displayName":
			out.Values[i] = ec._Host_displayName(ctx, field, obj)
		case "distro":
			out.Values[i] = ec._Host_distro(ctx, field, obj)
		case "distroId":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_distroId(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "elapsed":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_elapsed(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventTypes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_eventTypes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "expiration":
			out.Values[i] = ec._Host_expiration(ctx, field, obj)
		case "hostUrl":
			out.Values[i] = ec._Host_hostUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "homeVolume":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_homeVolume(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "homeVolumeID":
			out.Values[i] = ec._Host_homeVolumeID(ctx, field, obj)
		case "instanceType":
			out.Values[i] = ec._Host_instanceType(ctx, field, obj)
		case "instanceTags":
			out.Values[i] = ec._Host_instanceTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastCommunicationTime":
			out.Values[i] = ec._Host_lastCommunicationTime(ctx, field, obj)
		case "noExpiration":
			out.Values[i] = ec._Host_noExpiration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "persistentDnsName":
			out.Values[i] = ec._Host_persistentDnsName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "provider":
			out.Values[i] = ec._Host_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "runningTask":
			out.Values[i] = ec._Host_runningTask(ctx, field, obj)
		case "sleepSchedule":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_sleepSchedule(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startedBy":
			out.Values[i] = ec._Host_startedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Host_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tag":
			out.Values[i] = ec._Host_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "totalIdleTime":
			out.Values[i] = ec._Host_totalIdleTime(ctx, field, obj)
		case "uptime":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_uptime(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			out.Values[i] = ec._Host_user(ctx, field, obj)
		case "volumes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_volumes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostAllocatorSettingsImplementors = []string{"HostAllocatorSettings"}

func (ec *executionContext) _HostAllocatorSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIHostAllocatorSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostAllocatorSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostAllocatorSettings")
		case "acceptableHostIdleTime":
			out.Values[i] = ec._HostAllocatorSettings_acceptableHostIdleTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feedbackRule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostAllocatorSettings_feedbackRule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "futureHostFraction":
			out.Values[i] = ec._HostAllocatorSettings_futureHostFraction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hostsOverallocatedRule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostAllocatorSettings_hostsOverallocatedRule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "maximumHosts":
			out.Values[i] = ec._HostAllocatorSettings_maximumHosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "minimumHosts":
			out.Values[i] = ec._HostAllocatorSettings_minimumHosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "roundingRule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostAllocatorSettings_roundingRule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostAllocatorSettings_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostEventLogDataImplementors = []string{"HostEventLogData"}

func (ec *executionContext) _HostEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.HostAPIEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventLogDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEventLogData")
		case "agentBuild":
			out.Values[i] = ec._HostEventLogData_agentBuild(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "agentRevision":
			out.Values[i] = ec._HostEventLogData_agentRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "duration":
			out.Values[i] = ec._HostEventLogData_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "execution":
			out.Values[i] = ec._HostEventLogData_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostname":
			out.Values[i] = ec._HostEventLogData_hostname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jasperRevision":
			out.Values[i] = ec._HostEventLogData_jasperRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "logs":
			out.Values[i] = ec._HostEventLogData_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "monitorOp":
			out.Values[i] = ec._HostEventLogData_monitorOp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newStatus":
			out.Values[i] = ec._HostEventLogData_newStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldStatus":
			out.Values[i] = ec._HostEventLogData_oldStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "provisioningMethod":
			out.Values[i] = ec._HostEventLogData_provisioningMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "successful":
			out.Values[i] = ec._HostEventLogData_successful(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._HostEventLogData_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskPid":
			out.Values[i] = ec._HostEventLogData_taskPid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskStatus":
			out.Values[i] = ec._HostEventLogData_taskStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._HostEventLogData_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostEventLogEntryImplementors = []string{"HostEventLogEntry"}

func (ec *executionContext) _HostEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.HostAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEventLogEntry")
		case "id":
			out.Values[i] = ec._HostEventLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._HostEventLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._HostEventLogEntry_eventType(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._HostEventLogEntry_processedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceId":
			out.Values[i] = ec._HostEventLogEntry_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._HostEventLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._HostEventLogEntry_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostEventsImplementors = []string{"HostEvents"}

func (ec *executionContext) _HostEvents(ctx context.Context, sel ast.SelectionSet, obj *HostEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEvents")
		case "count":
			out.Values[i] = ec._HostEvents_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._HostEvents_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostsResponseImplementors = []string{"HostsResponse"}

func (ec *executionContext) _HostsResponse(ctx context.Context, sel ast.SelectionSet, obj *HostsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostsResponse")
		case "filteredHostsCount":
			out.Values[i] = ec._HostsResponse_filteredHostsCount(ctx, field, obj)
		case "hosts":
			out.Values[i] = ec._HostsResponse_hosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalHostsCount":
			out.Values[i] = ec._HostsResponse_totalHostsCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iceCreamSettingsImplementors = []string{"IceCreamSettings"}

func (ec *executionContext) _IceCreamSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIIceCreamSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iceCreamSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IceCreamSettings")
		case "configPath":
			out.Values[i] = ec._IceCreamSettings_configPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schedulerHost":
			out.Values[i] = ec._IceCreamSettings_schedulerHost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageImplementors = []string{"Image"}

func (ec *executionContext) _Image(ctx context.Context, sel ast.SelectionSet, obj *model.APIImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Image")
		case "id":
			out.Values[i] = ec._Image_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ami":
			out.Values[i] = ec._Image_ami(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "distros":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_distros(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lastDeployed":
			out.Values[i] = ec._Image_lastDeployed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "latestTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_latestTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "operatingSystem":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_operatingSystem(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "packages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_packages(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "toolchains":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_toolchains(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageEventImplementors = []string{"ImageEvent"}

func (ec *executionContext) _ImageEvent(ctx context.Context, sel ast.SelectionSet, obj *model.APIImageEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageEvent")
		case "entries":
			out.Values[i] = ec._ImageEvent_entries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ImageEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "amiBefore":
			out.Values[i] = ec._ImageEvent_amiBefore(ctx, field, obj)
		case "amiAfter":
			out.Values[i] = ec._ImageEvent_amiAfter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageEventEntryImplementors = []string{"ImageEventEntry"}

func (ec *executionContext) _ImageEventEntry(ctx context.Context, sel ast.SelectionSet, obj *model.APIImageEventEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageEventEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageEventEntry")
		case "name":
			out.Values[i] = ec._ImageEventEntry_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "after":
			out.Values[i] = ec._ImageEventEntry_after(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "before":
			out.Values[i] = ec._ImageEventEntry_before(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ImageEventEntry_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "action":
			out.Values[i] = ec._ImageEventEntry_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageEventsPayloadImplementors = []string{"ImageEventsPayload"}

func (ec *executionContext) _ImageEventsPayload(ctx context.Context, sel ast.SelectionSet, obj *ImageEventsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageEventsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageEventsPayload")
		case "count":
			out.Values[i] = ec._ImageEventsPayload_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._ImageEventsPayload_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageOperatingSystemPayloadImplementors = []string{"ImageOperatingSystemPayload"}

func (ec *executionContext) _ImageOperatingSystemPayload(ctx context.Context, sel ast.SelectionSet, obj *ImageOperatingSystemPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageOperatingSystemPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageOperatingSystemPayload")
		case "data":
			out.Values[i] = ec._ImageOperatingSystemPayload_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredCount":
			out.Values[i] = ec._ImageOperatingSystemPayload_filteredCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ImageOperatingSystemPayload_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imagePackagesPayloadImplementors = []string{"ImagePackagesPayload"}

func (ec *executionContext) _ImagePackagesPayload(ctx context.Context, sel ast.SelectionSet, obj *ImagePackagesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imagePackagesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImagePackagesPayload")
		case "data":
			out.Values[i] = ec._ImagePackagesPayload_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredCount":
			out.Values[i] = ec._ImagePackagesPayload_filteredCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ImagePackagesPayload_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageToolchainsPayloadImplementors = []string{"ImageToolchainsPayload"}

func (ec *executionContext) _ImageToolchainsPayload(ctx context.Context, sel ast.SelectionSet, obj *ImageToolchainsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageToolchainsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageToolchainsPayload")
		case "data":
			out.Values[i] = ec._ImageToolchainsPayload_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredCount":
			out.Values[i] = ec._ImageToolchainsPayload_filteredCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ImageToolchainsPayload_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var instanceTagImplementors = []string{"InstanceTag"}

func (ec *executionContext) _InstanceTag(ctx context.Context, sel ast.SelectionSet, obj *host.Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, instanceTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InstanceTag")
		case "canBeModified":
			out.Values[i] = ec._InstanceTag_canBeModified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "key":
			out.Values[i] = ec._InstanceTag_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._InstanceTag_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var issueLinkImplementors = []string{"IssueLink"}

func (ec *executionContext) _IssueLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIIssueLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, issueLinkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IssueLink")
		case "confidenceScore":
			out.Values[i] = ec._IssueLink_confidenceScore(ctx, field, obj)
		case "issueKey":
			out.Values[i] = ec._IssueLink_issueKey(ctx, field, obj)
		case "jiraTicket":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IssueLink_jiraTicket(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "source":
			out.Values[i] = ec._IssueLink_source(ctx, field, obj)
		case "url":
			out.Values[i] = ec._IssueLink_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraConfigImplementors = []string{"JiraConfig"}

func (ec *executionContext) _JiraConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIJiraConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraConfig")
		case "email":
			out.Values[i] = ec._JiraConfig_email(ctx, field, obj)
		case "host":
			out.Values[i] = ec._JiraConfig_host(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraIssueSubscriberImplementors = []string{"JiraIssueSubscriber"}

func (ec *executionContext) _JiraIssueSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIJIRAIssueSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraIssueSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraIssueSubscriber")
		case "issueType":
			out.Values[i] = ec._JiraIssueSubscriber_issueType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec._JiraIssueSubscriber_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraStatusImplementors = []string{"JiraStatus"}

func (ec *executionContext) _JiraStatus(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.JiraStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraStatus")
		case "id":
			out.Values[i] = ec._JiraStatus_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._JiraStatus_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraTicketImplementors = []string{"JiraTicket"}

func (ec *executionContext) _JiraTicket(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.JiraTicket) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraTicketImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraTicket")
		case "fields":
			out.Values[i] = ec._JiraTicket_fields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "key":
			out.Values[i] = ec._JiraTicket_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logMessageImplementors = []string{"LogMessage"}

func (ec *executionContext) _LogMessage(ctx context.Context, sel ast.SelectionSet, obj *apimodels.LogMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logMessageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogMessage")
		case "message":
			out.Values[i] = ec._LogMessage_message(ctx, field, obj)
		case "severity":
			out.Values[i] = ec._LogMessage_severity(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._LogMessage_timestamp(ctx, field, obj)
		case "type":
			out.Values[i] = ec._LogMessage_type(ctx, field, obj)
		case "version":
			out.Values[i] = ec._LogMessage_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logkeeperBuildImplementors = []string{"LogkeeperBuild"}

func (ec *executionContext) _LogkeeperBuild(ctx context.Context, sel ast.SelectionSet, obj *plank.Build) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logkeeperBuildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogkeeperBuild")
		case "id":
			out.Values[i] = ec._LogkeeperBuild_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "builder":
			out.Values[i] = ec._LogkeeperBuild_builder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildNum":
			out.Values[i] = ec._LogkeeperBuild_buildNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskId":
			out.Values[i] = ec._LogkeeperBuild_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskExecution":
			out.Values[i] = ec._LogkeeperBuild_taskExecution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tests":
			out.Values[i] = ec._LogkeeperBuild_tests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "task":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LogkeeperBuild_task(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logkeeperTestImplementors = []string{"LogkeeperTest"}

func (ec *executionContext) _LogkeeperTest(ctx context.Context, sel ast.SelectionSet, obj *plank.Test) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logkeeperTestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogkeeperTest")
		case "id":
			out.Values[i] = ec._LogkeeperTest_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._LogkeeperTest_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildId":
			out.Values[i] = ec._LogkeeperTest_buildId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._LogkeeperTest_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskExecution":
			out.Values[i] = ec._LogkeeperTest_taskExecution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phase":
			out.Values[i] = ec._LogkeeperTest_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "command":
			out.Values[i] = ec._LogkeeperTest_command(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mainlineCommitVersionImplementors = []string{"MainlineCommitVersion"}

func (ec *executionContext) _MainlineCommitVersion(ctx context.Context, sel ast.SelectionSet, obj *MainlineCommitVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mainlineCommitVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MainlineCommitVersion")
		case "rolledUpVersions":
			out.Values[i] = ec._MainlineCommitVersion_rolledUpVersions(ctx, field, obj)
		case "version":
			out.Values[i] = ec._MainlineCommitVersion_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mainlineCommitsImplementors = []string{"MainlineCommits"}

func (ec *executionContext) _MainlineCommits(ctx context.Context, sel ast.SelectionSet, obj *MainlineCommits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mainlineCommitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MainlineCommits")
		case "nextPageOrderNumber":
			out.Values[i] = ec._MainlineCommits_nextPageOrderNumber(ctx, field, obj)
		case "prevPageOrderNumber":
			out.Values[i] = ec._MainlineCommits_prevPageOrderNumber(ctx, field, obj)
		case "versions":
			out.Values[i] = ec._MainlineCommits_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var manifestImplementors = []string{"Manifest"}

func (ec *executionContext) _Manifest(ctx context.Context, sel ast.SelectionSet, obj *Manifest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, manifestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Manifest")
		case "id":
			out.Values[i] = ec._Manifest_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "branch":
			out.Values[i] = ec._Manifest_branch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isBase":
			out.Values[i] = ec._Manifest_isBase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "moduleOverrides":
			out.Values[i] = ec._Manifest_moduleOverrides(ctx, field, obj)
		case "modules":
			out.Values[i] = ec._Manifest_modules(ctx, field, obj)
		case "project":
			out.Values[i] = ec._Manifest_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revision":
			out.Values[i] = ec._Manifest_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var metadataLinkImplementors = []string{"MetadataLink"}

func (ec *executionContext) _MetadataLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIMetadataLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metadataLinkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetadataLink")
		case "url":
			out.Values[i] = ec._MetadataLink_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "text":
			out.Values[i] = ec._MetadataLink_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "source":
			out.Values[i] = ec._MetadataLink_source(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var moduleCodeChangeImplementors = []string{"ModuleCodeChange"}

func (ec *executionContext) _ModuleCodeChange(ctx context.Context, sel ast.SelectionSet, obj *model.APIModulePatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, moduleCodeChangeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModuleCodeChange")
		case "branchName":
			out.Values[i] = ec._ModuleCodeChange_branchName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileDiffs":
			out.Values[i] = ec._ModuleCodeChange_fileDiffs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "htmlLink":
			out.Values[i] = ec._ModuleCodeChange_htmlLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rawLink":
			out.Values[i] = ec._ModuleCodeChange_rawLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "bbCreateTicket":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bbCreateTicket(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addAnnotationIssue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addAnnotationIssue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editAnnotationNote":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editAnnotationNote(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "moveAnnotationIssue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_moveAnnotationIssue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeAnnotationIssue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeAnnotationIssue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setAnnotationMetadataLinks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setAnnotationMetadataLinks(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "copyDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_copyDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reprovisionToNew":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reprovisionToNew(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartJasper":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartJasper(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateHostStatus":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateHostStatus(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setPatchVisibility":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setPatchVisibility(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schedulePatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_schedulePatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachProjectToNewRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachProjectToNewRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachProjectToRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachProjectToRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "copyProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_copyProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deactivateStepbackTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deactivateStepbackTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultSectionToRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_defaultSectionToRepo(ctx, field)
			})
		case "deleteGithubAppCredentials":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGithubAppCredentials(ctx, field)
			})
		case "deleteProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detachProjectFromRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_detachProjectFromRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "forceRepotrackerRun":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_forceRepotrackerRun(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "promoteVarsToRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_promoteVarsToRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveProjectSettingsForSection":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveProjectSettingsForSection(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveRepoSettingsForSection":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveRepoSettingsForSection(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setLastRevision":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setLastRevision(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachVolumeToHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachVolumeToHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detachVolumeFromHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_detachVolumeFromHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editSpawnHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editSpawnHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "migrateVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_migrateVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spawnHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_spawnHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spawnVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_spawnVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSpawnHostStatus":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSpawnHostStatus(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "abortTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_abortTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "overrideTaskDependencies":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_overrideTaskDependencies(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scheduleTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_scheduleTasks(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setTaskPriority":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setTaskPriority(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unscheduleTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unscheduleTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addFavoriteProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addFavoriteProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clearMySubscriptions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_clearMySubscriptions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createPublicKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPublicKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSubscriptions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSubscriptions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeFavoriteProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeFavoriteProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removePublicKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removePublicKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveSubscription":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveSubscription(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBetaFeatures":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBetaFeatures(ctx, field)
			})
		case "updateParsleySettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateParsleySettings(ctx, field)
			})
		case "updatePublicKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePublicKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUserSettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserSettings(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartVersions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartVersions(ctx, field)
			})
		case "scheduleUndispatchedBaseTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_scheduleUndispatchedBaseTasks(ctx, field)
			})
		case "setVersionPriority":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setVersionPriority(ctx, field)
			})
		case "unscheduleVersionTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unscheduleVersionTasks(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var newDistroPayloadImplementors = []string{"NewDistroPayload"}

func (ec *executionContext) _NewDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *NewDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, newDistroPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NewDistroPayload")
		case "newDistroId":
			out.Values[i] = ec._NewDistroPayload_newDistroId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var noteImplementors = []string{"Note"}

func (ec *executionContext) _Note(ctx context.Context, sel ast.SelectionSet, obj *model.APINote) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, noteImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Note")
		case "message":
			out.Values[i] = ec._Note_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "source":
			out.Values[i] = ec._Note_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationsImplementors = []string{"Notifications"}

func (ec *executionContext) _Notifications(ctx context.Context, sel ast.SelectionSet, obj *model.APINotificationPreferences) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Notifications")
		case "buildBreak":
			out.Values[i] = ec._Notifications_buildBreak(ctx, field, obj)
		case "buildBreakId":
			out.Values[i] = ec._Notifications_buildBreakId(ctx, field, obj)
		case "patchFinish":
			out.Values[i] = ec._Notifications_patchFinish(ctx, field, obj)
		case "patchFinishId":
			out.Values[i] = ec._Notifications_patchFinishId(ctx, field, obj)
		case "patchFirstFailure":
			out.Values[i] = ec._Notifications_patchFirstFailure(ctx, field, obj)
		case "patchFirstFailureId":
			out.Values[i] = ec._Notifications_patchFirstFailureId(ctx, field, obj)
		case "spawnHostExpiration":
			out.Values[i] = ec._Notifications_spawnHostExpiration(ctx, field, obj)
		case "spawnHostExpirationId":
			out.Values[i] = ec._Notifications_spawnHostExpirationId(ctx, field, obj)
		case "spawnHostOutcome":
			out.Values[i] = ec._Notifications_spawnHostOutcome(ctx, field, obj)
		case "spawnHostOutcomeId":
			out.Values[i] = ec._Notifications_spawnHostOutcomeId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oSInfoImplementors = []string{"OSInfo"}

func (ec *executionContext) _OSInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APIOSInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oSInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OSInfo")
		case "name":
			out.Values[i] = ec._OSInfo_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._OSInfo_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oomTrackerInfoImplementors = []string{"OomTrackerInfo"}

func (ec *executionContext) _OomTrackerInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APIOomTrackerInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oomTrackerInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OomTrackerInfo")
		case "detected":
			out.Values[i] = ec._OomTrackerInfo_detected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pids":
			out.Values[i] = ec._OomTrackerInfo_pids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var packageImplementors = []string{"Package"}

func (ec *executionContext) _Package(ctx context.Context, sel ast.SelectionSet, obj *model.APIPackage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Package")
		case "name":
			out.Values[i] = ec._Package_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "manager":
			out.Values[i] = ec._Package_manager(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Package_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parameterImplementors = []string{"Parameter"}

func (ec *executionContext) _Parameter(ctx context.Context, sel ast.SelectionSet, obj *model.APIParameter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parameterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Parameter")
		case "key":
			out.Values[i] = ec._Parameter_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._Parameter_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parsleyFilterImplementors = []string{"ParsleyFilter"}

func (ec *executionContext) _ParsleyFilter(ctx context.Context, sel ast.SelectionSet, obj *model.APIParsleyFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parsleyFilterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ParsleyFilter")
		case "expression":
			out.Values[i] = ec._ParsleyFilter_expression(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "caseSensitive":
			out.Values[i] = ec._ParsleyFilter_caseSensitive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exactMatch":
			out.Values[i] = ec._ParsleyFilter_exactMatch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parsleySettingsImplementors = []string{"ParsleySettings"}

func (ec *executionContext) _ParsleySettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIParsleySettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parsleySettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ParsleySettings")
		case "sectionsEnabled":
			out.Values[i] = ec._ParsleySettings_sectionsEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jumpToFailingLineEnabled":
			out.Values[i] = ec._ParsleySettings_jumpToFailingLineEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchImplementors = []string{"Patch"}

func (ec *executionContext) _Patch(ctx context.Context, sel ast.SelectionSet, obj *model.APIPatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Patch")
		case "id":
			out.Values[i] = ec._Patch_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activated":
			out.Values[i] = ec._Patch_activated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "alias":
			out.Values[i] = ec._Patch_alias(ctx, field, obj)
		case "author":
			out.Values[i] = ec._Patch_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authorDisplayName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_authorDisplayName(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "baseTaskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_baseTaskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "builds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_builds(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "childPatchAliases":
			out.Values[i] = ec._Patch_childPatchAliases(ctx, field, obj)
		case "childPatches":
			out.Values[i] = ec._Patch_childPatches(ctx, field, obj)
		case "createTime":
			out.Values[i] = ec._Patch_createTime(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Patch_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "duration":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_duration(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "generatedTaskCounts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_generatedTaskCounts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githash":
			out.Values[i] = ec._Patch_githash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hidden":
			out.Values[i] = ec._Patch_hidden(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "moduleCodeChanges":
			out.Values[i] = ec._Patch_moduleCodeChanges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parameters":
			out.Values[i] = ec._Patch_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patchNumber":
			out.Values[i] = ec._Patch_patchNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patchTriggerAliases":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_patchTriggerAliases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "project":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_project(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectID":
			out.Values[i] = ec._Patch_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_projectIdentifier(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectMetadata":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_projectMetadata(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._Patch_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskCount":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_taskCount(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tasks":
			out.Values[i] = ec._Patch_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_taskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "time":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_time(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "variants":
			out.Values[i] = ec._Patch_variants(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "variantsTasks":
			out.Values[i] = ec._Patch_variantsTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "versionFull":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_versionFull(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchDurationImplementors = []string{"PatchDuration"}

func (ec *executionContext) _PatchDuration(ctx context.Context, sel ast.SelectionSet, obj *PatchDuration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchDurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchDuration")
		case "makespan":
			out.Values[i] = ec._PatchDuration_makespan(ctx, field, obj)
		case "time":
			out.Values[i] = ec._PatchDuration_time(ctx, field, obj)
		case "timeTaken":
			out.Values[i] = ec._PatchDuration_timeTaken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchProjectImplementors = []string{"PatchProject"}

func (ec *executionContext) _PatchProject(ctx context.Context, sel ast.SelectionSet, obj *PatchProject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchProjectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchProject")
		case "variants":
			out.Values[i] = ec._PatchProject_variants(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchTimeImplementors = []string{"PatchTime"}

func (ec *executionContext) _PatchTime(ctx context.Context, sel ast.SelectionSet, obj *PatchTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchTimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchTime")
		case "finished":
			out.Values[i] = ec._PatchTime_finished(ctx, field, obj)
		case "started":
			out.Values[i] = ec._PatchTime_started(ctx, field, obj)
		case "submittedAt":
			out.Values[i] = ec._PatchTime_submittedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchTriggerAliasImplementors = []string{"PatchTriggerAlias"}

func (ec *executionContext) _PatchTriggerAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIPatchTriggerDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchTriggerAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchTriggerAlias")
		case "alias":
			out.Values[i] = ec._PatchTriggerAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "childProjectId":
			out.Values[i] = ec._PatchTriggerAlias_childProjectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "childProjectIdentifier":
			out.Values[i] = ec._PatchTriggerAlias_childProjectIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parentAsModule":
			out.Values[i] = ec._PatchTriggerAlias_parentAsModule(ctx, field, obj)
		case "status":
			out.Values[i] = ec._PatchTriggerAlias_status(ctx, field, obj)
		case "downstreamRevision":
			out.Values[i] = ec._PatchTriggerAlias_downstreamRevision(ctx, field, obj)
		case "taskSpecifiers":
			out.Values[i] = ec._PatchTriggerAlias_taskSpecifiers(ctx, field, obj)
		case "variantsTasks":
			out.Values[i] = ec._PatchTriggerAlias_variantsTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchesImplementors = []string{"Patches"}

func (ec *executionContext) _Patches(ctx context.Context, sel ast.SelectionSet, obj *Patches) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Patches")
		case "filteredPatchCount":
			out.Values[i] = ec._Patches_filteredPatchCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patches":
			out.Values[i] = ec._Patches_patches(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var periodicBuildImplementors = []string{"PeriodicBuild"}

func (ec *executionContext) _PeriodicBuild(ctx context.Context, sel ast.SelectionSet, obj *model.APIPeriodicBuildDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, periodicBuildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PeriodicBuild")
		case "id":
			out.Values[i] = ec._PeriodicBuild_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alias":
			out.Values[i] = ec._PeriodicBuild_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configFile":
			out.Values[i] = ec._PeriodicBuild_configFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "intervalHours":
			out.Values[i] = ec._PeriodicBuild_intervalHours(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cron":
			out.Values[i] = ec._PeriodicBuild_cron(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._PeriodicBuild_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextRunTime":
			out.Values[i] = ec._PeriodicBuild_nextRunTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var permissionsImplementors = []string{"Permissions"}

func (ec *executionContext) _Permissions(ctx context.Context, sel ast.SelectionSet, obj *Permissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, permissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Permissions")
		case "canCreateDistro":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canCreateDistro(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canCreateProject":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canCreateProject(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canEditAdminSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canEditAdminSettings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "distroPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_distroPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_projectPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "repoPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_repoPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userId":
			out.Values[i] = ec._Permissions_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var plannerSettingsImplementors = []string{"PlannerSettings"}

func (ec *executionContext) _PlannerSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIPlannerSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plannerSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlannerSettings")
		case "commitQueueFactor":
			out.Values[i] = ec._PlannerSettings_commitQueueFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expectedRuntimeFactor":
			out.Values[i] = ec._PlannerSettings_expectedRuntimeFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "generateTaskFactor":
			out.Values[i] = ec._PlannerSettings_generateTaskFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "numDependentsFactor":
			out.Values[i] = ec._PlannerSettings_numDependentsFactor(ctx, field, obj)
		case "groupVersions":
			out.Values[i] = ec._PlannerSettings_groupVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mainlineTimeInQueueFactor":
			out.Values[i] = ec._PlannerSettings_mainlineTimeInQueueFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patchFactor":
			out.Values[i] = ec._PlannerSettings_patchFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patchTimeInQueueFactor":
			out.Values[i] = ec._PlannerSettings_patchTimeInQueueFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "targetTime":
			out.Values[i] = ec._PlannerSettings_targetTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlannerSettings_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podImplementors = []string{"Pod"}

func (ec *executionContext) _Pod(ctx context.Context, sel ast.SelectionSet, obj *model.APIPod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pod")
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "id":
			out.Values[i] = ec._Pod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "task":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_task(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskContainerCreationOpts":
			out.Values[i] = ec._Pod_taskContainerCreationOpts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podEventLogDataImplementors = []string{"PodEventLogData"}

func (ec *executionContext) _PodEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.PodAPIEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventLogDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEventLogData")
		case "oldStatus":
			out.Values[i] = ec._PodEventLogData_oldStatus(ctx, field, obj)
		case "newStatus":
			out.Values[i] = ec._PodEventLogData_newStatus(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._PodEventLogData_reason(ctx, field, obj)
		case "taskID":
			out.Values[i] = ec._PodEventLogData_taskID(ctx, field, obj)
		case "taskExecution":
			out.Values[i] = ec._PodEventLogData_taskExecution(ctx, field, obj)
		case "taskStatus":
			out.Values[i] = ec._PodEventLogData_taskStatus(ctx, field, obj)
		case "task":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PodEventLogData_task(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podEventLogEntryImplementors = []string{"PodEventLogEntry"}

func (ec *executionContext) _PodEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.PodAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEventLogEntry")
		case "id":
			out.Values[i] = ec._PodEventLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._PodEventLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._PodEventLogEntry_eventType(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._PodEventLogEntry_processedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceId":
			out.Values[i] = ec._PodEventLogEntry_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._PodEventLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._PodEventLogEntry_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podEventsImplementors = []string{"PodEvents"}

func (ec *executionContext) _PodEvents(ctx context.Context, sel ast.SelectionSet, obj *PodEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEvents")
		case "count":
			out.Values[i] = ec._PodEvents_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._PodEvents_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var preconditionScriptImplementors = []string{"PreconditionScript"}

func (ec *executionContext) _PreconditionScript(ctx context.Context, sel ast.SelectionSet, obj *model.APIPreconditionScript) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preconditionScriptImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreconditionScript")
		case "path":
			out.Values[i] = ec._PreconditionScript_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "script":
			out.Values[i] = ec._PreconditionScript_script(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectImplementors = []string{"Project"}

func (ec *executionContext) _Project(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectRef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Project")
		case "id":
			out.Values[i] = ec._Project_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "admins":
			out.Values[i] = ec._Project_admins(ctx, field, obj)
		case "banner":
			out.Values[i] = ec._Project_banner(ctx, field, obj)
		case "batchTime":
			out.Values[i] = ec._Project_batchTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "branch":
			out.Values[i] = ec._Project_branch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildBaronSettings":
			out.Values[i] = ec._Project_buildBaronSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "commitQueue":
			out.Values[i] = ec._Project_commitQueue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "containerSizeDefinitions":
			out.Values[i] = ec._Project_containerSizeDefinitions(ctx, field, obj)
		case "deactivatePrevious":
			out.Values[i] = ec._Project_deactivatePrevious(ctx, field, obj)
		case "disabledStatsCache":
			out.Values[i] = ec._Project_disabledStatsCache(ctx, field, obj)
		case "dispatchingDisabled":
			out.Values[i] = ec._Project_dispatchingDisabled(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Project_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "enabled":
			out.Values[i] = ec._Project_enabled(ctx, field, obj)
		case "externalLinks":
			out.Values[i] = ec._Project_externalLinks(ctx, field, obj)
		case "githubChecksEnabled":
			out.Values[i] = ec._Project_githubChecksEnabled(ctx, field, obj)
		case "githubDynamicTokenPermissionGroups":
			out.Values[i] = ec._Project_githubDynamicTokenPermissionGroups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "githubPermissionGroupByRequester":
			out.Values[i] = ec._Project_githubPermissionGroupByRequester(ctx, field, obj)
		case "githubTriggerAliases":
			out.Values[i] = ec._Project_githubTriggerAliases(ctx, field, obj)
		case "gitTagAuthorizedTeams":
			out.Values[i] = ec._Project_gitTagAuthorizedTeams(ctx, field, obj)
		case "gitTagAuthorizedUsers":
			out.Values[i] = ec._Project_gitTagAuthorizedUsers(ctx, field, obj)
		case "gitTagVersionsEnabled":
			out.Values[i] = ec._Project_gitTagVersionsEnabled(ctx, field, obj)
		case "hidden":
			out.Values[i] = ec._Project_hidden(ctx, field, obj)
		case "identifier":
			out.Values[i] = ec._Project_identifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isFavorite":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_isFavorite(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manualPrTestingEnabled":
			out.Values[i] = ec._Project_manualPrTestingEnabled(ctx, field, obj)
		case "notifyOnBuildFailure":
			out.Values[i] = ec._Project_notifyOnBuildFailure(ctx, field, obj)
		case "oldestAllowedMergeBase":
			out.Values[i] = ec._Project_oldestAllowedMergeBase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "owner":
			out.Values[i] = ec._Project_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parsleyFilters":
			out.Values[i] = ec._Project_parsleyFilters(ctx, field, obj)
		case "patches":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_patches(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "patchingDisabled":
			out.Values[i] = ec._Project_patchingDisabled(ctx, field, obj)
		case "patchTriggerAliases":
			out.Values[i] = ec._Project_patchTriggerAliases(ctx, field, obj)
		case "perfEnabled":
			out.Values[i] = ec._Project_perfEnabled(ctx, field, obj)
		case "periodicBuilds":
			out.Values[i] = ec._Project_periodicBuilds(ctx, field, obj)
		case "projectHealthView":
			out.Values[i] = ec._Project_projectHealthView(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "prTestingEnabled":
			out.Values[i] = ec._Project_prTestingEnabled(ctx, field, obj)
		case "remotePath":
			out.Values[i] = ec._Project_remotePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repo":
			out.Values[i] = ec._Project_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repoRefId":
			out.Values[i] = ec._Project_repoRefId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repotrackerDisabled":
			out.Values[i] = ec._Project_repotrackerDisabled(ctx, field, obj)
		case "repotrackerError":
			out.Values[i] = ec._Project_repotrackerError(ctx, field, obj)
		case "restricted":
			out.Values[i] = ec._Project_restricted(ctx, field, obj)
		case "spawnHostScriptPath":
			out.Values[i] = ec._Project_spawnHostScriptPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stepbackDisabled":
			out.Values[i] = ec._Project_stepbackDisabled(ctx, field, obj)
		case "stepbackBisect":
			out.Values[i] = ec._Project_stepbackBisect(ctx, field, obj)
		case "taskAnnotationSettings":
			out.Values[i] = ec._Project_taskAnnotationSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tracksPushEvents":
			out.Values[i] = ec._Project_tracksPushEvents(ctx, field, obj)
		case "triggers":
			out.Values[i] = ec._Project_triggers(ctx, field, obj)
		case "versionControlEnabled":
			out.Values[i] = ec._Project_versionControlEnabled(ctx, field, obj)
		case "workstationConfig":
			out.Values[i] = ec._Project_workstationConfig(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectAliasImplementors = []string{"ProjectAlias"}

func (ec *executionContext) _ProjectAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectAlias) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectAlias")
		case "id":
			out.Values[i] = ec._ProjectAlias_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alias":
			out.Values[i] = ec._ProjectAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ProjectAlias_description(ctx, field, obj)
		case "gitTag":
			out.Values[i] = ec._ProjectAlias_gitTag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remotePath":
			out.Values[i] = ec._ProjectAlias_remotePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "task":
			out.Values[i] = ec._ProjectAlias_task(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskTags":
			out.Values[i] = ec._ProjectAlias_taskTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variant":
			out.Values[i] = ec._ProjectAlias_variant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variantTags":
			out.Values[i] = ec._ProjectAlias_variantTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parameters":
			out.Values[i] = ec._ProjectAlias_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectBannerImplementors = []string{"ProjectBanner"}

func (ec *executionContext) _ProjectBanner(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectBanner) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectBannerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectBanner")
		case "text":
			out.Values[i] = ec._ProjectBanner_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "theme":
			out.Values[i] = ec._ProjectBanner_theme(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectBuildVariantImplementors = []string{"ProjectBuildVariant"}

func (ec *executionContext) _ProjectBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *ProjectBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectBuildVariantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectBuildVariant")
		case "displayName":
			out.Values[i] = ec._ProjectBuildVariant_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ProjectBuildVariant_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._ProjectBuildVariant_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectEventLogEntryImplementors = []string{"ProjectEventLogEntry"}

func (ec *executionContext) _ProjectEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEventLogEntry")
		case "after":
			out.Values[i] = ec._ProjectEventLogEntry_after(ctx, field, obj)
		case "before":
			out.Values[i] = ec._ProjectEventLogEntry_before(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._ProjectEventLogEntry_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._ProjectEventLogEntry_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectEventSettingsImplementors = []string{"ProjectEventSettings"}

func (ec *executionContext) _ProjectEventSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectEventSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEventSettings")
		case "aliases":
			out.Values[i] = ec._ProjectEventSettings_aliases(ctx, field, obj)
		case "githubAppAuth":
			out.Values[i] = ec._ProjectEventSettings_githubAppAuth(ctx, field, obj)
		case "githubWebhooksEnabled":
			out.Values[i] = ec._ProjectEventSettings_githubWebhooksEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "projectRef":
			out.Values[i] = ec._ProjectEventSettings_projectRef(ctx, field, obj)
		case "subscriptions":
			out.Values[i] = ec._ProjectEventSettings_subscriptions(ctx, field, obj)
		case "vars":
			out.Values[i] = ec._ProjectEventSettings_vars(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectEventsImplementors = []string{"ProjectEvents"}

func (ec *executionContext) _ProjectEvents(ctx context.Context, sel ast.SelectionSet, obj *ProjectEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEvents")
		case "count":
			out.Values[i] = ec._ProjectEvents_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._ProjectEvents_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectPermissionsImplementors = []string{"ProjectPermissions"}

func (ec *executionContext) _ProjectPermissions(ctx context.Context, sel ast.SelectionSet, obj *ProjectPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectPermissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectPermissions")
		case "edit":
			out.Values[i] = ec._ProjectPermissions_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "view":
			out.Values[i] = ec._ProjectPermissions_view(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectSettingsImplementors = []string{"ProjectSettings"}

func (ec *executionContext) _ProjectSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectSettings")
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_aliases(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubAppAuth":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_githubAppAuth(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubWebhooksEnabled":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_githubWebhooksEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectRef":
			out.Values[i] = ec._ProjectSettings_projectRef(ctx, field, obj)
		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_subscriptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vars":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_vars(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectTasksPairImplementors = []string{"ProjectTasksPair"}

func (ec *executionContext) _ProjectTasksPair(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectTasksPair) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectTasksPairImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectTasksPair")
		case "projectId":
			out.Values[i] = ec._ProjectTasksPair_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowedTasks":
			out.Values[i] = ec._ProjectTasksPair_allowedTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowedBVs":
			out.Values[i] = ec._ProjectTasksPair_allowedBVs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectVarsImplementors = []string{"ProjectVars"}

func (ec *executionContext) _ProjectVars(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectVars) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectVarsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectVars")
		case "adminOnlyVars":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectVars_adminOnlyVars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "privateVars":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectVars_privateVars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vars":
			out.Values[i] = ec._ProjectVars_vars(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var publicKeyImplementors = []string{"PublicKey"}

func (ec *executionContext) _PublicKey(ctx context.Context, sel ast.SelectionSet, obj *model.APIPubKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, publicKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublicKey")
		case "key":
			out.Values[i] = ec._PublicKey_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._PublicKey_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "bbGetCreatedTickets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bbGetCreatedTickets(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "buildBaron":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildBaron(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "awsRegions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_awsRegions(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "clientConfig":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_clientConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "instanceTypes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_instanceTypes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "spruceConfig":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_spruceConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "subnetAvailabilityZones":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_subnetAvailabilityZones(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distro":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distro(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distroEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distroEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distros":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distros(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distroTaskQueue":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distroTaskQueue(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "host":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_host(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hostEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hostEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hosts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hosts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskQueueDistros":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskQueueDistros(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "pod":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_pod(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "patch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_patch(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "githubProjectConflicts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubProjectConflicts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_project(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "projects":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projects(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "projectEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "projectSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "repoEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "repoSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "viewableProjectRefs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewableProjectRefs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "isRepo":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_isRepo(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myHosts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myHosts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myVolumes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myVolumes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "logkeeperBuildMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_logkeeperBuildMetadata(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "task":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_task(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskAllExecutions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskAllExecutions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskTestSample":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskTestSample(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myPublicKeys":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myPublicKeys(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userConfig":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "buildVariantsForTaskName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildVariantsForTaskName(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "mainlineCommits":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_mainlineCommits(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskNamesForBuildVariant":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskNamesForBuildVariant(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "waterfall":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_waterfall(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskHistory(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hasVersion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hasVersion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_version(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "image":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_image(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "images":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_images(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoCommitQueueParamsImplementors = []string{"RepoCommitQueueParams"}

func (ec *executionContext) _RepoCommitQueueParams(ctx context.Context, sel ast.SelectionSet, obj *model.APICommitQueueParams) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoCommitQueueParamsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoCommitQueueParams")
		case "enabled":
			out.Values[i] = ec._RepoCommitQueueParams_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mergeMethod":
			out.Values[i] = ec._RepoCommitQueueParams_mergeMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RepoCommitQueueParams_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoPermissionsImplementors = []string{"RepoPermissions"}

func (ec *executionContext) _RepoPermissions(ctx context.Context, sel ast.SelectionSet, obj *RepoPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoPermissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoPermissions")
		case "edit":
			out.Values[i] = ec._RepoPermissions_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "view":
			out.Values[i] = ec._RepoPermissions_view(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoRefImplementors = []string{"RepoRef"}

func (ec *executionContext) _RepoRef(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectRef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoRefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoRef")
		case "id":
			out.Values[i] = ec._RepoRef_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "admins":
			out.Values[i] = ec._RepoRef_admins(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "batchTime":
			out.Values[i] = ec._RepoRef_batchTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildBaronSettings":
			out.Values[i] = ec._RepoRef_buildBaronSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "commitQueue":
			out.Values[i] = ec._RepoRef_commitQueue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "containerSizeDefinitions":
			out.Values[i] = ec._RepoRef_containerSizeDefinitions(ctx, field, obj)
		case "deactivatePrevious":
			out.Values[i] = ec._RepoRef_deactivatePrevious(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disabledStatsCache":
			out.Values[i] = ec._RepoRef_disabledStatsCache(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dispatchingDisabled":
			out.Values[i] = ec._RepoRef_dispatchingDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._RepoRef_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enabled":
			out.Values[i] = ec._RepoRef_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "githubChecksEnabled":
			out.Values[i] = ec._RepoRef_githubChecksEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "githubDynamicTokenPermissionGroups":
			out.Values[i] = ec._RepoRef_githubDynamicTokenPermissionGroups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "githubPermissionGroupByRequester":
			out.Values[i] = ec._RepoRef_githubPermissionGroupByRequester(ctx, field, obj)
		case "githubTriggerAliases":
			out.Values[i] = ec._RepoRef_githubTriggerAliases(ctx, field, obj)
		case "gitTagAuthorizedTeams":
			out.Values[i] = ec._RepoRef_gitTagAuthorizedTeams(ctx, field, obj)
		case "gitTagAuthorizedUsers":
			out.Values[i] = ec._RepoRef_gitTagAuthorizedUsers(ctx, field, obj)
		case "gitTagVersionsEnabled":
			out.Values[i] = ec._RepoRef_gitTagVersionsEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "manualPrTestingEnabled":
			out.Values[i] = ec._RepoRef_manualPrTestingEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "notifyOnBuildFailure":
			out.Values[i] = ec._RepoRef_notifyOnBuildFailure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldestAllowedMergeBase":
			out.Values[i] = ec._RepoRef_oldestAllowedMergeBase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "owner":
			out.Values[i] = ec._RepoRef_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parsleyFilters":
			out.Values[i] = ec._RepoRef_parsleyFilters(ctx, field, obj)
		case "patchingDisabled":
			out.Values[i] = ec._RepoRef_patchingDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchTriggerAliases":
			out.Values[i] = ec._RepoRef_patchTriggerAliases(ctx, field, obj)
		case "perfEnabled":
			out.Values[i] = ec._RepoRef_perfEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "periodicBuilds":
			out.Values[i] = ec._RepoRef_periodicBuilds(ctx, field, obj)
		case "prTestingEnabled":
			out.Values[i] = ec._RepoRef_prTestingEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remotePath":
			out.Values[i] = ec._RepoRef_remotePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._RepoRef_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repotrackerDisabled":
			out.Values[i] = ec._RepoRef_repotrackerDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restricted":
			out.Values[i] = ec._RepoRef_restricted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spawnHostScriptPath":
			out.Values[i] = ec._RepoRef_spawnHostScriptPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stepbackDisabled":
			out.Values[i] = ec._RepoRef_stepbackDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stepbackBisect":
			out.Values[i] = ec._RepoRef_stepbackBisect(ctx, field, obj)
		case "taskAnnotationSettings":
			out.Values[i] = ec._RepoRef_taskAnnotationSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tracksPushEvents":
			out.Values[i] = ec._RepoRef_tracksPushEvents(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggers":
			out.Values[i] = ec._RepoRef_triggers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionControlEnabled":
			out.Values[i] = ec._RepoRef_versionControlEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "workstationConfig":
			out.Values[i] = ec._RepoRef_workstationConfig(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "externalLinks":
			out.Values[i] = ec._RepoRef_externalLinks(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoSettingsImplementors = []string{"RepoSettings"}

func (ec *executionContext) _RepoSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoSettings")
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_aliases(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubAppAuth":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_githubAppAuth(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubWebhooksEnabled":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_githubWebhooksEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectRef":
			out.Values[i] = ec._RepoSettings_projectRef(ctx, field, obj)
		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_subscriptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vars":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_vars(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoWorkstationConfigImplementors = []string{"RepoWorkstationConfig"}

func (ec *executionContext) _RepoWorkstationConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoWorkstationConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoWorkstationConfig")
		case "gitClone":
			out.Values[i] = ec._RepoWorkstationConfig_gitClone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setupCommands":
			out.Values[i] = ec._RepoWorkstationConfig_setupCommands(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repotrackerErrorImplementors = []string{"RepotrackerError"}

func (ec *executionContext) _RepotrackerError(ctx context.Context, sel ast.SelectionSet, obj *model.APIRepositoryErrorDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repotrackerErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepotrackerError")
		case "exists":
			out.Values[i] = ec._RepotrackerError_exists(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invalidRevision":
			out.Values[i] = ec._RepotrackerError_invalidRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mergeBaseRevision":
			out.Values[i] = ec._RepotrackerError_mergeBaseRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceLimitsImplementors = []string{"ResourceLimits"}

func (ec *executionContext) _ResourceLimits(ctx context.Context, sel ast.SelectionSet, obj *model.APIResourceLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceLimits")
		case "lockedMemoryKb":
			out.Values[i] = ec._ResourceLimits_lockedMemoryKb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numFiles":
			out.Values[i] = ec._ResourceLimits_numFiles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numProcesses":
			out.Values[i] = ec._ResourceLimits_numProcesses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numTasks":
			out.Values[i] = ec._ResourceLimits_numTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "virtualMemoryKb":
			out.Values[i] = ec._ResourceLimits_virtualMemoryKb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var saveDistroPayloadImplementors = []string{"SaveDistroPayload"}

func (ec *executionContext) _SaveDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *SaveDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, saveDistroPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SaveDistroPayload")
		case "distro":
			out.Values[i] = ec._SaveDistroPayload_distro(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostCount":
			out.Values[i] = ec._SaveDistroPayload_hostCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchReturnInfoImplementors = []string{"SearchReturnInfo"}

func (ec *executionContext) _SearchReturnInfo(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.SearchReturnInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchReturnInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchReturnInfo")
		case "featuresURL":
			out.Values[i] = ec._SearchReturnInfo_featuresURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "issues":
			out.Values[i] = ec._SearchReturnInfo_issues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "search":
			out.Values[i] = ec._SearchReturnInfo_search(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "source":
			out.Values[i] = ec._SearchReturnInfo_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var selectorImplementors = []string{"Selector"}

func (ec *executionContext) _Selector(ctx context.Context, sel ast.SelectionSet, obj *model.APISelector) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, selectorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Selector")
		case "data":
			out.Values[i] = ec._Selector_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Selector_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var setLastRevisionPayloadImplementors = []string{"SetLastRevisionPayload"}

func (ec *executionContext) _SetLastRevisionPayload(ctx context.Context, sel ast.SelectionSet, obj *SetLastRevisionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setLastRevisionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetLastRevisionPayload")
		case "mergeBaseRevision":
			out.Values[i] = ec._SetLastRevisionPayload_mergeBaseRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var singleTaskDistroConfigImplementors = []string{"SingleTaskDistroConfig"}

func (ec *executionContext) _SingleTaskDistroConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISingleTaskDistroConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, singleTaskDistroConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SingleTaskDistroConfig")
		case "projectTasksPairs":
			out.Values[i] = ec._SingleTaskDistroConfig_projectTasksPairs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var slackConfigImplementors = []string{"SlackConfig"}

func (ec *executionContext) _SlackConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISlackConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, slackConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SlackConfig")
		case "name":
			out.Values[i] = ec._SlackConfig_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sleepScheduleImplementors = []string{"SleepSchedule"}

func (ec *executionContext) _SleepSchedule(ctx context.Context, sel ast.SelectionSet, obj *host.SleepScheduleInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sleepScheduleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SleepSchedule")
		case "dailyStartTime":
			out.Values[i] = ec._SleepSchedule_dailyStartTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dailyStopTime":
			out.Values[i] = ec._SleepSchedule_dailyStopTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "nextStartTime":
			out.Values[i] = ec._SleepSchedule_nextStartTime(ctx, field, obj)
		case "nextStopTime":
			out.Values[i] = ec._SleepSchedule_nextStopTime(ctx, field, obj)
		case "permanentlyExempt":
			out.Values[i] = ec._SleepSchedule_permanentlyExempt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "shouldKeepOff":
			out.Values[i] = ec._SleepSchedule_shouldKeepOff(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "timeZone":
			out.Values[i] = ec._SleepSchedule_timeZone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "temporarilyExemptUntil":
			out.Values[i] = ec._SleepSchedule_temporarilyExemptUntil(ctx, field, obj)
		case "wholeWeekdaysOff":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SleepSchedule_wholeWeekdaysOff(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sourceImplementors = []string{"Source"}

func (ec *executionContext) _Source(ctx context.Context, sel ast.SelectionSet, obj *model.APISource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Source")
		case "author":
			out.Values[i] = ec._Source_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requester":
			out.Values[i] = ec._Source_requester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "time":
			out.Values[i] = ec._Source_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var spawnHostConfigImplementors = []string{"SpawnHostConfig"}

func (ec *executionContext) _SpawnHostConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISpawnHostConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spawnHostConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpawnHostConfig")
		case "spawnHostsPerUser":
			out.Values[i] = ec._SpawnHostConfig_spawnHostsPerUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unexpirableHostsPerUser":
			out.Values[i] = ec._SpawnHostConfig_unexpirableHostsPerUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unexpirableVolumesPerUser":
			out.Values[i] = ec._SpawnHostConfig_unexpirableVolumesPerUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var spruceConfigImplementors = []string{"SpruceConfig"}

func (ec *executionContext) _SpruceConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAdminSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spruceConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpruceConfig")
		case "banner":
			out.Values[i] = ec._SpruceConfig_banner(ctx, field, obj)
		case "bannerTheme":
			out.Values[i] = ec._SpruceConfig_bannerTheme(ctx, field, obj)
		case "containerPools":
			out.Values[i] = ec._SpruceConfig_containerPools(ctx, field, obj)
		case "githubOrgs":
			out.Values[i] = ec._SpruceConfig_githubOrgs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "jira":
			out.Values[i] = ec._SpruceConfig_jira(ctx, field, obj)
		case "providers":
			out.Values[i] = ec._SpruceConfig_providers(ctx, field, obj)
		case "secretFields":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SpruceConfig_secretFields(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "singleTaskDistro":
			out.Values[i] = ec._SpruceConfig_singleTaskDistro(ctx, field, obj)
		case "slack":
			out.Values[i] = ec._SpruceConfig_slack(ctx, field, obj)
		case "spawnHost":
			out.Values[i] = ec._SpruceConfig_spawnHost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ui":
			out.Values[i] = ec._SpruceConfig_ui(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var statusCountImplementors = []string{"StatusCount"}

func (ec *executionContext) _StatusCount(ctx context.Context, sel ast.SelectionSet, obj *task.StatusCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statusCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatusCount")
		case "count":
			out.Values[i] = ec._StatusCount_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._StatusCount_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stepbackInfoImplementors = []string{"StepbackInfo"}

func (ec *executionContext) _StepbackInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APIStepbackInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stepbackInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StepbackInfo")
		case "lastFailingStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_lastFailingStepbackTaskId(ctx, field, obj)
		case "lastPassingStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_lastPassingStepbackTaskId(ctx, field, obj)
		case "nextStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_nextStepbackTaskId(ctx, field, obj)
		case "previousStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_previousStepbackTaskId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriberImplementors = []string{"Subscriber"}

func (ec *executionContext) _Subscriber(ctx context.Context, sel ast.SelectionSet, obj *Subscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Subscriber")
		case "emailSubscriber":
			out.Values[i] = ec._Subscriber_emailSubscriber(ctx, field, obj)
		case "githubCheckSubscriber":
			out.Values[i] = ec._Subscriber_githubCheckSubscriber(ctx, field, obj)
		case "githubPRSubscriber":
			out.Values[i] = ec._Subscriber_githubPRSubscriber(ctx, field, obj)
		case "jiraCommentSubscriber":
			out.Values[i] = ec._Subscriber_jiraCommentSubscriber(ctx, field, obj)
		case "jiraIssueSubscriber":
			out.Values[i] = ec._Subscriber_jiraIssueSubscriber(ctx, field, obj)
		case "slackSubscriber":
			out.Values[i] = ec._Subscriber_slackSubscriber(ctx, field, obj)
		case "webhookSubscriber":
			out.Values[i] = ec._Subscriber_webhookSubscriber(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriberWrapperImplementors = []string{"SubscriberWrapper"}

func (ec *executionContext) _SubscriberWrapper(ctx context.Context, sel ast.SelectionSet, obj *model.APISubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriberWrapperImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SubscriberWrapper")
		case "subscriber":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SubscriberWrapper_subscriber(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._SubscriberWrapper_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskImplementors = []string{"Task"}

func (ec *executionContext) _Task(ctx context.Context, sel ast.SelectionSet, obj *model.APITask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Task")
		case "aborted":
			out.Values[i] = ec._Task_aborted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "abortInfo":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_abortInfo(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "activated":
			out.Values[i] = ec._Task_activated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activatedBy":
			out.Values[i] = ec._Task_activatedBy(ctx, field, obj)
		case "activatedTime":
			out.Values[i] = ec._Task_activatedTime(ctx, field, obj)
		case "ami":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_ami(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "annotation":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_annotation(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "id":
			out.Values[i] = ec._Task_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "baseStatus":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_baseStatus(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "baseTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_baseTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "blocked":
			out.Values[i] = ec._Task_blocked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildId":
			out.Values[i] = ec._Task_buildId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariant":
			out.Values[i] = ec._Task_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariantDisplayName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_buildVariantDisplayName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canAbort":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canAbort(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canDisable":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canDisable(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canModifyAnnotation":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canModifyAnnotation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canOverrideDependencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canOverrideDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canRestart":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canRestart(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canSchedule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canSchedule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canSetPriority":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canSetPriority(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canUnschedule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canUnschedule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "containerAllocatedTime":
			out.Values[i] = ec._Task_containerAllocatedTime(ctx, field, obj)
		case "createTime":
			out.Values[i] = ec._Task_createTime(ctx, field, obj)
		case "dependsOn":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_dependsOn(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "details":
			out.Values[i] = ec._Task_details(ctx, field, obj)
		case "dispatchTime":
			out.Values[i] = ec._Task_dispatchTime(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Task_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayOnly":
			out.Values[i] = ec._Task_displayOnly(ctx, field, obj)
		case "displayStatus":
			out.Values[i] = ec._Task_displayStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_displayTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "distroId":
			out.Values[i] = ec._Task_distroId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "estimatedStart":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_estimatedStart(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "execution":
			out.Values[i] = ec._Task_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "executionTasks":
			out.Values[i] = ec._Task_executionTasks(ctx, field, obj)
		case "executionTasksFull":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_executionTasksFull(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "expectedDuration":
			out.Values[i] = ec._Task_expectedDuration(ctx, field, obj)
		case "failedTestCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_failedTestCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "files":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_files(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "finishTime":
			out.Values[i] = ec._Task_finishTime(ctx, field, obj)
		case "generatedBy":
			out.Values[i] = ec._Task_generatedBy(ctx, field, obj)
		case "generatedByName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_generatedByName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "generateTask":
			out.Values[i] = ec._Task_generateTask(ctx, field, obj)
		case "hasCedarResults":
			out.Values[i] = ec._Task_hasCedarResults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hostId":
			out.Values[i] = ec._Task_hostId(ctx, field, obj)
		case "imageId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_imageId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "ingestTime":
			out.Values[i] = ec._Task_ingestTime(ctx, field, obj)
		case "isPerfPluginEnabled":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_isPerfPluginEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "latestExecution":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_latestExecution(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logs":
			out.Values[i] = ec._Task_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "minQueuePosition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_minQueuePosition(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "order":
			out.Values[i] = ec._Task_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_patch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "patchNumber":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_patchNumber(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "pod":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_pod(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "priority":
			out.Values[i] = ec._Task_priority(ctx, field, obj)
		case "project":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_project(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectId":
			out.Values[i] = ec._Task_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_projectIdentifier(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "requester":
			out.Values[i] = ec._Task_requester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resetWhenFinished":
			out.Values[i] = ec._Task_resetWhenFinished(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "revision":
			out.Values[i] = ec._Task_revision(ctx, field, obj)
		case "scheduledTime":
			out.Values[i] = ec._Task_scheduledTime(ctx, field, obj)
		case "spawnHostLink":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_spawnHostLink(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startTime":
			out.Values[i] = ec._Task_startTime(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Task_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			out.Values[i] = ec._Task_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskGroup":
			out.Values[i] = ec._Task_taskGroup(ctx, field, obj)
		case "taskGroupMaxHosts":
			out.Values[i] = ec._Task_taskGroupMaxHosts(ctx, field, obj)
		case "stepbackInfo":
			out.Values[i] = ec._Task_stepbackInfo(ctx, field, obj)
		case "taskLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_taskLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskOwnerTeam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_taskOwnerTeam(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tests":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_tests(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "timeTaken":
			out.Values[i] = ec._Task_timeTaken(ctx, field, obj)
		case "totalTestCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_totalTestCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "versionMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_versionMetadata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskAnnotationSettingsImplementors = []string{"TaskAnnotationSettings"}

func (ec *executionContext) _TaskAnnotationSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskAnnotationSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskAnnotationSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskAnnotationSettings")
		case "fileTicketWebhook":
			out.Values[i] = ec._TaskAnnotationSettings_fileTicketWebhook(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskContainerCreationOptsImplementors = []string{"TaskContainerCreationOpts"}

func (ec *executionContext) _TaskContainerCreationOpts(ctx context.Context, sel ast.SelectionSet, obj *model.APIPodTaskContainerCreationOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskContainerCreationOptsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskContainerCreationOpts")
		case "image":
			out.Values[i] = ec._TaskContainerCreationOpts_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "memoryMB":
			out.Values[i] = ec._TaskContainerCreationOpts_memoryMB(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cpu":
			out.Values[i] = ec._TaskContainerCreationOpts_cpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "os":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskContainerCreationOpts_os(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "arch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskContainerCreationOpts_arch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workingDir":
			out.Values[i] = ec._TaskContainerCreationOpts_workingDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskEndDetailImplementors = []string{"TaskEndDetail"}

func (ec *executionContext) _TaskEndDetail(ctx context.Context, sel ast.SelectionSet, obj *model.ApiTaskEndDetail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEndDetailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEndDetail")
		case "description":
			out.Values[i] = ec._TaskEndDetail_description(ctx, field, obj)
		case "diskDevices":
			out.Values[i] = ec._TaskEndDetail_diskDevices(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failingCommand":
			out.Values[i] = ec._TaskEndDetail_failingCommand(ctx, field, obj)
		case "failureMetadataTags":
			out.Values[i] = ec._TaskEndDetail_failureMetadataTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oomTracker":
			out.Values[i] = ec._TaskEndDetail_oomTracker(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TaskEndDetail_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timedOut":
			out.Values[i] = ec._TaskEndDetail_timedOut(ctx, field, obj)
		case "timeoutType":
			out.Values[i] = ec._TaskEndDetail_timeoutType(ctx, field, obj)
		case "traceID":
			out.Values[i] = ec._TaskEndDetail_traceID(ctx, field, obj)
		case "type":
			out.Values[i] = ec._TaskEndDetail_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskEventLogDataImplementors = []string{"TaskEventLogData"}

func (ec *executionContext) _TaskEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.TaskEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEventLogDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEventLogData")
		case "hostId":
			out.Values[i] = ec._TaskEventLogData_hostId(ctx, field, obj)
		case "podId":
			out.Values[i] = ec._TaskEventLogData_podId(ctx, field, obj)
		case "jiraIssue":
			out.Values[i] = ec._TaskEventLogData_jiraIssue(ctx, field, obj)
		case "jiraLink":
			out.Values[i] = ec._TaskEventLogData_jiraLink(ctx, field, obj)
		case "priority":
			out.Values[i] = ec._TaskEventLogData_priority(ctx, field, obj)
		case "status":
			out.Values[i] = ec._TaskEventLogData_status(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._TaskEventLogData_timestamp(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._TaskEventLogData_userId(ctx, field, obj)
		case "blockedOn":
			out.Values[i] = ec._TaskEventLogData_blockedOn(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskEventLogEntryImplementors = []string{"TaskEventLogEntry"}

func (ec *executionContext) _TaskEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.TaskAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEventLogEntry")
		case "id":
			out.Values[i] = ec._TaskEventLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._TaskEventLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._TaskEventLogEntry_eventType(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._TaskEventLogEntry_processedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceId":
			out.Values[i] = ec._TaskEventLogEntry_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TaskEventLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._TaskEventLogEntry_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskFilesImplementors = []string{"TaskFiles"}

func (ec *executionContext) _TaskFiles(ctx context.Context, sel ast.SelectionSet, obj *TaskFiles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskFilesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskFiles")
		case "fileCount":
			out.Values[i] = ec._TaskFiles_fileCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "groupedFiles":
			out.Values[i] = ec._TaskFiles_groupedFiles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskHistoryImplementors = []string{"TaskHistory"}

func (ec *executionContext) _TaskHistory(ctx context.Context, sel ast.SelectionSet, obj *TaskHistory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskHistoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskHistory")
		case "tasks":
			out.Values[i] = ec._TaskHistory_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._TaskHistory_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskHistoryPaginationImplementors = []string{"TaskHistoryPagination"}

func (ec *executionContext) _TaskHistoryPagination(ctx context.Context, sel ast.SelectionSet, obj *TaskHistoryPagination) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskHistoryPaginationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskHistoryPagination")
		case "mostRecentTaskOrder":
			out.Values[i] = ec._TaskHistoryPagination_mostRecentTaskOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldestTaskOrder":
			out.Values[i] = ec._TaskHistoryPagination_oldestTaskOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskInfoImplementors = []string{"TaskInfo"}

func (ec *executionContext) _TaskInfo(ctx context.Context, sel ast.SelectionSet, obj *model.TaskInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskInfo")
		case "id":
			out.Values[i] = ec._TaskInfo_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._TaskInfo_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskLogLinksImplementors = []string{"TaskLogLinks"}

func (ec *executionContext) _TaskLogLinks(ctx context.Context, sel ast.SelectionSet, obj *model.LogLinks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskLogLinksImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskLogLinks")
		case "agentLogLink":
			out.Values[i] = ec._TaskLogLinks_agentLogLink(ctx, field, obj)
		case "allLogLink":
			out.Values[i] = ec._TaskLogLinks_allLogLink(ctx, field, obj)
		case "eventLogLink":
			out.Values[i] = ec._TaskLogLinks_eventLogLink(ctx, field, obj)
		case "systemLogLink":
			out.Values[i] = ec._TaskLogLinks_systemLogLink(ctx, field, obj)
		case "taskLogLink":
			out.Values[i] = ec._TaskLogLinks_taskLogLink(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskLogsImplementors = []string{"TaskLogs"}

func (ec *executionContext) _TaskLogs(ctx context.Context, sel ast.SelectionSet, obj *TaskLogs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskLogsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskLogs")
		case "agentLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_agentLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "allLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_allLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_eventLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "execution":
			out.Values[i] = ec._TaskLogs_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "systemLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_systemLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskId":
			out.Values[i] = ec._TaskLogs_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_taskLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskOwnerTeamImplementors = []string{"TaskOwnerTeam"}

func (ec *executionContext) _TaskOwnerTeam(ctx context.Context, sel ast.SelectionSet, obj *TaskOwnerTeam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskOwnerTeamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskOwnerTeam")
		case "assignmentType":
			out.Values[i] = ec._TaskOwnerTeam_assignmentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "messages":
			out.Values[i] = ec._TaskOwnerTeam_messages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamName":
			out.Values[i] = ec._TaskOwnerTeam_teamName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jiraProject":
			out.Values[i] = ec._TaskOwnerTeam_jiraProject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskQueueDistroImplementors = []string{"TaskQueueDistro"}

func (ec *executionContext) _TaskQueueDistro(ctx context.Context, sel ast.SelectionSet, obj *TaskQueueDistro) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskQueueDistroImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskQueueDistro")
		case "id":
			out.Values[i] = ec._TaskQueueDistro_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostCount":
			out.Values[i] = ec._TaskQueueDistro_hostCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskCount":
			out.Values[i] = ec._TaskQueueDistro_taskCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskQueueItemImplementors = []string{"TaskQueueItem"}

func (ec *executionContext) _TaskQueueItem(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskQueueItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskQueueItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskQueueItem")
		case "id":
			out.Values[i] = ec._TaskQueueItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariant":
			out.Values[i] = ec._TaskQueueItem_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._TaskQueueItem_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expectedDuration":
			out.Values[i] = ec._TaskQueueItem_expectedDuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "priority":
			out.Values[i] = ec._TaskQueueItem_priority(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "project":
			out.Values[i] = ec._TaskQueueItem_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			out.Values[i] = ec._TaskQueueItem_projectIdentifier(ctx, field, obj)
		case "requester":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskQueueItem_requester(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "activatedBy":
			out.Values[i] = ec._TaskQueueItem_activatedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "revision":
			out.Values[i] = ec._TaskQueueItem_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._TaskQueueItem_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskSpecifierImplementors = []string{"TaskSpecifier"}

func (ec *executionContext) _TaskSpecifier(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskSpecifier) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskSpecifierImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskSpecifier")
		case "patchAlias":
			out.Values[i] = ec._TaskSpecifier_patchAlias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskRegex":
			out.Values[i] = ec._TaskSpecifier_taskRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variantRegex":
			out.Values[i] = ec._TaskSpecifier_variantRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskStatsImplementors = []string{"TaskStats"}

func (ec *executionContext) _TaskStats(ctx context.Context, sel ast.SelectionSet, obj *task.TaskStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskStats")
		case "counts":
			out.Values[i] = ec._TaskStats_counts(ctx, field, obj)
		case "eta":
			out.Values[i] = ec._TaskStats_eta(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskTestResultImplementors = []string{"TaskTestResult"}

func (ec *executionContext) _TaskTestResult(ctx context.Context, sel ast.SelectionSet, obj *TaskTestResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskTestResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskTestResult")
		case "testResults":
			out.Values[i] = ec._TaskTestResult_testResults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalTestCount":
			out.Values[i] = ec._TaskTestResult_totalTestCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredTestCount":
			out.Values[i] = ec._TaskTestResult_filteredTestCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskTestResultSampleImplementors = []string{"TaskTestResultSample"}

func (ec *executionContext) _TaskTestResultSample(ctx context.Context, sel ast.SelectionSet, obj *TaskTestResultSample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskTestResultSampleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskTestResultSample")
		case "execution":
			out.Values[i] = ec._TaskTestResultSample_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingFailedTestNames":
			out.Values[i] = ec._TaskTestResultSample_matchingFailedTestNames(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._TaskTestResultSample_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalTestCount":
			out.Values[i] = ec._TaskTestResultSample_totalTestCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testLogImplementors = []string{"TestLog"}

func (ec *executionContext) _TestLog(ctx context.Context, sel ast.SelectionSet, obj *model.TestLogs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testLogImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestLog")
		case "lineNum":
			out.Values[i] = ec._TestLog_lineNum(ctx, field, obj)
		case "url":
			out.Values[i] = ec._TestLog_url(ctx, field, obj)
		case "urlParsley":
			out.Values[i] = ec._TestLog_urlParsley(ctx, field, obj)
		case "urlRaw":
			out.Values[i] = ec._TestLog_urlRaw(ctx, field, obj)
		case "renderingType":
			out.Values[i] = ec._TestLog_renderingType(ctx, field, obj)
		case "version":
			out.Values[i] = ec._TestLog_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testResultImplementors = []string{"TestResult"}

func (ec *executionContext) _TestResult(ctx context.Context, sel ast.SelectionSet, obj *model.APITest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestResult")
		case "id":
			out.Values[i] = ec._TestResult_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "baseStatus":
			out.Values[i] = ec._TestResult_baseStatus(ctx, field, obj)
		case "duration":
			out.Values[i] = ec._TestResult_duration(ctx, field, obj)
		case "endTime":
			out.Values[i] = ec._TestResult_endTime(ctx, field, obj)
		case "execution":
			out.Values[i] = ec._TestResult_execution(ctx, field, obj)
		case "exitCode":
			out.Values[i] = ec._TestResult_exitCode(ctx, field, obj)
		case "groupID":
			out.Values[i] = ec._TestResult_groupID(ctx, field, obj)
		case "logs":
			out.Values[i] = ec._TestResult_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startTime":
			out.Values[i] = ec._TestResult_startTime(ctx, field, obj)
		case "status":
			out.Values[i] = ec._TestResult_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._TestResult_taskId(ctx, field, obj)
		case "testFile":
			out.Values[i] = ec._TestResult_testFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ticketFieldsImplementors = []string{"TicketFields"}

func (ec *executionContext) _TicketFields(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.TicketFields) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ticketFieldsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TicketFields")
		case "assignedTeam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_assignedTeam(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "assigneeDisplayName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_assigneeDisplayName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "created":
			out.Values[i] = ec._TicketFields_created(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resolutionName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_resolutionName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._TicketFields_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "summary":
			out.Values[i] = ec._TicketFields_summary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updated":
			out.Values[i] = ec._TicketFields_updated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var toolchainImplementors = []string{"Toolchain"}

func (ec *executionContext) _Toolchain(ctx context.Context, sel ast.SelectionSet, obj *model.APIToolchain) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, toolchainImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Toolchain")
		case "name":
			out.Values[i] = ec._Toolchain_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "path":
			out.Values[i] = ec._Toolchain_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Toolchain_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var triggerAliasImplementors = []string{"TriggerAlias"}

func (ec *executionContext) _TriggerAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APITriggerDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, triggerAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TriggerAlias")
		case "alias":
			out.Values[i] = ec._TriggerAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildVariantRegex":
			out.Values[i] = ec._TriggerAlias_buildVariantRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configFile":
			out.Values[i] = ec._TriggerAlias_configFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dateCutoff":
			out.Values[i] = ec._TriggerAlias_dateCutoff(ctx, field, obj)
		case "level":
			out.Values[i] = ec._TriggerAlias_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec._TriggerAlias_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TriggerAlias_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskRegex":
			out.Values[i] = ec._TriggerAlias_taskRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unscheduleDownstreamVersions":
			out.Values[i] = ec._TriggerAlias_unscheduleDownstreamVersions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var uIConfigImplementors = []string{"UIConfig"}

func (ec *executionContext) _UIConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIUIConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uIConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UIConfig")
		case "betaFeatures":
			out.Values[i] = ec._UIConfig_betaFeatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultProject":
			out.Values[i] = ec._UIConfig_defaultProject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userVoice":
			out.Values[i] = ec._UIConfig_userVoice(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateBetaFeaturesPayloadImplementors = []string{"UpdateBetaFeaturesPayload"}

func (ec *executionContext) _UpdateBetaFeaturesPayload(ctx context.Context, sel ast.SelectionSet, obj *UpdateBetaFeaturesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateBetaFeaturesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateBetaFeaturesPayload")
		case "betaFeatures":
			out.Values[i] = ec._UpdateBetaFeaturesPayload_betaFeatures(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateParsleySettingsPayloadImplementors = []string{"UpdateParsleySettingsPayload"}

func (ec *executionContext) _UpdateParsleySettingsPayload(ctx context.Context, sel ast.SelectionSet, obj *UpdateParsleySettingsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateParsleySettingsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateParsleySettingsPayload")
		case "parsleySettings":
			out.Values[i] = ec._UpdateParsleySettingsPayload_parsleySettings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var upstreamProjectImplementors = []string{"UpstreamProject"}

func (ec *executionContext) _UpstreamProject(ctx context.Context, sel ast.SelectionSet, obj *UpstreamProject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, upstreamProjectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamProject")
		case "owner":
			out.Values[i] = ec._UpstreamProject_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec._UpstreamProject_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._UpstreamProject_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceID":
			out.Values[i] = ec._UpstreamProject_resourceID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revision":
			out.Values[i] = ec._UpstreamProject_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "task":
			out.Values[i] = ec._UpstreamProject_task(ctx, field, obj)
		case "triggerID":
			out.Values[i] = ec._UpstreamProject_triggerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerType":
			out.Values[i] = ec._UpstreamProject_triggerType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._UpstreamProject_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var useSpruceOptionsImplementors = []string{"UseSpruceOptions"}

func (ec *executionContext) _UseSpruceOptions(ctx context.Context, sel ast.SelectionSet, obj *model.APIUseSpruceOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, useSpruceOptionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UseSpruceOptions")
		case "hasUsedMainlineCommitsBefore":
			out.Values[i] = ec._UseSpruceOptions_hasUsedMainlineCommitsBefore(ctx, field, obj)
		case "hasUsedSpruceBefore":
			out.Values[i] = ec._UseSpruceOptions_hasUsedSpruceBefore(ctx, field, obj)
		case "spruceV1":
			out.Values[i] = ec._UseSpruceOptions_spruceV1(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.APIDBUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "betaFeatures":
			out.Values[i] = ec._User_betaFeatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._User_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "emailAddress":
			out.Values[i] = ec._User_emailAddress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parsleyFilters":
			out.Values[i] = ec._User_parsleyFilters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parsleySettings":
			out.Values[i] = ec._User_parsleySettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patches":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_patches(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "permissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_permissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "settings":
			out.Values[i] = ec._User_settings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_subscriptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userId":
			out.Values[i] = ec._User_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userConfigImplementors = []string{"UserConfig"}

func (ec *executionContext) _UserConfig(ctx context.Context, sel ast.SelectionSet, obj *UserConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConfig")
		case "api_key":
			out.Values[i] = ec._UserConfig_api_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "api_server_host":
			out.Values[i] = ec._UserConfig_api_server_host(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ui_server_host":
			out.Values[i] = ec._UserConfig_ui_server_host(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._UserConfig_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSettingsImplementors = []string{"UserSettings"}

func (ec *executionContext) _UserSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIUserSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSettings")
		case "githubUser":
			out.Values[i] = ec._UserSettings_githubUser(ctx, field, obj)
		case "notifications":
			out.Values[i] = ec._UserSettings_notifications(ctx, field, obj)
		case "region":
			out.Values[i] = ec._UserSettings_region(ctx, field, obj)
		case "slackUsername":
			out.Values[i] = ec._UserSettings_slackUsername(ctx, field, obj)
		case "slackMemberId":
			out.Values[i] = ec._UserSettings_slackMemberId(ctx, field, obj)
		case "timezone":
			out.Values[i] = ec._UserSettings_timezone(ctx, field, obj)
		case "useSpruceOptions":
			out.Values[i] = ec._UserSettings_useSpruceOptions(ctx, field, obj)
		case "dateFormat":
			out.Values[i] = ec._UserSettings_dateFormat(ctx, field, obj)
		case "timeFormat":
			out.Values[i] = ec._UserSettings_timeFormat(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var variantTaskImplementors = []string{"VariantTask"}

func (ec *executionContext) _VariantTask(ctx context.Context, sel ast.SelectionSet, obj *model.VariantTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, variantTaskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VariantTask")
		case "name":
			out.Values[i] = ec._VariantTask_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._VariantTask_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *model.APIVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "id":
			out.Values[i] = ec._Version_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activated":
			out.Values[i] = ec._Version_activated(ctx, field, obj)
		case "author":
			out.Values[i] = ec._Version_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authorEmail":
			out.Values[i] = ec._Version_authorEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "baseTaskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_baseTaskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "baseVersion":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_baseVersion(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "branch":
			out.Values[i] = ec._Version_branch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariants":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_buildVariants(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buildVariantStats":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_buildVariantStats(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "childVersions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_childVersions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createTime":
			out.Values[i] = ec._Version_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "errors":
			out.Values[i] = ec._Version_errors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "externalLinksForMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_externalLinksForMetadata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "finishTime":
			out.Values[i] = ec._Version_finishTime(ctx, field, obj)
		case "generatedTaskCounts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_generatedTaskCounts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "gitTags":
			out.Values[i] = ec._Version_gitTags(ctx, field, obj)
		case "ignored":
			out.Values[i] = ec._Version_ignored(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isPatch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_isPatch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manifest":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_manifest(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "message":
			out.Values[i] = ec._Version_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "order":
			out.Values[i] = ec._Version_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parameters":
			out.Values[i] = ec._Version_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_patch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "previousVersion":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_previousVersion(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "project":
			out.Values[i] = ec._Version_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			out.Values[i] = ec._Version_projectIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectMetadata":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_projectMetadata(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "repo":
			out.Values[i] = ec._Version_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "requester":
			out.Values[i] = ec._Version_requester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "revision":
			out.Values[i] = ec._Version_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "startTime":
			out.Values[i] = ec._Version_startTime(ctx, field, obj)
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskCount":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskCount(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_tasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskStatusStats":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskStatusStats(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "upstreamProject":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_upstreamProject(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "versionTiming":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_versionTiming(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "warnings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_warnings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "waterfallBuilds":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_waterfallBuilds(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionTasksImplementors = []string{"VersionTasks"}

func (ec *executionContext) _VersionTasks(ctx context.Context, sel ast.SelectionSet, obj *VersionTasks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionTasksImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionTasks")
		case "count":
			out.Values[i] = ec._VersionTasks_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._VersionTasks_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionTimingImplementors = []string{"VersionTiming"}

func (ec *executionContext) _VersionTiming(ctx context.Context, sel ast.SelectionSet, obj *VersionTiming) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionTimingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionTiming")
		case "makespan":
			out.Values[i] = ec._VersionTiming_makespan(ctx, field, obj)
		case "timeTaken":
			out.Values[i] = ec._VersionTiming_timeTaken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var volumeImplementors = []string{"Volume"}

func (ec *executionContext) _Volume(ctx context.Context, sel ast.SelectionSet, obj *model.APIVolume) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, volumeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Volume")
		case "id":
			out.Values[i] = ec._Volume_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "availabilityZone":
			out.Values[i] = ec._Volume_availabilityZone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._Volume_createdBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "creationTime":
			out.Values[i] = ec._Volume_creationTime(ctx, field, obj)
		case "deviceName":
			out.Values[i] = ec._Volume_deviceName(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Volume_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expiration":
			out.Values[i] = ec._Volume_expiration(ctx, field, obj)
		case "homeVolume":
			out.Values[i] = ec._Volume_homeVolume(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "host":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Volume_host(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hostID":
			out.Values[i] = ec._Volume_hostID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "migrating":
			out.Values[i] = ec._Volume_migrating(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "noExpiration":
			out.Values[i] = ec._Volume_noExpiration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "size":
			out.Values[i] = ec._Volume_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Volume_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallImplementors = []string{"Waterfall"}

func (ec *executionContext) _Waterfall(ctx context.Context, sel ast.SelectionSet, obj *Waterfall) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Waterfall")
		case "flattenedVersions":
			out.Values[i] = ec._Waterfall_flattenedVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._Waterfall_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallBuildImplementors = []string{"WaterfallBuild"}

func (ec *executionContext) _WaterfallBuild(ctx context.Context, sel ast.SelectionSet, obj *model1.WaterfallBuild) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallBuildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallBuild")
		case "id":
			out.Values[i] = ec._WaterfallBuild_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activated":
			out.Values[i] = ec._WaterfallBuild_activated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildVariant":
			out.Values[i] = ec._WaterfallBuild_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._WaterfallBuild_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._WaterfallBuild_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._WaterfallBuild_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallBuildVariantImplementors = []string{"WaterfallBuildVariant"}

func (ec *executionContext) _WaterfallBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *model1.WaterfallBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallBuildVariantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallBuildVariant")
		case "id":
			out.Values[i] = ec._WaterfallBuildVariant_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "builds":
			out.Values[i] = ec._WaterfallBuildVariant_builds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._WaterfallBuildVariant_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._WaterfallBuildVariant_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallPaginationImplementors = []string{"WaterfallPagination"}

func (ec *executionContext) _WaterfallPagination(ctx context.Context, sel ast.SelectionSet, obj *WaterfallPagination) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallPaginationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallPagination")
		case "activeVersionIds":
			out.Values[i] = ec._WaterfallPagination_activeVersionIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasNextPage":
			out.Values[i] = ec._WaterfallPagination_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPrevPage":
			out.Values[i] = ec._WaterfallPagination_hasPrevPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mostRecentVersionOrder":
			out.Values[i] = ec._WaterfallPagination_mostRecentVersionOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextPageOrder":
			out.Values[i] = ec._WaterfallPagination_nextPageOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prevPageOrder":
			out.Values[i] = ec._WaterfallPagination_prevPageOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallTaskImplementors = []string{"WaterfallTask"}

func (ec *executionContext) _WaterfallTask(ctx context.Context, sel ast.SelectionSet, obj *model1.WaterfallTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallTaskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallTask")
		case "id":
			out.Values[i] = ec._WaterfallTask_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._WaterfallTask_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayStatusCache":
			out.Values[i] = ec._WaterfallTask_displayStatusCache(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "execution":
			out.Values[i] = ec._WaterfallTask_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._WaterfallTask_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallVersionImplementors = []string{"WaterfallVersion"}

func (ec *executionContext) _WaterfallVersion(ctx context.Context, sel ast.SelectionSet, obj *WaterfallVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallVersion")
		case "inactiveVersions":
			out.Values[i] = ec._WaterfallVersion_inactiveVersions(ctx, field, obj)
		case "version":
			out.Values[i] = ec._WaterfallVersion_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookImplementors = []string{"Webhook"}

func (ec *executionContext) _Webhook(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebHook) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Webhook")
		case "endpoint":
			out.Values[i] = ec._Webhook_endpoint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secret":
			out.Values[i] = ec._Webhook_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookHeaderImplementors = []string{"WebhookHeader"}

func (ec *executionContext) _WebhookHeader(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebhookHeader) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookHeaderImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookHeader")
		case "key":
			out.Values[i] = ec._WebhookHeader_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._WebhookHeader_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookSubscriberImplementors = []string{"WebhookSubscriber"}

func (ec *executionContext) _WebhookSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebhookSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookSubscriber")
		case "headers":
			out.Values[i] = ec._WebhookSubscriber_headers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secret":
			out.Values[i] = ec._WebhookSubscriber_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._WebhookSubscriber_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "retries":
			out.Values[i] = ec._WebhookSubscriber_retries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minDelayMs":
			out.Values[i] = ec._WebhookSubscriber_minDelayMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timeoutMs":
			out.Values[i] = ec._WebhookSubscriber_timeoutMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workstationConfigImplementors = []string{"WorkstationConfig"}

func (ec *executionContext) _WorkstationConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workstationConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkstationConfig")
		case "gitClone":
			out.Values[i] = ec._WorkstationConfig_gitClone(ctx, field, obj)
		case "setupCommands":
			out.Values[i] = ec._WorkstationConfig_setupCommands(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workstationSetupCommandImplementors = []string{"WorkstationSetupCommand"}

func (ec *executionContext) _WorkstationSetupCommand(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationSetupCommand) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workstationSetupCommandImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkstationSetupCommand")
		case "command":
			out.Values[i] = ec._WorkstationSetupCommand_command(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "directory":
			out.Values[i] = ec._WorkstationSetupCommand_directory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx context.Context, v any) (AccessLevel, error) {
	var res AccessLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAccessLevel2githubcomevergreencievergreengraphqlAccessLevel(ctx context.Context, sel ast.SelectionSet, v AccessLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAddFavoriteProjectInput2githubcomevergreencievergreengraphqlAddFavoriteProjectInput(ctx context.Context, v any) (AddFavoriteProjectInput, error) {
	res, err := ec.unmarshalInputAddFavoriteProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNArch2githubcomevergreencievergreengraphqlArch(ctx context.Context, v any) (Arch, error) {
	var res Arch
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArch2githubcomevergreencievergreengraphqlArch(ctx context.Context, sel ast.SelectionSet, v Arch) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBannerTheme2githubcomevergreencievergreenBannerTheme(ctx context.Context, v any) (evergreen.BannerTheme, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := evergreen.BannerTheme(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBannerTheme2githubcomevergreencievergreenBannerTheme(ctx context.Context, sel ast.SelectionSet, v evergreen.BannerTheme) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBetaFeatures2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx context.Context, sel ast.SelectionSet, v model.APIBetaFeatures) graphql.Marshaler {
	return ec._BetaFeatures(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBetaFeaturesInput2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx context.Context, v any) (*model.APIBetaFeatures, error) {
	res, err := ec.unmarshalInputBetaFeaturesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (*bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalBoolean(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBootstrapMethod2githubcomevergreencievergreengraphqlBootstrapMethod(ctx context.Context, v any) (BootstrapMethod, error) {
	var res BootstrapMethod
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBootstrapMethod2githubcomevergreencievergreengraphqlBootstrapMethod(ctx context.Context, sel ast.SelectionSet, v BootstrapMethod) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBootstrapSettings2githubcomevergreencievergreenrestmodelAPIBootstrapSettings(ctx context.Context, sel ast.SelectionSet, v model.APIBootstrapSettings) graphql.Marshaler {
	return ec._BootstrapSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBootstrapSettingsInput2githubcomevergreencievergreenrestmodelAPIBootstrapSettings(ctx context.Context, v any) (model.APIBootstrapSettings, error) {
	res, err := ec.unmarshalInputBootstrapSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuild2githubcomevergreencievergreenrestmodelAPIBuild(ctx context.Context, sel ast.SelectionSet, v []*model.APIBuild) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuild2githubcomevergreencievergreenrestmodelAPIBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBuild2githubcomevergreencievergreenrestmodelAPIBuild(ctx context.Context, sel ast.SelectionSet, v *model.APIBuild) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildBaron2githubcomevergreencievergreengraphqlBuildBaron(ctx context.Context, sel ast.SelectionSet, v BuildBaron) graphql.Marshaler {
	return ec._BuildBaron(ctx, sel, &v)
}

func (ec *executionContext) marshalNBuildBaron2githubcomevergreencievergreengraphqlBuildBaron(ctx context.Context, sel ast.SelectionSet, v *BuildBaron) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildBaron(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildBaronSettings2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings(ctx context.Context, sel ast.SelectionSet, v model.APIBuildBaronSettings) graphql.Marshaler {
	return ec._BuildBaronSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions(ctx context.Context, v any) (BuildVariantOptions, error) {
	res, err := ec.unmarshalInputBuildVariantOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuildVariantTuple2githubcomevergreencievergreenmodeltaskBuildVariantTuple(ctx context.Context, sel ast.SelectionSet, v *task.BuildVariantTuple) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildVariantTuple(ctx, sel, v)
}

func (ec *executionContext) marshalNChildPatchAlias2githubcomevergreencievergreenrestmodelAPIChildPatchAlias(ctx context.Context, sel ast.SelectionSet, v model.APIChildPatchAlias) graphql.Marshaler {
	return ec._ChildPatchAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNClientBinary2githubcomevergreencievergreenrestmodelAPIClientBinary(ctx context.Context, sel ast.SelectionSet, v model.APIClientBinary) graphql.Marshaler {
	return ec._ClientBinary(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommitQueueParams2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx context.Context, sel ast.SelectionSet, v model.APICommitQueueParams) graphql.Marshaler {
	return ec._CommitQueueParams(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNCommunicationMethod2githubcomevergreencievergreengraphqlCommunicationMethod(ctx context.Context, v any) (CommunicationMethod, error) {
	var res CommunicationMethod
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCommunicationMethod2githubcomevergreencievergreengraphqlCommunicationMethod(ctx context.Context, sel ast.SelectionSet, v CommunicationMethod) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNContainerPool2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx context.Context, sel ast.SelectionSet, v model.APIContainerPool) graphql.Marshaler {
	return ec._ContainerPool(ctx, sel, &v)
}

func (ec *executionContext) marshalNContainerPool2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx context.Context, sel ast.SelectionSet, v []model.APIContainerPool) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerPool2githubcomevergreencievergreenrestmodelAPIContainerPool(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNContainerResources2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx context.Context, sel ast.SelectionSet, v model.APIContainerResources) graphql.Marshaler {
	return ec._ContainerResources(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNContainerResourcesInput2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx context.Context, v any) (model.APIContainerResources, error) {
	res, err := ec.unmarshalInputContainerResourcesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCopyDistroInput2githubcomevergreencievergreenrestmodelCopyDistroOpts(ctx context.Context, v any) (model.CopyDistroOpts, error) {
	res, err := ec.unmarshalInputCopyDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCopyProjectInput2githubcomevergreencievergreenrestmodelCopyProjectOpts(ctx context.Context, v any) (model.CopyProjectOpts, error) {
	res, err := ec.unmarshalInputCopyProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateDistroInput2githubcomevergreencievergreengraphqlCreateDistroInput(ctx context.Context, v any) (CreateDistroInput, error) {
	res, err := ec.unmarshalInputCreateDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateProjectInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, v any) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputCreateProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursorParams2githubcomevergreencievergreengraphqlCursorParams(ctx context.Context, v any) (*CursorParams, error) {
	res, err := ec.unmarshalInputCursorParams(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDeactivateStepbackTaskInput2githubcomevergreencievergreengraphqlDeactivateStepbackTaskInput(ctx context.Context, v any) (DeactivateStepbackTaskInput, error) {
	res, err := ec.unmarshalInputDeactivateStepbackTaskInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDefaultSectionToRepoInput2githubcomevergreencievergreengraphqlDefaultSectionToRepoInput(ctx context.Context, v any) (DefaultSectionToRepoInput, error) {
	res, err := ec.unmarshalInputDefaultSectionToRepoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDeleteDistroInput2githubcomevergreencievergreengraphqlDeleteDistroInput(ctx context.Context, v any) (DeleteDistroInput, error) {
	res, err := ec.unmarshalInputDeleteDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteDistroPayload2githubcomevergreencievergreengraphqlDeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, v DeleteDistroPayload) graphql.Marshaler {
	return ec._DeleteDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteDistroPayload2githubcomevergreencievergreengraphqlDeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, v *DeleteDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteDistroPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteGithubAppCredentialsInput2githubcomevergreencievergreengraphqlDeleteGithubAppCredentialsInput(ctx context.Context, v any) (DeleteGithubAppCredentialsInput, error) {
	res, err := ec.unmarshalInputDeleteGithubAppCredentialsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDependency2githubcomevergreencievergreengraphqlDependency(ctx context.Context, sel ast.SelectionSet, v *Dependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Dependency(ctx, sel, v)
}

func (ec *executionContext) marshalNDispatcherSettings2githubcomevergreencievergreenrestmodelAPIDispatcherSettings(ctx context.Context, sel ast.SelectionSet, v model.APIDispatcherSettings) graphql.Marshaler {
	return ec._DispatcherSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNDispatcherSettingsInput2githubcomevergreencievergreenrestmodelAPIDispatcherSettings(ctx context.Context, v any) (model.APIDispatcherSettings, error) {
	res, err := ec.unmarshalInputDispatcherSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDispatcherVersion2githubcomevergreencievergreengraphqlDispatcherVersion(ctx context.Context, v any) (DispatcherVersion, error) {
	var res DispatcherVersion
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDispatcherVersion2githubcomevergreencievergreengraphqlDispatcherVersion(ctx context.Context, sel ast.SelectionSet, v DispatcherVersion) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDisplayTask2githubcomevergreencievergreengraphqlDisplayTask(ctx context.Context, v any) ([]*DisplayTask, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*DisplayTask, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDisplayTask2githubcomevergreencievergreengraphqlDisplayTask(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNDisplayTask2githubcomevergreencievergreengraphqlDisplayTask(ctx context.Context, v any) (*DisplayTask, error) {
	res, err := ec.unmarshalInputDisplayTask(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx context.Context, sel ast.SelectionSet, v []*model.APIDistro) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx context.Context, sel ast.SelectionSet, v *model.APIDistro) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Distro(ctx, sel, v)
}

func (ec *executionContext) marshalNDistroEvent2githubcomevergreencievergreengraphqlDistroEvent(ctx context.Context, sel ast.SelectionSet, v []*DistroEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDistroEvent2githubcomevergreencievergreengraphqlDistroEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDistroEvent2githubcomevergreencievergreengraphqlDistroEvent(ctx context.Context, sel ast.SelectionSet, v *DistroEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroEventsInput2githubcomevergreencievergreengraphqlDistroEventsInput(ctx context.Context, v any) (DistroEventsInput, error) {
	res, err := ec.unmarshalInputDistroEventsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroEventsPayload2githubcomevergreencievergreengraphqlDistroEventsPayload(ctx context.Context, sel ast.SelectionSet, v DistroEventsPayload) graphql.Marshaler {
	return ec._DistroEventsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDistroEventsPayload2githubcomevergreencievergreengraphqlDistroEventsPayload(ctx context.Context, sel ast.SelectionSet, v *DistroEventsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroEventsPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroInput2githubcomevergreencievergreenrestmodelAPIDistro(ctx context.Context, v any) (*model.APIDistro, error) {
	res, err := ec.unmarshalInputDistroInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDistroOnSaveOperation2githubcomevergreencievergreengraphqlDistroOnSaveOperation(ctx context.Context, v any) (DistroOnSaveOperation, error) {
	var res DistroOnSaveOperation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroOnSaveOperation2githubcomevergreencievergreengraphqlDistroOnSaveOperation(ctx context.Context, sel ast.SelectionSet, v DistroOnSaveOperation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDistroPermissions2githubcomevergreencievergreengraphqlDistroPermissions(ctx context.Context, sel ast.SelectionSet, v DistroPermissions) graphql.Marshaler {
	return ec._DistroPermissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNDistroPermissions2githubcomevergreencievergreengraphqlDistroPermissions(ctx context.Context, sel ast.SelectionSet, v *DistroPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroPermissionsOptions2githubcomevergreencievergreengraphqlDistroPermissionsOptions(ctx context.Context, v any) (DistroPermissionsOptions, error) {
	res, err := ec.unmarshalInputDistroPermissionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx context.Context, v any) (DistroSettingsAccess, error) {
	var res DistroSettingsAccess
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroSettingsAccess2githubcomevergreencievergreengraphqlDistroSettingsAccess(ctx context.Context, sel ast.SelectionSet, v DistroSettingsAccess) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, v any) (model.APIDuration, error) {
	res, err := model.UnmarshalAPIDuration(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, sel ast.SelectionSet, v model.APIDuration) graphql.Marshaler {
	_ = sel
	res := model.MarshalAPIDuration(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNEnvVar2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx context.Context, sel ast.SelectionSet, v model.APIEnvVar) graphql.Marshaler {
	return ec._EnvVar(ctx, sel, &v)
}

func (ec *executionContext) marshalNEnvVar2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx context.Context, sel ast.SelectionSet, v []model.APIEnvVar) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEnvVar2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNEnvVarInput2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx context.Context, v any) (model.APIEnvVar, error) {
	res, err := ec.unmarshalInputEnvVarInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEnvVarInput2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx context.Context, v any) ([]model.APIEnvVar, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIEnvVar, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEnvVarInput2githubcomevergreencievergreenrestmodelAPIEnvVar(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNExpansion2githubcomevergreencievergreenrestmodelAPIExpansion(ctx context.Context, sel ast.SelectionSet, v model.APIExpansion) graphql.Marshaler {
	return ec._Expansion(ctx, sel, &v)
}

func (ec *executionContext) marshalNExpansion2githubcomevergreencievergreenrestmodelAPIExpansion(ctx context.Context, sel ast.SelectionSet, v []model.APIExpansion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExpansion2githubcomevergreencievergreenrestmodelAPIExpansion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNExpansionInput2githubcomevergreencievergreenrestmodelAPIExpansion(ctx context.Context, v any) (model.APIExpansion, error) {
	res, err := ec.unmarshalInputExpansionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNExpansionInput2githubcomevergreencievergreenrestmodelAPIExpansion(ctx context.Context, v any) ([]model.APIExpansion, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIExpansion, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNExpansionInput2githubcomevergreencievergreenrestmodelAPIExpansion(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNExternalLink2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx context.Context, sel ast.SelectionSet, v model.APIExternalLink) graphql.Marshaler {
	return ec._ExternalLink(ctx, sel, &v)
}

func (ec *executionContext) marshalNExternalLinkForMetadata2githubcomevergreencievergreengraphqlExternalLinkForMetadata(ctx context.Context, sel ast.SelectionSet, v []*ExternalLinkForMetadata) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExternalLinkForMetadata2githubcomevergreencievergreengraphqlExternalLinkForMetadata(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNExternalLinkForMetadata2githubcomevergreencievergreengraphqlExternalLinkForMetadata(ctx context.Context, sel ast.SelectionSet, v *ExternalLinkForMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExternalLinkForMetadata(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExternalLinkInput2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx context.Context, v any) (model.APIExternalLink, error) {
	res, err := ec.unmarshalInputExternalLinkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFeedbackRule2githubcomevergreencievergreengraphqlFeedbackRule(ctx context.Context, v any) (FeedbackRule, error) {
	var res FeedbackRule
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeedbackRule2githubcomevergreencievergreengraphqlFeedbackRule(ctx context.Context, sel ast.SelectionSet, v FeedbackRule) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFile2githubcomevergreencievergreenrestmodelAPIFile(ctx context.Context, sel ast.SelectionSet, v *model.APIFile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._File(ctx, sel, v)
}

func (ec *executionContext) marshalNFileDiff2githubcomevergreencievergreenrestmodelFileDiff(ctx context.Context, sel ast.SelectionSet, v model.FileDiff) graphql.Marshaler {
	return ec._FileDiff(ctx, sel, &v)
}

func (ec *executionContext) marshalNFileDiff2githubcomevergreencievergreenrestmodelFileDiff(ctx context.Context, sel ast.SelectionSet, v []model.FileDiff) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFileDiff2githubcomevergreencievergreenrestmodelFileDiff(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFinderSettings2githubcomevergreencievergreenrestmodelAPIFinderSettings(ctx context.Context, sel ast.SelectionSet, v model.APIFinderSettings) graphql.Marshaler {
	return ec._FinderSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNFinderSettingsInput2githubcomevergreencievergreenrestmodelAPIFinderSettings(ctx context.Context, v any) (model.APIFinderSettings, error) {
	res, err := ec.unmarshalInputFinderSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFinderVersion2githubcomevergreencievergreengraphqlFinderVersion(ctx context.Context, v any) (FinderVersion, error) {
	var res FinderVersion
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFinderVersion2githubcomevergreencievergreengraphqlFinderVersion(ctx context.Context, sel ast.SelectionSet, v FinderVersion) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, sel ast.SelectionSet, v model.APISubscription) graphql.Marshaler {
	return ec._GeneralSubscription(ctx, sel, &v)
}

func (ec *executionContext) marshalNGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, sel ast.SelectionSet, v *model.APISubscription) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GeneralSubscription(ctx, sel, v)
}

func (ec *executionContext) marshalNGeneratedTaskCountResults2githubcomevergreencievergreengraphqlGeneratedTaskCountResults(ctx context.Context, sel ast.SelectionSet, v []*GeneratedTaskCountResults) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneratedTaskCountResults2githubcomevergreencievergreengraphqlGeneratedTaskCountResults(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGeneratedTaskCountResults2githubcomevergreencievergreengraphqlGeneratedTaskCountResults(ctx context.Context, sel ast.SelectionSet, v *GeneratedTaskCountResults) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GeneratedTaskCountResults(ctx, sel, v)
}

func (ec *executionContext) marshalNGitHubDynamicTokenPermissionGroup2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx context.Context, sel ast.SelectionSet, v model.APIGitHubDynamicTokenPermissionGroup) graphql.Marshaler {
	return ec._GitHubDynamicTokenPermissionGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitHubDynamicTokenPermissionGroup2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx context.Context, sel ast.SelectionSet, v []model.APIGitHubDynamicTokenPermissionGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitHubDynamicTokenPermissionGroup2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNGitHubDynamicTokenPermissionGroupInput2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx context.Context, v any) (model.APIGitHubDynamicTokenPermissionGroup, error) {
	res, err := ec.unmarshalInputGitHubDynamicTokenPermissionGroupInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGitTag2githubcomevergreencievergreenrestmodelAPIGitTag(ctx context.Context, sel ast.SelectionSet, v model.APIGitTag) graphql.Marshaler {
	return ec._GitTag(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubProjectConflicts2githubcomevergreencievergreenmodelGithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, v model1.GithubProjectConflicts) graphql.Marshaler {
	return ec._GithubProjectConflicts(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubProjectConflicts2githubcomevergreencievergreenmodelGithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, v *model1.GithubProjectConflicts) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubProjectConflicts(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedBuildVariant2githubcomevergreencievergreengraphqlGroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, v *GroupedBuildVariant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedBuildVariant(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedFiles2githubcomevergreencievergreengraphqlGroupedFiles(ctx context.Context, sel ast.SelectionSet, v []*GroupedFiles) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedFiles2githubcomevergreencievergreengraphqlGroupedFiles(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGroupedFiles2githubcomevergreencievergreengraphqlGroupedFiles(ctx context.Context, sel ast.SelectionSet, v *GroupedFiles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedFiles(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedProjects2githubcomevergreencievergreengraphqlGroupedProjects(ctx context.Context, sel ast.SelectionSet, v []*GroupedProjects) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedProjects2githubcomevergreencievergreengraphqlGroupedProjects(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGroupedProjects2githubcomevergreencievergreengraphqlGroupedProjects(ctx context.Context, sel ast.SelectionSet, v *GroupedProjects) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedProjects(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedTaskStatusCount2githubcomevergreencievergreenmodeltaskGroupedTaskStatusCount(ctx context.Context, sel ast.SelectionSet, v *task.GroupedTaskStatusCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedTaskStatusCount(ctx, sel, v)
}

func (ec *executionContext) marshalNHomeVolumeSettings2githubcomevergreencievergreenrestmodelAPIHomeVolumeSettings(ctx context.Context, sel ast.SelectionSet, v model.APIHomeVolumeSettings) graphql.Marshaler {
	return ec._HomeVolumeSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNHomeVolumeSettingsInput2githubcomevergreencievergreenrestmodelAPIHomeVolumeSettings(ctx context.Context, v any) (model.APIHomeVolumeSettings, error) {
	res, err := ec.unmarshalInputHomeVolumeSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx context.Context, sel ast.SelectionSet, v model.APIHost) graphql.Marshaler {
	return ec._Host(ctx, sel, &v)
}

func (ec *executionContext) marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx context.Context, sel ast.SelectionSet, v []*model.APIHost) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHost2githubcomevergreencievergreenrestmodelAPIHost(ctx context.Context, sel ast.SelectionSet, v *model.APIHost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx context.Context, v any) (HostAccessLevel, error) {
	var res HostAccessLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostAccessLevel2githubcomevergreencievergreengraphqlHostAccessLevel(ctx context.Context, sel ast.SelectionSet, v HostAccessLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNHostAllocatorSettings2githubcomevergreencievergreenrestmodelAPIHostAllocatorSettings(ctx context.Context, sel ast.SelectionSet, v model.APIHostAllocatorSettings) graphql.Marshaler {
	return ec._HostAllocatorSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNHostAllocatorSettingsInput2githubcomevergreencievergreenrestmodelAPIHostAllocatorSettings(ctx context.Context, v any) (model.APIHostAllocatorSettings, error) {
	res, err := ec.unmarshalInputHostAllocatorSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNHostAllocatorVersion2githubcomevergreencievergreengraphqlHostAllocatorVersion(ctx context.Context, v any) (HostAllocatorVersion, error) {
	var res HostAllocatorVersion
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostAllocatorVersion2githubcomevergreencievergreengraphqlHostAllocatorVersion(ctx context.Context, sel ast.SelectionSet, v HostAllocatorVersion) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNHostEventLogData2githubcomevergreencievergreenrestmodelHostAPIEventData(ctx context.Context, sel ast.SelectionSet, v *model.HostAPIEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNHostEventLogEntry2githubcomevergreencievergreenrestmodelHostAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v []*model.HostAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHostEventLogEntry2githubcomevergreencievergreenrestmodelHostAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHostEventLogEntry2githubcomevergreencievergreenrestmodelHostAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.HostAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHostEventType2string(ctx context.Context, v any) (string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNHostEventType2string[tmp]
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostEventType2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(marshalNHostEventType2string[v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNHostEventType2string = map[string]string{
		"HOST_CREATED":                                     event.EventHostCreated,
		"HOST_CREATED_ERROR":                               event.EventHostCreatedError,
		"HOST_STARTED":                                     event.EventHostStarted,
		"HOST_STOPPED":                                     event.EventHostStopped,
		"HOST_MODIFIED":                                    event.EventHostModified,
		"HOST_AGENT_DEPLOYED":                              event.EventHostAgentDeployed,
		"HOST_AGENT_DEPLOY_FAILED":                         event.EventHostAgentDeployFailed,
		"HOST_AGENT_MONITOR_DEPLOYED":                      event.EventHostAgentMonitorDeployed,
		"HOST_AGENT_MONITOR_DEPLOY_FAILED":                 event.EventHostAgentMonitorDeployFailed,
		"HOST_JASPER_RESTARTING":                           event.EventHostJasperRestarting,
		"HOST_JASPER_RESTARTED":                            event.EventHostJasperRestarted,
		"HOST_JASPER_RESTART_ERROR":                        event.EventHostJasperRestartError,
		"HOST_CONVERTING_PROVISIONING":                     event.EventHostConvertingProvisioning,
		"HOST_CONVERTED_PROVISIONING":                      event.EventHostConvertedProvisioning,
		"HOST_CONVERTING_PROVISIONING_ERROR":               event.EventHostConvertingProvisioningError,
		"HOST_STATUS_CHANGED":                              event.EventHostStatusChanged,
		"HOST_DNS_NAME_SET":                                event.EventHostDNSNameSet,
		"HOST_PROVISION_ERROR":                             event.EventHostProvisionError,
		"HOST_PROVISION_FAILED":                            event.EventHostProvisionFailed,
		"HOST_PROVISIONED":                                 event.EventHostProvisioned,
		"HOST_RUNNING_TASK_SET":                            event.EventHostRunningTaskSet,
		"HOST_RUNNING_TASK_CLEARED":                        event.EventHostRunningTaskCleared,
		"HOST_TASK_FINISHED":                               event.EventHostTaskFinished,
		"HOST_TERMINATED_EXTERNALLY":                       event.EventHostTerminatedExternally,
		"HOST_EXPIRATION_WARNING_SENT":                     event.EventHostExpirationWarningSent,
		"HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT": event.EventHostTemporaryExemptionExpirationWarningSent,
		"HOST_IDLE_NOTIFICATION":                           event.EventSpawnHostIdleNotification,
		"HOST_SCRIPT_EXECUTED":                             event.EventHostScriptExecuted,
		"HOST_SCRIPT_EXECUTE_FAILED":                       event.EventHostScriptExecuteFailed,
		"SPAWN_HOST_CREATED_ERROR":                         event.EventSpawnHostCreatedError,
		"VOLUME_EXPIRATION_WARNING_SENT":                   event.EventVolumeExpirationWarningSent,
		"VOLUME_MIGRATION_FAILED":                          event.EventVolumeMigrationFailed,
	}
	marshalNHostEventType2string = map[string]string{
		event.EventHostCreated:                                 "HOST_CREATED",
		event.EventHostCreatedError:                            "HOST_CREATED_ERROR",
		event.EventHostStarted:                                 "HOST_STARTED",
		event.EventHostStopped:                                 "HOST_STOPPED",
		event.EventHostModified:                                "HOST_MODIFIED",
		event.EventHostAgentDeployed:                           "HOST_AGENT_DEPLOYED",
		event.EventHostAgentDeployFailed:                       "HOST_AGENT_DEPLOY_FAILED",
		event.EventHostAgentMonitorDeployed:                    "HOST_AGENT_MONITOR_DEPLOYED",
		event.EventHostAgentMonitorDeployFailed:                "HOST_AGENT_MONITOR_DEPLOY_FAILED",
		event.EventHostJasperRestarting:                        "HOST_JASPER_RESTARTING",
		event.EventHostJasperRestarted:                         "HOST_JASPER_RESTARTED",
		event.EventHostJasperRestartError:                      "HOST_JASPER_RESTART_ERROR",
		event.EventHostConvertingProvisioning:                  "HOST_CONVERTING_PROVISIONING",
		event.EventHostConvertedProvisioning:                   "HOST_CONVERTED_PROVISIONING",
		event.EventHostConvertingProvisioningError:             "HOST_CONVERTING_PROVISIONING_ERROR",
		event.EventHostStatusChanged:                           "HOST_STATUS_CHANGED",
		event.EventHostDNSNameSet:                              "HOST_DNS_NAME_SET",
		event.EventHostProvisionError:                          "HOST_PROVISION_ERROR",
		event.EventHostProvisionFailed:                         "HOST_PROVISION_FAILED",
		event.EventHostProvisioned:                             "HOST_PROVISIONED",
		event.EventHostRunningTaskSet:                          "HOST_RUNNING_TASK_SET",
		event.EventHostRunningTaskCleared:                      "HOST_RUNNING_TASK_CLEARED",
		event.EventHostTaskFinished:                            "HOST_TASK_FINISHED",
		event.EventHostTerminatedExternally:                    "HOST_TERMINATED_EXTERNALLY",
		event.EventHostExpirationWarningSent:                   "HOST_EXPIRATION_WARNING_SENT",
		event.EventHostTemporaryExemptionExpirationWarningSent: "HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT",
		event.EventSpawnHostIdleNotification:                   "HOST_IDLE_NOTIFICATION",
		event.EventHostScriptExecuted:                          "HOST_SCRIPT_EXECUTED",
		event.EventHostScriptExecuteFailed:                     "HOST_SCRIPT_EXECUTE_FAILED",
		event.EventSpawnHostCreatedError:                       "SPAWN_HOST_CREATED_ERROR",
		event.EventVolumeExpirationWarningSent:                 "VOLUME_EXPIRATION_WARNING_SENT",
		event.EventVolumeMigrationFailed:                       "VOLUME_MIGRATION_FAILED",
	}
)

func (ec *executionContext) unmarshalNHostEventType2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHostEventType2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNHostEventType2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHostEventType2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

var (
	unmarshalNHostEventType2string = map[string]string{
		"HOST_CREATED":                                     event.EventHostCreated,
		"HOST_CREATED_ERROR":                               event.EventHostCreatedError,
		"HOST_STARTED":                                     event.EventHostStarted,
		"HOST_STOPPED":                                     event.EventHostStopped,
		"HOST_MODIFIED":                                    event.EventHostModified,
		"HOST_AGENT_DEPLOYED":                              event.EventHostAgentDeployed,
		"HOST_AGENT_DEPLOY_FAILED":                         event.EventHostAgentDeployFailed,
		"HOST_AGENT_MONITOR_DEPLOYED":                      event.EventHostAgentMonitorDeployed,
		"HOST_AGENT_MONITOR_DEPLOY_FAILED":                 event.EventHostAgentMonitorDeployFailed,
		"HOST_JASPER_RESTARTING":                           event.EventHostJasperRestarting,
		"HOST_JASPER_RESTARTED":                            event.EventHostJasperRestarted,
		"HOST_JASPER_RESTART_ERROR":                        event.EventHostJasperRestartError,
		"HOST_CONVERTING_PROVISIONING":                     event.EventHostConvertingProvisioning,
		"HOST_CONVERTED_PROVISIONING":                      event.EventHostConvertedProvisioning,
		"HOST_CONVERTING_PROVISIONING_ERROR":               event.EventHostConvertingProvisioningError,
		"HOST_STATUS_CHANGED":                              event.EventHostStatusChanged,
		"HOST_DNS_NAME_SET":                                event.EventHostDNSNameSet,
		"HOST_PROVISION_ERROR":                             event.EventHostProvisionError,
		"HOST_PROVISION_FAILED":                            event.EventHostProvisionFailed,
		"HOST_PROVISIONED":                                 event.EventHostProvisioned,
		"HOST_RUNNING_TASK_SET":                            event.EventHostRunningTaskSet,
		"HOST_RUNNING_TASK_CLEARED":                        event.EventHostRunningTaskCleared,
		"HOST_TASK_FINISHED":                               event.EventHostTaskFinished,
		"HOST_TERMINATED_EXTERNALLY":                       event.EventHostTerminatedExternally,
		"HOST_EXPIRATION_WARNING_SENT":                     event.EventHostExpirationWarningSent,
		"HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT": event.EventHostTemporaryExemptionExpirationWarningSent,
		"HOST_IDLE_NOTIFICATION":                           event.EventSpawnHostIdleNotification,
		"HOST_SCRIPT_EXECUTED":                             event.EventHostScriptExecuted,
		"HOST_SCRIPT_EXECUTE_FAILED":                       event.EventHostScriptExecuteFailed,
		"SPAWN_HOST_CREATED_ERROR":                         event.EventSpawnHostCreatedError,
		"VOLUME_EXPIRATION_WARNING_SENT":                   event.EventVolumeExpirationWarningSent,
		"VOLUME_MIGRATION_FAILED":                          event.EventVolumeMigrationFailed,
	}
	marshalNHostEventType2string = map[string]string{
		event.EventHostCreated:                                 "HOST_CREATED",
		event.EventHostCreatedError:                            "HOST_CREATED_ERROR",
		event.EventHostStarted:                                 "HOST_STARTED",
		event.EventHostStopped:                                 "HOST_STOPPED",
		event.EventHostModified:                                "HOST_MODIFIED",
		event.EventHostAgentDeployed:                           "HOST_AGENT_DEPLOYED",
		event.EventHostAgentDeployFailed:                       "HOST_AGENT_DEPLOY_FAILED",
		event.EventHostAgentMonitorDeployed:                    "HOST_AGENT_MONITOR_DEPLOYED",
		event.EventHostAgentMonitorDeployFailed:                "HOST_AGENT_MONITOR_DEPLOY_FAILED",
		event.EventHostJasperRestarting:                        "HOST_JASPER_RESTARTING",
		event.EventHostJasperRestarted:                         "HOST_JASPER_RESTARTED",
		event.EventHostJasperRestartError:                      "HOST_JASPER_RESTART_ERROR",
		event.EventHostConvertingProvisioning:                  "HOST_CONVERTING_PROVISIONING",
		event.EventHostConvertedProvisioning:                   "HOST_CONVERTED_PROVISIONING",
		event.EventHostConvertingProvisioningError:             "HOST_CONVERTING_PROVISIONING_ERROR",
		event.EventHostStatusChanged:                           "HOST_STATUS_CHANGED",
		event.EventHostDNSNameSet:                              "HOST_DNS_NAME_SET",
		event.EventHostProvisionError:                          "HOST_PROVISION_ERROR",
		event.EventHostProvisionFailed:                         "HOST_PROVISION_FAILED",
		event.EventHostProvisioned:                             "HOST_PROVISIONED",
		event.EventHostRunningTaskSet:                          "HOST_RUNNING_TASK_SET",
		event.EventHostRunningTaskCleared:                      "HOST_RUNNING_TASK_CLEARED",
		event.EventHostTaskFinished:                            "HOST_TASK_FINISHED",
		event.EventHostTerminatedExternally:                    "HOST_TERMINATED_EXTERNALLY",
		event.EventHostExpirationWarningSent:                   "HOST_EXPIRATION_WARNING_SENT",
		event.EventHostTemporaryExemptionExpirationWarningSent: "HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT",
		event.EventSpawnHostIdleNotification:                   "HOST_IDLE_NOTIFICATION",
		event.EventHostScriptExecuted:                          "HOST_SCRIPT_EXECUTED",
		event.EventHostScriptExecuteFailed:                     "HOST_SCRIPT_EXECUTE_FAILED",
		event.EventSpawnHostCreatedError:                       "SPAWN_HOST_CREATED_ERROR",
		event.EventVolumeExpirationWarningSent:                 "VOLUME_EXPIRATION_WARNING_SENT",
		event.EventVolumeMigrationFailed:                       "VOLUME_MIGRATION_FAILED",
	}
)

func (ec *executionContext) marshalNHostEvents2githubcomevergreencievergreengraphqlHostEvents(ctx context.Context, sel ast.SelectionSet, v HostEvents) graphql.Marshaler {
	return ec._HostEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNHostEvents2githubcomevergreencievergreengraphqlHostEvents(ctx context.Context, sel ast.SelectionSet, v *HostEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEvents(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHostEventsInput2githubcomevergreencievergreengraphqlHostEventsInput(ctx context.Context, v any) (HostEventsInput, error) {
	res, err := ec.unmarshalInputHostEventsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostsResponse2githubcomevergreencievergreengraphqlHostsResponse(ctx context.Context, sel ast.SelectionSet, v HostsResponse) graphql.Marshaler {
	return ec._HostsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNHostsResponse2githubcomevergreencievergreengraphqlHostsResponse(ctx context.Context, sel ast.SelectionSet, v *HostsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (*string, error) {
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalID(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIceCreamSettings2githubcomevergreencievergreenrestmodelAPIIceCreamSettings(ctx context.Context, sel ast.SelectionSet, v model.APIIceCreamSettings) graphql.Marshaler {
	return ec._IceCreamSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNIceCreamSettingsInput2githubcomevergreencievergreenrestmodelAPIIceCreamSettings(ctx context.Context, v any) (model.APIIceCreamSettings, error) {
	res, err := ec.unmarshalInputIceCreamSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageEvent2githubcomevergreencievergreenrestmodelAPIImageEvent(ctx context.Context, sel ast.SelectionSet, v []*model.APIImageEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageEvent2githubcomevergreencievergreenrestmodelAPIImageEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImageEvent2githubcomevergreencievergreenrestmodelAPIImageEvent(ctx context.Context, sel ast.SelectionSet, v *model.APIImageEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNImageEventEntry2githubcomevergreencievergreenrestmodelAPIImageEventEntry(ctx context.Context, sel ast.SelectionSet, v model.APIImageEventEntry) graphql.Marshaler {
	return ec._ImageEventEntry(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageEventEntry2githubcomevergreencievergreenrestmodelAPIImageEventEntry(ctx context.Context, sel ast.SelectionSet, v []model.APIImageEventEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageEventEntry2githubcomevergreencievergreenrestmodelAPIImageEventEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNImageEventEntryAction2githubcomevergreencievergreenthirdpartyImageEventEntryAction(ctx context.Context, v any) (thirdparty.ImageEventEntryAction, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := thirdparty.ImageEventEntryAction(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageEventEntryAction2githubcomevergreencievergreenthirdpartyImageEventEntryAction(ctx context.Context, sel ast.SelectionSet, v thirdparty.ImageEventEntryAction) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNImageEventType2githubcomevergreencievergreenthirdpartyImageEventType(ctx context.Context, v any) (thirdparty.ImageEventType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := thirdparty.ImageEventType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageEventType2githubcomevergreencievergreenthirdpartyImageEventType(ctx context.Context, sel ast.SelectionSet, v thirdparty.ImageEventType) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNImageEventsPayload2githubcomevergreencievergreengraphqlImageEventsPayload(ctx context.Context, sel ast.SelectionSet, v ImageEventsPayload) graphql.Marshaler {
	return ec._ImageEventsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageEventsPayload2githubcomevergreencievergreengraphqlImageEventsPayload(ctx context.Context, sel ast.SelectionSet, v *ImageEventsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageEventsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNImageOperatingSystemPayload2githubcomevergreencievergreengraphqlImageOperatingSystemPayload(ctx context.Context, sel ast.SelectionSet, v ImageOperatingSystemPayload) graphql.Marshaler {
	return ec._ImageOperatingSystemPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageOperatingSystemPayload2githubcomevergreencievergreengraphqlImageOperatingSystemPayload(ctx context.Context, sel ast.SelectionSet, v *ImageOperatingSystemPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageOperatingSystemPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNImagePackagesPayload2githubcomevergreencievergreengraphqlImagePackagesPayload(ctx context.Context, sel ast.SelectionSet, v ImagePackagesPayload) graphql.Marshaler {
	return ec._ImagePackagesPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImagePackagesPayload2githubcomevergreencievergreengraphqlImagePackagesPayload(ctx context.Context, sel ast.SelectionSet, v *ImagePackagesPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImagePackagesPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNImageToolchainsPayload2githubcomevergreencievergreengraphqlImageToolchainsPayload(ctx context.Context, sel ast.SelectionSet, v ImageToolchainsPayload) graphql.Marshaler {
	return ec._ImageToolchainsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageToolchainsPayload2githubcomevergreencievergreengraphqlImageToolchainsPayload(ctx context.Context, sel ast.SelectionSet, v *ImageToolchainsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageToolchainsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNInstanceTag2githubcomevergreencievergreenmodelhostTag(ctx context.Context, sel ast.SelectionSet, v host.Tag) graphql.Marshaler {
	return ec._InstanceTag(ctx, sel, &v)
}

func (ec *executionContext) marshalNInstanceTag2githubcomevergreencievergreenmodelhostTag(ctx context.Context, sel ast.SelectionSet, v []host.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInstanceTag2githubcomevergreencievergreenmodelhostTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInstanceTagInput2githubcomevergreencievergreenmodelhostTag(ctx context.Context, v any) (*host.Tag, error) {
	res, err := ec.unmarshalInputInstanceTagInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) ([]int, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (*int, error) {
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalInt(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx context.Context, sel ast.SelectionSet, v model.APIIssueLink) graphql.Marshaler {
	return ec._IssueLink(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNIssueLinkInput2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx context.Context, v any) (model.APIIssueLink, error) {
	res, err := ec.unmarshalInputIssueLinkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJiraStatus2githubcomevergreencievergreenthirdpartyJiraStatus(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JiraStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx context.Context, sel ast.SelectionSet, v thirdparty.JiraTicket) graphql.Marshaler {
	return ec._JiraTicket(ctx, sel, &v)
}

func (ec *executionContext) marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx context.Context, sel ast.SelectionSet, v []thirdparty.JiraTicket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx context.Context, sel ast.SelectionSet, v []*thirdparty.JiraTicket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraTicket) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JiraTicket(ctx, sel, v)
}

func (ec *executionContext) marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage(ctx context.Context, sel ast.SelectionSet, v []*apimodels.LogMessage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLogMessage2githubcomevergreencievergreenapimodelsLogMessage(ctx context.Context, sel ast.SelectionSet, v *apimodels.LogMessage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogMessage(ctx, sel, v)
}

func (ec *executionContext) marshalNLogkeeperBuild2githubcomevergreenciplankBuild(ctx context.Context, sel ast.SelectionSet, v plank.Build) graphql.Marshaler {
	return ec._LogkeeperBuild(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogkeeperBuild2githubcomevergreenciplankBuild(ctx context.Context, sel ast.SelectionSet, v *plank.Build) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogkeeperBuild(ctx, sel, v)
}

func (ec *executionContext) marshalNLogkeeperTest2githubcomevergreenciplankTest(ctx context.Context, sel ast.SelectionSet, v plank.Test) graphql.Marshaler {
	return ec._LogkeeperTest(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogkeeperTest2githubcomevergreenciplankTest(ctx context.Context, sel ast.SelectionSet, v []plank.Test) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLogkeeperTest2githubcomevergreenciplankTest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMainlineCommitVersion2githubcomevergreencievergreengraphqlMainlineCommitVersion(ctx context.Context, sel ast.SelectionSet, v []*MainlineCommitVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMainlineCommitVersion2githubcomevergreencievergreengraphqlMainlineCommitVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMainlineCommitVersion2githubcomevergreencievergreengraphqlMainlineCommitVersion(ctx context.Context, sel ast.SelectionSet, v *MainlineCommitVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MainlineCommitVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMainlineCommitsOptions2githubcomevergreencievergreengraphqlMainlineCommitsOptions(ctx context.Context, v any) (MainlineCommitsOptions, error) {
	res, err := ec.unmarshalInputMainlineCommitsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v any) (map[string]any, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v any) ([]map[string]any, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]map[string]any, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMap2map(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v []map[string]any) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNMap2map(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMetStatus2githubcomevergreencievergreengraphqlMetStatus(ctx context.Context, v any) (MetStatus, error) {
	var res MetStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMetStatus2githubcomevergreencievergreengraphqlMetStatus(ctx context.Context, sel ast.SelectionSet, v MetStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMetadataLink2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx context.Context, sel ast.SelectionSet, v model.APIMetadataLink) graphql.Marshaler {
	return ec._MetadataLink(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNMetadataLinkInput2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx context.Context, v any) ([]*model.APIMetadataLink, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.APIMetadataLink, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMetadataLinkInput2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMetadataLinkInput2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx context.Context, v any) (*model.APIMetadataLink, error) {
	res, err := ec.unmarshalInputMetadataLinkInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNModuleCodeChange2githubcomevergreencievergreenrestmodelAPIModulePatch(ctx context.Context, sel ast.SelectionSet, v model.APIModulePatch) graphql.Marshaler {
	return ec._ModuleCodeChange(ctx, sel, &v)
}

func (ec *executionContext) marshalNModuleCodeChange2githubcomevergreencievergreenrestmodelAPIModulePatch(ctx context.Context, sel ast.SelectionSet, v []model.APIModulePatch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNModuleCodeChange2githubcomevergreencievergreenrestmodelAPIModulePatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMoveProjectInput2githubcomevergreencievergreengraphqlMoveProjectInput(ctx context.Context, v any) (MoveProjectInput, error) {
	res, err := ec.unmarshalInputMoveProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNewDistroPayload2githubcomevergreencievergreengraphqlNewDistroPayload(ctx context.Context, sel ast.SelectionSet, v NewDistroPayload) graphql.Marshaler {
	return ec._NewDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNNewDistroPayload2githubcomevergreencievergreengraphqlNewDistroPayload(ctx context.Context, sel ast.SelectionSet, v *NewDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NewDistroPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOSInfo2githubcomevergreencievergreenrestmodelAPIOSInfo(ctx context.Context, sel ast.SelectionSet, v []*model.APIOSInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOSInfo2githubcomevergreencievergreenrestmodelAPIOSInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOSInfo2githubcomevergreencievergreenrestmodelAPIOSInfo(ctx context.Context, sel ast.SelectionSet, v *model.APIOSInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OSInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNOomTrackerInfo2githubcomevergreencievergreenrestmodelAPIOomTrackerInfo(ctx context.Context, sel ast.SelectionSet, v model.APIOomTrackerInfo) graphql.Marshaler {
	return ec._OomTrackerInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNOperatingSystemOpts2githubcomevergreencievergreenthirdpartyOSInfoFilterOptions(ctx context.Context, v any) (thirdparty.OSInfoFilterOptions, error) {
	res, err := ec.unmarshalInputOperatingSystemOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNOverallocatedRule2githubcomevergreencievergreengraphqlOverallocatedRule(ctx context.Context, v any) (OverallocatedRule, error) {
	var res OverallocatedRule
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOverallocatedRule2githubcomevergreencievergreengraphqlOverallocatedRule(ctx context.Context, sel ast.SelectionSet, v OverallocatedRule) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPackage2githubcomevergreencievergreenrestmodelAPIPackage(ctx context.Context, sel ast.SelectionSet, v []*model.APIPackage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPackage2githubcomevergreencievergreenrestmodelAPIPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPackage2githubcomevergreencievergreenrestmodelAPIPackage(ctx context.Context, sel ast.SelectionSet, v *model.APIPackage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Package(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPackageOpts2githubcomevergreencievergreenthirdpartyPackageFilterOptions(ctx context.Context, v any) (thirdparty.PackageFilterOptions, error) {
	res, err := ec.unmarshalInputPackageOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, sel ast.SelectionSet, v model.APIParameter) graphql.Marshaler {
	return ec._Parameter(ctx, sel, &v)
}

func (ec *executionContext) marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, sel ast.SelectionSet, v []model.APIParameter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, sel ast.SelectionSet, v []*model.APIParameter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNParameter2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, sel ast.SelectionSet, v *model.APIParameter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Parameter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNParameterInput2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, v any) (*model.APIParameter, error) {
	res, err := ec.unmarshalInputParameterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx context.Context, sel ast.SelectionSet, v model.APIParsleyFilter) graphql.Marshaler {
	return ec._ParsleyFilter(ctx, sel, &v)
}

func (ec *executionContext) marshalNParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx context.Context, sel ast.SelectionSet, v []model.APIParsleyFilter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNParsleyFilterInput2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx context.Context, v any) (model.APIParsleyFilter, error) {
	res, err := ec.unmarshalInputParsleyFilterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNParsleySettings2githubcomevergreencievergreenrestmodelAPIParsleySettings(ctx context.Context, sel ast.SelectionSet, v model.APIParsleySettings) graphql.Marshaler {
	return ec._ParsleySettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNParsleySettingsInput2githubcomevergreencievergreenrestmodelAPIParsleySettings(ctx context.Context, v any) (*model.APIParsleySettings, error) {
	res, err := ec.unmarshalInputParsleySettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx context.Context, sel ast.SelectionSet, v model.APIPatch) graphql.Marshaler {
	return ec._Patch(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx context.Context, sel ast.SelectionSet, v []*model.APIPatch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx context.Context, sel ast.SelectionSet, v *model.APIPatch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Patch(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchConfigure2githubcomevergreencievergreengraphqlPatchConfigure(ctx context.Context, v any) (PatchConfigure, error) {
	res, err := ec.unmarshalInputPatchConfigure(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v model.APIPatchTriggerDefinition) graphql.Marshaler {
	return ec._PatchTriggerAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v []*model.APIPatchTriggerDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v *model.APIPatchTriggerDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PatchTriggerAlias(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchTriggerAliasInput2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, v any) (model.APIPatchTriggerDefinition, error) {
	res, err := ec.unmarshalInputPatchTriggerAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatches2githubcomevergreencievergreengraphqlPatches(ctx context.Context, sel ast.SelectionSet, v Patches) graphql.Marshaler {
	return ec._Patches(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatches2githubcomevergreencievergreengraphqlPatches(ctx context.Context, sel ast.SelectionSet, v *Patches) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Patches(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchesInput2githubcomevergreencievergreengraphqlPatchesInput(ctx context.Context, v any) (PatchesInput, error) {
	res, err := ec.unmarshalInputPatchesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPeriodicBuild2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx context.Context, sel ast.SelectionSet, v model.APIPeriodicBuildDefinition) graphql.Marshaler {
	return ec._PeriodicBuild(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNPeriodicBuildInput2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx context.Context, v any) (model.APIPeriodicBuildDefinition, error) {
	res, err := ec.unmarshalInputPeriodicBuildInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPermissions2githubcomevergreencievergreengraphqlPermissions(ctx context.Context, sel ast.SelectionSet, v Permissions) graphql.Marshaler {
	return ec._Permissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNPermissions2githubcomevergreencievergreengraphqlPermissions(ctx context.Context, sel ast.SelectionSet, v *Permissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Permissions(ctx, sel, v)
}

func (ec *executionContext) marshalNPlannerSettings2githubcomevergreencievergreenrestmodelAPIPlannerSettings(ctx context.Context, sel ast.SelectionSet, v model.APIPlannerSettings) graphql.Marshaler {
	return ec._PlannerSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNPlannerSettingsInput2githubcomevergreencievergreenrestmodelAPIPlannerSettings(ctx context.Context, v any) (model.APIPlannerSettings, error) {
	res, err := ec.unmarshalInputPlannerSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPlannerVersion2githubcomevergreencievergreengraphqlPlannerVersion(ctx context.Context, v any) (PlannerVersion, error) {
	var res PlannerVersion
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPlannerVersion2githubcomevergreencievergreengraphqlPlannerVersion(ctx context.Context, sel ast.SelectionSet, v PlannerVersion) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPod2githubcomevergreencievergreenrestmodelAPIPod(ctx context.Context, sel ast.SelectionSet, v model.APIPod) graphql.Marshaler {
	return ec._Pod(ctx, sel, &v)
}

func (ec *executionContext) marshalNPod2githubcomevergreencievergreenrestmodelAPIPod(ctx context.Context, sel ast.SelectionSet, v *model.APIPod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Pod(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEventLogData2githubcomevergreencievergreenrestmodelPodAPIEventData(ctx context.Context, sel ast.SelectionSet, v *model.PodAPIEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEventLogEntry2githubcomevergreencievergreenrestmodelPodAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v []*model.PodAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPodEventLogEntry2githubcomevergreencievergreenrestmodelPodAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPodEventLogEntry2githubcomevergreencievergreenrestmodelPodAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.PodAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEvents2githubcomevergreencievergreengraphqlPodEvents(ctx context.Context, sel ast.SelectionSet, v PodEvents) graphql.Marshaler {
	return ec._PodEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNPodEvents2githubcomevergreencievergreengraphqlPodEvents(ctx context.Context, sel ast.SelectionSet, v *PodEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEvents(ctx, sel, v)
}

func (ec *executionContext) marshalNPreconditionScript2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx context.Context, sel ast.SelectionSet, v model.APIPreconditionScript) graphql.Marshaler {
	return ec._PreconditionScript(ctx, sel, &v)
}

func (ec *executionContext) marshalNPreconditionScript2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx context.Context, sel ast.SelectionSet, v []model.APIPreconditionScript) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPreconditionScript2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNPreconditionScriptInput2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx context.Context, v any) (model.APIPreconditionScript, error) {
	res, err := ec.unmarshalInputPreconditionScriptInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPreconditionScriptInput2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx context.Context, v any) ([]model.APIPreconditionScript, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIPreconditionScript, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPreconditionScriptInput2githubcomevergreencievergreenrestmodelAPIPreconditionScript(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectRef) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v model.APIProjectAlias) graphql.Marshaler {
	return ec._ProjectAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectAlias(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectAliasInput2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, v any) (model.APIProjectAlias, error) {
	res, err := ec.unmarshalInputProjectAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectBuildVariant2githubcomevergreencievergreengraphqlProjectBuildVariant(ctx context.Context, sel ast.SelectionSet, v []*ProjectBuildVariant) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectBuildVariant2githubcomevergreencievergreengraphqlProjectBuildVariant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProjectBuildVariant2githubcomevergreencievergreengraphqlProjectBuildVariant(ctx context.Context, sel ast.SelectionSet, v *ProjectBuildVariant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectBuildVariant(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectEventLogEntry2githubcomevergreencievergreenrestmodelAPIProjectEvent(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectEventLogEntry2githubcomevergreencievergreenrestmodelAPIProjectEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProjectEventLogEntry2githubcomevergreencievergreenrestmodelAPIProjectEvent(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectEvents2githubcomevergreencievergreengraphqlProjectEvents(ctx context.Context, sel ast.SelectionSet, v ProjectEvents) graphql.Marshaler {
	return ec._ProjectEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectEvents2githubcomevergreencievergreengraphqlProjectEvents(ctx context.Context, sel ast.SelectionSet, v *ProjectEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectEvents(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx context.Context, v any) (model1.ProjectHealthView, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model1.ProjectHealthView(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx context.Context, sel ast.SelectionSet, v model1.ProjectHealthView) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx context.Context, v any) (ProjectPermission, error) {
	var res ProjectPermission
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectPermission2githubcomevergreencievergreengraphqlProjectPermission(ctx context.Context, sel ast.SelectionSet, v ProjectPermission) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProjectPermissions2githubcomevergreencievergreengraphqlProjectPermissions(ctx context.Context, sel ast.SelectionSet, v ProjectPermissions) graphql.Marshaler {
	return ec._ProjectPermissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectPermissions2githubcomevergreencievergreengraphqlProjectPermissions(ctx context.Context, sel ast.SelectionSet, v *ProjectPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectPermissionsOptions2githubcomevergreencievergreengraphqlProjectPermissionsOptions(ctx context.Context, v any) (ProjectPermissionsOptions, error) {
	res, err := ec.unmarshalInputProjectPermissionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectSettings) graphql.Marshaler {
	return ec._ProjectSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectSettingsSection2githubcomevergreencievergreengraphqlProjectSettingsSection(ctx context.Context, v any) (ProjectSettingsSection, error) {
	var res ProjectSettingsSection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectSettingsSection2githubcomevergreencievergreengraphqlProjectSettingsSection(ctx context.Context, sel ast.SelectionSet, v ProjectSettingsSection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProjectTasksPair2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx context.Context, sel ast.SelectionSet, v model.APIProjectTasksPair) graphql.Marshaler {
	return ec._ProjectTasksPair(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectTasksPair2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx context.Context, sel ast.SelectionSet, v []model.APIProjectTasksPair) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectTasksPair2githubcomevergreencievergreenrestmodelAPIProjectTasksPair(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNPromoteVarsToRepoInput2githubcomevergreencievergreengraphqlPromoteVarsToRepoInput(ctx context.Context, v any) (PromoteVarsToRepoInput, error) {
	res, err := ec.unmarshalInputPromoteVarsToRepoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProvider2githubcomevergreencievergreengraphqlProvider(ctx context.Context, v any) (Provider, error) {
	var res Provider
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvider2githubcomevergreencievergreengraphqlProvider(ctx context.Context, sel ast.SelectionSet, v Provider) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey(ctx context.Context, sel ast.SelectionSet, v []*model.APIPubKey) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPublicKey2githubcomevergreencievergreenrestmodelAPIPubKey(ctx context.Context, sel ast.SelectionSet, v *model.APIPubKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PublicKey(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx context.Context, v any) (PublicKeyInput, error) {
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx context.Context, v any) (*PublicKeyInput, error) {
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRemoveFavoriteProjectInput2githubcomevergreencievergreengraphqlRemoveFavoriteProjectInput(ctx context.Context, v any) (RemoveFavoriteProjectInput, error) {
	res, err := ec.unmarshalInputRemoveFavoriteProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepoCommitQueueParams2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx context.Context, sel ast.SelectionSet, v model.APICommitQueueParams) graphql.Marshaler {
	return ec._RepoCommitQueueParams(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoPermissions2githubcomevergreencievergreengraphqlRepoPermissions(ctx context.Context, sel ast.SelectionSet, v RepoPermissions) graphql.Marshaler {
	return ec._RepoPermissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoPermissions2githubcomevergreencievergreengraphqlRepoPermissions(ctx context.Context, sel ast.SelectionSet, v *RepoPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepoPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRepoPermissionsOptions2githubcomevergreencievergreengraphqlRepoPermissionsOptions(ctx context.Context, v any) (RepoPermissionsOptions, error) {
	res, err := ec.unmarshalInputRepoPermissionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepoSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectSettings) graphql.Marshaler {
	return ec._RepoSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoSettings2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepoSettings(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoWorkstationConfig2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationConfig) graphql.Marshaler {
	return ec._RepoWorkstationConfig(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNRequiredStatus2githubcomevergreencievergreengraphqlRequiredStatus(ctx context.Context, v any) (RequiredStatus, error) {
	var res RequiredStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRequiredStatus2githubcomevergreencievergreengraphqlRequiredStatus(ctx context.Context, sel ast.SelectionSet, v RequiredStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNResourceLimits2githubcomevergreencievergreenrestmodelAPIResourceLimits(ctx context.Context, sel ast.SelectionSet, v model.APIResourceLimits) graphql.Marshaler {
	return ec._ResourceLimits(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNResourceLimitsInput2githubcomevergreencievergreenrestmodelAPIResourceLimits(ctx context.Context, v any) (model.APIResourceLimits, error) {
	res, err := ec.unmarshalInputResourceLimitsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRoundingRule2githubcomevergreencievergreengraphqlRoundingRule(ctx context.Context, v any) (RoundingRule, error) {
	var res RoundingRule
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRoundingRule2githubcomevergreencievergreengraphqlRoundingRule(ctx context.Context, sel ast.SelectionSet, v RoundingRule) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSaveDistroInput2githubcomevergreencievergreengraphqlSaveDistroInput(ctx context.Context, v any) (SaveDistroInput, error) {
	res, err := ec.unmarshalInputSaveDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSaveDistroPayload2githubcomevergreencievergreengraphqlSaveDistroPayload(ctx context.Context, sel ast.SelectionSet, v SaveDistroPayload) graphql.Marshaler {
	return ec._SaveDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSaveDistroPayload2githubcomevergreencievergreengraphqlSaveDistroPayload(ctx context.Context, sel ast.SelectionSet, v *SaveDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SaveDistroPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNSelector2githubcomevergreencievergreenrestmodelAPISelector(ctx context.Context, sel ast.SelectionSet, v model.APISelector) graphql.Marshaler {
	return ec._Selector(ctx, sel, &v)
}

func (ec *executionContext) marshalNSelector2githubcomevergreencievergreenrestmodelAPISelector(ctx context.Context, sel ast.SelectionSet, v []model.APISelector) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSelector2githubcomevergreencievergreenrestmodelAPISelector(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSelectorInput2githubcomevergreencievergreenrestmodelAPISelector(ctx context.Context, v any) (model.APISelector, error) {
	res, err := ec.unmarshalInputSelectorInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSelectorInput2githubcomevergreencievergreenrestmodelAPISelector(ctx context.Context, v any) ([]model.APISelector, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APISelector, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSelectorInput2githubcomevergreencievergreenrestmodelAPISelector(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSetLastRevisionInput2githubcomevergreencievergreengraphqlSetLastRevisionInput(ctx context.Context, v any) (SetLastRevisionInput, error) {
	res, err := ec.unmarshalInputSetLastRevisionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSetLastRevisionPayload2githubcomevergreencievergreengraphqlSetLastRevisionPayload(ctx context.Context, sel ast.SelectionSet, v SetLastRevisionPayload) graphql.Marshaler {
	return ec._SetLastRevisionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetLastRevisionPayload2githubcomevergreencievergreengraphqlSetLastRevisionPayload(ctx context.Context, sel ast.SelectionSet, v *SetLastRevisionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SetLastRevisionPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx context.Context, v any) (SortDirection, error) {
	var res SortDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx context.Context, sel ast.SelectionSet, v SortDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSortOrder2githubcomevergreencievergreengraphqlSortOrder(ctx context.Context, v any) (*SortOrder, error) {
	res, err := ec.unmarshalInputSortOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSource2githubcomevergreencievergreenrestmodelAPISource(ctx context.Context, sel ast.SelectionSet, v *model.APISource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Source(ctx, sel, v)
}

func (ec *executionContext) marshalNSpawnHostConfig2githubcomevergreencievergreenrestmodelAPISpawnHostConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISpawnHostConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SpawnHostConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSpawnHostStatusActions2githubcomevergreencievergreengraphqlSpawnHostStatusActions(ctx context.Context, v any) (SpawnHostStatusActions, error) {
	var res SpawnHostStatusActions
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSpawnHostStatusActions2githubcomevergreencievergreengraphqlSpawnHostStatusActions(ctx context.Context, sel ast.SelectionSet, v SpawnHostStatusActions) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSpawnVolumeInput2githubcomevergreencievergreengraphqlSpawnVolumeInput(ctx context.Context, v any) (SpawnVolumeInput, error) {
	res, err := ec.unmarshalInputSpawnVolumeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx context.Context, sel ast.SelectionSet, v task.StatusCount) graphql.Marshaler {
	return ec._StatusCount(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx context.Context, sel ast.SelectionSet, v []*task.StatusCount) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx context.Context, sel ast.SelectionSet, v *task.StatusCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StatusCount(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]*string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (*string, error) {
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNStringMap2map(ctx context.Context, v any) (map[string]string, error) {
	res, err := UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := MarshalStringMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNSubscriber2githubcomevergreencievergreengraphqlSubscriber(ctx context.Context, sel ast.SelectionSet, v Subscriber) graphql.Marshaler {
	return ec._Subscriber(ctx, sel, &v)
}

func (ec *executionContext) marshalNSubscriber2githubcomevergreencievergreengraphqlSubscriber(ctx context.Context, sel ast.SelectionSet, v *Subscriber) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Subscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSubscriberInput2githubcomevergreencievergreenrestmodelAPISubscriber(ctx context.Context, v any) (model.APISubscriber, error) {
	res, err := ec.unmarshalInputSubscriberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, v any) (model.APISubscription, error) {
	res, err := ec.unmarshalInputSubscriptionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx context.Context, sel ast.SelectionSet, v model.APITask) graphql.Marshaler {
	return ec._Task(ctx, sel, &v)
}

func (ec *executionContext) marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx context.Context, sel ast.SelectionSet, v []*model.APITask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx context.Context, sel ast.SelectionSet, v *model.APITask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskAnnotationSettings2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings(ctx context.Context, sel ast.SelectionSet, v model.APITaskAnnotationSettings) graphql.Marshaler {
	return ec._TaskAnnotationSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskContainerCreationOpts2githubcomevergreencievergreenrestmodelAPIPodTaskContainerCreationOptions(ctx context.Context, sel ast.SelectionSet, v model.APIPodTaskContainerCreationOptions) graphql.Marshaler {
	return ec._TaskContainerCreationOpts(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskEventLogData2githubcomevergreencievergreenrestmodelTaskEventData(ctx context.Context, sel ast.SelectionSet, v *model.TaskEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskEventLogEntry2githubcomevergreencievergreenrestmodelTaskAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v []*model.TaskAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskEventLogEntry2githubcomevergreencievergreenrestmodelTaskAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskEventLogEntry2githubcomevergreencievergreenrestmodelTaskAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.TaskAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskFiles2githubcomevergreencievergreengraphqlTaskFiles(ctx context.Context, sel ast.SelectionSet, v TaskFiles) graphql.Marshaler {
	return ec._TaskFiles(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskFiles2githubcomevergreencievergreengraphqlTaskFiles(ctx context.Context, sel ast.SelectionSet, v *TaskFiles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskFiles(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskFilterOptions2githubcomevergreencievergreengraphqlTaskFilterOptions(ctx context.Context, v any) (TaskFilterOptions, error) {
	res, err := ec.unmarshalInputTaskFilterOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskHistory2githubcomevergreencievergreengraphqlTaskHistory(ctx context.Context, sel ast.SelectionSet, v TaskHistory) graphql.Marshaler {
	return ec._TaskHistory(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskHistory2githubcomevergreencievergreengraphqlTaskHistory(ctx context.Context, sel ast.SelectionSet, v *TaskHistory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskHistory(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskHistoryDirection2githubcomevergreencievergreengraphqlTaskHistoryDirection(ctx context.Context, v any) (TaskHistoryDirection, error) {
	var res TaskHistoryDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskHistoryDirection2githubcomevergreencievergreengraphqlTaskHistoryDirection(ctx context.Context, sel ast.SelectionSet, v TaskHistoryDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTaskHistoryOpts2githubcomevergreencievergreengraphqlTaskHistoryOpts(ctx context.Context, v any) (TaskHistoryOpts, error) {
	res, err := ec.unmarshalInputTaskHistoryOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskHistoryPagination2githubcomevergreencievergreengraphqlTaskHistoryPagination(ctx context.Context, sel ast.SelectionSet, v *TaskHistoryPagination) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskHistoryPagination(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskLogLinks2githubcomevergreencievergreenrestmodelLogLinks(ctx context.Context, sel ast.SelectionSet, v model.LogLinks) graphql.Marshaler {
	return ec._TaskLogLinks(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskLogs2githubcomevergreencievergreengraphqlTaskLogs(ctx context.Context, sel ast.SelectionSet, v TaskLogs) graphql.Marshaler {
	return ec._TaskLogs(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskLogs2githubcomevergreencievergreengraphqlTaskLogs(ctx context.Context, sel ast.SelectionSet, v *TaskLogs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskLogs(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskQueueDistro2githubcomevergreencievergreengraphqlTaskQueueDistro(ctx context.Context, sel ast.SelectionSet, v []*TaskQueueDistro) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskQueueDistro2githubcomevergreencievergreengraphqlTaskQueueDistro(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskQueueDistro2githubcomevergreencievergreengraphqlTaskQueueDistro(ctx context.Context, sel ast.SelectionSet, v *TaskQueueDistro) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskQueueDistro(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskQueueItem2githubcomevergreencievergreenrestmodelAPITaskQueueItem(ctx context.Context, sel ast.SelectionSet, v []*model.APITaskQueueItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskQueueItem2githubcomevergreencievergreenrestmodelAPITaskQueueItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskQueueItem2githubcomevergreencievergreenrestmodelAPITaskQueueItem(ctx context.Context, sel ast.SelectionSet, v *model.APITaskQueueItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskQueueItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskQueueItemType2githubcomevergreencievergreengraphqlTaskQueueItemType(ctx context.Context, v any) (TaskQueueItemType, error) {
	var res TaskQueueItemType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskQueueItemType2githubcomevergreencievergreengraphqlTaskQueueItemType(ctx context.Context, sel ast.SelectionSet, v TaskQueueItemType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTaskSortCategory2githubcomevergreencievergreengraphqlTaskSortCategory(ctx context.Context, v any) (TaskSortCategory, error) {
	var res TaskSortCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskSortCategory2githubcomevergreencievergreengraphqlTaskSortCategory(ctx context.Context, sel ast.SelectionSet, v TaskSortCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTaskSpecifier2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx context.Context, sel ast.SelectionSet, v model.APITaskSpecifier) graphql.Marshaler {
	return ec._TaskSpecifier(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNTaskSpecifierInput2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx context.Context, v any) (model.APITaskSpecifier, error) {
	res, err := ec.unmarshalInputTaskSpecifierInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTaskSpecifierInput2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx context.Context, v any) ([]model.APITaskSpecifier, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APITaskSpecifier, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTaskSpecifierInput2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTaskTestResult2githubcomevergreencievergreengraphqlTaskTestResult(ctx context.Context, sel ast.SelectionSet, v TaskTestResult) graphql.Marshaler {
	return ec._TaskTestResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskTestResult2githubcomevergreencievergreengraphqlTaskTestResult(ctx context.Context, sel ast.SelectionSet, v *TaskTestResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskTestResult(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskTestResultSample2githubcomevergreencievergreengraphqlTaskTestResultSample(ctx context.Context, sel ast.SelectionSet, v *TaskTestResultSample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskTestResultSample(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTestFilter2githubcomevergreencievergreengraphqlTestFilter(ctx context.Context, v any) ([]*TestFilter, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*TestFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTestFilter2githubcomevergreencievergreengraphqlTestFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNTestFilter2githubcomevergreencievergreengraphqlTestFilter(ctx context.Context, v any) (*TestFilter, error) {
	res, err := ec.unmarshalInputTestFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTestLog2githubcomevergreencievergreenrestmodelTestLogs(ctx context.Context, sel ast.SelectionSet, v model.TestLogs) graphql.Marshaler {
	return ec._TestLog(ctx, sel, &v)
}

func (ec *executionContext) marshalNTestResult2githubcomevergreencievergreenrestmodelAPITest(ctx context.Context, sel ast.SelectionSet, v []*model.APITest) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTestResult2githubcomevergreencievergreenrestmodelAPITest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTestResult2githubcomevergreencievergreenrestmodelAPITest(ctx context.Context, sel ast.SelectionSet, v *model.APITest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TestResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTestSortCategory2githubcomevergreencievergreengraphqlTestSortCategory(ctx context.Context, v any) (TestSortCategory, error) {
	var res TestSortCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTestSortCategory2githubcomevergreencievergreengraphqlTestSortCategory(ctx context.Context, sel ast.SelectionSet, v TestSortCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTestSortOptions2githubcomevergreencievergreengraphqlTestSortOptions(ctx context.Context, v any) (*TestSortOptions, error) {
	res, err := ec.unmarshalInputTestSortOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTicketFields2githubcomevergreencievergreenthirdpartyTicketFields(ctx context.Context, sel ast.SelectionSet, v *thirdparty.TicketFields) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TicketFields(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNToolchain2githubcomevergreencievergreenrestmodelAPIToolchain(ctx context.Context, sel ast.SelectionSet, v []*model.APIToolchain) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNToolchain2githubcomevergreencievergreenrestmodelAPIToolchain(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNToolchain2githubcomevergreencievergreenrestmodelAPIToolchain(ctx context.Context, sel ast.SelectionSet, v *model.APIToolchain) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Toolchain(ctx, sel, v)
}

func (ec *executionContext) unmarshalNToolchainOpts2githubcomevergreencievergreenthirdpartyToolchainFilterOptions(ctx context.Context, v any) (thirdparty.ToolchainFilterOptions, error) {
	res, err := ec.unmarshalInputToolchainOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx context.Context, sel ast.SelectionSet, v model.APITriggerDefinition) graphql.Marshaler {
	return ec._TriggerAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx context.Context, sel ast.SelectionSet, v []model.APITriggerDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTriggerAliasInput2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx context.Context, v any) (model.APITriggerDefinition, error) {
	res, err := ec.unmarshalInputTriggerAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUIConfig2githubcomevergreencievergreenrestmodelAPIUIConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIUIConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UIConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateBetaFeaturesInput2githubcomevergreencievergreengraphqlUpdateBetaFeaturesInput(ctx context.Context, v any) (UpdateBetaFeaturesInput, error) {
	res, err := ec.unmarshalInputUpdateBetaFeaturesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateParsleySettingsInput2githubcomevergreencievergreengraphqlUpdateParsleySettingsInput(ctx context.Context, v any) (UpdateParsleySettingsInput, error) {
	res, err := ec.unmarshalInputUpdateParsleySettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSpawnHostStatusInput2githubcomevergreencievergreengraphqlUpdateSpawnHostStatusInput(ctx context.Context, v any) (UpdateSpawnHostStatusInput, error) {
	res, err := ec.unmarshalInputUpdateSpawnHostStatusInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateVolumeInput2githubcomevergreencievergreengraphqlUpdateVolumeInput(ctx context.Context, v any) (UpdateVolumeInput, error) {
	res, err := ec.unmarshalInputUpdateVolumeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubcomevergreencievergreenrestmodelAPIDBUser(ctx context.Context, sel ast.SelectionSet, v model.APIDBUser) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcomevergreencievergreenrestmodelAPIDBUser(ctx context.Context, sel ast.SelectionSet, v *model.APIDBUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserSettings2githubcomevergreencievergreenrestmodelAPIUserSettings(ctx context.Context, sel ast.SelectionSet, v model.APIUserSettings) graphql.Marshaler {
	return ec._UserSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNVariantTask2githubcomevergreencievergreenrestmodelVariantTask(ctx context.Context, sel ast.SelectionSet, v model.VariantTask) graphql.Marshaler {
	return ec._VariantTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNVariantTask2githubcomevergreencievergreenrestmodelVariantTask(ctx context.Context, sel ast.SelectionSet, v []model.VariantTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVariantTask2githubcomevergreencievergreenrestmodelVariantTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNVariantTasks2githubcomevergreencievergreengraphqlVariantTasks(ctx context.Context, v any) ([]*VariantTasks, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*VariantTasks, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVariantTasks2githubcomevergreencievergreengraphqlVariantTasks(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNVariantTasks2githubcomevergreencievergreengraphqlVariantTasks(ctx context.Context, v any) (*VariantTasks, error) {
	res, err := ec.unmarshalInputVariantTasks(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx context.Context, sel ast.SelectionSet, v model.APIVersion) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx context.Context, sel ast.SelectionSet, v []*model.APIVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx context.Context, sel ast.SelectionSet, v *model.APIVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalNVersionTasks2githubcomevergreencievergreengraphqlVersionTasks(ctx context.Context, sel ast.SelectionSet, v VersionTasks) graphql.Marshaler {
	return ec._VersionTasks(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersionTasks2githubcomevergreencievergreengraphqlVersionTasks(ctx context.Context, sel ast.SelectionSet, v *VersionTasks) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VersionTasks(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVersionToRestart2githubcomevergreencievergreenmodelVersionToRestart(ctx context.Context, v any) ([]*model1.VersionToRestart, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model1.VersionToRestart, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVersionToRestart2githubcomevergreencievergreenmodelVersionToRestart(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNVersionToRestart2githubcomevergreencievergreenmodelVersionToRestart(ctx context.Context, v any) (*model1.VersionToRestart, error) {
	res, err := ec.unmarshalInputVersionToRestart(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx context.Context, sel ast.SelectionSet, v []*model.APIVolume) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx context.Context, sel ast.SelectionSet, v *model.APIVolume) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Volume(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVolumeHost2githubcomevergreencievergreengraphqlVolumeHost(ctx context.Context, v any) (VolumeHost, error) {
	res, err := ec.unmarshalInputVolumeHost(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWaterfall2githubcomevergreencievergreengraphqlWaterfall(ctx context.Context, sel ast.SelectionSet, v Waterfall) graphql.Marshaler {
	return ec._Waterfall(ctx, sel, &v)
}

func (ec *executionContext) marshalNWaterfall2githubcomevergreencievergreengraphqlWaterfall(ctx context.Context, sel ast.SelectionSet, v *Waterfall) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Waterfall(ctx, sel, v)
}

func (ec *executionContext) marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx context.Context, sel ast.SelectionSet, v model1.WaterfallBuild) graphql.Marshaler {
	return ec._WaterfallBuild(ctx, sel, &v)
}

func (ec *executionContext) marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx context.Context, sel ast.SelectionSet, v []model1.WaterfallBuild) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx context.Context, sel ast.SelectionSet, v *model1.WaterfallBuild) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WaterfallBuild(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWaterfallOptions2githubcomevergreencievergreengraphqlWaterfallOptions(ctx context.Context, v any) (WaterfallOptions, error) {
	res, err := ec.unmarshalInputWaterfallOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWaterfallPagination2githubcomevergreencievergreengraphqlWaterfallPagination(ctx context.Context, sel ast.SelectionSet, v *WaterfallPagination) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WaterfallPagination(ctx, sel, v)
}

func (ec *executionContext) marshalNWaterfallTask2githubcomevergreencievergreenmodelWaterfallTask(ctx context.Context, sel ast.SelectionSet, v model1.WaterfallTask) graphql.Marshaler {
	return ec._WaterfallTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNWaterfallTask2githubcomevergreencievergreenmodelWaterfallTask(ctx context.Context, sel ast.SelectionSet, v []model1.WaterfallTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaterfallTask2githubcomevergreencievergreenmodelWaterfallTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWebhook2githubcomevergreencievergreenrestmodelAPIWebHook(ctx context.Context, sel ast.SelectionSet, v model.APIWebHook) graphql.Marshaler {
	return ec._Webhook(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhookHeader2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx context.Context, sel ast.SelectionSet, v model.APIWebhookHeader) graphql.Marshaler {
	return ec._WebhookHeader(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhookHeader2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx context.Context, sel ast.SelectionSet, v []model.APIWebhookHeader) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWebhookHeader2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNWebhookHeaderInput2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx context.Context, v any) (model.APIWebhookHeader, error) {
	res, err := ec.unmarshalInputWebhookHeaderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWebhookHeaderInput2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx context.Context, v any) ([]model.APIWebhookHeader, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIWebhookHeader, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWebhookHeaderInput2githubcomevergreencievergreenrestmodelAPIWebhookHeader(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNWorkstationConfig2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationConfig) graphql.Marshaler {
	return ec._WorkstationConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkstationSetupCommand2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationSetupCommand) graphql.Marshaler {
	return ec._WorkstationSetupCommand(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNWorkstationSetupCommandInput2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx context.Context, v any) (model.APIWorkstationSetupCommand, error) {
	res, err := ec.unmarshalInputWorkstationSetupCommandInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAWSConfig2githubcomevergreencievergreenrestmodelAPIAWSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAWSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AWSConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOAWSPodConfig2githubcomevergreencievergreenrestmodelAPIAWSPodConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAWSPodConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AWSPodConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOAbortInfo2githubcomevergreencievergreengraphqlAbortInfo(ctx context.Context, sel ast.SelectionSet, v *AbortInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AbortInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOAnnotation2githubcomevergreencievergreenrestmodelAPITaskAnnotation(ctx context.Context, sel ast.SelectionSet, v *model.APITaskAnnotation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Annotation(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBannerTheme2githubcomevergreencievergreenBannerTheme(ctx context.Context, v any) (*evergreen.BannerTheme, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := evergreen.BannerTheme(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBannerTheme2githubcomevergreencievergreenBannerTheme(ctx context.Context, sel ast.SelectionSet, v *evergreen.BannerTheme) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOBetaFeatures2githubcomevergreencievergreenrestmodelAPIBetaFeatures(ctx context.Context, sel ast.SelectionSet, v *model.APIBetaFeatures) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BetaFeatures(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOBuildBaronSettingsInput2githubcomevergreencievergreenrestmodelAPIBuildBaronSettings(ctx context.Context, v any) (model.APIBuildBaronSettings, error) {
	res, err := ec.unmarshalInputBuildBaronSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBuildVariantOptions2githubcomevergreencievergreengraphqlBuildVariantOptions(ctx context.Context, v any) (*BuildVariantOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBuildVariantOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBuildVariantTuple2githubcomevergreencievergreenmodeltaskBuildVariantTuple(ctx context.Context, sel ast.SelectionSet, v []*task.BuildVariantTuple) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuildVariantTuple2githubcomevergreencievergreenmodeltaskBuildVariantTuple(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOChildPatchAlias2githubcomevergreencievergreenrestmodelAPIChildPatchAlias(ctx context.Context, sel ast.SelectionSet, v []model.APIChildPatchAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChildPatchAlias2githubcomevergreencievergreenrestmodelAPIChildPatchAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOClientBinary2githubcomevergreencievergreenrestmodelAPIClientBinary(ctx context.Context, sel ast.SelectionSet, v []model.APIClientBinary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNClientBinary2githubcomevergreencievergreenrestmodelAPIClientBinary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOClientConfig2githubcomevergreencievergreenrestmodelAPIClientConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIClientConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ClientConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOCloudProviderConfig2githubcomevergreencievergreenrestmodelAPICloudProviders(ctx context.Context, sel ast.SelectionSet, v *model.APICloudProviders) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CloudProviderConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCommitQueueParamsInput2githubcomevergreencievergreenrestmodelAPICommitQueueParams(ctx context.Context, v any) (model.APICommitQueueParams, error) {
	res, err := ec.unmarshalInputCommitQueueParamsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOContainerPoolsConfig2githubcomevergreencievergreenrestmodelAPIContainerPoolsConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIContainerPoolsConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ContainerPoolsConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOContainerResources2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx context.Context, sel ast.SelectionSet, v []model.APIContainerResources) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerResources2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOContainerResourcesInput2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx context.Context, v any) ([]model.APIContainerResources, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIContainerResources, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContainerResourcesInput2githubcomevergreencievergreenrestmodelAPIContainerResources(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODeleteGithubAppCredentialsPayload2githubcomevergreencievergreengraphqlDeleteGithubAppCredentialsPayload(ctx context.Context, sel ast.SelectionSet, v *DeleteGithubAppCredentialsPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeleteGithubAppCredentialsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalODependency2githubcomevergreencievergreengraphqlDependency(ctx context.Context, sel ast.SelectionSet, v []*Dependency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDependency2githubcomevergreencievergreengraphqlDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODistro2githubcomevergreencievergreenrestmodelAPIDistro(ctx context.Context, sel ast.SelectionSet, v *model.APIDistro) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Distro(ctx, sel, v)
}

func (ec *executionContext) marshalODistroInfo2githubcomevergreencievergreenrestmodelDistroInfo(ctx context.Context, sel ast.SelectionSet, v model.DistroInfo) graphql.Marshaler {
	return ec._DistroInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, v any) (model.APIDuration, error) {
	res, err := model.UnmarshalAPIDuration(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, sel ast.SelectionSet, v model.APIDuration) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := model.MarshalAPIDuration(v)
	return res
}

func (ec *executionContext) unmarshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, v any) (*model.APIDuration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalAPIDuration(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2githubcomevergreencievergreenrestmodelAPIDuration(ctx context.Context, sel ast.SelectionSet, v *model.APIDuration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := model.MarshalAPIDuration(*v)
	return res
}

func (ec *executionContext) marshalOECSConfig2githubcomevergreencievergreenrestmodelAPIECSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIECSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ECSConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEditSpawnHostInput2githubcomevergreencievergreengraphqlEditSpawnHostInput(ctx context.Context, v any) (*EditSpawnHostInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEditSpawnHostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOExternalLink2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx context.Context, sel ast.SelectionSet, v []model.APIExternalLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExternalLink2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOExternalLinkInput2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx context.Context, v any) ([]model.APIExternalLink, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIExternalLink, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNExternalLinkInput2githubcomevergreencievergreenrestmodelAPIExternalLink(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFile2githubcomevergreencievergreenrestmodelAPIFile(ctx context.Context, sel ast.SelectionSet, v []*model.APIFile) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFile2githubcomevergreencievergreenrestmodelAPIFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, sel ast.SelectionSet, v []model.APISubscription) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, sel ast.SelectionSet, v []*model.APISubscription) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneralSubscription2githubcomevergreencievergreenrestmodelAPISubscription(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGitHubDynamicTokenPermissionGroupInput2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx context.Context, v any) ([]model.APIGitHubDynamicTokenPermissionGroup, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIGitHubDynamicTokenPermissionGroup, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGitHubDynamicTokenPermissionGroupInput2githubcomevergreencievergreenrestmodelAPIGitHubDynamicTokenPermissionGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOGitTag2githubcomevergreencievergreenrestmodelAPIGitTag(ctx context.Context, sel ast.SelectionSet, v []model.APIGitTag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitTag2githubcomevergreencievergreenrestmodelAPIGitTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGithubAppAuth2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx context.Context, sel ast.SelectionSet, v model.APIGithubAppAuth) graphql.Marshaler {
	return ec._GithubAppAuth(ctx, sel, &v)
}

func (ec *executionContext) marshalOGithubAppAuth2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubAppAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubAppAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubAppAuthInput2githubcomevergreencievergreenrestmodelAPIGithubAppAuth(ctx context.Context, v any) (model.APIGithubAppAuth, error) {
	res, err := ec.unmarshalInputGithubAppAuthInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGithubCheckSubscriber2githubcomevergreencievergreenrestmodelAPIGithubCheckSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubCheckSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubCheckSubscriber(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubPRSubscriber2githubcomevergreencievergreenrestmodelAPIGithubPRSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubPRSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubPRSubscriber(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubUser2githubcomevergreencievergreenrestmodelAPIGithubUser(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubUserInput2githubcomevergreencievergreenrestmodelAPIGithubUser(ctx context.Context, v any) (*model.APIGithubUser, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubUserInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGroupedBuildVariant2githubcomevergreencievergreengraphqlGroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, v []*GroupedBuildVariant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedBuildVariant2githubcomevergreencievergreengraphqlGroupedBuildVariant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGroupedTaskStatusCount2githubcomevergreencievergreenmodeltaskGroupedTaskStatusCount(ctx context.Context, sel ast.SelectionSet, v []*task.GroupedTaskStatusCount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedTaskStatusCount2githubcomevergreencievergreenmodeltaskGroupedTaskStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOHost2githubcomevergreencievergreenrestmodelAPIHost(ctx context.Context, sel ast.SelectionSet, v *model.APIHost) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHostEventType2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHostEventType2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOHostEventType2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHostEventType2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

var (
	unmarshalOHostEventType2string = map[string]string{
		"HOST_CREATED":                                     event.EventHostCreated,
		"HOST_CREATED_ERROR":                               event.EventHostCreatedError,
		"HOST_STARTED":                                     event.EventHostStarted,
		"HOST_STOPPED":                                     event.EventHostStopped,
		"HOST_MODIFIED":                                    event.EventHostModified,
		"HOST_AGENT_DEPLOYED":                              event.EventHostAgentDeployed,
		"HOST_AGENT_DEPLOY_FAILED":                         event.EventHostAgentDeployFailed,
		"HOST_AGENT_MONITOR_DEPLOYED":                      event.EventHostAgentMonitorDeployed,
		"HOST_AGENT_MONITOR_DEPLOY_FAILED":                 event.EventHostAgentMonitorDeployFailed,
		"HOST_JASPER_RESTARTING":                           event.EventHostJasperRestarting,
		"HOST_JASPER_RESTARTED":                            event.EventHostJasperRestarted,
		"HOST_JASPER_RESTART_ERROR":                        event.EventHostJasperRestartError,
		"HOST_CONVERTING_PROVISIONING":                     event.EventHostConvertingProvisioning,
		"HOST_CONVERTED_PROVISIONING":                      event.EventHostConvertedProvisioning,
		"HOST_CONVERTING_PROVISIONING_ERROR":               event.EventHostConvertingProvisioningError,
		"HOST_STATUS_CHANGED":                              event.EventHostStatusChanged,
		"HOST_DNS_NAME_SET":                                event.EventHostDNSNameSet,
		"HOST_PROVISION_ERROR":                             event.EventHostProvisionError,
		"HOST_PROVISION_FAILED":                            event.EventHostProvisionFailed,
		"HOST_PROVISIONED":                                 event.EventHostProvisioned,
		"HOST_RUNNING_TASK_SET":                            event.EventHostRunningTaskSet,
		"HOST_RUNNING_TASK_CLEARED":                        event.EventHostRunningTaskCleared,
		"HOST_TASK_FINISHED":                               event.EventHostTaskFinished,
		"HOST_TERMINATED_EXTERNALLY":                       event.EventHostTerminatedExternally,
		"HOST_EXPIRATION_WARNING_SENT":                     event.EventHostExpirationWarningSent,
		"HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT": event.EventHostTemporaryExemptionExpirationWarningSent,
		"HOST_IDLE_NOTIFICATION":                           event.EventSpawnHostIdleNotification,
		"HOST_SCRIPT_EXECUTED":                             event.EventHostScriptExecuted,
		"HOST_SCRIPT_EXECUTE_FAILED":                       event.EventHostScriptExecuteFailed,
		"SPAWN_HOST_CREATED_ERROR":                         event.EventSpawnHostCreatedError,
		"VOLUME_EXPIRATION_WARNING_SENT":                   event.EventVolumeExpirationWarningSent,
		"VOLUME_MIGRATION_FAILED":                          event.EventVolumeMigrationFailed,
	}
	marshalOHostEventType2string = map[string]string{
		event.EventHostCreated:                                 "HOST_CREATED",
		event.EventHostCreatedError:                            "HOST_CREATED_ERROR",
		event.EventHostStarted:                                 "HOST_STARTED",
		event.EventHostStopped:                                 "HOST_STOPPED",
		event.EventHostModified:                                "HOST_MODIFIED",
		event.EventHostAgentDeployed:                           "HOST_AGENT_DEPLOYED",
		event.EventHostAgentDeployFailed:                       "HOST_AGENT_DEPLOY_FAILED",
		event.EventHostAgentMonitorDeployed:                    "HOST_AGENT_MONITOR_DEPLOYED",
		event.EventHostAgentMonitorDeployFailed:                "HOST_AGENT_MONITOR_DEPLOY_FAILED",
		event.EventHostJasperRestarting:                        "HOST_JASPER_RESTARTING",
		event.EventHostJasperRestarted:                         "HOST_JASPER_RESTARTED",
		event.EventHostJasperRestartError:                      "HOST_JASPER_RESTART_ERROR",
		event.EventHostConvertingProvisioning:                  "HOST_CONVERTING_PROVISIONING",
		event.EventHostConvertedProvisioning:                   "HOST_CONVERTED_PROVISIONING",
		event.EventHostConvertingProvisioningError:             "HOST_CONVERTING_PROVISIONING_ERROR",
		event.EventHostStatusChanged:                           "HOST_STATUS_CHANGED",
		event.EventHostDNSNameSet:                              "HOST_DNS_NAME_SET",
		event.EventHostProvisionError:                          "HOST_PROVISION_ERROR",
		event.EventHostProvisionFailed:                         "HOST_PROVISION_FAILED",
		event.EventHostProvisioned:                             "HOST_PROVISIONED",
		event.EventHostRunningTaskSet:                          "HOST_RUNNING_TASK_SET",
		event.EventHostRunningTaskCleared:                      "HOST_RUNNING_TASK_CLEARED",
		event.EventHostTaskFinished:                            "HOST_TASK_FINISHED",
		event.EventHostTerminatedExternally:                    "HOST_TERMINATED_EXTERNALLY",
		event.EventHostExpirationWarningSent:                   "HOST_EXPIRATION_WARNING_SENT",
		event.EventHostTemporaryExemptionExpirationWarningSent: "HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT",
		event.EventSpawnHostIdleNotification:                   "HOST_IDLE_NOTIFICATION",
		event.EventHostScriptExecuted:                          "HOST_SCRIPT_EXECUTED",
		event.EventHostScriptExecuteFailed:                     "HOST_SCRIPT_EXECUTE_FAILED",
		event.EventSpawnHostCreatedError:                       "SPAWN_HOST_CREATED_ERROR",
		event.EventVolumeExpirationWarningSent:                 "VOLUME_EXPIRATION_WARNING_SENT",
		event.EventVolumeMigrationFailed:                       "VOLUME_MIGRATION_FAILED",
	}
)

func (ec *executionContext) unmarshalOHostEventType2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOHostEventType2string[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHostEventType2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOHostEventType2string[*v])
	return res
}

var (
	unmarshalOHostEventType2string = map[string]string{
		"HOST_CREATED":                                     event.EventHostCreated,
		"HOST_CREATED_ERROR":                               event.EventHostCreatedError,
		"HOST_STARTED":                                     event.EventHostStarted,
		"HOST_STOPPED":                                     event.EventHostStopped,
		"HOST_MODIFIED":                                    event.EventHostModified,
		"HOST_AGENT_DEPLOYED":                              event.EventHostAgentDeployed,
		"HOST_AGENT_DEPLOY_FAILED":                         event.EventHostAgentDeployFailed,
		"HOST_AGENT_MONITOR_DEPLOYED":                      event.EventHostAgentMonitorDeployed,
		"HOST_AGENT_MONITOR_DEPLOY_FAILED":                 event.EventHostAgentMonitorDeployFailed,
		"HOST_JASPER_RESTARTING":                           event.EventHostJasperRestarting,
		"HOST_JASPER_RESTARTED":                            event.EventHostJasperRestarted,
		"HOST_JASPER_RESTART_ERROR":                        event.EventHostJasperRestartError,
		"HOST_CONVERTING_PROVISIONING":                     event.EventHostConvertingProvisioning,
		"HOST_CONVERTED_PROVISIONING":                      event.EventHostConvertedProvisioning,
		"HOST_CONVERTING_PROVISIONING_ERROR":               event.EventHostConvertingProvisioningError,
		"HOST_STATUS_CHANGED":                              event.EventHostStatusChanged,
		"HOST_DNS_NAME_SET":                                event.EventHostDNSNameSet,
		"HOST_PROVISION_ERROR":                             event.EventHostProvisionError,
		"HOST_PROVISION_FAILED":                            event.EventHostProvisionFailed,
		"HOST_PROVISIONED":                                 event.EventHostProvisioned,
		"HOST_RUNNING_TASK_SET":                            event.EventHostRunningTaskSet,
		"HOST_RUNNING_TASK_CLEARED":                        event.EventHostRunningTaskCleared,
		"HOST_TASK_FINISHED":                               event.EventHostTaskFinished,
		"HOST_TERMINATED_EXTERNALLY":                       event.EventHostTerminatedExternally,
		"HOST_EXPIRATION_WARNING_SENT":                     event.EventHostExpirationWarningSent,
		"HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT": event.EventHostTemporaryExemptionExpirationWarningSent,
		"HOST_IDLE_NOTIFICATION":                           event.EventSpawnHostIdleNotification,
		"HOST_SCRIPT_EXECUTED":                             event.EventHostScriptExecuted,
		"HOST_SCRIPT_EXECUTE_FAILED":                       event.EventHostScriptExecuteFailed,
		"SPAWN_HOST_CREATED_ERROR":                         event.EventSpawnHostCreatedError,
		"VOLUME_EXPIRATION_WARNING_SENT":                   event.EventVolumeExpirationWarningSent,
		"VOLUME_MIGRATION_FAILED":                          event.EventVolumeMigrationFailed,
	}
	marshalOHostEventType2string = map[string]string{
		event.EventHostCreated:                                 "HOST_CREATED",
		event.EventHostCreatedError:                            "HOST_CREATED_ERROR",
		event.EventHostStarted:                                 "HOST_STARTED",
		event.EventHostStopped:                                 "HOST_STOPPED",
		event.EventHostModified:                                "HOST_MODIFIED",
		event.EventHostAgentDeployed:                           "HOST_AGENT_DEPLOYED",
		event.EventHostAgentDeployFailed:                       "HOST_AGENT_DEPLOY_FAILED",
		event.EventHostAgentMonitorDeployed:                    "HOST_AGENT_MONITOR_DEPLOYED",
		event.EventHostAgentMonitorDeployFailed:                "HOST_AGENT_MONITOR_DEPLOY_FAILED",
		event.EventHostJasperRestarting:                        "HOST_JASPER_RESTARTING",
		event.EventHostJasperRestarted:                         "HOST_JASPER_RESTARTED",
		event.EventHostJasperRestartError:                      "HOST_JASPER_RESTART_ERROR",
		event.EventHostConvertingProvisioning:                  "HOST_CONVERTING_PROVISIONING",
		event.EventHostConvertedProvisioning:                   "HOST_CONVERTED_PROVISIONING",
		event.EventHostConvertingProvisioningError:             "HOST_CONVERTING_PROVISIONING_ERROR",
		event.EventHostStatusChanged:                           "HOST_STATUS_CHANGED",
		event.EventHostDNSNameSet:                              "HOST_DNS_NAME_SET",
		event.EventHostProvisionError:                          "HOST_PROVISION_ERROR",
		event.EventHostProvisionFailed:                         "HOST_PROVISION_FAILED",
		event.EventHostProvisioned:                             "HOST_PROVISIONED",
		event.EventHostRunningTaskSet:                          "HOST_RUNNING_TASK_SET",
		event.EventHostRunningTaskCleared:                      "HOST_RUNNING_TASK_CLEARED",
		event.EventHostTaskFinished:                            "HOST_TASK_FINISHED",
		event.EventHostTerminatedExternally:                    "HOST_TERMINATED_EXTERNALLY",
		event.EventHostExpirationWarningSent:                   "HOST_EXPIRATION_WARNING_SENT",
		event.EventHostTemporaryExemptionExpirationWarningSent: "HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT",
		event.EventSpawnHostIdleNotification:                   "HOST_IDLE_NOTIFICATION",
		event.EventHostScriptExecuted:                          "HOST_SCRIPT_EXECUTED",
		event.EventHostScriptExecuteFailed:                     "HOST_SCRIPT_EXECUTE_FAILED",
		event.EventSpawnHostCreatedError:                       "SPAWN_HOST_CREATED_ERROR",
		event.EventVolumeExpirationWarningSent:                 "VOLUME_EXPIRATION_WARNING_SENT",
		event.EventVolumeMigrationFailed:                       "VOLUME_MIGRATION_FAILED",
	}
)

func (ec *executionContext) unmarshalOHostSortBy2githubcomevergreencievergreengraphqlHostSortBy(ctx context.Context, v any) (*HostSortBy, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(HostSortBy)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHostSortBy2githubcomevergreencievergreengraphqlHostSortBy(ctx context.Context, sel ast.SelectionSet, v *HostSortBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) marshalOImage2githubcomevergreencievergreenrestmodelAPIImage(ctx context.Context, sel ast.SelectionSet, v *model.APIImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Image(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInstanceTagInput2githubcomevergreencievergreenmodelhostTag(ctx context.Context, v any) ([]*host.Tag, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*host.Tag, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInstanceTagInput2githubcomevergreencievergreenmodelhostTag(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int32(ctx context.Context, v any) (int32, error) {
	res, err := graphql.UnmarshalInt32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalInt32(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalInt64(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx context.Context, sel ast.SelectionSet, v []model.APIIssueLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIssueLink2githubcomevergreencievergreenrestmodelAPIIssueLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOJiraConfig2githubcomevergreencievergreenrestmodelAPIJiraConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIJiraConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOJiraIssueSubscriber2githubcomevergreencievergreenrestmodelAPIJIRAIssueSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIJIRAIssueSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraIssueSubscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJiraIssueSubscriberInput2githubcomevergreencievergreenrestmodelAPIJIRAIssueSubscriber(ctx context.Context, v any) (*model.APIJIRAIssueSubscriber, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJiraIssueSubscriberInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJiraTicket2githubcomevergreencievergreenthirdpartyJiraTicket(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraTicket) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraTicket(ctx, sel, v)
}

func (ec *executionContext) marshalOMainlineCommits2githubcomevergreencievergreengraphqlMainlineCommits(ctx context.Context, sel ast.SelectionSet, v *MainlineCommits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MainlineCommits(ctx, sel, v)
}

func (ec *executionContext) marshalOManifest2githubcomevergreencievergreengraphqlManifest(ctx context.Context, sel ast.SelectionSet, v *Manifest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Manifest(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v any) (map[string]any, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) marshalOMetadataLink2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx context.Context, sel ast.SelectionSet, v []model.APIMetadataLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMetadataLink2githubcomevergreencievergreenrestmodelAPIMetadataLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONote2githubcomevergreencievergreenrestmodelAPINote(ctx context.Context, sel ast.SelectionSet, v *model.APINote) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Note(ctx, sel, v)
}

func (ec *executionContext) marshalONotifications2githubcomevergreencievergreenrestmodelAPINotificationPreferences(ctx context.Context, sel ast.SelectionSet, v *model.APINotificationPreferences) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Notifications(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotificationsInput2githubcomevergreencievergreenrestmodelAPINotificationPreferences(ctx context.Context, v any) (*model.APINotificationPreferences, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotificationsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOParameterInput2githubcomevergreencievergreenrestmodelAPIParameter(ctx context.Context, v any) ([]*model.APIParameter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.APIParameter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNParameterInput2githubcomevergreencievergreenrestmodelAPIParameter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx context.Context, sel ast.SelectionSet, v []model.APIParsleyFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParsleyFilter2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOParsleyFilterInput2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx context.Context, v any) ([]model.APIParsleyFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIParsleyFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNParsleyFilterInput2githubcomevergreencievergreenrestmodelAPIParsleyFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOParsleySettings2githubcomevergreencievergreenrestmodelAPIParsleySettings(ctx context.Context, sel ast.SelectionSet, v *model.APIParsleySettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ParsleySettings(ctx, sel, v)
}

func (ec *executionContext) marshalOPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx context.Context, sel ast.SelectionSet, v []model.APIPatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPatch2githubcomevergreencievergreenrestmodelAPIPatch(ctx context.Context, sel ast.SelectionSet, v *model.APIPatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Patch(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchDuration2githubcomevergreencievergreengraphqlPatchDuration(ctx context.Context, sel ast.SelectionSet, v *PatchDuration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchDuration(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchProject2githubcomevergreencievergreengraphqlPatchProject(ctx context.Context, sel ast.SelectionSet, v *PatchProject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchProject(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchTime2githubcomevergreencievergreengraphqlPatchTime(ctx context.Context, sel ast.SelectionSet, v *PatchTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchTime(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v []model.APIPatchTriggerDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatchTriggerAlias2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPatchTriggerAliasInput2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx context.Context, v any) ([]model.APIPatchTriggerDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIPatchTriggerDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPatchTriggerAliasInput2githubcomevergreencievergreenrestmodelAPIPatchTriggerDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPeriodicBuild2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx context.Context, sel ast.SelectionSet, v []model.APIPeriodicBuildDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPeriodicBuild2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPeriodicBuildInput2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx context.Context, v any) ([]model.APIPeriodicBuildDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIPeriodicBuildDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPeriodicBuildInput2githubcomevergreencievergreenrestmodelAPIPeriodicBuildDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPod2githubcomevergreencievergreenrestmodelAPIPod(ctx context.Context, sel ast.SelectionSet, v *model.APIPod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Pod(ctx, sel, v)
}

func (ec *executionContext) marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalOProject2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalOProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v []model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectAlias2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOProjectAliasInput2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx context.Context, v any) ([]model.APIProjectAlias, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIProjectAlias, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectAliasInput2githubcomevergreencievergreenrestmodelAPIProjectAlias(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOProjectBanner2githubcomevergreencievergreenrestmodelAPIProjectBanner(ctx context.Context, sel ast.SelectionSet, v model.APIProjectBanner) graphql.Marshaler {
	return ec._ProjectBanner(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOProjectBannerInput2githubcomevergreencievergreenrestmodelAPIProjectBanner(ctx context.Context, v any) (model.APIProjectBanner, error) {
	res, err := ec.unmarshalInputProjectBannerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectEventSettings2githubcomevergreencievergreenrestmodelAPIProjectEventSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectEventSettings) graphql.Marshaler {
	return ec._ProjectEventSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx context.Context, v any) (model1.ProjectHealthView, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model1.ProjectHealthView(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectHealthView2githubcomevergreencievergreenmodelProjectHealthView(ctx context.Context, sel ast.SelectionSet, v model1.ProjectHealthView) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) unmarshalOProjectInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, v any) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProjectSettingsInput2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, v any) (*model.APIProjectSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectVars2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx context.Context, sel ast.SelectionSet, v model.APIProjectVars) graphql.Marshaler {
	return ec._ProjectVars(ctx, sel, &v)
}

func (ec *executionContext) marshalOProjectVars2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectVars) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectVars(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProjectVarsInput2githubcomevergreencievergreenrestmodelAPIProjectVars(ctx context.Context, v any) (model.APIProjectVars, error) {
	res, err := ec.unmarshalInputProjectVarsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPublicKeyInput2githubcomevergreencievergreengraphqlPublicKeyInput(ctx context.Context, v any) (*PublicKeyInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepoRef2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._RepoRef(ctx, sel, &v)
}

func (ec *executionContext) marshalORepoRef2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoRef(ctx, sel, v)
}

func (ec *executionContext) unmarshalORepoRefInput2githubcomevergreencievergreenrestmodelAPIProjectRef(ctx context.Context, v any) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputRepoRefInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORepoSettingsInput2githubcomevergreencievergreenrestmodelAPIProjectSettings(ctx context.Context, v any) (*model.APIProjectSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepoSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepotrackerError2githubcomevergreencievergreenrestmodelAPIRepositoryErrorDetails(ctx context.Context, sel ast.SelectionSet, v *model.APIRepositoryErrorDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepotrackerError(ctx, sel, v)
}

func (ec *executionContext) marshalOSearchReturnInfo2githubcomevergreencievergreenthirdpartySearchReturnInfo(ctx context.Context, sel ast.SelectionSet, v *thirdparty.SearchReturnInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchReturnInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOSingleTaskDistroConfig2githubcomevergreencievergreenrestmodelAPISingleTaskDistroConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISingleTaskDistroConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SingleTaskDistroConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOSlackConfig2githubcomevergreencievergreenrestmodelAPISlackConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISlackConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SlackConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOSleepSchedule2githubcomevergreencievergreenmodelhostSleepScheduleInfo(ctx context.Context, sel ast.SelectionSet, v *host.SleepScheduleInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SleepSchedule(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSleepScheduleInput2githubcomevergreencievergreenmodelhostSleepScheduleInfo(ctx context.Context, v any) (*host.SleepScheduleInfo, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSleepScheduleInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx context.Context, v any) (*SortDirection, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(SortDirection)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSortDirection2githubcomevergreencievergreengraphqlSortDirection(ctx context.Context, sel ast.SelectionSet, v *SortDirection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSortOrder2githubcomevergreencievergreengraphqlSortOrder(ctx context.Context, v any) ([]*SortOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*SortOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSortOrder2githubcomevergreencievergreengraphqlSortOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSource2githubcomevergreencievergreenrestmodelAPISource(ctx context.Context, sel ast.SelectionSet, v *model.APISource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Source(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSpawnHostInput2githubcomevergreencievergreengraphqlSpawnHostInput(ctx context.Context, v any) (*SpawnHostInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSpawnHostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSpruceConfig2githubcomevergreencievergreenrestmodelAPIAdminSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIAdminSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SpruceConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx context.Context, sel ast.SelectionSet, v []task.StatusCount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatusCount2githubcomevergreencievergreenmodeltaskStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOStepbackInfo2githubcomevergreencievergreenrestmodelAPIStepbackInfo(ctx context.Context, sel ast.SelectionSet, v *model.APIStepbackInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StepbackInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStringMap2map(ctx context.Context, v any) (map[string]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := MarshalStringMap(v)
	return res
}

func (ec *executionContext) marshalOSubscriberWrapper2githubcomevergreencievergreenrestmodelAPISubscriber(ctx context.Context, sel ast.SelectionSet, v model.APISubscriber) graphql.Marshaler {
	return ec._SubscriberWrapper(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx context.Context, v any) ([]model.APISubscription, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APISubscription, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSubscriptionInput2githubcomevergreencievergreenrestmodelAPISubscription(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx context.Context, sel ast.SelectionSet, v []*model.APITask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTask2githubcomevergreencievergreenrestmodelAPITask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTask2githubcomevergreencievergreenrestmodelAPITask(ctx context.Context, sel ast.SelectionSet, v *model.APITask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskAnnotationSettingsInput2githubcomevergreencievergreenrestmodelAPITaskAnnotationSettings(ctx context.Context, v any) (model.APITaskAnnotationSettings, error) {
	res, err := ec.unmarshalInputTaskAnnotationSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTaskEndDetail2githubcomevergreencievergreenrestmodelApiTaskEndDetail(ctx context.Context, sel ast.SelectionSet, v model.ApiTaskEndDetail) graphql.Marshaler {
	return ec._TaskEndDetail(ctx, sel, &v)
}

func (ec *executionContext) marshalOTaskInfo2githubcomevergreencievergreenrestmodelTaskInfo(ctx context.Context, sel ast.SelectionSet, v model.TaskInfo) graphql.Marshaler {
	return ec._TaskInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalOTaskOwnerTeam2githubcomevergreencievergreengraphqlTaskOwnerTeam(ctx context.Context, sel ast.SelectionSet, v *TaskOwnerTeam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskOwnerTeam(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskSpecifier2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx context.Context, sel ast.SelectionSet, v []model.APITaskSpecifier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskSpecifier2githubcomevergreencievergreenrestmodelAPITaskSpecifier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTaskStats2githubcomevergreencievergreenmodeltaskTaskStats(ctx context.Context, sel ast.SelectionSet, v *task.TaskStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskStats(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskTestResultSample2githubcomevergreencievergreengraphqlTaskTestResultSample(ctx context.Context, sel ast.SelectionSet, v []*TaskTestResultSample) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskTestResultSample2githubcomevergreencievergreengraphqlTaskTestResultSample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTestFilterOptions2githubcomevergreencievergreengraphqlTestFilterOptions(ctx context.Context, v any) (*TestFilterOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTestFilterOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTestSortOptions2githubcomevergreencievergreengraphqlTestSortOptions(ctx context.Context, v any) ([]*TestSortOptions, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*TestSortOptions, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTestSortOptions2githubcomevergreencievergreengraphqlTestSortOptions(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx context.Context, sel ast.SelectionSet, v []model.APITriggerDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTriggerAlias2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTriggerAliasInput2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx context.Context, v any) ([]model.APITriggerDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APITriggerDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTriggerAliasInput2githubcomevergreencievergreenrestmodelAPITriggerDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUpdateBetaFeaturesPayload2githubcomevergreencievergreengraphqlUpdateBetaFeaturesPayload(ctx context.Context, sel ast.SelectionSet, v *UpdateBetaFeaturesPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateBetaFeaturesPayload(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateParsleySettingsPayload2githubcomevergreencievergreengraphqlUpdateParsleySettingsPayload(ctx context.Context, sel ast.SelectionSet, v *UpdateParsleySettingsPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateParsleySettingsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalOUpstreamProject2githubcomevergreencievergreengraphqlUpstreamProject(ctx context.Context, sel ast.SelectionSet, v *UpstreamProject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpstreamProject(ctx, sel, v)
}

func (ec *executionContext) marshalOUseSpruceOptions2githubcomevergreencievergreenrestmodelAPIUseSpruceOptions(ctx context.Context, sel ast.SelectionSet, v *model.APIUseSpruceOptions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UseSpruceOptions(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUseSpruceOptionsInput2githubcomevergreencievergreenrestmodelAPIUseSpruceOptions(ctx context.Context, v any) (*model.APIUseSpruceOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUseSpruceOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserConfig2githubcomevergreencievergreengraphqlUserConfig(ctx context.Context, sel ast.SelectionSet, v *UserConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserSettingsInput2githubcomevergreencievergreenrestmodelAPIUserSettings(ctx context.Context, v any) (*model.APIUserSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx context.Context, sel ast.SelectionSet, v []*model.APIVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOVersion2githubcomevergreencievergreenrestmodelAPIVersion(ctx context.Context, sel ast.SelectionSet, v *model.APIVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalOVersionTiming2githubcomevergreencievergreengraphqlVersionTiming(ctx context.Context, sel ast.SelectionSet, v *VersionTiming) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VersionTiming(ctx, sel, v)
}

func (ec *executionContext) marshalOVolume2githubcomevergreencievergreenrestmodelAPIVolume(ctx context.Context, sel ast.SelectionSet, v *model.APIVolume) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Volume(ctx, sel, v)
}

func (ec *executionContext) marshalOWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx context.Context, sel ast.SelectionSet, v []*model1.WaterfallBuild) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaterfallBuild2githubcomevergreencievergreenmodelWaterfallBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWebhookInput2githubcomevergreencievergreenrestmodelAPIWebHook(ctx context.Context, v any) (model.APIWebHook, error) {
	res, err := ec.unmarshalInputWebhookInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWebhookSubscriber2githubcomevergreencievergreenrestmodelAPIWebhookSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIWebhookSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WebhookSubscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWebhookSubscriberInput2githubcomevergreencievergreenrestmodelAPIWebhookSubscriber(ctx context.Context, v any) (*model.APIWebhookSubscriber, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWebhookSubscriberInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWorkstationConfigInput2githubcomevergreencievergreenrestmodelAPIWorkstationConfig(ctx context.Context, v any) (model.APIWorkstationConfig, error) {
	res, err := ec.unmarshalInputWorkstationConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorkstationSetupCommand2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx context.Context, sel ast.SelectionSet, v []model.APIWorkstationSetupCommand) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkstationSetupCommand2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWorkstationSetupCommandInput2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx context.Context, v any) ([]model.APIWorkstationSetupCommand, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIWorkstationSetupCommand, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWorkstationSetupCommandInput2githubcomevergreencievergreenrestmodelAPIWorkstationSetupCommand(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
