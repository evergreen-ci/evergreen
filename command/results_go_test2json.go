package command

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"time"
	"unicode"

	"github.com/evergreen-ci/evergreen"
	"github.com/evergreen-ci/evergreen/model"
	"github.com/evergreen-ci/evergreen/model/task"
	"github.com/evergreen-ci/evergreen/rest/client"
	"github.com/evergreen-ci/evergreen/util"
	"github.com/mitchellh/mapstructure"
	"github.com/mongodb/grip"
	"github.com/pkg/errors"
)

var (
	testStartRegex = regexp.MustCompile(`^=== (RUN|BENCH)\s+.*$`)
	// Match benchmark output like "BenchmarkSomethingSilent-8    	       1	10005034392 ns/op"
	benchmarkRegex = regexp.MustCompile(fmt.Sprintf(`^(%s)(-\d+)?\s+\d+\s+\d+\s+`, identRegex))
)

const (
	// Golang ident (see grammar spec)
	identRegex      = `\p{L}(\p{L}|\d)*`
	benchFailPrefix = "--- FAIL: %s"
	benchSkipPrefix = "--- SKIP: %s"

	actionPass   = "pass"
	actionFail   = "fail"
	actionRun    = "run"
	actionPause  = "pause"
	actionCont   = "cont"
	actionBench  = "bench"
	actionOutput = "output"
	actionSkip   = "skip"
)

// Golang's JSON result output ('test2json') is a newline delimited list
// of the following struct, encoded as JSON.

// The following rules APPEAR to hold true of Golang's JSON output:
// 1. Golang offers no field to distinguish between subsequent runs of a test,
// such as when setting -test.count to a number greater than 1. However,
// Golang will not run more than one test of the same name at once, even with a
// call to t.Parallel(). This means that when you observe a "fail" or "pass"
// action with the same test name, you know that the next time you see "run",
// it corresponds to a subsequent iteration.
// 2. Benchmarks do not have a "run" action
// 3. The Output field has trailing newlines, even on Windows
// 4. The file emitted by test2json on Windows uses Unix-style line endings
// 5. Benchmarks do not provide Elapsed, even on fail, except in the package
// level result
// 6. Benchmark output will not necessarily match the Test. For example,
// in the benchmark corpus, the output for BenchmarkSomethingSilent-8 is tagged
// with Test name BenchmarkSomethingElse-8
type goTest2JSONTestEvent struct {
	// Time is the time that the line was processed by by go test. Contrary
	// to the documentation, this string appears to be an RFC3339Nano
	// formatted string
	Time time.Time

	// Action is one of:
	// run    - the test has started running
	// pause  - the test has been paused
	// cont   - the test has continued running
	// pass   - the test passed
	// bench  - the benchmark printed log output but did not fail
	// fail   - the test or benchmark failed
	// output - the test printed output
	// Additionally, the following is generated by go 1.10.3 but is undocumented:
	// skip   - the test was skipped
	Action string

	// Package optionally specifies the go package path of the test being
	// run
	Package string

	// Test specifies the name of the test function being tested. When
	// go test is reporting benchmarks or package level results, Test is
	// empty
	Test string

	// Elapsed is the number of seconds a test took. It is set only when
	// action is pass or fail for tests, and in the package-level pass/fail
	// action
	Elapsed float64 // seconds

	// Output is the line that gotest captured, including trailing newlines
	// or carriage returns. On Windows, the trailing newlines are
	// Unix-style
	Output string
}

type goTest2JSONCommand struct {
	Files []string `mapstructure:"files" plugin:"expand"`

	base
}

type goTest2JSONKey struct {
	name      string
	iteration int
}

func goTest2JSONFactory() Command          { return &goTest2JSONCommand{} }
func (c *goTest2JSONCommand) Name() string { return "gotest.parse_json" }

func (c *goTest2JSONCommand) ParseParams(params map[string]interface{}) error {
	if err := mapstructure.Decode(params, c); err != nil {
		return errors.Wrapf(err, "error decoding '%s' params", c.Name())
	}

	if len(c.Files) == 0 {
		return errors.Errorf("error validating params: must specify at least one "+
			"file pattern to parse: '%+v'", params)
	}
	return nil
}

func (c *goTest2JSONCommand) Execute(ctx context.Context,
	comm client.Communicator, logger client.LoggerProducer, conf *model.TaskConfig) error {

	if err := util.ExpandValues(c, conf.Expansions); err != nil {
		return errors.Wrap(err, "failed to expand files")
	}

	catcher := grip.NewBasicCatcher()
	for i := range c.Files {
		if ctx.Err() != nil {
			return errors.New("operation canceled")
		}

		catcher.Add(c.executeOneFile(ctx, c.Files[i], comm, logger, conf))
	}

	return catcher.Resolve()
}

func (c *goTest2JSONCommand) executeOneFile(ctx context.Context, file string,
	comm client.Communicator, logger client.LoggerProducer, conf *model.TaskConfig) error {
	logger.Task().Infof("Parsing test file '%s'...", file)
	events, err := c.loadJSONFile(file, logger, conf)
	if err != nil {
		logger.Task().Errorf("Error parsing test file: %s", err)
		return errors.Wrapf(err, "Error parsing test file: %s", err)
	}

	testLog, merged := processTestEvents(events)
	if len(merged) == 0 {
		logger.Task().Warning("Parsed no events from test file")
		return nil
	}

	logger.Task().Info("Sending test logs to server...")
	_, suiteName := filepath.Split(file)
	log := model.TestLog{
		Name:          suiteName,
		Task:          conf.Task.Id,
		TaskExecution: conf.Task.Execution,
		Lines:         testLog,
	}
	td := client.TaskData{ID: conf.Task.Id, Secret: conf.Task.Secret}
	var logID string
	logID, err = comm.SendTestLog(ctx, td, &log)
	if err != nil {
		// continue on error to let the other logs be posted
		logger.Task().Errorf("failed to post log: %v", err)
		return errors.Wrap(err, "failed to post log")
	}
	logger.Task().Info("Finished posting logs to server")

	results := make([]task.TestResult, 0, len(merged))
	for k, v := range merged {
		testResult := goMergedTest2JSONToTestResult(k.name, conf.Task, v)
		testResult.LogId = logID
		results = append(results, testResult)
	}

	logger.Task().Info("Sending parsed results to server...")
	if err := comm.SendTestResults(ctx, td, &task.LocalTestResults{
		Results: results,
	}); err != nil {
		logger.Task().Errorf("problem posting parsed results to the server: %+v", err)
		return errors.Wrap(err, "problem sending test results")
	}

	logger.Task().Info("Successfully sent parsed results to server")
	return nil
}

func (c *goTest2JSONCommand) loadJSONFile(file string, logger client.LoggerProducer, conf *model.TaskConfig) ([]*goTest2JSONTestEvent, error) {
	filePath := file
	if !path.IsAbs(filePath) {
		filePath = path.Join(conf.WorkDir, filePath)
	}

	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		logger.Task().Errorf("Failed to open '%s'", filePath)
		return nil, errors.Wrapf(err, "failed to open: %s", filePath)
	}

	lines := bytes.Split(data, []byte("\n"))
	out := make([]*goTest2JSONTestEvent, 0, len(lines))
	for i := range lines {
		if len(lines[i]) == 0 {
			continue
		}

		test2JSON, err := parseGoTest2JSON(lines[i])
		if err != nil {
			logger.Task().Errorf("failed to parse %s:%d", filePath, i+1)
			continue
		}

		out = append(out, test2JSON)
	}

	return out, nil
}

func parseGoTest2JSON(bytes []byte) (*goTest2JSONTestEvent, error) {
	t := goTest2JSONTestEvent{}
	if err := json.Unmarshal(bytes, &t); err != nil {
		return nil, errors.Wrap(err, "failed to parse test2json")
	}
	return &t, nil
}

type goTest2JSONMergedTestEvent struct {
	// Status is an evergreen.Test.* constant
	Status string
	// 0-indexed line number into the log
	StartLine int
	StartTime time.Time
	EndTime   time.Time
}

func processTestEvents(data []*goTest2JSONTestEvent) ([]string, map[goTest2JSONKey]*goTest2JSONMergedTestEvent) {
	iteration := map[string]int{}
	testLog := []string{}
	m := map[goTest2JSONKey]*goTest2JSONMergedTestEvent{}

	for _, event := range data {
		key := goTest2JSONKey{
			name:      event.Test,
			iteration: iteration[event.Test],
		}

		if len(event.Test) == 0 && event.Action != actionOutput {
			continue
		}
		if _, ok := m[key]; !ok {
			m[key] = &goTest2JSONMergedTestEvent{}
		}

		switch event.Action {
		case actionRun:
			m[key].StartTime = event.Time

		case actionPass, actionFail, actionSkip:
			m[key].Status = event.Action
			m[key].EndTime = event.Time

			// Benchmark test results do not provide any timing info
			// so we just set start/end to the same time
			if strings.HasPrefix(key.name, "Benchmark") {
				m[key].StartTime = event.Time
			} else if m[key].StartTime.IsZero() {
				elapsedNano := math.Ceil(event.Elapsed * float64(time.Second))
				m[key].StartTime = m[key].EndTime.Add(-time.Duration(elapsedNano))
			}

			iteration[event.Test] += 1

		case actionBench:
			m[key].Status = actionPass
			m[key].StartTime = event.Time
			m[key].EndTime = event.Time

		case actionPause, actionCont, actionOutput:
			// test2json does not guarantee that all tests will
			// have a "pass" or "fail" event (ex: panics), so
			// we assign the most recent event's time to the EndTime
			// if the status hasn't been set yet
			if len(m[key].Status) == 0 {
				m[key].EndTime = event.Time
			}

			if event.Action == actionOutput {
				trimmedLine := strings.TrimRightFunc(event.Output, unicode.IsSpace)
				testLog = append(testLog, trimmedLine)
				if shouldTagLineNumber(trimmedLine, event.Package, key.name) {
					m[key].StartLine = len(testLog) - 1
				}
			}
			if len(event.Test) == 0 {
				delete(m, key)
			}
		}
	}

	return testLog, m
}

func shouldTagLineNumber(line, packageName, testName string) bool {
	if testStartRegex.MatchString(line) {
		return true
	}

	// All tests below apply only to benchmarks
	if !strings.HasPrefix(testName, "Benchmark") {
		return false
	}

	if strings.HasPrefix(line, fmt.Sprintf(benchFailPrefix, testName)) {
		return true
	}
	if strings.HasPrefix(line, fmt.Sprintf(benchSkipPrefix, testName)) {
		return true
	}

	return false
}

func goMergedTest2JSONToTestResult(key string, t *task.Task, test2JSON *goTest2JSONMergedTestEvent) task.TestResult {
	result := task.TestResult{
		TestFile:  key,
		LineNum:   test2JSON.StartLine,
		Status:    evergreen.TestFailedStatus,
		StartTime: float64(test2JSON.StartTime.Unix()),
		EndTime:   float64(test2JSON.EndTime.Unix()),
	}
	switch test2JSON.Status {
	case "pass":
		result.Status = evergreen.TestSucceededStatus
	case "skip":
		result.Status = evergreen.TestSkippedStatus
	}

	return result
}
