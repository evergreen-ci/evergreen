# 2023-06-05 GitHub Merge Queue

* status: accepted
* date: 2023-06-05
* authors: Brian Samek

## Context and Problem Statement

* [Epic](https://go/github-merge-queue)
* [Scope](https://go/github-merge-queue-scope)
* [Design](https://go/github-merge-queue-design)

GitHub merge queue integrates natively with GitHub Actions. Integration with
other CI systems exists but is lightly documented. The
[docs](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue#triggering-merge-group-checks-with-other-ci-providers)
state that a CI system should listen for branches matching a pattern and that
the PR will be merged once required checks pass.

The purpose of this ADR is to keep a record of the details of the integration
between the GitHub merge queue and Evergreen for later reference.

## Architectural Overview

Evergreen listens for new GitHub merge queue items, creates and runs versions
for these items, and posts the results of these versions to GitHub.

### Listen

Evergreen listens for new branches created by the merge queue by listening for
the merge_group event.  These are generated by a user clicking the add to queue
or (eventually) the merge when ready buttons in the GitHub UI.

### Create version

Evergreen creates a new version with a new requester type "github-merge-queue".
The variants and tasks will be those defined in the existing commit queue
settings on the project configuration page.

There are two alternative possibilities for the requester type: First, use the
ad hoc version type.  However, the ad hoc version type cannot independently be
given increased priority in the scheduler. Using ad hoc overloads the meaning of
this type.  Second, use the commit queue type. However, this type triggers a
substantial amount of Evergreen commit queue logic, so it's more straightforward
to make a new type. A disadvantage is that anyone downstream who has written
queries that assumes the number of requesters is fixed will need to take into
account the new requester.

### Inter-Project Triggers

The GitHub merge queue integration does not create inter-project triggers. This
will be left to another project if there is interest from users.

### Post results

Post a check to the checks API. The merge when ready button waits for the branch
protection rules to be fulfilled before adding the PR to the merge queue.

## Code Overview

* There is a new patch intent type in
[model/patch](https://github.com/evergreen-ci/evergreen/blob/main/model/patch/github_merge_intent.go)
* The intent will be processed by the amboy [patch-intent-processor
job](https://github.com/evergreen-ci/evergreen/blob/main/units/patch_intent.go).
* New clone logic in the agent will clone the merge group branch.
* Evergreen will post the result to the GitHub checks API.
* A new UI element will allow users to opt into the GitHub merge queue.

## Pending Status Checks

Evergreen doesn't behave in the way that GitHub designers intended: For PRs,
instead of sending a pending and then a success/fail status for each check, it
sends a single "evergreen" pending status, and then it sends "evergreen"
success/failure as well as "evergreen/\<variant\>" status for each variant. This
is fine for PRs because "evergreen" links to the version in Evergreen.

However, for GitHub merge queue builds, sending an "evergreen" pending check
only works if "evergreen" is configured as a branch protection rule. If instead
the user has configured an "evergreen/\<variant\>" branch protection rule but
_not_ an "evergreen" branch protection rule, the "evergreen" pending check does
not show up in the GitHub UI, which means the user can't click a link to the
Evergreen version. They eventually can, when it completes, but not while it's running.

There are several options to handle this:

1. Accept the problem that there is no link to the version until it finishes.
2. Send status pending for variants in the version.
3. Send status pending for branch protection rules.

The first will be frustrating to users. The second will not work if the branch
protection rule depends on a variant created by generate.tasks. Only the third
posts a link immediately.
